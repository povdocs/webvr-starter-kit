{"version":3,"sources":["webpack:///vr.js","webpack:///webpack/bootstrap e575faca7415056888a3","webpack:///./src/entry.js","webpack:///./src/vr.js","webpack:///./src/css/style.css?21aa","webpack:///./src/css/style.css","webpack:///./~/style-loader/addStyles.js","webpack:///./bower_components/open-iconic/svg/fullscreen-enter.svg","webpack:///./bower_components/open-iconic/svg/fullscreen-exit.svg","webpack:///./bower_components/open-iconic/svg/eye.svg","webpack:///./bower_components/open-iconic/svg/compass.svg","webpack:///./bower_components/nosleep/NoSleep.js","webpack:///./src/materials.js","webpack:///./src/vr-object.js","webpack:///./src/objects ^\\.\\/.*$","webpack:///./src/objects/empty.js","webpack:///./~/css-loader/lib/css-base.js","webpack:///./bower_components/DeviceOrientationControls/index.js","webpack:///./bower_components/OrbitControls/index.js","webpack:///./bower_components/AugmentedConsole/index.js","webpack:///./src/lib/VRStereoEffect.js","webpack:///./src/lib/VRControls.js","webpack:///./~/event-emitter/index.js","webpack:///./src/objects/box.js","webpack:///./src/objects/cylinder.js","webpack:///./src/objects/floor.js","webpack:///./src/objects/image.js","webpack:///./src/objects/panorama.js","webpack:///./src/objects/particles.js","webpack:///./src/objects/sky.js","webpack:///./src/objects/sound.js","webpack:///./src/objects/sphere.js","webpack:///./src/objects/text.js","webpack:///./src/objects/torus.js","webpack:///./src/objects/video.js","webpack:///./~/three/three.js","webpack:///./src/images ^\\.\\/.*$","webpack:///./src/utils/urlregex.js","webpack:///./~/lodash.foreach/index.js","webpack:///./~/lodash.assign/index.js","webpack:///./src/lib/ThreeAudio.js","webpack:///./bower_components/SkyShader/index.js","webpack:///./bower_components/ShaderParticles/index.js","webpack:///./~/event-emitter/~/d/index.js","webpack:///./src/images/asphalt.jpg","webpack:///./src/images/brick-tiles.jpg","webpack:///./src/images/bricks-normal.jpg","webpack:///./src/images/bricks-specular.jpg","webpack:///./src/images/bricks.jpg","webpack:///./src/images/checkerboard.png","webpack:///./src/images/cloud10.png","webpack:///./src/images/grass.jpg","webpack:///./src/images/metal-floor.jpg","webpack:///./src/images/metal.jpg","webpack:///./src/images/stone.jpg","webpack:///./src/images/tiles.jpg","webpack:///./src/images/weathered-wood.jpg","webpack:///./src/images/wood.jpg","webpack:///./~/event-emitter/~/es5-ext/object/valid-callable.js","webpack:///./~/lodash.assign/~/lodash._createassigner/index.js","webpack:///./~/lodash.assign/~/lodash.isnative/index.js","webpack:///./~/lodash.assign/~/lodash._baseassign/index.js","webpack:///./~/lodash.foreach/~/lodash._baseeach/index.js","webpack:///./~/lodash.foreach/~/lodash._arrayeach/index.js","webpack:///./~/lodash.foreach/~/lodash._bindcallback/index.js","webpack:///./~/lodash.foreach/~/lodash.isarray/index.js","webpack:///./~/event-emitter/~/es5-ext/object/normalize-options.js","webpack:///./~/event-emitter/~/es5-ext/object/is-callable.js","webpack:///./~/event-emitter/~/es5-ext/object/assign/index.js","webpack:///./~/event-emitter/~/es5-ext/string/#/contains/index.js","webpack:///./~/event-emitter/~/es5-ext/object/assign/is-implemented.js","webpack:///./~/event-emitter/~/es5-ext/object/assign/shim.js","webpack:///./~/event-emitter/~/es5-ext/string/#/contains/is-implemented.js","webpack:///./~/event-emitter/~/es5-ext/string/#/contains/shim.js","webpack:///./~/lodash.assign/~/lodash._createassigner/~/lodash.restparam/index.js","webpack:///./~/lodash.assign/~/lodash._createassigner/~/lodash._isiterateecall/index.js","webpack:///./~/lodash.assign/~/lodash.keys/~/lodash.isarguments/index.js","webpack:///./~/lodash.assign/~/lodash._baseassign/~/lodash._basecopy/index.js","webpack:///./~/event-emitter/~/es5-ext/object/valid-value.js","webpack:///./~/event-emitter/~/es5-ext/object/keys/index.js","webpack:///./~/event-emitter/~/es5-ext/object/keys/is-implemented.js","webpack:///./~/event-emitter/~/es5-ext/object/keys/shim.js","webpack:///./~/lodash.foreach/~/lodash._baseeach/~/lodash.keys/index.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","i","Object","prototype","hasOwnProperty","_m","args","slice","fn","a","b","apply","concat","initRequirements","VR","initUI","svgButton","source","svg","span","document","createElement","innerHTML","firstChild","setAttribute","container","appendChild","toggleOrientation","orientationEnabled","disableOrientation","enableOrientation","deviceChange","controlMode","vrButton","classList","remove","orientationButton","enableFullscreen","disableFullscreen","element","noSleep","NoSleep","fullScreenElement","body","fullscreenEnabled","webkitFullscreenEnabled","mozFullScreenEnabled","msFullscreenEnabled","requestFullscreen","webkitRequestFullscreen","mozRequestFullScreen","msRequestFullscreen","head","addEventListener","bind","exitFullscreen","on","isFullscreen","style","display","vrMode","enable","disable","className","requestVR","window","evt","keyCode","charCodeAt","zeroSensor","resize","initialize","init","THREE","start","fullscreenElement","mozFullScreenElement","webkitFullscreenElement","msFullscreenElement","fullScreenError","vrEffect","exit","raycast","intersect","object","intersects","vrObject","raycaster","ray","origin","copy","camera","position","direction","set","unproject","sub","normalize","intersectObjects","scene","children","length","Mesh","target","VRObject","findObject","emit","render","now","Date","delta","Math","min","lastTick","vrControls","update","animationCallbacks","forEach","cb","updateMatrixWorld","vrObjects","renderLoop","going","requestAnimationFrame","stop","visibilityChange","audioListener","volume","hidden","mozHidden","msHidden","webkitHidden","width","height","innerWidth","innerHeight","aspect","updateProjectionMatrix","renderer","setSize","initShake","lastX","lastY","lastZ","lastTime","threshold","time","diff","dist","current","accelerationIncludingGravity","deltaX","deltaY","deltaZ","undefined","abs","x","y","z","sqrt","navigator","vibrate","orientationPossible","initScene","attachCanvas","insertBefore","domElement","WebGLRenderer","event","console","log","Scene","bodyWrapper","name","moveTo","cameraWrapper","parent","PerspectiveCamera","NEAR","FAR","add","AudioListener","VRControls","freeze","VRStereoEffect","near","far","screen","mouseControls","enabled","reset","lockOrientation","mozLockOrientation","orientation","lock","exitVR","rotation","mode","hmd","OrbitControls","target0","dLight","DirectionalLight","castShadow","shadowCameraVisible","shadowMapWidth","shadowMapHeight","shadowCameraLeft","shadowCameraRight","shadowCameraTop","shadowCameraBottom","shadowCameraFar","shadowCameraNear","shadowDarkness","AmbientLight","canvas","Raycaster","ImageUtils","crossOrigin","eventEmitter","materials","nop","mozCancelFullScreen","webkitExitFullscreen","msExitFullscreen","objectMethods","animate","callback","indexOf","push","end","splice","requestFullScreen","times","n","method","key","creator","options","obj","this","defineProperty","get","content","locals","addStylesToDom","styles","item","domStyle","stylesInDom","refs","j","parts","addStyle","listToStyles","list","newStyles","css","media","sourceMap","part","createStyleElement","styleElement","getHeadElement","type","createLinkElement","linkElement","rel","singleton","styleIndex","singletonCounter","singletonElement","applyToSingletonTag","URL","createObjectURL","revokeObjectURL","Blob","btoa","updateLink","parentNode","removeChild","href","applyToTag","newObj","index","styleSheet","cssText","replaceText","cssNode","createTextNode","childNodes","JSON","stringify","blob","oldSrc","memoize","memo","arguments","isOldIE","test","userAgent","toLowerCase","getElementsByTagName","newList","mayRemove","textStore","replacement","filter","Boolean","join","root","addSourceToVideo","dataURI","src","ua","Android","iOS","WebM","MP4","noSleepTimer","noSleepVideo","duration","setInterval","location","setTimeout","play","clearInterval","pause","imageTexture","mapping","imageLoaded","scale","ctx","image","naturalWidth","naturalHeight","max","floor","getContext","drawImage","texture","needsUpdate","parse","isDataUri","dataUri","exec","urlRegex","images","hostname","port","Texture","material","threeTexture","textures","opts","Material","materialTypes","MeshLambertMaterial","assign","ambient","color","emissive","map","specularMap","normalMap","alphaMap","envMap","lightMap","val","match","assetPath","lambert","basic","MeshBasicMaterial","phong","MeshPhongMaterial","normal","MeshNormalMaterial","depth","MeshDepthMaterial","textureFiles","asphalt","repeat","brick-tiles","bricks","checkerboard","grass","metal-floor","shininess","metal","shading","SmoothShading","stone","tiles","weathered-wood","wood","url","scripts","currentScript","getAttribute","replace","standard","library","props","textureFactory","file","imagePath","Vector2","wrapS","wrapT","RepeatWrapping","materialDef","distance","geometry","scratchVector1","setFromMatrixPosition","matrixWorld","computeBoundingBox","worldToLocal","boundingBox","distanceToPoint","scratchVector2","distanceTo","self","isNear","wasNear","NEAR_DISTANCE","receiveShadow","allObjects","parseFloat","setMaterial","Color","prop","visible","xAxis","Vector3","yAxis","zAxis","WeakMap","hide","show","isNaN","moveX","translateX","moveY","translateY","moveUp","moveDown","moveZ","translateZ","rotateX","angle","rotateOnAxis","rotateY","rotateZ","setScale","e","count","Quaternion","offset","Object3D","webpackContext","req","webpackContextResolve","Error","./box","./box.js","./cylinder","./cylinder.js","./empty","./empty.js","./floor","./floor.js","./image","./image.js","./panorama","./panorama.js","./particles","./particles.js","./sky","./sky.js","./sound","./sound.js","./sphere","./sphere.js","./text","./text.js","./torus","./torus.js","./video","./video.js","keys","resolve","toString","result","mediaQuery","alreadyImportedModules","DeviceOrientationControls","scope","reorder","deviceOrientation","screenOrientation","onDeviceOrientationChangeEvent","onScreenOrientationChangeEvent","setObjectQuaternion","zee","euler","Euler","q0","q1","quaternion","alpha","beta","gamma","orient","setFromEuler","multiply","setFromAxisAngle","connect","disconnect","removeEventListener","degToRad","getAutoRotationAngle","PI","autoRotateSpeed","getZoomScale","pow","zoomSpeed","onMouseDown","button","MOUSE","LEFT","preventDefault","mouseButtons","ORBIT","noRotate","state","STATE","ROTATE","rotateStart","clientX","clientY","ZOOM","noZoom","DOLLY","dollyStart","PAN","noPan","panStart","NONE","onMouseMove","onMouseUp","dispatchEvent","startEvent","rotateEnd","rotateDelta","subVectors","rotateLeft","clientWidth","rotateSpeed","rotateUp","clientHeight","dollyEnd","dollyDelta","dollyIn","dollyOut","panEnd","panDelta","pan","endEvent","onMouseWheel","stopPropagation","wheelDelta","detail","onKeyDown","noKeys","UP","keyPanSpeed","BOTTOM","RIGHT","touchstart","touches","TOUCH_ROTATE","pageX","pageY","TOUCH_DOLLY","dx","dy","TOUCH_PAN","touchmove","touchend","center","minDistance","maxDistance","Infinity","autoRotate","minPolarAngle","maxPolarAngle","minAzimuthAngle","maxAzimuthAngle","MIDDLE","theta","phi","EPS","panOffset","phiDelta","thetaDelta","lastPosition","lastQuaternion","clone","position0","quat","setFromUnitVectors","up","quatInverse","inverse","changeEvent","panLeft","te","matrix","elements","multiplyScalar","panUp","fov","targetDistance","tan","top","right","left","bottom","warn","dollyScale","applyQuaternion","atan2","radius","sin","cos","lookAt","distanceToSquared","dot","getPolarAngle","getAzimuthalAngle","create","EventDispatcher","constructor","addSupportedType","format","supportedTypes","_oldConsole","Matrix4","v","Matrix3","Vector4","w","order","Ray","Ray origin","Ray direction","special","t","table","perspectiveMatrixFromVRFieldOfView","zNear","zFar","outMat","out","upTan","upDegrees","RADIANS","downTan","downDegrees","leftTan","leftDegrees","rightTan","rightDegrees","xScale","yScale","h","hmdDevice","hmdWidth","hmdHeight","offsetWidth","offsetHeight","updateProjection","fovLeft","fovRight","leftEyeParams","rightEyeParams","leftEyeRect","rightEyeRect","leftEyeViewport","rightEyeViewport","getEyeParameters","renderRect","currentFieldOfView","setFieldOfView","eyeOffsetLeft","eyeTranslation","eyeOffsetRight","leftRenderRect","rightRenderRect","getRecommendedEyeRenderRect","getCurrentEyeFieldOfView","getRecommendedEyeFieldOfView","getEyeTranslation","cameraLeft","projectionMatrix","cameraRight","gotVRDevices","devices","device","HMDVRDevice","hardwareUnitId","deviceName","setTimewarp","fullScreenParam","vrDisplay","poll","clearTimeout","pollTimeout","scan","onFullscreenChange","vrPreview","separation","autoClear","getVRDevices","then","mozGetVRDevices","leftScene","rightScene","renderTarget","forceClear","WebGLRenderTarget","Camera","decompose","enableScissorTest","context","drawingBufferWidth","setRenderTarget","traverseVisible","userData","stereo","setScissor","setViewport","PositionSensorVRDevice","sensorDevice","resetSensor","deviceOrientationChange","deviceControls","vrState","zeroAngle","vrBrowser","getState","hasOrientation","hasPosition","once","off","methods","descriptors","base","d","callable","Function","defineProperties","descriptor","configurable","enumerable","writable","listener","data","__ee__","value","__eeOnceListener__","listeners","candidate","l","Array","o","BoxGeometry","mesh","cylinder","CylinderGeometry","radiusTop","radiusBottom","radiusSegments","heightSegments","openEnded","CircleGeometry","segments","applyMatrix","makeRotationX","tex","UVMapping","makeScale","PlaneBufferGeometry","side","DoubleSide","transparent","SphereGeometry","makeRotationY","SPE","groupFields","groupOptions","field","particleGroup","Group","cloud","maxAge","blending","NormalBlending","hasPerspective","emitter","Emitter","positionSpread","colorStart","sizeStart","sizeStartSpread","particleCount","isStatic","addEmitter","tick","TAU","HALF_PI","params","mod","sinTheta","cosTheta","sinPhi","cosPhi","altitude","azimuth","sunPosition","light","intensity","exp","Sky","getObjectByName","setOptions","param","uniforms","isArray","setAltitude","setAzimuth","Audio","load","widthSegments","phiStart","phiLength","thetaStart","thetaLength","fontSizeRegex","newLineRegex","spaceRegex","log2","nextPowerOfTwo","ceil","Line","word","spaceWidth","measureText","totalWidth","wordsWidth","words","wrap","text","letter","line","inherit","fontSize","padding","lineHeight","measure","lines","getComputedStyle","resolution","wrapped","font","String","trim","charAt","reduce","previous","mipmap","textAlign","textBaseline","fillStyle","space","fillText","textWidth","textHeight","wordWidth","minFilter","LinearMipMapLinearFilter","generateMipmaps","TorusGeometry","tube","radialSegments","tubularSegments","arc","video","extRegex","isPowerOfTwo","num","loadedMetadata","newAspectRatio","vid","videoWidth","videoHeight","sphere","aspectRatio","LinearFilter","playing","setSource","sources","ext","hostÎ©","canPlayType","loop","VideoTexture","RGBFormat","readyState","vol","muted","currentTime","error","code","MediaError","MEDIA_ERR_DECODE","touchStart","REVISION","sign","CullFaceNone","CullFaceBack","CullFaceFront","CullFaceFrontBack","FrontFaceDirectionCW","FrontFaceDirectionCCW","BasicShadowMap","PCFShadowMap","PCFSoftShadowMap","FrontSide","BackSide","NoShading","FlatShading","NoColors","FaceColors","VertexColors","NoBlending","AdditiveBlending","SubtractiveBlending","MultiplyBlending","CustomBlending","AddEquation","SubtractEquation","ReverseSubtractEquation","MinEquation","MaxEquation","ZeroFactor","OneFactor","SrcColorFactor","OneMinusSrcColorFactor","SrcAlphaFactor","OneMinusSrcAlphaFactor","DstAlphaFactor","OneMinusDstAlphaFactor","DstColorFactor","OneMinusDstColorFactor","SrcAlphaSaturateFactor","MultiplyOperation","MixOperation","AddOperation","CubeReflectionMapping","CubeRefractionMapping","EquirectangularReflectionMapping","EquirectangularRefractionMapping","SphericalReflectionMapping","ClampToEdgeWrapping","MirroredRepeatWrapping","NearestFilter","NearestMipMapNearestFilter","NearestMipMapLinearFilter","LinearMipMapNearestFilter","UnsignedByteType","ByteType","ShortType","UnsignedShortType","IntType","UnsignedIntType","FloatType","HalfFloatType","UnsignedShort4444Type","UnsignedShort5551Type","UnsignedShort565Type","AlphaFormat","RGBAFormat","LuminanceFormat","LuminanceAlphaFormat","RGBEFormat","RGB_S3TC_DXT1_Format","RGBA_S3TC_DXT1_Format","RGBA_S3TC_DXT3_Format","RGBA_S3TC_DXT5_Format","RGB_PVRTC_4BPPV1_Format","RGB_PVRTC_2BPPV1_Format","RGBA_PVRTC_4BPPV1_Format","RGBA_PVRTC_2BPPV1_Format","Projector","projectVector","vector","project","unprojectVector","pickingRay","CanvasRenderer","clear","setClearColor","setRGB","r","g","setHex","setStyle","hex","setHSL","s","hue2rgb","q","parseInt","ColorKeywords","copyGammaToLinear","gammaFactor","copyLinearToGamma","safeInverse","convertGammaToLinear","convertLinearToGamma","getHex","getHexString","getHSL","optionalTarget","hue","saturation","hsl","lightness","getStyle","offsetHSL","addColors","color1","color2","addScalar","lerp","equals","fromArray","array","toArray","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","green","greenyellow","grey","honeydew","hotpink","indianred","indigo","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","red","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","springgreen","steelblue","teal","thistle","tomato","turquoise","violet","wheat","white","whitesmoke","yellow","yellowgreen","_x","_y","_z","_w",{"end":{"file":"vr.js","comments_before":[],"nlb":false,"endpos":130568,"endcol":7,"endline":5276,"pos":130567,"col":6,"line":5276,"value":"x","type":"name","_comments_dumped":true},"start":{"file":"vr.js","comments_before":[],"nlb":false,"endpos":130568,"endcol":7,"endline":5276,"pos":130567,"col":6,"line":5276,"value":"x","type":"name","_comments_dumped":true},"name":"x"},"onChangeCallback","c1","c2","c3","s1","s2","s3","axis","halfAngle","setFromRotationMatrix","m11","m12","m13","m21","m22","m23","m31","m32","m33","trace","v1","vFrom","vTo","crossVectors","conjugate","lengthSq","multiplyQuaternions","qax","qay","qaz","qaw","qbx","qby","qbz","qbw","multiplyVector3","slerp","qb","cosHalfTheta","halfTheta","acos","sinHalfTheta","ratioA","ratioB","onChange","qa","qm","setX","setY","setComponent","getComponent","addVectors","subScalar","divide","divideScalar","scalar","invScalar","clamp","clampScalar","minVal","maxVal","round","roundToZero","negate","setLength","oldLength","lerpVectors","v2","fromAttribute","attribute","itemSize","setZ","multiplyVectors","applyEuler","applyAxisAngle","applyMatrix3","applyMatrix4","applyProjection","qx","qy","qz","qw","ix","iy","iz","iw","multiplyMatrices","getInverse","transformDirection","lengthManhattan","cross","ax","ay","az","bx","by","bz","projectOnVector","projectOnPlane","planeNormal","reflect","angleTo","dz","setEulerFromRotationMatrix","setEulerFromQuaternion","getPositionFromMatrix","getScaleFromMatrix","setFromMatrixScale","getColumnFromMatrix","setFromMatrixColumn","sx","sy","sz","me","setW","setAxisAngleFromQuaternion","setAxisAngleFromRotationMatrix","epsilon","epsilon2","xx","yy","zz","xy","xz","yz","_order","DefaultOrder","RotationOrders","asin","setFromQuaternion","makeRotationFromQuaternion","setFromVector3","newOrder","toVector3","optionalResult","Line3","distanceSq","at","closestPointToPointParameter","startP","startEnd","point","clampToLine","startEnd2","startEnd_startP","closestPointToPoint","Box2","setFromPoints","points","makeEmpty","il","expandByPoint","setFromCenterAndSize","size","halfSize","box","empty","expandByVector","expandByScalar","containsPoint","containsBox","getParameter","isIntersectionBox","clampPoint","clampedPoint","union","translate","Box3","setFromObject","traverse","node","Geometry","vertices","BufferGeometry","attributes","positions","getBoundingSphere","Sphere","Float32Array","n11","n12","n13","n21","n22","n23","n31","n32","n33","identity","multiplyVector3Array","applyToVector3Array","determinant","f","throwOnInvertible","det","msg","transpose","tmp","flattenToArrayOffset","getNormalMatrix","transposeIntoArray","n14","n24","n34","n41","n42","n43","n44","extractPosition","copyPosition","extractBasis","makeBasis","extractRotation","scaleX","scaleY","scaleZ","makeRotationFromEuler","ae","af","be","bf","ce","cf","de","df","ac","ad","bc","bd","setRotationFromQuaternion","x2","y2","z2","wx","wy","wz","eye","a11","a12","a13","a14","a21","a22","a23","a24","a31","a32","a33","a34","a41","a42","a43","a44","b11","b12","b13","b14","b21","b22","b23","b24","b31","b32","b33","b34","b41","b42","b43","b44","multiplyToArray","multiplyVector4","rotateAxis","crossVector","getPosition","setPosition","rotateByAxis","getMaxScaleOnAxis","scaleXSq","scaleYSq","scaleZSq","makeTranslation","makeRotationZ","makeRotationAxis","tx","ty","compose","invSX","invSY","invSZ","makeFrustum","makePerspective","ymax","ymin","xmin","xmax","makeOrthographic","recast","directionDistance","distanceSqToSegment","segCenter","segDir","v0","optionalPointOnRay","optionalPointOnSegment","s0","sqrDist","extDet","segExtent","a01","b0","b1","invDet","isIntersectionSphere","intersectSphere","tca","d2","radius2","thc","t0","t1","isIntersectionPlane","plane","distToPoint","denominator","distanceToPlane","constant","intersectPlane","intersectBox","tmin","tmax","tymin","tymax","tzmin","tzmax","invdirx","invdiry","invdirz","intersectTriangle","edge1","edge2","backfaceCulling","DdN","DdQxE2","DdE1xQ","QdN","matrix4","optionalCenter","maxRadiusSq","intersectsSphere","radiusSum","deltaLengthSq","getBoundingBox","Frustum","p0","p1","p2","p3","p4","p5","planes","Plane","frustum","setFromMatrix","me0","me1","me2","me3","me4","me5","me6","me7","me8","me9","me10","me11","me12","me13","me14","me15","setComponents","intersectsObject","boundingSphere","computeBoundingSphere","negRadius","intersectsBox","d1","setFromNormalAndCoplanarPoint","setFromCoplanarPoints","inverseNormalLength","distanceToSphere","projectPoint","orthoPoint","perpendicularMagnitude","isIntersectionLine","startSign","endSign","intersectLine","coplanarPoint","m1","optionalNormalMatrix","normalMatrix","newNormal","newCoplanarPoint","generateUUID","chars","split","uuid","rnd","random","clampBottom","mapLinear","a1","a2","b2","smoothstep","smootherstep","random16","randInt","low","high","randFloat","randFloatSpread","range","degreeToRadiansFactor","degrees","radToDeg","radianToDegreesFactor","radians","Spline","interpolate","t2","t3","intPoint","weight","w2","w3","pa","pb","pc","pd","v3","initFromArray","getPoint","k","getControlPointsArray","coords","getLength","nSubDivisions","nSamples","oldIntPoint","oldPosition","tmpVec","chunkLengths","totalLength","chunks","total","reparametrizeByArcLength","samplingCoef","indexCurrent","indexNext","realDistance","sampling","newpoints","sl","Triangle","resultLengthSq","barycoordFromPoint","dot00","dot01","dot02","dot11","dot12","denom","invDenom","u","setFromPointsAndIndices","i0","i1","i2","triangle","area","midpoint","Clock","autoStart","startTime","oldTime","elapsedTime","running","performance","getElapsedTime","getDelta","newTime","hasEventListener","_listeners","listenerArray","Sprite","PointCloud","LOD","descSort","intersectObject","recursive","precision","linePrecision","setFromCamera","OrthographicCamera","sort","objects","Object3DIdCount","DefaultUp","onRotationChange","onQuaternionChange","rotationAutoUpdate","matrixAutoUpdate","matrixWorldNeedsUpdate","frustumCulled","renderOrder","eulerOrder","useQuaternion","setRotationFromAxisAngle","setRotationFromEuler","setRotationFromMatrix","translateOnAxis","localToWorld","getChildByName","getObjectById","getObjectByProperty","child","getWorldPosition","getWorldQuaternion","getWorldRotation","getWorldScale","getWorldDirection","traverseAncestors","updateMatrix","force","toJSON","output","metadata","version","generator","geometries","parseGeometry","json","parseMaterial","parseObject","PointLight","decay","SpotLight","exponent","HemisphereLight","groundColor","Face3","materialIndex","vertexNormals","vertexColors","vertexTangents","face","Face4","BufferAttribute","copyAt","index1","index2","setXY","setXYZ","setXYZW","Int8Attribute","Uint8Attribute","Uint8ClampedAttribute","Int16Attribute","Uint16Attribute","Int32Attribute","Uint32Attribute","Float32Attribute","Float64Attribute","DynamicBufferAttribute","updateRange","GeometryIdCount","attributesKeys","drawcalls","offsets","addAttribute","addDrawCall","indexOffset","fromGeometry","settings","faces","faceVertexUvs","hasFaceVertexUv","hasFaceVertexNormals","normals","colors","uvs","i3","na","nb","nc","fc","vca","vcb","vcc","uva","uvb","uvc","bb","computeFaceNormals","computeVertexNormals","vA","vB","vC","pA","pB","pC","ab","indices","jl","normalizeNormals","computeTangents","handleTriangle","uvA","uvB","uvC","x1","y1","z1","sdir","tdir","tan1","tan2","handleVertex","n2","tmp2","tangents","uv","nVertices","tangent","iA","iB","iC","computeOffsets","facesCount","sortedIndices","Uint16Array","indexPtr","vertexPtr","duplicatedVertices","newVerticeMaps","faceVertices","Int32Array","vertexMap","revVertexMap","findex","vo","faceMax","new_offset","new_vid","reorderBuffers","merge","attribute1","attributeArray1","attribute2","attributeArray2","attributeSize","indexBuffer","indexMap","vertexCount","sortedAttributes","attr","sourceArray","attrArray","attrSize","sortedAttr","numItems","sourceAttr","dispose","morphTargets","morphColors","morphNormals","skinWeights","skinIndices","lineDistances","hasTangents","dynamic","verticesNeedUpdate","elementsNeedUpdate","uvsNeedUpdate","normalsNeedUpdate","tangentsNeedUpdate","colorsNeedUpdate","lineDistancesNeedUpdate","groupsNeedUpdate","vertex","fromBufferGeometry","tempNormals","tempUVs","addFace","drawcall","fl","areaWeighted","vl","computeMorphNormals","__originalFaceNormal","__originalVertexNormals","tmpGeo","faceNormals","faceNormal","dstNormalsFace","dstNormalsVertex","ub","uc","vertexIndex","faceIndex","computeLineDistances","materialIndexOffset","vertexOffset","vertices1","vertices2","faces1","faces2","uvs1","uvs2","vertexCopy","faceCopy","faceVertexNormals","faceVertexColors","uvCopy","mergeMesh","mergeVertices","verticesMap","unique","changes","precisionPoints","faceIndicesToRemove","dupIndex","idx","setBit","getNormalIndex","hash","normalsHash","getColorIndex","colorsHash","getUvIndex","uvsHash","parameters","hasMaterial","hasFaceUv","hasFaceNormal","hasFaceVertexNormal","hasFaceColor","hasFaceVertexColor","faceType","uvsCopy","kl","matrixWorldInverse","CubeCamera","cubeResolution","cameraPX","cameraNX","cameraPY","cameraNY","cameraPZ","cameraNZ","WebGLRenderTargetCube","magFilter","updateCubeMap","activeCubeFace","zoom","cx","cy","setLens","focalLength","frameHeight","atan","setViewOffset","fullWidth","fullHeight","Light","AreaLight","constantAttenuation","linearAttenuation","quadraticAttenuation","onlyShadow","shadowBias","shadowCascade","shadowCascadeOffset","shadowCascadeCount","shadowCascadeBias","shadowCascadeWidth","shadowCascadeHeight","shadowCascadeNearZ","shadowCascadeFarZ","shadowCascadeArray","shadowMap","shadowMapSize","shadowCamera","shadowMatrix","skyColor","shadowCameraFov","Cache","files","Loader","showStatus","statusDomElement","addStatusElement","imageLoader","ImageLoader","onLoadStart","onLoadProgress","onLoadComplete","background","zIndex","updateProgress","progress","message","toFixed","extractUrlBase","pop","initMaterials","texturePath","createMaterial","needsTangents","ShaderMaterial","nearest_pow2","LN2","create_texture","where","sourceFile","anisotropy","fullPath","loader","Handlers","wrapMap","mirror","rgb2hex","rgb","mtype","mpars","opacity","bumpMap","wireframe","depthTest","depthWrite","flipSided","doubleSided","colorDiffuse","DbgColor","colorSpecular","specular","colorEmissive","transparency","specularCoef","mapDiffuse","mapDiffuseRepeat","mapDiffuseOffset","mapDiffuseWrap","mapDiffuseAnisotropy","mapLight","mapLightRepeat","mapLightOffset","mapLightWrap","mapLightAnisotropy","mapBump","mapBumpRepeat","mapBumpOffset","mapBumpWrap","mapBumpAnisotropy","mapNormal","mapNormalRepeat","mapNormalOffset","mapNormalWrap","mapNormalAnisotropy","mapSpecular","mapSpecularRepeat","mapSpecularOffset","mapSpecularWrap","mapSpecularAnisotropy","mapAlpha","mapAlphaRepeat","mapAlphaOffset","mapAlphaWrap","mapAlphaAnisotropy","mapBumpScale","bumpScale","mapNormalFactor","normalScale","DbgName","handlers","regex","XHRLoader","manager","DefaultLoadingManager","onLoad","onProgress","onError","cached","request","XMLHttpRequest","open","response","itemEnd","responseType","send","itemStart","setResponseType","setCrossOrigin","JSONLoader","withCredentials","loadAjaxJSON","callbackProgress","xhr","onreadystatechange","DONE","status","responseText","LOADING","getResponseHeader","HEADERS_RECEIVED","parseModel","isBitSet","fi","zLength","colorIndex","normalIndex","uvIndex","isQuad","faceA","faceB","uvLayer","nUvLayers","parseSkin","influencesPerVertex","bones","animation","animations","parseMorphing","dstVertices","srcVertices","cl","dstColors","srcColors","LoadingManager","BufferGeometryLoader","typedArray","MaterialLoader","vertexShader","fragmentShader","sizeAttenuation","ObjectLoader","substring","lastIndexOf","setTexturePath","parseGeometries","parseImages","parseTextures","parseMaterials","geometryLoader","bufferGeometryLoader","depthSegments","IcosahedronGeometry","TorusKnotGeometry","heightScale","getTexture","loadImage","path","getGeometry","getMaterial","TextureLoader","DataTextureLoader","BinaryTextureLoader","_parser","DataTexture","buffer","texData","mipmaps","mipmapCount","CompressedTextureLoader","CompressedTexture","loadTexture","texDatas","isCubemap","MaterialIdCount","blendSrc","blendDst","blendEquation","blendSrcAlpha","blendDstAlpha","blendEquationAlpha","colorWrite","polygonOffset","polygonOffsetFactor","polygonOffsetUnits","alphaTest","overdraw","_needsUpdate","setValues","values","newValue","currentValue","Number","PointCloudMaterial","SpriteMaterial","LineBasicMaterial","linewidth","linecap","linejoin","fog","LineDashedMaterial","dashSize","gapSize","combine","reflectivity","refractionRatio","wireframeLinewidth","wireframeLinecap","wireframeLinejoin","skinning","wrapAround","wrapRGB","MeshFaceMaterial","ParticleBasicMaterial","ParticleSystemMaterial","defines","lights","defaultAttributeValues","uv2","index0AttributeName","UniformsUtils","RawShaderMaterial","TextureIdCount","DEFAULT_IMAGE","DEFAULT_MAPPING","premultiplyAlpha","flipY","unpackAlignment","onUpdate","CubeTexture","HAVE_ENOUGH_DATA","inverseMatrix","localThreshold","testPoint","rayPointDistance","intersectPoint","distanceToRay","oi","ol","pointCount","ParticleSystem","LineStrip","LinePieces","precisionSq","vStart","vEnd","interSegment","interRay","step","distSq","offsetIndex","nbVertices","updateMorphTargets","morphTargetBase","morphTargetForcedOrder","morphTargetInfluences","morphTargetDictionary","ml","getMorphTargetIndexByName","intersectionPoint","isFaceMaterial","objectMaterials","morphInfluences","tl","influence","targets","Bone","skin","Skeleton","boneInverses","useVertexTexture","identityMatrix","boneTextureWidth","boneTextureHeight","boneMatrices","boneTexture","calculateInverses","bl","pose","bone","offsetMatrix","SkinnedMesh","bindMode","bindMatrix","bindMatrixInverse","gbone","pos","rotq","scl","normalizeSkinWeights","skeleton","sw","MorphAnimMesh","mirroredLoop","lastKeyframe","currentKeyframe","directionBackwards","setFrameRange","startKeyframe","endKeyframe","setDirectionForward","setDirectionBackward","parseAnimations","firstAnimation","pattern","morph","label","setAnimationLabel","playAnimation","fps","updateAnimation","frameTime","keyframe","mix","interpolateTargets","influences","addLevel","getObjectForDistance","matrixPosition","Particle","LensFlare","lensFlares","positionScreen","customUpdateCallback","updateLensFlares","flare","vecX","vecY","wantedRotation","overrideMaterial","autoUpdate","Fog","FogExp2","density","ShaderChunk","merged","uniforms_src","uniforms_dst","parameter_src","UniformsLib","common","diffuse","offsetRepeat","flipEnvMap","bump","normalmap","fogDensity","fogNear","fogFar","fogColor","ambientLightColor","directionalLightDirection","directionalLightColor","hemisphereLightDirection","hemisphereLightSkyColor","hemisphereLightGroundColor","pointLightColor","pointLightPosition","pointLightDistance","pointLightDecay","spotLightColor","spotLightPosition","spotLightDirection","spotLightDistance","spotLightAngleCos","spotLightExponent","spotLightDecay","particle","psColor","shadowmap","ShaderLib","particle_basic","dashed","totalSize","mNear","mFar","cube","tCube","tFlip","equirect","tEquirect","depthRGBA","createParticleBuffers","__webglVertexBuffer","_gl","createBuffer","__webglColorBuffer","_this","info","memory","createLineBuffers","__webglLineDistanceBuffer","createMeshBuffers","geometryGroup","__webglNormalBuffer","__webglTangentBuffer","__webglUVBuffer","__webglUV2Buffer","__webglSkinIndicesBuffer","__webglSkinWeightsBuffer","__webglFaceBuffer","__webglLineBuffer","numMorphTargets","__webglMorphTargetsBuffers","numMorphNormals","__webglMorphNormalsBuffers","initCustomAttributes","nvertices","__webglCustomAttributesList","__webglInitialized","createUniqueBuffers","belongsToAttribute","initParticleBuffers","__vertexArray","__colorArray","__webglParticleCount","initLineBuffers","__lineDistanceArray","__webglLineCount","initMeshBuffers","faces3","ntris","nlines","getBufferMaterial","__normalArray","__uvArray","__uv2Array","__tangentArray","__skinIndexArray","__skinWeightArray","UintArray","extensions","Uint32Array","__typeArray","__faceArray","__lineArray","__morphTargetsArrays","__morphNormalsArrays","__webglFaceCount","originalAttribute","property","__original","__inittedArrays","materialNeedsFaceNormals","setParticleBuffers","hint","ca","cal","customAttribute","vertexArray","colorArray","dirtyVertices","dirtyColors","customAttributes","bindBuffer","ARRAY_BUFFER","bufferData","boundTo","setLineBuffers","dl","lineDistanceArray","dirtyLineDistances","setMeshBuffers","faceColor","n1","n3","sw1","sw2","sw3","si1","si2","si3","vn","uvi","uv2i","vk","vkl","vka","nka","chf","needsFaceNormals","offset_uv","offset_uv2","offset_face","offset_normal","offset_tangent","offset_line","offset_color","offset_skin","offset_morphTarget","offset_custom","uvArray","uv2Array","normalArray","tangentArray","skinIndexArray","skinWeightArray","morphTargetsArrays","morphNormalsArrays","faceArray","lineArray","dirtyElements","dirtyUvs","dirtyNormals","dirtyTangents","dirtyMorphTargets","morphTargetsNeedUpdate","chunk_faces3","obj_faces","obj_uvs","obj_uvs2","obj_skinIndices","obj_skinWeights","ELEMENT_ARRAY_BUFFER","pp","setupVertexAttributes","program","startIndex","geometryAttributes","programAttributes","programAttributesKeys","programAttribute","geometryAttribute","enableAttribute","vertexAttribPointer","FLOAT","vertexAttrib2fv","vertexAttrib3fv","disableUnusedAttributes","setupMorphTargets","numSupportedMorphTargets","__webglMorphTargetInfluences","activeInfluenceIndices","numericalSort","numSupportedMorphNormals","influenceIndex","uniform1fv","painterSortStable","reversePainterSortStable","projectObject","initObject","sprites","webglObjects","_webglObjects","_frustum","webglObject","unrollBufferMaterial","sortObjects","_vector3","_projScreenMatrix","renderObjects","renderList","setupMatrices","setMaterialFaces","renderBufferDirect","renderBuffer","renderObjectsImmediate","materialType","renderImmediateObject","unrollImmediateBufferMaterial","globject","opaque","transparentObjects","opaqueObjects","__webglInit","_modelViewMatrix","_normalMatrix","onObjectRemoved","onGeometryDispose","initGeometryGroups","__webglActive","addBuffer","geometryGroupsList","geometryGroups","ImmediateRenderObject","immediateRenderCallback","addBufferImmediate","_webglObjectsImmediate","makeGroups","usesFaceMaterial","groupHash","group","maxVerticesInGroup","hash_map","groups","groupsList","counter","geometryGroupCounter","addBuffers","objlist","updateObject","bufferType","DYNAMIC_DRAW","STATIC_DRAW","bufferSubData","BYTES_PER_ELEMENT","subarray","customAttributesDirty","areCustomAttributesDirty","clearCustomAttributes","removeObject","removeInstances","initMaterial","onMaterialDispose","shaderID","shaderIDs","shader","__webglShader","maxLightCount","allocateLights","maxShadows","allocateShadows","maxBones","allocateBones","_precision","supportsVertexTextures","_supportsVertexTextures","envMapMode","useFog","fogExp","flatShading","logarithmicDepthBuffer","_logarithmicDepthBuffer","_supportsBoneTextures","maxMorphTargets","maxMorphNormals","maxDirLights","directional","maxPointLights","maxSpotLights","spot","maxHemiLights","hemi","shadowMapEnabled","shadowMapType","shadowMapDebug","shadowMapCascade","pl","_programs","programInfo","usedTimes","WebGLProgram","programs","uniformsList","setBlending","setDepthTest","setDepthWrite","setColorWrite","setPolygonOffset","setProgram","_usedTextureUnits","deallocateMaterial","refreshProgram","refreshMaterial","refreshLights","p_uniforms","m_uniforms","_currentProgram","useProgram","_currentMaterialId","_currentCamera","uniformMatrix4fv","uniform1f","logDepthBufFC","cameraPosition","uniform3f","viewMatrix","textureUnit","getTextureUnit","uniform1i","setTexture","boneGlobalMatrices","refreshUniformsFog","_lightsNeedUpdate","setupLights","refreshUniformsLights","_lights","markUniformsLightsNeedsUpdate","refreshUniformsCommon","refreshUniformsLine","refreshUniformsDash","refreshUniformsParticle","refreshUniformsPhong","refreshUniformsLambert","_shadowPass","refreshUniformsShadow","loadUniformsGeneric","loadUniformsMatrices","modelMatrix","uvScaleMap","_canvas","distances","decays","directions","anglesCos","exponents","skyColors","groundColors","modelViewMatrix","uniformMatrix3fv","_maxTextures","uniform","uniform2f","uniform4f","uniform1iv","uniform3iv","uniform2fv","uniform3fv","uniform4fv","_array","setCubeTexture","setCubeTextureDynamic","setColorLinear","ll","zlights","dirColors","dirPositions","pointColors","pointPositions","pointDistances","pointDecays","spotColors","spotPositions","spotDistances","spotDirections","spotAnglesCos","spotExponents","spotDecays","hemiSkyColors","hemiGroundColors","hemiPositions","dirLength","pointLength","spotLength","hemiLength","dirCount","spotCount","hemiCount","dirOffset","pointOffset","spotOffset","hemiOffset","_direction","setTextureParameters","textureType","isImagePowerOfTwo","extension","texParameteri","TEXTURE_WRAP_S","paramThreeToGL","TEXTURE_WRAP_T","TEXTURE_MAG_FILTER","TEXTURE_MIN_FILTER","CLAMP_TO_EDGE","filterFallback","__currentAnisotropy","texParameterf","TEXTURE_MAX_ANISOTROPY_EXT","getMaxAnisotropy","clampToMaxSize","maxSize","slot","__webglTextureCube","onTextureDispose","createTexture","activeTexture","TEXTURE0","bindTexture","TEXTURE_CUBE_MAP","pixelStorei","UNPACK_FLIP_Y_WEBGL","isCompressed","isDataTexture","cubeImage","autoScaleCubemaps","_maxCubemapSize","glFormat","glType","getCompressedTextureFormats","compressedTexImage2D","TEXTURE_CUBE_MAP_POSITIVE_X","texImage2D","generateMipmap","__webglTexture","setupFrameBuffer","framebuffer","textureTarget","bindFramebuffer","FRAMEBUFFER","framebufferTexture2D","COLOR_ATTACHMENT0","setupRenderBuffer","renderbuffer","bindRenderbuffer","RENDERBUFFER","depthBuffer","stencilBuffer","renderbufferStorage","DEPTH_COMPONENT16","framebufferRenderbuffer","DEPTH_ATTACHMENT","DEPTH_STENCIL","DEPTH_STENCIL_ATTACHMENT","RGBA4","updateRenderTargetMipmap","TEXTURE_2D","NEAREST","LINEAR","REPEAT","MIRRORED_REPEAT","NEAREST_MIPMAP_NEAREST","NEAREST_MIPMAP_LINEAR","LINEAR_MIPMAP_NEAREST","LINEAR_MIPMAP_LINEAR","UNSIGNED_BYTE","UNSIGNED_SHORT_4_4_4_4","UNSIGNED_SHORT_5_5_5_1","UNSIGNED_SHORT_5_6_5","BYTE","SHORT","UNSIGNED_SHORT","INT","UNSIGNED_INT","HALF_FLOAT_OES","ALPHA","RGB","RGBA","LUMINANCE","LUMINANCE_ALPHA","FUNC_ADD","FUNC_SUBTRACT","FUNC_REVERSE_SUBTRACT","ZERO","ONE","SRC_COLOR","ONE_MINUS_SRC_COLOR","SRC_ALPHA","ONE_MINUS_SRC_ALPHA","DST_ALPHA","ONE_MINUS_DST_ALPHA","DST_COLOR","ONE_MINUS_DST_COLOR","SRC_ALPHA_SATURATE","COMPRESSED_RGB_S3TC_DXT1_EXT","COMPRESSED_RGBA_S3TC_DXT1_EXT","COMPRESSED_RGBA_S3TC_DXT3_EXT","COMPRESSED_RGBA_S3TC_DXT5_EXT","COMPRESSED_RGB_PVRTC_4BPPV1_IMG","COMPRESSED_RGB_PVRTC_2BPPV1_IMG","COMPRESSED_RGBA_PVRTC_4BPPV1_IMG","COMPRESSED_RGBA_PVRTC_2BPPV1_IMG","MIN_EXT","MAX_EXT","nVertexUniforms","MAX_VERTEX_UNIFORM_VECTORS","nVertexMatrices","dirLights","pointLights","spotLights","hemiLights","_context","pixelRatio","_alpha","_depth","_stencil","stencil","_antialias","antialias","_premultipliedAlpha","premultipliedAlpha","_preserveDrawingBuffer","preserveDrawingBuffer","_clearColor","_clearAlpha","autoClearColor","autoClearDepth","autoClearStencil","gammaInput","gammaOutput","shadowMapCullFace","calls","_currentFramebuffer","_currentGeometryProgram","_viewportX","_viewportY","_viewportWidth","_viewportHeight","_currentWidth","_currentHeight","resetGLState","setDefaultGLState","WebGLState","getShaderPrecisionFormat","rangeMin","rangeMax","WebGLExtensions","glClearColor","clearColor","clearDepth","clearStencil","DEPTH_TEST","depthFunc","LEQUAL","frontFace","CCW","cullFace","BACK","CULL_FACE","BLEND","blendFunc","viewport","MAX_TEXTURE_IMAGE_UNITS","_maxVertexTextures","MAX_VERTEX_TEXTURE_IMAGE_UNITS","_maxTextureSize","MAX_TEXTURE_SIZE","MAX_CUBE_MAP_TEXTURE_SIZE","_vertexShaderPrecisionHighpFloat","VERTEX_SHADER","HIGH_FLOAT","_vertexShaderPrecisionMediumpFloat","MEDIUM_FLOAT","_fragmentShaderPrecisionHighpFloat","FRAGMENT_SHADER","_fragmentShaderPrecisionMediumpFloat","formats","COMPRESSED_TEXTURE_FORMATS","highpAvailable","mediumpAvailable","shadowMapPlugin","ShadowMapPlugin","spritePlugin","SpritePlugin","lensFlarePlugin","LensFlarePlugin","forceContextLoss","loseContext","supportsFloatTextures","supportsHalfFloatTextures","supportsStandardDerivatives","supportsCompressedTextureS3TC","supportsCompressedTexturePVRTC","supportsBlendMinMax","MAX_TEXTURE_MAX_ANISOTROPY_EXT","getPrecision","getPixelRatio","setPixelRatio","updateStyle","scissor","SCISSOR_TEST","getClearColor","getClearAlpha","setClearAlpha","bits","COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","STENCIL_BUFFER_BIT","clearTarget","deallocateGeometry","deallocateTexture","onRenderTargetDispose","deallocateRenderTarget","deleteBuffers","buffers","deleteBuffer","deleteTexture","deleteFramebuffer","__webglFramebuffer","deleteRenderbuffer","__webglRenderbuffer","deleteProgram","newPrograms","renderBufferImmediate","initAttributes","hasPositions","hasNormals","hasUvs","__webglUvBuffer","hasColors","positionArray","nx","ny","nz","nax","nbx","ncx","nay","nby","ncy","naz","nbz","ncz","drawArrays","TRIANGLES","updateBuffers","wireframeBit","geometryProgram","LINES","drawElements","POINTS","LINE_STRIP","setLineWidth","skinIndex","skinWeight","lineDistance","setFaceCulling","frontFaceDirection","CW","FRONT","FRONT_AND_BACK","setDoubleSided","setFlipSided","uploadTexture","UNPACK_PREMULTIPLY_ALPHA_WEBGL","UNPACK_ALIGNMENT","isCube","isTargetPowerOfTwo","createFramebuffer","createRenderbuffer","shareDepthFrom","vx","vy","readRenderTargetPixels","restore","checkFramebufferStatus","FRAMEBUFFER_COMPLETE","readPixels","addPrePlugin","addPostPlugin","updateShadowMap","gl","getExtension","programIdCount","generateDefines","chunk","cacheUniformLocations","identifiers","getUniformLocation","cacheAttributeLocations","getAttribLocation","shadowMapTypeDefine","envMapTypeDefine","envMapModeDefine","envMapBlendingDefine","prefix_vertex","prefix_fragment","gammaFactorDefine","customDefines","createProgram","glVertexShader","WebGLShader","glFragmentShader","attachShader","bindAttribLocation","linkProgram","programLogInfo","getProgramInfoLog","getProgramParameter","LINK_STATUS","getError","VALIDATE_STATUS","deleteShader","addLineNumbers","string","createShader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","getShaderInfoLog","newAttributes","Uint8Array","enabledAttributes","currentBlending","currentBlendEquation","currentBlendSrc","currentBlendDst","currentBlendEquationAlpha","currentBlendSrcAlpha","currentBlendDstAlpha","currentDepthTest","currentDepthWrite","currentColorWrite","currentDoubleSided","currentFlipSided","currentLineWidth","currentPolygonOffset","currentPolygonOffsetFactor","currentPolygonOffsetUnits","enableVertexAttribArray","disableVertexAttribArray","blendEquationSeparate","blendFuncSeparate","depthMask","colorMask","lineWidth","polygonoffset","factor","units","POLYGON_OFFSET_FILL","flares","prefix","vertexBuffer","elementBuffer","hasVertexTexture","tempTexture","occlusionTexture","renderType","occlusionMap","screenPosition","viewportWidth","viewportHeight","tempPosition","invAspect","halfViewportWidth","halfViewportHeight","screenPositionPixels","TEXTURE1","copyTexImage2D","sprite","_renderer","_renderList","createVirtualLight","cascade","virtualLight","isVirtual","pointsWorld","pointsFrustum","nearZ","farZ","updateVirtualLight","updateShadowCamera","_min","_max","getObjectMaterial","_depthMaterial","_depthMaterialMorph","_depthMaterialSkin","_depthMaterialMorphSkin","_matrixPosition","depthShader","depthUniforms","originalCamera","gyro","Gyroscope","shadowFilter","pars","cameraHelper","CameraHelper","objectMaterial","useMorphing","useSkinning","customDepthMaterial","clearAlpha","spritePosition","spriteRotation","spriteScale","uvOffset","uvScale","fogType","fillRect","oldFogType","sceneFogType","GeometryUtils","geometry1","geometry2","loadTextureCube","loadCompressedTexture","loadCompressedTextureCube","getNormalMap","subtract","getImageData","imageData","createImageData","ly","uy","lx","ux","num_points","putImageData","generateDataTexture","SceneUtils","createMultiMaterialObject","detach","attach","FontUtils","divisions","getFace","loadFace","family","familyName","ThreeFont","cssFontWeight","cssFontStyle","drawText","fontPaths","Path","ret","extractGlyphPoints","paths","outline","action","cpx","cpy","cpx0","cpy0","cpx1","cpy1","cpx2","cpy2","laste","pts","glyph","glyphs","_cachedOutline","lineTo","quadraticCurveTo","Shape","Utils","bezierCurveTo","b3","ha","generateShapes","curveSegments","shapes","toShapes","namespace","EPSILON","process","contour","verts","vertIndices","nv","snip","px","py","aX","aY","bX","bY","cX","cY","apx","apy","bpx","bpy","cCROSSap","bCROSScp","aCROSSbp","Triangulate","_typeface_js","typeface_js","createBufferSource","onended","onEnded","gain","createGain","destination","panner","createPanner","autoplay","isPlaying","onload","decodeAudioData","setLoop","setRefDistance","refDistance","setRolloffFactor","rolloffFactor","setVolume","AudioContext","webkitAudioContext","velocity","positionPrev","setOrientation","setVelocity","Curve","getPointAt","getUtoTmapping","getPoints","getSpacedPoints","lengths","getLengths","cacheArcLengths","cache","last","sum","updateArcLengths","targetArcLength","arcLengths","comparison","lengthBefore","lengthAfter","segmentLength","segmentFraction","getTangent","pt1","pt2","vec","getTangentAt","tangentQuadraticBezier","tangentCubicBezier","tangentSpline","h00","h10","h01","h11","getPointFunc","CurvePath","curves","bends","autoClose","curve","checkConnection","closePath","startPoint","endPoint","LineCurve","curveLengths","getCurveLengths","lens","cacheLengths","sums","maxX","maxY","maxZ","minX","minY","minZ","NEGATIVE_INFINITY","POSITIVE_INFINITY","createPointsGeometry","createGeometry","createSpacedPointsGeometry","addWrapPath","bendpath","getTransformedPoints","oldPts","getWrapPoints","getTransformedSpacedPoints","oldX","oldY","xNorm","bounds","pathPt","translationObject","quaternionObject","scaleObject","translationWorld","quaternionWorld","scaleWorld","actions","fromPoints","PathActions","MOVE_TO","LINE_TO","QUADRATIC_CURVE_TO","BEZIER_CURVE_TO","CSPLINE_THRU","ARC","ELLIPSE","vectors","vlen","lastargs","x0","y0","aCPx","aCPy","QuadraticBezierCurve","aCP1x","aCP1y","aCP2x","aCP2y","CubicBezierCurve","splineThru","npts","SplineCurve","aRadius","aStartAngle","aEndAngle","aClockwise","absarc","absellipse","ellipse","xRadius","yRadius","EllipseCurve","lastPoint","closedPath","useSpacedPoints","spts","spline","deltaAngle","tdivisions","isCCW","noHoles","extractSubpaths","inActions","subPaths","lastPath","toShapesNoHoles","inSubpaths","tmpPath","tmpShape","isPointInsidePolygon","inPt","inPolygon","polyLen","inside","edgeLowPt","edgeHighPt","edgeDx","edgeDy","perpEdge","solid","holesFirst","isClockWise","tmpPoints","betterShapeHoles","newShapes","newShapeHoles","mainIdx","ambigious","toChange","sIdx","sLen","sho","hIdx","ho","hole_unassigned","s2Idx","froms","tos","hole","tmpHoles","holes","extrude","extruded","ExtrudeGeometry","makeGeometry","ShapeGeometry","getPointsHoles","holesPts","getSpacedPointsHoles","extractAllPoints","shape","extractPoints","extractAllSpacedPoints","triangulateShape","point_in_segment_2D_colin","inSegPt1","inSegPt2","inOtherPt","intersect_segments_2D","inSeg1Pt1","inSeg1Pt2","inSeg2Pt1","inSeg2Pt2","inExcludeAdjacentSegs","seg1dx","seg1dy","seg2dx","seg2dy","seg1seg2dx","seg1seg2dy","limit","perpSeg1","perpSeg2","factorSeg1","seg1Pt","seg2Pt","seg1min","seg1max","seg1minVal","seg1maxVal","seg2min","seg2max","seg2minVal","seg2maxVal","isPointInsideAngle","inVertex","inLegFromPt","inLegToPt","legFromPtX","legFromPtY","legToPtX","legToPtY","otherPtX","otherPtY","from2toAngle","from2otherAngle","other2toAngle","removeHoles","isCutLineInsideAngles","inShapeIdx","inHoleIdx","lastShapeIdx","prevShapeIdx","nextShapeIdx","insideAngle","lastHoleIdx","prevHoleIdx","nextHoleIdx","intersectsShapeEdge","inShapePt","inHolePt","nextIdx","intersection","intersectsHoleEdge","ihIdx","chkHole","indepHoles","holeIndex","shapeIndex","shapePt","holePt","holeIdx","cutKey","tmpShape1","tmpShape2","tmpHole1","tmpHole2","failedCuts","hl","minShapeIndex","h2","allPointsMap","allpoints","shapeWithoutHoles","triangles","b2p0","b2p1","b2p2","b3p0","b3p1","b3p2","b3p3","point0","point1","point2","point3","ArcCurve","LineCurve3","QuadraticBezierCurve3","CubicBezierCurve3","SplineCurve3","ClosedSplineCurve3","AnimationHandler","CATMULLROM","CATMULLROM_FORWARD","initialized","hierarchy","rot","usedMorphTargets","morphTargetName","morphTargetsInfluences","parseRecurseHierarchy","deltaTimeMS","resetBlendWeights","Animation","timeScale","interpolationType","keyTypes","animationCache","positionWeight","quaternionWeight","scaleWeight","prevKey","nextKey","originalMatrix","getNextKeyWith","newVector","newQuat","interpolateCatmullRom","prevXYZ","nextXYZ","proportionalWeight","getPrevKeyWith","currentPoint","forwardPoint","KeyFrameAnimation","isPaused","sids","sid","next","endTime","original","hasTarget","MorphAnimation","frames","lastFrame","currentFrame","interpolation","frame","buildPlane","udir","vdir","gridX","gridY","width_half","height_half","gridX1","gridY1","segment_width","segment_height","uvd","depth_half","centerUV","segment","CubeGeometry","heightHalf","verticesRow","uvsRow","tanTheta","v4","n4","uv1","uv3","uv4","addShapeList","addShape","scalePt2","pt","getBevelVec","inPrev","inNext","v_trans_x","v_trans_y","shrink_by","v_prev_x","v_prev_y","v_next_x","v_next_y","v_prev_lensq","colinear0","v_prev_len","v_next_len","ptPrevShift_x","ptPrevShift_y","ptNextShift_x","ptNextShift_y","sf","v_trans_lensq","direction_eq","buildLidFaces","bevelEnabled","layer","flen","f3","steps","bevelSegments","buildSideFaces","layeroffset","sidewalls","ahole","slen1","slen2","f4","shapesOffset","uvgen","generateTopUV","wallContour","stepIndex","stepsLength","contourIndex1","contourIndex2","extrudeMaterial","generateSideWallUV","extrudePts","splineTube","binormal","position2","amount","bevelThickness","bevelSize","extrudePath","extrudeByPath","UVGenerator","WorldUVGenerator","TubeGeometry","FrenetFrames","shapePoints","reverse","bs","vert","contourMovements","oneHoleMovements","holesMovements","verticesMovements","binormals","indexA","indexB","indexC","indexD","LatheGeometry","inversePointLength","inverseSegments","np","u0","u1","PlaneGeometry","offset2","RingGeometry","innerRadius","outerRadius","thetaSegments","phiSegments","radiusStep","thetaSegment","TextGeometry","textShapes","getPos","in_q","in_p","cu","su","quOverP","cs","tz","grid","tang","bitan","ip","jp","closed","taper","NoTaper","numpoints","pos2","SinusoidalTaper","initialNormal3","smallest","MAX_VALUE","mat","PolyhedronGeometry","prepare","that","inclination","make","centroid","azi","correctUV","subdivide","cols","aj","bj","rows","DodecahedronGeometry","OctahedronGeometry","TetrahedronGeometry","ParametricGeometry","func","slices","stacks","sliceCount","AxisHelper","ArrowHelper","lineGeometry","coneGeometry","dir","headLength","headWidth","cone","setDirection","setColor","BoxHelper","BoundingBoxHelper","addLine","addPoint","pointMap","hexFrustum","hexCone","hexUp","hexTarget","hexCross","setPoint","DirectionalLightHelper","lightPlane","targetLine","EdgesHelper","thresholdAngle","thresholdDot","edge","sortFunction","numEdges","vert1","vert2","face1","face2","FaceNormalsHelper","objectVertices","objectFaces","objectWorldMatrix","GridHelper","setColors","colorCenterLine","colorGrid","HemisphereLightHelper","sphereSize","lightSphere","PointLightHelper","SkeletonHelper","getBoneList","boneList","matrixWorldInv","boneMatrix","SpotLightHelper","vector2","coneLength","coneWidth","VertexNormalsHelper","worldMatrix","vertexId","VertexTangentsHelper","WireframeHelper","edges","numTris","renderCallback","MorphBlendMesh","animationsMap","animationsList","numFrames","startFrame","endFrame","createAnimation","setAnimationWeight","active","autoCreateAnimations","frameRanges","setAnimationDirectionForward","setAnimationDirectionBackward","setAnimationFPS","setAnimationDuration","setAnimationTime","getAnimationTime","getAnimationDuration","stopAnimation","./asphalt.jpg","./brick-tiles.jpg","./bricks-normal.jpg","./bricks-specular.jpg","./bricks.jpg","./checkerboard.png","./cloud10.png","./grass.jpg","./metal-floor.jpg","./metal.jpg","./stone.jpg","./tiles.jpg","./weathered-wood.jpg","./wood.jpg","RegExp","createForEach","arrayFunc","eachFunc","collection","iteratee","thisArg","bindCallback","arrayEach","baseEach","assignWith","customizer","getSymbols","toObject","isObject","baseAssign","createAssigner","isNative","arrayProto","getOwnPropertySymbols","started","input","HTMLAudioElement","onerror","linearRampToValueAtTime","luminance","turbidity","reileigh","mieCoefficient","mieDirectionalG","skyShader","skyUniforms","skyMat","skyGeo","skyMesh","utils","randomVector3","spread","randomColor","randomFloat","randomVector3OnSphere","radiusSpread","radiusScale","radiusSpreadClamp","rand","_randomFloat","randomVector3OnDisk","randomVelocityVector3OnSphere","speed","speedSpread","randomizeExistingVector3","randomizeExistingColor","randomizeExistingVector3OnSphere","randomizeExistingVector3OnDisk","randomizeExistingVelocityVector3OnSphere","generateID","str","fixedTimeStep","colorize","acceleration","alive","age","colorMiddle","colorEnd","emitters","_pool","_poolCreationSettings","_createNewWhenPoolEmpty","maxAgeMilliseconds","shaders","fragment","_flagUpdate","particlesPerSecond","particleIndex","_randomVector3OnSphere","_randomVelocityVector3OnSphere","_randomVector3OnDisk","_randomVector3","velocitySpread","accelerationSpread","sizeMiddle","sizeMiddleSpread","sizeEnd","sizeEndSpread","angleStart","angleStartSpread","angleMiddle","angleMiddleSpread","angleEnd","angleEndSpread","angleAlignVelocity","_randomColor","colorStartSpread","colorMiddleSpread","colorEndSpread","opacityStart","opacityStartSpread","opacityMiddle","opacityMiddleSpread","opacityEnd","opacityEndSpread","verticesIndex","__id","_generateID","removeEmitter","dt","numEmitters","getFromPool","pool","createNew","releaseIntoPool","unshift","getPool","addPool","emitterSettings","_triggerSingleEmitter","triggerPoolEmitter","onParticleSpawn","_resetParticle","particlePosition","particleVelocity","vSpread","aSpread","_randomizeExistingVector3","_randomizeExistingVector3OnSphere","_randomizeExistingVelocityVector3OnSphere","_randomizeExistingVector3OnDisk","pps","ppsdt","emitterAge","pIndex","dtInc","pIndexFloor","normalizeOpts","isCallable","contains","dscr","desc","gs","TypeError","assigner","restParam","guard","isIterateeCall","baseToString","isObjectLike","objToString","funcTag","reIsNative","fnToString","reIsHostCtor","escapeRegExp","reHasRegExpChars","reRegExpChars","objectProto","baseCopy","preventExtensions","nativeAssign","1","baseForOwn","baseFor","baseProperty","createBaseEach","fromRight","isLength","iterable","createBaseFor","keysFunc","MAX_SAFE_INTEGER","argCount","accumulator","other","arrayTag","nativeIsArray","foo","bar","trzy","dest","searchString","FUNC_ERROR_TEXT","nativeMax","rest","otherArgs","isIndex","prereq","isArguments","argsTag","__webpack_module_template_argument_0__","__webpack_module_template_argument_1__","__webpack_module_template_argument_2__","shimKeys","keysIn","propsLength","allowIndexes","support","nonEnumArgs","Ctor","isProto","skipIndexes","propertyIsEnumerable","nativeKeys","valueOf"],"mappings":"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","file":"vr.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ((function(modules) {\n\t// Check all modules for deduplicated modules\n\tfor(var i in modules) {\n\t\tif(Object.prototype.hasOwnProperty.call(modules, i)) {\n\t\t\tswitch(typeof modules[i]) {\n\t\t\tcase \"number\":\n\t\t\t\t// Module is a copy of another module\n\t\t\t\tmodules[i] = modules[modules[i]];\n\t\t\t\tbreak;\n\t\t\tcase \"object\":\n\t\t\t\t// Module can be created from a template\n\t\t\t\tmodules[i] = (function(_m) {\n\t\t\t\t\tvar args = _m.slice(1), fn = modules[_m[0]];\n\t\t\t\t\treturn function (a,b,c) {\n\t\t\t\t\t\tfn.apply(null, [a,b,c].concat(args));\n\t\t\t\t\t};\n\t\t\t\t}(modules[i]));\n\t\t\t}\n\t\t}\n\t}\n\treturn modules;\n}([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t(function () {\n\t\t'use strict';\n\t\n\t\t//global-ish declarations\n\t\tvar VR,\n\t\t\tNoSleep = __webpack_require__(9).NoSleep;\n\t\n\t\tfunction initRequirements() {\n\t\t\t//load styles\n\t\t\t__webpack_require__(2);\n\t\n\t\t\tVR = __webpack_require__(1);\n\t\t}\n\t\n\t\tfunction initUI() {\n\t\t\tvar container,\n\t\t\t\tenableFullscreen,\n\t\t\t\tdisableFullscreen,\n\t\t\t\tvrButton,\n\t\t\t\torientationButton,\n\t\t\t\telement,\n\t\n\t\t\t\tnoSleep = new NoSleep(),\n\t\n\t\t\t\tfullScreenElement = document.body,\n\t\n\t\t\t\tfullscreenEnabled = document.fullscreenEnabled ||\n\t\t\t\t\tdocument.webkitFullscreenEnabled ||\n\t\t\t\t\tdocument.mozFullScreenEnabled ||\n\t\t\t\t\tdocument.msFullscreenEnabled,\n\t\n\t\t\t\trequestFullscreen = fullScreenElement.webkitRequestFullscreen ||\n\t\t\t\t\tfullScreenElement.mozRequestFullScreen ||\n\t\t\t\t\tfullScreenElement.msRequestFullscreen;\n\t\n\t\t\tfunction svgButton(source, id) {\n\t\t\t\tvar span = document.createElement('span'),\n\t\t\t\t\tsvg;\n\t\n\t\t\t\tspan.innerHTML = source;\n\t\t\t\tspan.id = id;\n\t\n\t\t\t\tsvg = span.firstChild;\n\t\t\t\tsvg.setAttribute('width', 18);\n\t\t\t\tsvg.setAttribute('height', 18);\n\t\n\t\t\t\tcontainer.appendChild(span);\n\t\n\t\t\t\treturn span;\n\t\t\t}\n\t\n\t\t\tfunction toggleOrientation() {\n\t\t\t\tif (VR.orientationEnabled()) {\n\t\t\t\t\tVR.disableOrientation();\n\t\t\t\t} else {\n\t\t\t\t\tVR.enableOrientation();\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tfunction deviceChange() {\n\t\t\t\tif (VR.controlMode()) {\n\t\t\t\t\tvrButton.classList.remove('unsupported');\n\t\t\t\t\torientationButton.classList.remove('unsupported');\n\t\t\t\t}\n\t\n\t\t\t\t//todo: enable this\n\t\t\t\t//info.innerHTML = hmd && hmd.deviceName ? 'HMD: ' + hmd.deviceName : '';\n\t\t\t\t//info.className = hmd && hmd.deviceId !== 'debug-0' ? 'has-hmd' : '';\n\t\t\t}\n\t\n\t\t\t//set up meta viewport tag for mobile devices\n\t\t\telement = document.createElement('meta');\n\t\t\telement.setAttribute('name', 'viewport');\n\t\t\telement.setAttribute('content', 'width=device-width, initial-scale=1, user-scalable=no');\n\t\t\tdocument.head.appendChild(element);\n\t\n\t\t\tcontainer = document.createElement('div');\n\t\t\tcontainer.id = 'buttons';\n\t\t\tdocument.body.appendChild(container);\n\t\n\t\t\t//todo: use icons instead of text\n\t\t\tif (requestFullscreen && fullscreenEnabled) {\n\t\t\t\tenableFullscreen = svgButton(__webpack_require__(5), 'fs-enable');\n\t\t\t\tenableFullscreen.setAttribute('title', 'Enable Full Screen');\n\t\t\t\tenableFullscreen.addEventListener('click', requestFullscreen.bind(fullScreenElement), false);\n\t\n\t\t\t\tdisableFullscreen = svgButton(__webpack_require__(6), 'fs-disable');\n\t\t\t\tdisableFullscreen.setAttribute('title', 'Exit Full Screen');\n\t\t\t\tdisableFullscreen.addEventListener('click', VR.exitFullscreen, false);\n\t\t\t}\n\t\n\t\t\tVR.on('fullscreenchange', function () {\n\t\t\t\tif (VR.isFullscreen()) {\n\t\t\t\t\tdisableFullscreen.style.display = 'inline-block';\n\t\t\t\t\tenableFullscreen.style.display = 'none';\n\t\t\t\t} else {\n\t\t\t\t\tdisableFullscreen.style.display = '';\n\t\t\t\t\tenableFullscreen.style.display = '';\n\t\t\t\t}\n\t\n\t\t\t\t//disable sleep on mobile devices in VR mode\n\t\t\t\tif (VR.vrMode()) {\n\t\t\t\t\tnoSleep.enable();\n\t\t\t\t} else {\n\t\t\t\t\tnoSleep.disable();\n\t\t\t\t}\n\t\t\t});\n\t\n\t\t\tvrButton = svgButton(__webpack_require__(7), 'vr');\n\t\t\tvrButton.setAttribute('title', 'Toggle Virtual Reality');\n\t\t\tvrButton.className = 'unsupported';\n\t\t\tvrButton.addEventListener('click', VR.requestVR, false);\n\t\n\t\t\torientationButton = svgButton(__webpack_require__(8), 'orientation');\n\t\t\torientationButton.setAttribute('title', 'Toggle Orientation');\n\t\t\torientationButton.className = 'unsupported';\n\t\t\torientationButton.addEventListener('click', toggleOrientation, false);\n\t\n\t\t\t//report on HMD\n\t\t\tVR.on('devicechange', deviceChange);\n\t\t\tdeviceChange();\n\t\n\t\t\t//keyboard shortcuts for making life a little easier\n\t\t\twindow.addEventListener('keydown', function (evt) {\n\t\t\t\tif (evt.keyCode === 'Z'.charCodeAt(0)) {\n\t\t\t\t\tVR.zeroSensor();\n\t\t\t\t} else if (evt.keyCode === 'O'.charCodeAt(0)) {\n\t\t\t\t\tVR.enableOrientation();\n\t\t\t\t} else if (evt.keyCode === 13) {\n\t\t\t\t\tVR.requestVR();\n\t\t\t\t}\n\t\t\t}, false);\n\t\n\t\t\tVR.resize();\n\t\t}\n\t\n\t\tfunction initialize() {\n\t\t\tinitRequirements();\n\t\n\t\t\t//todo: set up button/info elements\n\t\n\t\t\tVR.init();\n\t\n\t\t\tif (document.body) {\n\t\t\t\tinitUI();\n\t\t\t} else {\n\t\t\t\twindow.addEventListener('load', initUI, false);\n\t\t\t}\n\t\n\t\t\twindow.addEventListener('resize', VR.resize, false);\n\t\n\t\t\t/*\n\t\t\texport global things\n\t\t\t*/\n\t\t\twindow.VR = VR;\n\t\t\twindow.THREE = VR.THREE;\n\t\t}\n\t\n\t\tinitialize();\n\t\tVR.start();\n\t}());\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t(function () {\n\t\t'use strict';\n\t\n\t\t//constants\n\t\tvar NEAR = 0.1,\n\t\t\tFAR = 1000000,\n\t\n\t\t//global-ish declarations\n\t\t\tTHREE,\n\t\t\teventEmitter,\n\t\t\tmaterials = __webpack_require__(10),\n\t\t\tnop = function () {},\n\t\t\trequestFullscreen = nop,\n\t\t\texitFullscreen = (\n\t\t\t\tdocument.exitFullscreen ||\n\t\t\t\tdocument.mozCancelFullScreen ||\n\t\t\t\tdocument.webkitExitFullscreen ||\n\t\t\t\tdocument.msExitFullscreen ||\n\t\t\t\tnop\n\t\t\t).bind(document),\n\t\n\t\t//scene assets\n\t\t\tcamera,\n\t\t\tscene,\n\t\t\tbody,\n\t\t\trenderer,\n\t\t\taudioListener,\n\t\t\tvrControls,\n\t\t\tvrEffect,\n\t\t\tmouseControls,\n\t\t\traycaster,\n\t\t\ttarget,\n\t\n\t\t\tbodyWrapper,\n\t\t\tcameraWrapper,\n\t\n\t\t\tfloor,\n\t\n\t\t//state\n\t\t\tgoing = false,\n\t\t\tvrMode = false,\n\t\t\torientationEnabled,\n\t\t\torientationPossible = false,\n\t\n\t\t//exported object\n\t\t\tVR,\n\t\n\t\t\tVRObject = __webpack_require__(11),\n\t\t\tobjectMethods = [\n\t\t\t\t'box',\n\t\t\t\t'cylinder',\n\t\t\t\t'torus',\n\t\t\t\t'sphere',\n\t\t\t\t'empty',\n\t\t\t\t'sound',\n\t\t\t\t'floor',\n\t\t\t\t'sky',\n\t\t\t\t'panorama',\n\t\t\t\t'image',\n\t\t\t\t'video',\n\t\t\t\t'text'\n\t\t\t],\n\t\n\t\t\t//todo: use a weak map or set instead\n\t\t\tvrObjects = [],\n\t\n\t\t\tlastTick = 0,\n\t\t\tanimationCallbacks = [];\n\t\n\t\tfunction isFullscreen() {\n\t\t\treturn !!(document.fullscreenElement ||\n\t\t\t\tdocument.mozFullScreenElement ||\n\t\t\t\tdocument.webkitFullscreenElement ||\n\t\t\t\tdocument.msFullscreenElement);\n\t\t}\n\t\n\t\tfunction fullScreenError() {\n\t\t\tvrMode = false;\n\t\t\tif (vrEffect) {\n\t\t\t\tvrEffect.exit();\n\t\t\t}\n\t\t}\n\t\n\t\tfunction raycast() {\n\t\t\tvar i,\n\t\t\t\tintersect,\n\t\t\t\tobject,\n\t\t\t\tintersects,\n\t\t\t\tvrObject;\n\t\n\t\t\traycaster.ray.origin.copy( camera.position );\n\t\t\traycaster.ray.direction.set(0, 0, 0.5).unproject(camera).sub(camera.position).normalize();\n\t\n\t\t\tintersects = raycaster.intersectObjects( scene.children );\n\t\t\tfor (i = 0; i < intersects.length; i++) {\n\t\t\t\tintersect = intersects[i];\n\t\t\t\tif (intersect.object instanceof THREE.Mesh) {\n\t\t\t\t\tobject = intersect.object;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tif (target !== object) {\n\t\t\t\tif (target) {\n\t\t\t\t\tvrObject = VRObject.findObject(target);\n\t\t\t\t\tvrObject.emit('lookaway');\n\t\t\t\t\tVR.emit('lookaway', vrObject);\n\t\t\t\t}\n\t\t\t\ttarget = object;\n\t\t\t\tif (target) {\n\t\t\t\t\tvrObject = VRObject.findObject(target);\n\t\t\t\t\tvrObject.emit('lookat', intersect);\n\t\t\t\t\tVR.emit('lookat', vrObject, intersect);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tfunction render() {\n\t\t\tvar now = Date.now() / 1000,\n\t\t\t\tdelta = Math.min(1, now - lastTick);\n\t\n\t\t\tvrControls.update();\n\t\n\t\t\tanimationCallbacks.forEach(function (cb) {\n\t\t\t\tcb(delta, now);\n\t\t\t});\n\t\n\t\t\tscene.updateMatrixWorld();\n\t\n\t\t\tvrObjects.forEach(function (object) {\n\t\t\t\tobject.update(now);\n\t\t\t});\n\t\n\t\t\traycast();\n\t\n\t\t\tvrEffect.render(scene, camera);\n\t\n\t\t\tlastTick = now;\n\t\t}\n\t\n\t\tfunction renderLoop() {\n\t\t\tif (going) {\n\t\t\t\trender();\n\t\t\t\trequestAnimationFrame(renderLoop);\n\t\t\t}\n\t\t}\n\t\n\t\tfunction stop() {\n\t\t\tgoing = false;\n\t\t}\n\t\n\t\tfunction start() {\n\t\t\tif (!going) {\n\t\t\t\tgoing = true;\n\t\t\t\trenderLoop();\n\t\t\t}\n\t\t}\n\t\n\t\t/*\n\t\tMute any sounds when this browser tab is in the background or minimized.\n\t\t*/\n\t\tfunction visibilityChange() {\n\t\t\tif (document.hidden || document.mozHidden || document.msHidden || document.webkitHidden) {\n\t\t\t\taudioListener.volume(0);\n\t\t\t} else {\n\t\t\t\taudioListener.volume(1);\n\t\t\t}\n\t\t}\n\t\n\t\tfunction resize(width, height) {\n\t\t\twidth = typeof width === 'number' && width || window.innerWidth;\n\t\t\theight = typeof height === 'number' && height || window.innerHeight;\n\t\n\t\t\tcamera.aspect = width / height;\n\t\t\tcamera.updateProjectionMatrix();\n\t\t\trenderer.setSize(width, height);\n\t\t}\n\t\n\t\tfunction initShake() {\n\t\t\tvar lastTime = 0,\n\t\t\t\tlastX,\n\t\t\t\tlastY,\n\t\t\t\tlastZ,\n\t\t\t\tthreshold = 15;\n\t\n\t\t\twindow.addEventListener('devicemotion', function (evt) {\n\t\t\t\tvar current = evt.accelerationIncludingGravity,\n\t\t\t\t\ttime,\n\t\t\t\t\tdiff,\n\t\t\t\t\tdeltaX = 0,\n\t\t\t\t\tdeltaY = 0,\n\t\t\t\t\tdeltaZ = 0,\n\t\t\t\t\tdist;\n\t\n\t\t\t\tif (lastX !== undefined) {\n\t\t\t\t\tdeltaX = Math.abs(lastX - current.x);\n\t\t\t\t\tdeltaY = Math.abs(lastY - current.y);\n\t\t\t\t\tdeltaZ = Math.abs(lastZ - current.z);\n\t\n\t\t\t\t\t// if (deltaX > threshold &&\n\t\t\t\t\t// \t\t(deltaY > threshold || deltaZ > threshold)\n\t\t\t\t\t// \t) {\n\t\t\t\t\tdist = Math.sqrt(deltaX * deltaX + deltaY * deltaY + deltaZ * deltaZ);\n\t\t\t\t\tif (dist > threshold) {\n\t\n\t\t\t\t\t\ttime = Date.now();\n\t\t\t\t\t\tdiff = time - lastTime;\n\t\t\t\t\t\tif (diff > 1000) {\n\t\t\t\t\t\t\tif (navigator.vibrate) {\n\t\t\t\t\t\t\t\tnavigator.vibrate(100);\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tlastTime = Date.now();\n\t\n\t\t\t\t\t\t\tVR.emit('shake');\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tlastX = current.x;\n\t\t\t\tlastY = current.y;\n\t\t\t\tlastZ = current.z;\n\t\n\t\t\t\torientationPossible = true;\n\t\t\t}, false);\n\t\t}\n\t\n\t\tfunction initScene() {\n\t\t\tfunction attachCanvas() {\n\t\t\t\tdocument.body.insertBefore(renderer.domElement, document.body.firstChild || null);\n\t\t\t\tresize();\n\t\t\t}\n\t\n\t\t\tif (renderer) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\t//create renderer and place in document\n\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\trenderer.domElement.addEventListener('webglcontextlost', function contextLost(event) {\n\t\t\t\tconsole.log('lost context', event);\n\t\t\t});\n\t\t\t// renderer.shadowMapEnabled = true;\n\t\t\t// renderer.shadowMapSoft = true;\n\t\n\t\t\t//need a scene to put all our objects in\n\t\t\tscene = new THREE.Scene();\n\t\n\t\t\tbodyWrapper = new VRObject(scene, __webpack_require__(13), null, {\n\t\t\t\tname: 'body'\n\t\t\t}).moveTo(0, 1.5, 4);\n\t\t\tbody = bodyWrapper.object;\n\t\n\t\t\tcameraWrapper = new VRObject(body, function (parent) {\n\t\t\t\t//need a camera with which to look at stuff\n\t\t\t\tcamera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, NEAR, FAR);\n\t\t\t\tparent.add(camera);\n\t\n\t\t\t\treturn camera;\n\t\t\t})\n\t\t\t// set camera position so that OrbitControls works properly.\n\t\t\t\t.moveTo(0, 0.0001, 0.0001);\n\t\n\t\t\taudioListener = new THREE.AudioListener();\n\t\t\taudioListener.name = 'audio-listener';\n\t\t\tcamera.add(audioListener);\n\t\n\t\t\t//VRControls point the camera wherever we're looking\n\t\t\tvrControls = new THREE.VRControls(camera);\n\t\t\tvrControls.freeze = !orientationEnabled;\n\t\n\t\t\t//render left and right eye\n\t\t\tvrEffect = new THREE.VRStereoEffect(renderer);\n\t\t\tvrEffect.near = NEAR;\n\t\t\tvrEffect.far = FAR;\n\t\t\tvrEffect.addEventListener('fullscreenchange', function (evt) {\n\t\t\t\tvar screen;\n\t\t\t\tif (isFullscreen()) {\n\t\t\t\t\tif (vrMode) {\n\t\t\t\t\t\t//no mouse control\n\t\t\t\t\t\tmouseControls.enabled = false;\n\t\n\t\t\t\t\t\tvrControls.freeze = false;\n\t\t\t\t\t\tvrControls.reset();\n\t\n\t\t\t\t\t\tscreen = window.screen;\n\t\t\t\t\t\tif (screen.lockOrientation) {\n\t\t\t\t\t\t\tscreen.lockOrientation('landscape-primary');\n\t\t\t\t\t\t} else if (screen.mozLockOrientation) {\n\t\t\t\t\t\t\tscreen.mozLockOrientation('landscape-primary');\n\t\t\t\t\t\t} else if (screen.orientation && screen.orientation.lock) {\n\t\t\t\t\t\t\tscreen.orientation.lock('landscape-primary');\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tVR.exitVR();\n\t\t\t\t}\n\t\n\t\t\t\tcamera.position.set(0, 0.0001, 0.0001);\n\t\t\t\tcamera.rotation.set(0, 0, 0);\n\t\n\t\t\t\tVR.emit('fullscreenchange', evt);\n\t\t\t});\n\t\n\t\t\t//report on HMD\n\t\t\tvrControls.addEventListener('devicechange', function () {\n\t\t\t\torientationPossible = true;\n\t\t\t\tif (orientationEnabled === undefined) {\n\t\t\t\t\torientationEnabled = vrControls.mode() === 'deviceorientation';\n\t\t\t\t}\n\t\n\t\t\t\tvrControls.freeze = !orientationEnabled && !vrMode;\n\t\n\t\t\t\tVR.emit('devicechange', vrControls.mode(), vrEffect.hmd());\n\t\t\t});\n\t\n\t\t\t//mouse control in case got no orientation device\n\t\t\tmouseControls = new THREE.OrbitControls(camera);\n\t\t\tmouseControls.target0.set(0, 0.0001, 0.000);\n\t\t\tmouseControls.target.copy(mouseControls.target0);\n\t\t\tmouseControls.update();\n\t\n\t\t\t//todo: remove any default lights once other lights are added\n\t\t\tvar dLight = new THREE.DirectionalLight(0xffffff, 0.8);\n\t\t\tdLight.name = 'directional-light';\n\t\t\tdLight.position.set(20, 100, 100);\n\t\n\t\t\tdLight.castShadow = true;\n\t\t\tdLight.shadowCameraVisible = true;\n\t\n\t\t\tdLight.shadowMapWidth = 2048;\n\t\t\tdLight.shadowMapHeight = 2048;\n\t\n\t\t\tdLight.shadowCameraLeft = -10;\n\t\t\tdLight.shadowCameraRight = 10;\n\t\t\tdLight.shadowCameraTop = 10;\n\t\t\tdLight.shadowCameraBottom = -10;\n\t\n\t\t\tdLight.shadowCameraFar = 150;\n\t\t\tdLight.shadowCameraNear = 100;\n\t\t\tdLight.shadowDarkness = 1;\n\t\n\t\t\tscene.add(dLight);\n\t\n\t\t\tscene.add(new THREE.AmbientLight(0x444444));\n\t\n\t\t\tif (VR) {\n\t\t\t\tVR.camera = cameraWrapper;\n\t\t\t\tVR.body = bodyWrapper;\n\t\t\t\tVR.scene = scene;\n\t\t\t\tVR.canvas = renderer.domElement;\n\t\t\t\tVR.zeroSensor = vrControls.zeroSensor;\n\t\t\t}\n\t\n\t\t\traycaster = new THREE.Raycaster();\n\t\n\t\t\tif (document.body) {\n\t\t\t\tattachCanvas();\n\t\t\t} else {\n\t\t\t\twindow.addEventListener('load', attachCanvas, false);\n\t\t\t}\n\t\n\t\t\tVR.canvas.addEventListener('mozfullscreenerror', fullScreenError, false);\n\t\t\tVR.canvas.addEventListener('webkitfullscreenerror', fullScreenError, false);\n\t\t\tVR.canvas.addEventListener('fullscreenerror', fullScreenError, false);\n\t\t}\n\t\n\t\tfunction initRequirements() {\n\t\t\t//load external requirements\n\t\t\tTHREE = __webpack_require__(33);\n\t\t\t__webpack_require__(15);\n\t\t\t__webpack_require__(16);\n\t\n\t\t\t//if (typeof __DEV__ !== 'undefined' && __DEV__) {\n\t\t\t\t__webpack_require__(17);\n\t\t\t//}\n\t\n\t\t\tTHREE.ImageUtils.crossOrigin = '';\n\t\n\t\t\teventEmitter = __webpack_require__(20);\n\t\n\t\t\t//my VR stuff. todo: move these to a separate repo or two for easy packaging\n\t\t\t__webpack_require__(18);\n\t\t\t__webpack_require__(19);\n\t\t}\n\t\n\t\tfunction initialize() {\n\t\t\t//todo: set up button/info elements\n\t\n\t\t\tinitScene();\n\t\n\t\t\tinitShake();\n\t\n\t\t\tresize();\n\t\n\t\t\tdocument.addEventListener('visibilitychange', visibilityChange);\n\t\t\tdocument.addEventListener('mozvisibilitychange', visibilityChange);\n\t\t\tdocument.addEventListener('msvisibilitychange', visibilityChange);\n\t\t\tdocument.addEventListener('webkitvisibilitychange', visibilityChange);\n\t\t}\n\t\n\t\tinitRequirements();\n\t\n\t\tmodule.exports = VR = {\n\t\t\tinit: initialize,\n\t\t\trender: render,\n\t\t\tstart: start,\n\t\t\tstop: stop,\n\t\t\tresize: resize,\n\t\n\t\t\tTHREE: THREE,\n\t\n\t\t\tmaterials: materials,\n\t\n\t\t\tanimate: function (callback) {\n\t\t\t\tvar i;\n\t\t\t\tif (typeof callback === 'function') {\n\t\t\t\t\ti = animationCallbacks.indexOf(callback);\n\t\t\t\t\tif (i < 0) {\n\t\t\t\t\t\tanimationCallbacks.push(callback);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\n\t\t\tend: function (callback) {\n\t\t\t\tvar i;\n\t\n\t\t\t\tif (!callback) {\n\t\t\t\t\tanimationCallbacks.length = 0;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\n\t\t\t\tif (typeof callback === 'function') {\n\t\t\t\t\ti = animationCallbacks.indexOf(callback);\n\t\t\t\t\tif (i >= 0) {\n\t\t\t\t\t\tanimationCallbacks.splice(i, 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\n\t\t\trequestVR: function () {\n\t\t\t\t//todo: check if it's possible\n\t\t\t\tif (vrMode || !vrEffect) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\n\t\t\t\tvrMode = true;\n\t\n\t\t\t\t//full screen and render two eyes\n\t\t\t\t//always full screen\n\t\t\t\tvrEffect.requestFullScreen();\n\t\t\t},\n\t\n\t\t\texitVR: function () {\n\t\t\t\tvrMode = false;\n\t\t\t\tif (isFullscreen()) {\n\t\t\t\t\texitFullscreen();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\n\t\t\t\tmouseControls.enabled = true;\n\t\t\t\tvrControls.freeze = !orientationEnabled;\n\t\t\t\tcamera.rotation.set(0, 0, 0);\n\t\t\t},\n\t\n\t\t\tvrMode: function () {\n\t\t\t\treturn vrMode && isFullscreen();\n\t\t\t},\n\t\n\t\t\torientationEnabled: function () {\n\t\t\t\treturn !!orientationEnabled;\n\t\t\t},\n\t\t\tenableOrientation: function () {\n\t\t\t\torientationEnabled = true;\n\t\t\t\tif (!vrMode) {\n\t\t\t\t\tvrControls.freeze = false;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdisableOrientation: function () {\n\t\t\t\torientationEnabled = false;\n\t\t\t\tcamera.rotation.set(0, 0, 0);\n\t\t\t\tvrControls.freeze = !vrMode;\n\t\t\t},\n\t\n\t\t\tisFullscreen: isFullscreen,\n\t\t\trequestFullscreen: requestFullscreen,\n\t\t\texitFullscreen: function () {\n\t\t\t\tif (isFullscreen()) {\n\t\t\t\t\texitFullscreen();\n\t\t\t\t}\n\t\t\t},\n\t\n\t\t\tcontrolMode: function () {\n\t\t\t\treturn vrControls && vrControls.mode();\n\t\t\t},\n\t\n\t\t\tzeroSensor: nop,\n\t\n\t\t\tvibrate: navigator.vibrate ? navigator.vibrate.bind(navigator) : nop,\n\t\n\t\t\t// Utility\n\t\t\ttimes: function (n, callback) {\n\t\t\t\tvar i;\n\t\n\t\t\t\tfor (i = 0; i < n; i++) {\n\t\t\t\t\tcallback(i);\n\t\t\t\t}\n\t\t\t},\n\t\n\t\t\tcamera: cameraWrapper,\n\t\t\tbody: bodyWrapper,\n\t\t\tscene: scene,\n\t\t\tcanvas: renderer && renderer.domElement || null\n\t\t};\n\t\n\t\tobjectMethods.forEach(function (method) {\n\t\t\tvar creator = __webpack_require__(12)(\"./\" + method),\n\t\t\t\tkey;\n\t\n\t\t\tVR[method] = function (options) {\n\t\t\t\tvar obj = new VRObject(scene, creator, body, options);\n\t\t\t\tvrObjects.push(obj);\n\t\t\t\treturn obj;\n\t\t\t};\n\t\n\t\t\tVRObject.prototype[method] = function (options) {\n\t\t\t\tvar obj = new VRObject(this.object, creator, body, options);\n\t\t\t\tvrObjects.push(obj);\n\t\t\t\treturn obj;\n\t\t\t};\n\t\n\t\t\tfor (key in creator) {\n\t\t\t\tif (creator.hasOwnProperty(key) && typeof creator[key] === 'function') {\n\t\t\t\t\tVR[method][key] = creator[key];\n\t\t\t\t\tVRObject.prototype[method][key] = creator[key];\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\n\t\teventEmitter(VR);\n\t\n\t\tObject.defineProperty(VR, 'target', {\n\t\t\tget: function () {\n\t\t\t\treturn target;\n\t\t\t}\n\t\t});\n\t}());\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// style-loader: Adds some css to the DOM by adding a <style> tag\n\t\n\t// load the styles\n\tvar content = __webpack_require__(3);\n\tif(typeof content === 'string') content = [[module.id, content, '']];\n\t// add the styles to the DOM\n\tvar update = __webpack_require__(4)(content, {});\n\tif(content.locals) module.exports = content.locals;\n\t// Hot Module Replacement\n\tif(false) {\n\t\t// When the styles change, update the <style> tags\n\t\tif(!content.locals) {\n\t\t\tmodule.hot.accept(\"!!./../../node_modules/css-loader/index.js!./style.css\", function() {\n\t\t\t\tvar newContent = require(\"!!./../../node_modules/css-loader/index.js!./style.css\");\n\t\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\t\tupdate(newContent);\n\t\t\t});\n\t\t}\n\t\t// When the module is disposed, remove the <style> tags\n\t\tmodule.hot.dispose(function() { update(); });\n\t}\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(14)();\n\texports.push([module.id, \"body{font-family:'Helvetica Neue',Helvetica,Arial,sans-serif;color:#eee;overflow:hidden;background:#282828;height:100%;width:100%;margin:0;padding:0}canvas{width:100%!important;height:100%!important;top:0;left:0}#buttons{position:absolute;bottom:0;left:0;padding:12px;margin:8px;border-radius:8px;background-color:rgba(128,128,128,.6)}#buttons>*{margin:0 10px;display:inline-block;width:18px;height:18px;cursor:pointer}#buttons>:first-child{margin-left:0}#buttons>.unsupported,#fs-disable{display:none}\", \"\"]);\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*\r\n\t\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\t\tAuthor Tobias Koppers @sokra\r\n\t*/\r\n\tvar stylesInDom = {},\r\n\t\tmemoize = function(fn) {\r\n\t\t\tvar memo;\r\n\t\t\treturn function () {\r\n\t\t\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\r\n\t\t\t\treturn memo;\r\n\t\t\t};\r\n\t\t},\r\n\t\tisOldIE = memoize(function() {\r\n\t\t\treturn /msie [6-9]\\b/.test(window.navigator.userAgent.toLowerCase());\r\n\t\t}),\r\n\t\tgetHeadElement = memoize(function () {\r\n\t\t\treturn document.head || document.getElementsByTagName(\"head\")[0];\r\n\t\t}),\r\n\t\tsingletonElement = null,\r\n\t\tsingletonCounter = 0;\r\n\t\r\n\tmodule.exports = function(list, options) {\r\n\t\tif(false) {\r\n\t\t\tif(typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\r\n\t\t}\r\n\t\r\n\t\toptions = options || {};\r\n\t\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\r\n\t\t// tags it will allow on a page\r\n\t\tif (typeof options.singleton === \"undefined\") options.singleton = isOldIE();\r\n\t\r\n\t\tvar styles = listToStyles(list);\r\n\t\taddStylesToDom(styles, options);\r\n\t\r\n\t\treturn function update(newList) {\r\n\t\t\tvar mayRemove = [];\r\n\t\t\tfor(var i = 0; i < styles.length; i++) {\r\n\t\t\t\tvar item = styles[i];\r\n\t\t\t\tvar domStyle = stylesInDom[item.id];\r\n\t\t\t\tdomStyle.refs--;\r\n\t\t\t\tmayRemove.push(domStyle);\r\n\t\t\t}\r\n\t\t\tif(newList) {\r\n\t\t\t\tvar newStyles = listToStyles(newList);\r\n\t\t\t\taddStylesToDom(newStyles, options);\r\n\t\t\t}\r\n\t\t\tfor(var i = 0; i < mayRemove.length; i++) {\r\n\t\t\t\tvar domStyle = mayRemove[i];\r\n\t\t\t\tif(domStyle.refs === 0) {\r\n\t\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++)\r\n\t\t\t\t\t\tdomStyle.parts[j]();\r\n\t\t\t\t\tdelete stylesInDom[domStyle.id];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n\t\r\n\tfunction addStylesToDom(styles, options) {\r\n\t\tfor(var i = 0; i < styles.length; i++) {\r\n\t\t\tvar item = styles[i];\r\n\t\t\tvar domStyle = stylesInDom[item.id];\r\n\t\t\tif(domStyle) {\r\n\t\t\t\tdomStyle.refs++;\r\n\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\r\n\t\t\t\t\tdomStyle.parts[j](item.parts[j]);\r\n\t\t\t\t}\r\n\t\t\t\tfor(; j < item.parts.length; j++) {\r\n\t\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tvar parts = [];\r\n\t\t\t\tfor(var j = 0; j < item.parts.length; j++) {\r\n\t\t\t\t\tparts.push(addStyle(item.parts[j], options));\r\n\t\t\t\t}\r\n\t\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction listToStyles(list) {\r\n\t\tvar styles = [];\r\n\t\tvar newStyles = {};\r\n\t\tfor(var i = 0; i < list.length; i++) {\r\n\t\t\tvar item = list[i];\r\n\t\t\tvar id = item[0];\r\n\t\t\tvar css = item[1];\r\n\t\t\tvar media = item[2];\r\n\t\t\tvar sourceMap = item[3];\r\n\t\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\r\n\t\t\tif(!newStyles[id])\r\n\t\t\t\tstyles.push(newStyles[id] = {id: id, parts: [part]});\r\n\t\t\telse\r\n\t\t\t\tnewStyles[id].parts.push(part);\r\n\t\t}\r\n\t\treturn styles;\r\n\t}\r\n\t\r\n\tfunction createStyleElement() {\r\n\t\tvar styleElement = document.createElement(\"style\");\r\n\t\tvar head = getHeadElement();\r\n\t\tstyleElement.type = \"text/css\";\r\n\t\thead.appendChild(styleElement);\r\n\t\treturn styleElement;\r\n\t}\r\n\t\r\n\tfunction createLinkElement() {\r\n\t\tvar linkElement = document.createElement(\"link\");\r\n\t\tvar head = getHeadElement();\r\n\t\tlinkElement.rel = \"stylesheet\";\r\n\t\thead.appendChild(linkElement);\r\n\t\treturn linkElement;\r\n\t}\r\n\t\r\n\tfunction addStyle(obj, options) {\r\n\t\tvar styleElement, update, remove;\r\n\t\r\n\t\tif (options.singleton) {\r\n\t\t\tvar styleIndex = singletonCounter++;\r\n\t\t\tstyleElement = singletonElement || (singletonElement = createStyleElement());\r\n\t\t\tupdate = applyToSingletonTag.bind(null, styleElement, styleIndex, false);\r\n\t\t\tremove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);\r\n\t\t} else if(obj.sourceMap &&\r\n\t\t\ttypeof URL === \"function\" &&\r\n\t\t\ttypeof URL.createObjectURL === \"function\" &&\r\n\t\t\ttypeof URL.revokeObjectURL === \"function\" &&\r\n\t\t\ttypeof Blob === \"function\" &&\r\n\t\t\ttypeof btoa === \"function\") {\r\n\t\t\tstyleElement = createLinkElement();\r\n\t\t\tupdate = updateLink.bind(null, styleElement);\r\n\t\t\tremove = function() {\r\n\t\t\t\tstyleElement.parentNode.removeChild(styleElement);\r\n\t\t\t\tif(styleElement.href)\r\n\t\t\t\t\tURL.revokeObjectURL(styleElement.href);\r\n\t\t\t};\r\n\t\t} else {\r\n\t\t\tstyleElement = createStyleElement();\r\n\t\t\tupdate = applyToTag.bind(null, styleElement);\r\n\t\t\tremove = function() {\r\n\t\t\t\tstyleElement.parentNode.removeChild(styleElement);\r\n\t\t\t};\r\n\t\t}\r\n\t\r\n\t\tupdate(obj);\r\n\t\r\n\t\treturn function updateStyle(newObj) {\r\n\t\t\tif(newObj) {\r\n\t\t\t\tif(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)\r\n\t\t\t\t\treturn;\r\n\t\t\t\tupdate(obj = newObj);\r\n\t\t\t} else {\r\n\t\t\t\tremove();\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n\t\r\n\tvar replaceText = (function () {\r\n\t\tvar textStore = [];\r\n\t\r\n\t\treturn function (index, replacement) {\r\n\t\t\ttextStore[index] = replacement;\r\n\t\t\treturn textStore.filter(Boolean).join('\\n');\r\n\t\t};\r\n\t})();\r\n\t\r\n\tfunction applyToSingletonTag(styleElement, index, remove, obj) {\r\n\t\tvar css = remove ? \"\" : obj.css;\r\n\t\r\n\t\tif (styleElement.styleSheet) {\r\n\t\t\tstyleElement.styleSheet.cssText = replaceText(index, css);\r\n\t\t} else {\r\n\t\t\tvar cssNode = document.createTextNode(css);\r\n\t\t\tvar childNodes = styleElement.childNodes;\r\n\t\t\tif (childNodes[index]) styleElement.removeChild(childNodes[index]);\r\n\t\t\tif (childNodes.length) {\r\n\t\t\t\tstyleElement.insertBefore(cssNode, childNodes[index]);\r\n\t\t\t} else {\r\n\t\t\t\tstyleElement.appendChild(cssNode);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction applyToTag(styleElement, obj) {\r\n\t\tvar css = obj.css;\r\n\t\tvar media = obj.media;\r\n\t\tvar sourceMap = obj.sourceMap;\r\n\t\r\n\t\tif(media) {\r\n\t\t\tstyleElement.setAttribute(\"media\", media)\r\n\t\t}\r\n\t\r\n\t\tif(styleElement.styleSheet) {\r\n\t\t\tstyleElement.styleSheet.cssText = css;\r\n\t\t} else {\r\n\t\t\twhile(styleElement.firstChild) {\r\n\t\t\t\tstyleElement.removeChild(styleElement.firstChild);\r\n\t\t\t}\r\n\t\t\tstyleElement.appendChild(document.createTextNode(css));\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction updateLink(linkElement, obj) {\r\n\t\tvar css = obj.css;\r\n\t\tvar media = obj.media;\r\n\t\tvar sourceMap = obj.sourceMap;\r\n\t\r\n\t\tif(sourceMap) {\r\n\t\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(JSON.stringify(sourceMap)) + \" */\";\r\n\t\t}\r\n\t\r\n\t\tvar blob = new Blob([css], { type: \"text/css\" });\r\n\t\r\n\t\tvar oldSrc = linkElement.href;\r\n\t\r\n\t\tlinkElement.href = URL.createObjectURL(blob);\r\n\t\r\n\t\tif(oldSrc)\r\n\t\t\tURL.revokeObjectURL(oldSrc);\r\n\t}\r\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"8\\\" height=\\\"8\\\" viewBox=\\\"0 0 8 8\\\">\\n  <path d=\\\"M0 0v4l1.5-1.5 1.5 1.5 1-1-1.5-1.5 1.5-1.5h-4zm5 4l-1 1 1.5 1.5-1.5 1.5h4v-4l-1.5 1.5-1.5-1.5z\\\" />\\n</svg>\"\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"8\\\" height=\\\"8\\\" viewBox=\\\"0 0 8 8\\\">\\n  <path d=\\\"M1 0l-1 1 1.5 1.5-1.5 1.5h4v-4l-1.5 1.5-1.5-1.5zm3 4v4l1.5-1.5 1.5 1.5 1-1-1.5-1.5 1.5-1.5h-4z\\\" />\\n</svg>\"\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"8\\\" height=\\\"8\\\" viewBox=\\\"0 0 8 8\\\">\\n  <path d=\\\"M4.03 0c-2.53 0-4.03 3-4.03 3s1.5 3 4.03 3c2.47 0 3.97-3 3.97-3s-1.5-3-3.97-3zm-.03 1c1.11 0 2 .9 2 2 0 1.11-.89 2-2 2-1.1 0-2-.89-2-2 0-1.1.9-2 2-2zm0 1c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1c0-.1-.04-.19-.06-.28-.08.16-.24.28-.44.28-.28 0-.5-.22-.5-.5 0-.2.12-.36.28-.44-.09-.03-.18-.06-.28-.06z\\\"\\n  transform=\\\"translate(0 1)\\\" />\\n</svg>\"\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"8\\\" height=\\\"8\\\" viewBox=\\\"0 0 8 8\\\">\\n  <path d=\\\"M4 0c-2.2 0-4 1.8-4 4s1.8 4 4 4 4-1.8 4-4-1.8-4-4-4zm0 1c1.66 0 3 1.34 3 3s-1.34 3-3 3-3-1.34-3-3 1.34-3 3-3zm2 1l-3 1-1 3 3-1 1-3zm-2 1.5c.28 0 .5.22.5.5s-.22.5-.5.5-.5-.22-.5-.5.22-.5.5-.5z\\\" />\\n</svg>\"\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * NoSleep.js v0.5.0 - git.io/vfn01\n\t * Rich Tibbett\n\t * MIT license\n\t **/\n\t(function(root) {\n\t  // UA matching\n\t  var ua = {\n\t    Android: /Android/ig.test(navigator.userAgent),\n\t    iOS: /AppleWebKit/.test(navigator.userAgent) && /Mobile\\/\\w+/.test(navigator.userAgent)\n\t  };\n\t\n\t  var media = {\n\t    WebM: \"data:video/webm;base64,GkXfo0AgQoaBAUL3gQFC8oEEQvOBCEKCQAR3ZWJtQoeBAkKFgQIYU4BnQI0VSalmQCgq17FAAw9CQE2AQAZ3aGFtbXlXQUAGd2hhbW15RIlACECPQAAAAAAAFlSua0AxrkAu14EBY8WBAZyBACK1nEADdW5khkAFVl9WUDglhohAA1ZQOIOBAeBABrCBCLqBCB9DtnVAIueBAKNAHIEAAIAwAQCdASoIAAgAAUAmJaQAA3AA/vz0AAA=\",\n\t    MP4: \"data:video/mp4;base64,AAAAHGZ0eXBpc29tAAACAGlzb21pc28ybXA0MQAAAAhmcmVlAAAAG21kYXQAAAGzABAHAAABthADAowdbb9/AAAC6W1vb3YAAABsbXZoZAAAAAB8JbCAfCWwgAAAA+gAAAAAAAEAAAEAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAIVdHJhawAAAFx0a2hkAAAAD3wlsIB8JbCAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAQAAAAAAIAAAACAAAAAABsW1kaWEAAAAgbWRoZAAAAAB8JbCAfCWwgAAAA+gAAAAAVcQAAAAAAC1oZGxyAAAAAAAAAAB2aWRlAAAAAAAAAAAAAAAAVmlkZW9IYW5kbGVyAAAAAVxtaW5mAAAAFHZtaGQAAAABAAAAAAAAAAAAAAAkZGluZgAAABxkcmVmAAAAAAAAAAEAAAAMdXJsIAAAAAEAAAEcc3RibAAAALhzdHNkAAAAAAAAAAEAAACobXA0dgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAIAAgASAAAAEgAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABj//wAAAFJlc2RzAAAAAANEAAEABDwgEQAAAAADDUAAAAAABS0AAAGwAQAAAbWJEwAAAQAAAAEgAMSNiB9FAEQBFGMAAAGyTGF2YzUyLjg3LjQGAQIAAAAYc3R0cwAAAAAAAAABAAAAAQAAAAAAAAAcc3RzYwAAAAAAAAABAAAAAQAAAAEAAAABAAAAFHN0c3oAAAAAAAAAEwAAAAEAAAAUc3RjbwAAAAAAAAABAAAALAAAAGB1ZHRhAAAAWG1ldGEAAAAAAAAAIWhkbHIAAAAAAAAAAG1kaXJhcHBsAAAAAAAAAAAAAAAAK2lsc3QAAAAjqXRvbwAAABtkYXRhAAAAAQAAAABMYXZmNTIuNzguMw==\"\n\t  };\n\t\n\t  function addSourceToVideo(element, type, dataURI) {\n\t    var source = document.createElement('source');\n\t    source.src = dataURI;\n\t    source.type = \"video/\" + type;\n\t    element.appendChild(source);\n\t  }\n\t\n\t  // NoSleep instance constructor\n\t  var NoSleep = function() {\n\t    if (ua.iOS) {\n\t      this.noSleepTimer = null;\n\t    } else if (ua.Android) {\n\t      // Set up no sleep video element\n\t      this.noSleepVideo = document.createElement('video');\n\t      this.noSleepVideo.setAttribute(\"loop\", \"\");\n\t\n\t      // Append nosleep video sources\n\t      addSourceToVideo(this.noSleepVideo, \"webm\", media.WebM);\n\t      addSourceToVideo(this.noSleepVideo, \"mp4\", media.MP4);\n\t    }\n\t\n\t    return this;\n\t  };\n\t\n\t  // Enable NoSleep instance\n\t  NoSleep.prototype.enable = function(duration) {\n\t    if (ua.iOS) {\n\t      this.disable();\n\t      this.noSleepTimer = window.setInterval(function() {\n\t        window.location = window.location;\n\t        window.setTimeout(window.stop, 0);\n\t      }, duration || 15000);\n\t    } else if (ua.Android) {\n\t      this.noSleepVideo.play();\n\t    }\n\t  };\n\t\n\t  // Disable NoSleep instance\n\t  NoSleep.prototype.disable = function() {\n\t    if (ua.iOS) {\n\t      if (this.noSleepTimer) {\n\t        window.clearInterval(this.noSleepTimer);\n\t        this.noSleepTimer = null;\n\t      }\n\t    } else if (ua.Android) {\n\t      this.noSleepVideo.pause();\n\t    }\n\t  };\n\t\n\t  // Append NoSleep API to root object\n\t  root.NoSleep = NoSleep;\n\t})(this);\n\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = (function () {\n\t\t'use strict';\n\t\n\t\tvar THREE = __webpack_require__(33),\n\t\t\tforEach = __webpack_require__(36),\n\t\t\tassign = __webpack_require__(37),\n\t\n\t\t\tiOS = navigator.userAgent.match(/(iPad|iPhone|iPod)/g),\n\t\n\t\t\t// https://gist.github.com/dperini/729294\n\t\t\t//urlRegex = /^(?:(?:https?|ftp):\\/\\/)(?:\\S+(?::\\S*)?@)?(?:(?!(?:10|127)(?:\\.\\d{1,3}){3})(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))(?::\\d{2,5})?(?:\\/\\S*)?$/i,\n\t\t\turlRegex = __webpack_require__(35),\n\t\n\t\t\tdataUri = /^data:image\\/(?:png|jpe?g|gif);/,\n\t\t\tassetPath = (\"http://pov-tc.pbs.org/pov/flv/2015/webvr-starter-kit/\"),\n\t\n\t\t\timages = {},\n\t\n\t\t\tmaterialTypes = {\n\t\t\t\tlambert: THREE.MeshLambertMaterial,\n\t\t\t\tbasic: THREE.MeshBasicMaterial,\n\t\t\t\tphong: THREE.MeshPhongMaterial,\n\t\t\t\tnormal: THREE.MeshNormalMaterial,\n\t\t\t\tdepth: THREE.MeshDepthMaterial\n\t\t\t},\n\t\t\ttextureFiles = {\n\t\t\t\t'asphalt': {\n\t\t\t\t\trepeat: 12\n\t\t\t\t},\n\t\t\t\t'brick-tiles': {\n\t\t\t\t\trepeat: 2\n\t\t\t\t},\n\t\t\t\t'bricks': {\n\t\t\t\t\ttype: 'phong',\n\t\t\t\t\trepeat: 4,\n\t\t\t\t\tnormalMap: 'bricks-normal.jpg',\n\t\t\t\t\tspecularMap: 'bricks-specular.jpg'\n\t\t\t\t},\n\t\t\t\t'checkerboard': {\n\t\t\t\t\trepeat: 10,\n\t\t\t\t\tmap: 'checkerboard.png'\n\t\t\t\t},\n\t\t\t\t'grass': {\n\t\t\t\t\trepeat: 12\n\t\t\t\t},\n\t\t\t\t'metal-floor': {\n\t\t\t\t\ttype: 'phong',\n\t\t\t\t\tshininess: 100,\n\t\n\t\t\t\t\trepeat: 2\n\t\t\t\t},\n\t\t\t\t'metal': {\n\t\t\t\t\ttype: 'phong',\n\t\t\t\t\tshininess: 100,\n\t\t\t\t\tshading: THREE.SmoothShading,\n\t\n\t\t\t\t\trepeat: 2\n\t\t\t\t},\n\t\t\t\t'stone': {\n\t\t\t\t\trepeat: 8\n\t\t\t\t},\n\t\t\t\t'tiles': {\n\t\t\t\t\trepeat: 4\n\t\t\t\t},\n\t\t\t\t'weathered-wood': {\n\t\t\t\t\trepeat: 8\n\t\t\t\t},\n\t\t\t\t'wood': {\n\t\t\t\t\trepeat: 4\n\t\t\t\t}\n\t\t\t},\n\t\t\ttextures = {},\n\t\t\tmaterials;\n\t\n\t\tfunction imageTexture(src, mapping, callback) {\n\t\t\tvar image,\n\t\t\t\tparse,\n\t\t\t\ttexture,\n\t\t\t\tisDataUri;\n\t\n\t\t\tfunction imageLoaded() {\n\t\t\t\tvar scale,\n\t\t\t\t\tcanvas,\n\t\t\t\t\tctx,\n\t\t\t\t\tsmallImage;\n\t\n\t\t\t\t/*\n\t\t\t\tiOS doesn't know how to handle large images. Even though the MAX_TEXTURE_SIZE\n\t\t\t\tmay be 4096, it still breaks on images that large. So we scale them down.\n\t\t\t\t*/\n\t\t\t\tif (iOS && (image.naturalWidth > 2048 || image.naturalHeight > 2048)) {\n\t\t\t\t\tscale = 2048 / Math.max( image.naturalWidth, image.naturalHeight );\n\t\n\t\t\t\t\tcanvas = document.createElement('canvas');\n\t\t\t\t\tcanvas.width = Math.floor(image.naturalWidth * scale);\n\t\t\t\t\tcanvas.height = Math.floor(image.naturalHeight * scale);\n\t\n\t\t\t\t\tctx = canvas.getContext('2d');\n\t\t\t\t\tctx.drawImage(image, 0, 0, image.naturalWidth, image.naturalHeight, 0, 0, canvas.width, canvas.height);\n\t\n\t\t\t\t\timage = canvas;\n\t\t\t\t}\n\t\n\t\t\t\ttexture.image = image;\n\t\t\t\ttexture.needsUpdate = true;\n\t\t\t\tif (typeof callback === 'function') {\n\t\t\t\t\tsetTimeout(callback.bind(null, texture, image), 1);\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tparse = dataUri.exec(src);\n\t\t\tisDataUri = !!parse;\n\t\t\tif (!parse) {\n\t\t\t\tparse = urlRegex.exec(src);\n\t\t\t}\n\t\n\t\t\t// if (!parse) {\n\t\t\t// \tconsole.error('Invalid image URL: ' + src);\n\t\t\t// \treturn;\n\t\t\t// }\n\t\n\t\t\tif (images[src]) {\n\t\t\t\timage = images[src];\n\t\t\t} else {\n\t\t\t\timage = document.createElement('img');\n\t\t\t\tif (parse && (parse[1] && parse[1] !== window.location.hostname || parse[2] && parse[2] !== window.location.port)) {\n\t\t\t\t\timage.crossOrigin = 'anonymous';\n\t\t\t\t}\n\t\t\t\timage.src = src;\n\t\t\t\timages[src] = image;\n\t\t\t}\n\t\n\t\t\ttexture = new THREE.Texture(undefined, mapping);\n\t\n\t\t\tif (image.naturalWidth || isDataUri) {\n\t\t\t\tsetTimeout(imageLoaded, 1);\n\t\t\t} else {\n\t\t\t\timage.addEventListener('load', imageLoaded);\n\t\t\t}\n\t\n\t\t\treturn texture;\n\t\t}\n\t\n\t\tfunction material(options) {\n\t\t\tvar opts,\n\t\t\t\tMaterial = materialTypes[options.type] || THREE.MeshLambertMaterial;\n\t\n\t\t\tfunction threeTexture(fn) {\n\t\t\t\tif (typeof fn === 'string') {\n\t\t\t\t\tif (urlRegex.test(fn) || dataUri.test(fn)) {\n\t\t\t\t\t\treturn imageTexture(fn);\n\t\t\t\t\t}\n\t\n\t\t\t\t\tfn = textures[fn];\n\t\t\t\t}\n\t\t\t\tif (typeof fn === 'function') {\n\t\t\t\t\treturn fn(options);\n\t\t\t\t}\n\t\n\t\t\t\treturn fn;\n\t\t\t}\n\t\n\t\t\topts = assign({}, options);\n\t\t\tforEach({\n\t\t\t\tambient: options.ambient || options.color,\n\t\t\t\temissive: options.emissive || options.color,\n\t\t\t\tmap: threeTexture(options.map),\n\t\t\t\tspecularMap: threeTexture(options.specularMap),\n\t\t\t\tnormalMap: threeTexture(options.normalMap),\n\t\t\t\talphaMap: threeTexture(options.alphaMap),\n\t\t\t\tenvMap: threeTexture(options.envMap),\n\t\t\t\tlightMap: threeTexture(options.lightMap)\n\t\t\t}, function (val, key) {\n\t\t\t\tif (val !== undefined) {\n\t\t\t\t\topts[key] = val;\n\t\t\t\t}\n\t\t\t});\n\t\n\t\t\tdelete opts.type;\n\t\n\t\t\treturn new Material(opts);\n\t\t}\n\t\n\t\t//figure out if script is loaded relative so we know where to find the images\n\t\tassetPath = (function () {\n\t\t\tvar url,\n\t\t\t\tscripts;\n\t\n\t\t\tif (document.currentScript) {\n\t\t\t\turl = document.currentScript.getAttribute('src');\n\t\t\t} else {\n\t\t\t\tscripts = document.getElementsByTagName('script');\n\t\t\t\turl = scripts[scripts.length - 1].getAttribute('src');\n\t\t\t}\n\t\n\t\t\tif (!urlRegex.test(url)) {\n\t\t\t\treturn url.replace(/[a-z\\-\\.]+\\.js$/i, '');\n\t\t\t}\n\t\n\t\t\treturn (\"http://pov-tc.pbs.org/pov/flv/2015/webvr-starter-kit/\");\n\t\t}());\n\t\n\t\tmaterials = {\n\t\t\tstandard: function () {\n\t\t\t\treturn new THREE.MeshLambertMaterial();\n\t\t\t},\n\t\t\ttextures: textures,\n\t\t\timageTexture: imageTexture,\n\t\t\tmaterial: material,\n\t\t\tlibrary: ['standard']\n\t\t};\n\t\n\t\tforEach(textureFiles, function (props, key) {\n\t\t\tfunction textureFactory(file, options) {\n\t\t\t\tfunction imagePath(url) {\n\t\t\t\t\tif ((/^[a-z0-9\\/\\-]+\\.(png|jpg)$/i).test(url)) {\n\t\t\t\t\t\treturn assetPath + url;\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn url;\n\t\t\t\t}\n\t\n\t\t\t\toptions = options || {};\n\t\n\t\t\t\treturn function (opts) {\n\t\t\t\t\tvar texture = imageTexture(imagePath(__webpack_require__(34)(\"./\" + file)));\n\t\n\t\t\t\t\topts = assign({}, options, opts);\n\t\n\t\t\t\t\tif (opts.repeat) {\n\t\t\t\t\t\tif (opts.repeat > 0) {\n\t\t\t\t\t\t\ttexture.repeat.set(opts.repeat, opts.repeat);\n\t\t\t\t\t\t} else if (opts.repeat instanceof THREE.Vector2) {\n\t\t\t\t\t\t\ttexture.repeat.copy(opts.repeat);\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttexture.wrapS = texture.wrapT = THREE.RepeatWrapping;\n\t\t\t\t\t}\n\t\t\t\t\treturn texture;\n\t\t\t\t};\n\t\t\t}\n\t\n\t\t\tvar map = textureFactory(props.map || key + '.jpg', props),\n\t\t\t\tmaterialDef;\n\t\n\t\t\tmaterialDef = assign({}, props, {\n\t\t\t\tmap: map\n\t\t\t});\n\t\t\ttextures[key] = map;\n\t\n\t\t\tif (props.normalMap) {\n\t\t\t\tmaterialDef.normalMap = textures[key + '-normal'] = textureFactory(props.normalMap, props);\n\t\t\t}\n\t\n\t\t\tif (props.specularMap) {\n\t\t\t\tmaterialDef.specularMap = textures[key + '-specular'] = textureFactory(props.specularMap, props);\n\t\t\t}\n\t\n\t\t\tmaterials.library.push(key);\n\t\t\tmaterials[key] = function (options) {\n\t\t\t\tvar opts = assign({}, materialDef, options);\n\t\n\t\t\t\treturn material(opts);\n\t\t\t};\n\t\t});\n\t\n\t\treturn materials;\n\t\n\t\t//var parse = urlRegex.exec('https://lh5.googleusercontent.com:80/-SNO8rWDqbUM/U085rfOBRuI/AAAAAAAAEdM/nWEWCtNceZ0/w955-h382-no/PANO_20130225_131211.jpg');\n\t}());\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = (function () {\n\t\t'use strict';\n\t\n\t\tvar\tNEAR_DISTANCE = 3,\n\t\t\tmaterials = __webpack_require__(10),\n\t\t\tTHREE = __webpack_require__(33),\n\t\t\teventEmitter = __webpack_require__(20),\n\t\n\t\t\txAxis = new THREE.Vector3(1, 0, 0),\n\t\t\tyAxis = new THREE.Vector3(0, 1, 0),\n\t\t\tzAxis = new THREE.Vector3(0, 0, 1),\n\t\n\t\t\tscratchVector1 = new THREE.Vector3(),\n\t\t\tscratchVector2 = new THREE.Vector3(),\n\t\n\t\t\tallObjects = window.WeakMap ? new window.WeakMap() : {};\n\t\n\t\tfunction distance(object, origin) {\n\t\t\tvar geometry;\n\t\n\t\t\tgeometry = object.geometry;\n\t\n\t\t\t//assumes object world matrix has been updated\n\t\t\tscratchVector1.setFromMatrixPosition(origin.matrixWorld);\n\t\n\t\t\tif (!geometry) {\n\t\t\t\t//first convert to world coordinate\n\t\t\t\tscratchVector2.setFromMatrixPosition(object.matrixWorld);\n\t\t\t\treturn scratchVector2.distanceTo(scratchVector1);\n\t\t\t}\n\t\n\t\t\tgeometry.computeBoundingBox();\n\t\t\tobject.worldToLocal(scratchVector1);\n\t\t\treturn object.geometry.boundingBox.distanceToPoint(scratchVector1);\n\t\t}\n\t\n\t\tfunction VRObject(parent, creator, camera, options) {\n\t\t\tvar material,\n\t\t\t\tobject,\n\t\t\t\tself = this,\n\t\n\t\t\t\tisNear = false,\n\t\t\t\tisTarget = false,\n\t\t\t\traycaster;\n\t\n\t\t\toptions = options || {};\n\t\n\t\t\teventEmitter(this);\n\t\n\t\t\tif (camera) {\n\t\t\t\t// raycaster = new THREE.Raycaster();\n\t\n\t\t\t\tthis.update = function () {\n\t\t\t\t\tvar wasNear = isNear,\n\t\t\t\t\t\twasTarget = isTarget,\n\t\n\t\t\t\t\t\tintersects, intersect, i;\n\t\n\t\t\t\t\tisNear = self.distance < NEAR_DISTANCE;\n\t\t\t\t\tif (isNear !== wasNear) {\n\t\t\t\t\t\tif (isNear) {\n\t\t\t\t\t\t\tself.emit('near', self);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tself.emit('far', self);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\t/*\n\t\t\t\t\traycaster.ray.origin.copy(origin);\n\t\t\t\t\traycaster.ray.direction.set(0, 0, 0.5).unproject(camera).sub(origin).normalize();\n\t\n\t\t\t\t\t//todo: consider whether this needs to be recursive. maybe a different event\n\t\t\t\t\tintersects = raycaster.intersectObject(object);\n\t\t\t\t\tif (intersects.length) {\n\t\t\t\t\t\tisTarget = true;\n\t\t\t\t\t\tif (!wasTarget) {\n\t\t\t\t\t\t\tself.emit('target-on', intersects[0]);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (wasTarget) {\n\t\t\t\t\t\tself.emit('target-off');\n\t\t\t\t\t}\n\t\t\t\t\t*/\n\t\t\t\t};\n\t\t\t}\n\t\n\t\t\t//todo: get material from options\n\t\t\tthis.object = object = creator.call(this, parent, options);\n\t\t\tthis.parent = this.object.parent || parent;\n\t\n\t\t\tif (object instanceof THREE.Mesh) {\n\t\t\t\tif (options.castShadow !== false) {\n\t\t\t\t\tobject.castShadow = true;\n\t\t\t\t}\n\t\t\t\tif (options.receiveShadow !== false) {\n\t\t\t\t\tobject.receiveShadow = true;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tif (options.name !== undefined) {\n\t\t\t\tobject.name = options.name;\n\t\t\t}\n\t\t\tself.name = object.name;\n\t\n\t\t\tif (allObjects.set) {\n\t\t\t\tallObjects.set(object, this);\n\t\t\t\t// allObjects.set(object.id, this);\n\t\t\t} else {\n\t\t\t\tallObjects[object.id] = this;\n\t\t\t}\n\t\n\t\t\tobject.position.set(\n\t\t\t\tparseFloat(options.x) || 0,\n\t\t\t\tparseFloat(options.y) || 0,\n\t\t\t\tparseFloat(options.z) || 0\n\t\t\t);\n\t\n\t\t\tthis.setMaterial(options.material);\n\t\n\t\t\tif (options.color) {\n\t\t\t\tmaterial = object.material;\n\t\t\t\tmaterial.color = new THREE.Color(options.color);\n\t\t\t\tmaterial.ambient = material.color;\n\t\t\t}\n\t\n\t\t\t['position', 'scale', 'rotation', 'quaternion', 'material'].forEach(function (prop) {\n\t\t\t\tif (prop in object && !self[prop]) {\n\t\t\t\t\tself[prop] = object[prop];\n\t\t\t\t}\n\t\t\t});\n\t\n\t\t\tObject.defineProperty(this, 'visible', {\n\t\t\t\tset: function (val) {\n\t\t\t\t\tself.object.visible = !!val;\n\t\t\t\t},\n\t\t\t\tget: function () {\n\t\t\t\t\treturn self.object.visible;\n\t\t\t\t}\n\t\t\t});\n\t\n\t\t\tObject.defineProperty(this, 'distance', {\n\t\t\t\tget: function () {\n\t\t\t\t\treturn distance(self.object, camera || parent);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\n\t\tVRObject.prototype.hide = function () {\n\t\t\tthis.object.visible = false;\n\t\t\treturn this;\n\t\t};\n\t\n\t\tVRObject.prototype.show = function () {\n\t\t\tthis.object.visible = true;\n\t\t\treturn this;\n\t\t};\n\t\n\t\tVRObject.prototype.moveTo = function (x, y, z) {\n\t\t\tvar position = this.object.position;\n\t\n\t\t\tx = !isNaN(x) ? x : position.x;\n\t\t\ty = !isNaN(y) ? y : position.y;\n\t\t\tz = !isNaN(z) ? z : position.z;\n\t\n\t\t\tposition.set(x, y, z);\n\t\n\t\t\treturn this;\n\t\t};\n\t\n\t\tVRObject.prototype.moveX = function (distance) {\n\t\t\tthis.object.translateX(distance);\n\t\t\treturn this;\n\t\t};\n\t\n\t\tVRObject.prototype.moveY = function (distance) {\n\t\t\tthis.object.translateY(distance);\n\t\t\treturn this;\n\t\t};\n\t\tVRObject.prototype.moveUp = VRObject.prototype.moveY;\n\t\tVRObject.prototype.moveDown = function (distance) {\n\t\t\tthis.moveY(-distance);\n\t\t\treturn this;\n\t\t};\n\t\n\t\tVRObject.prototype.moveZ = function (distance) {\n\t\t\tthis.object.translateZ(distance);\n\t\t\treturn this;\n\t\t};\n\t\n\t\tVRObject.prototype.rotateX = function (angle) {\n\t\t\tthis.object.rotateOnAxis(xAxis, angle);\n\t\t\treturn this;\n\t\t};\n\t\n\t\tVRObject.prototype.rotateY = function (angle) {\n\t\t\tthis.object.rotateOnAxis(yAxis, angle);\n\t\t\treturn this;\n\t\t};\n\t\n\t\tVRObject.prototype.rotateZ = function (angle) {\n\t\t\tthis.object.rotateOnAxis(zAxis, angle);\n\t\t\treturn this;\n\t\t};\n\t\n\t\tVRObject.prototype.setScale = function (x, y, z) {\n\t\t\tvar scale = this.object.scale;\n\t\n\t\t\tif (x !== undefined && !isNaN(x)) {\n\t\t\t\tif (y === undefined && z === undefined) {\n\t\t\t\t\ty = z = x;\n\t\t\t\t} else {\n\t\t\t\t\tx = scale.x;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tx = !isNaN(x) ? x : scale.x;\n\t\t\ty = !isNaN(y) ? y : scale.y;\n\t\t\tz = !isNaN(z) ? z : scale.z;\n\t\n\t\t\tscale.set(x, y, z);\n\t\n\t\t\treturn this;\n\t\t};\n\t\n\t\tVRObject.prototype.setMaterial = function (material, options) {\n\t\t\tif (material && this.object instanceof THREE.Mesh) {\n\t\t\t\tif (typeof material === 'function') {\n\t\t\t\t\tmaterial = material();\n\t\t\t\t} else if (typeof material === 'string' && materials[material]) {\n\t\t\t\t\tmaterial = materials[material](options);\n\t\t\t\t} else if (material && !(material instanceof THREE.Material) && typeof material !== 'number') {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tmaterial = materials(material);\n\t\t\t\t\t} catch (e) {}\n\t\t\t\t}\n\t\t\t\tthis.object.material = material || this.object.material;\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\t};\n\t\n\t\tVRObject.prototype.update = function () {};\n\t\n\t\tVRObject.repeat = function (count, options) {\n\t\t\tvar i,\n\t\t\t\tchange = false,\n\t\t\t\tlastObject = this,\n\t\t\t\tcurrentPosition = new THREE.Vector3(),\n\t\t\t\tdeltaPosition = new THREE.Vector3(),\n\t\t\t\tcurrentQuaternion = new THREE.Quaternion(),\n\t\t\t\tdeltaQuaternion = new THREE.Quaternion();\n\t\n\t\t\tif (!options) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\tif (options.offset) {}\n\t\n\t\t\tfor (i = 0; i < count; i++) {\n\t\n\t\t\t}\n\t\t};\n\t\n\t\tVRObject.findObject = function (object) {\n\t\t\tif (object instanceof VRObject) {\n\t\t\t\treturn object;\n\t\t\t}\n\t\n\t\t\tif (object && object instanceof THREE.Object3D) {\n\t\t\t\tif (allObjects.get) {\n\t\t\t\t\treturn allObjects.get(object);\n\t\t\t\t}\n\t\n\t\t\t\treturn allObjects[object.id];\n\t\t\t}\n\t\n\t\t\t// if (typeof object === 'number') {\n\t\t\t// \treturn allObjects[object];\n\t\t\t// }\n\t\t};\n\t\n\t\treturn VRObject;\n\t\n\t}());\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar map = {\n\t\t\"./box\": 21,\n\t\t\"./box.js\": 21,\n\t\t\"./cylinder\": 22,\n\t\t\"./cylinder.js\": 22,\n\t\t\"./empty\": 13,\n\t\t\"./empty.js\": 13,\n\t\t\"./floor\": 23,\n\t\t\"./floor.js\": 23,\n\t\t\"./image\": 24,\n\t\t\"./image.js\": 24,\n\t\t\"./panorama\": 25,\n\t\t\"./panorama.js\": 25,\n\t\t\"./particles\": 26,\n\t\t\"./particles.js\": 26,\n\t\t\"./sky\": 27,\n\t\t\"./sky.js\": 27,\n\t\t\"./sound\": 28,\n\t\t\"./sound.js\": 28,\n\t\t\"./sphere\": 29,\n\t\t\"./sphere.js\": 29,\n\t\t\"./text\": 30,\n\t\t\"./text.js\": 30,\n\t\t\"./torus\": 31,\n\t\t\"./torus.js\": 31,\n\t\t\"./video\": 32,\n\t\t\"./video.js\": 32\n\t};\n\tfunction webpackContext(req) {\n\t\treturn __webpack_require__(webpackContextResolve(req));\n\t};\n\tfunction webpackContextResolve(req) {\n\t\treturn map[req] || (function() { throw new Error(\"Cannot find module '\" + req + \"'.\") }());\n\t};\n\twebpackContext.keys = function webpackContextKeys() {\n\t\treturn Object.keys(map);\n\t};\n\twebpackContext.resolve = webpackContextResolve;\n\tmodule.exports = webpackContext;\n\twebpackContext.id = 12;\n\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = (function () {\n\t\t'use strict';\n\t\n\t\tvar materials = __webpack_require__(10),\n\t\t\tTHREE = __webpack_require__(33);\n\t\n\t\treturn function empty(parent, options) {\n\t\t\tvar obj = new THREE.Object3D();\n\t\n\t\t\tobj.name = 'empty';\n\t\n\t\t\tparent.add(obj);\n\t\n\t\t\treturn obj;\n\t\t};\n\t}());\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*\r\n\t\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\t\tAuthor Tobias Koppers @sokra\r\n\t*/\r\n\t// css base code, injected by the css-loader\r\n\tmodule.exports = function() {\r\n\t\tvar list = [];\r\n\t\r\n\t\t// return the list of modules as css string\r\n\t\tlist.toString = function toString() {\r\n\t\t\tvar result = [];\r\n\t\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\t\tvar item = this[i];\r\n\t\t\t\tif(item[2]) {\r\n\t\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\r\n\t\t\t\t} else {\r\n\t\t\t\t\tresult.push(item[1]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn result.join(\"\");\r\n\t\t};\r\n\t\r\n\t\t// import a list of modules into the list\r\n\t\tlist.i = function(modules, mediaQuery) {\r\n\t\t\tif(typeof modules === \"string\")\r\n\t\t\t\tmodules = [[null, modules, \"\"]];\r\n\t\t\tvar alreadyImportedModules = {};\r\n\t\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\t\tvar id = this[i][0];\r\n\t\t\t\tif(typeof id === \"number\")\r\n\t\t\t\t\talreadyImportedModules[id] = true;\r\n\t\t\t}\r\n\t\t\tfor(i = 0; i < modules.length; i++) {\r\n\t\t\t\tvar item = modules[i];\r\n\t\t\t\t// skip already imported module\r\n\t\t\t\t// this implementation is not 100% perfect for weird media query combinations\r\n\t\t\t\t//  when a module is imported multiple times with different media queries.\r\n\t\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\r\n\t\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\r\n\t\t\t\t\tif(mediaQuery && !item[2]) {\r\n\t\t\t\t\t\titem[2] = mediaQuery;\r\n\t\t\t\t\t} else if(mediaQuery) {\r\n\t\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlist.push(item);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t\treturn list;\r\n\t};\r\n\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*** IMPORTS FROM imports-loader ***/\n\tvar THREE = __webpack_require__(33);\n\t\n\t/**\n\t * @author richt / http://richt.me\n\t * @author WestLangley / http://github.com/WestLangley\n\t *\n\t * W3C Device Orientation control (http://w3c.github.io/deviceorientation/spec-source-orientation.html)\n\t */\n\t\n\tTHREE.DeviceOrientationControls = function ( object ) {\n\t\n\t\tvar scope = this;\n\t\n\t\tthis.object = object;\n\t\tthis.object.rotation.reorder( \"YXZ\" );\n\t\n\t\tthis.enabled = true;\n\t\n\t\tthis.deviceOrientation = {};\n\t\tthis.screenOrientation = 0;\n\t\n\t\tvar onDeviceOrientationChangeEvent = function ( event ) {\n\t\n\t\t\tscope.deviceOrientation = event;\n\t\n\t\t};\n\t\n\t\tvar onScreenOrientationChangeEvent = function () {\n\t\n\t\t\tscope.screenOrientation = window.orientation || 0;\n\t\n\t\t};\n\t\n\t\t// The angles alpha, beta and gamma form a set of intrinsic Tait-Bryan angles of type Z-X'-Y''\n\t\n\t\tvar setObjectQuaternion = function () {\n\t\n\t\t\tvar zee = new THREE.Vector3( 0, 0, 1 );\n\t\n\t\t\tvar euler = new THREE.Euler();\n\t\n\t\t\tvar q0 = new THREE.Quaternion();\n\t\n\t\t\tvar q1 = new THREE.Quaternion( - Math.sqrt( 0.5 ), 0, 0, Math.sqrt( 0.5 ) ); // - PI/2 around the x-axis\n\t\n\t\t\treturn function ( quaternion, alpha, beta, gamma, orient ) {\n\t\n\t\t\t\teuler.set( beta, alpha, - gamma, 'YXZ' );                       // 'ZXY' for the device, but 'YXZ' for us\n\t\n\t\t\t\tquaternion.setFromEuler( euler );                               // orient the device\n\t\n\t\t\t\tquaternion.multiply( q1 );                                      // camera looks out the back of the device, not the top\n\t\n\t\t\t\tquaternion.multiply( q0.setFromAxisAngle( zee, - orient ) );    // adjust for screen orientation\n\t\n\t\t\t}\n\t\n\t\t}();\n\t\n\t\tthis.connect = function() {\n\t\n\t\t\tonScreenOrientationChangeEvent(); // run once on load\n\t\n\t\t\twindow.addEventListener( 'orientationchange', onScreenOrientationChangeEvent, false );\n\t\t\twindow.addEventListener( 'deviceorientation', onDeviceOrientationChangeEvent, false );\n\t\n\t\t\tscope.enabled = true;\n\t\n\t\t};\n\t\n\t\tthis.disconnect = function() {\n\t\n\t\t\twindow.removeEventListener( 'orientationchange', onScreenOrientationChangeEvent, false );\n\t\t\twindow.removeEventListener( 'deviceorientation', onDeviceOrientationChangeEvent, false );\n\t\n\t\t\tscope.enabled = false;\n\t\n\t\t};\n\t\n\t\tthis.update = function () {\n\t\n\t\t\tif ( scope.enabled === false ) return;\n\t\n\t\t\tvar alpha  = scope.deviceOrientation.alpha ? THREE.Math.degToRad( scope.deviceOrientation.alpha ) : 0; // Z\n\t\t\tvar beta   = scope.deviceOrientation.beta  ? THREE.Math.degToRad( scope.deviceOrientation.beta  ) : 0; // X'\n\t\t\tvar gamma  = scope.deviceOrientation.gamma ? THREE.Math.degToRad( scope.deviceOrientation.gamma ) : 0; // Y''\n\t\t\tvar orient = scope.screenOrientation       ? THREE.Math.degToRad( scope.screenOrientation       ) : 0; // O\n\t\n\t\t\tsetObjectQuaternion( scope.object.quaternion, alpha, beta, gamma, orient );\n\t\n\t\t};\n\t\n\t\tthis.connect();\n\t\n\t};\n\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*** IMPORTS FROM imports-loader ***/\n\tvar THREE = __webpack_require__(33);\n\t\n\t/**\n\t * @author qiao / https://github.com/qiao\n\t * @author mrdoob / http://mrdoob.com\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t * @author erich666 / http://erichaines.com\n\t */\n\t/*global THREE, console */\n\t\n\t// This set of controls performs orbiting, dollying (zooming), and panning. It maintains\n\t// the \"up\" direction as +Y, unlike the TrackballControls. Touch on tablet and phones is\n\t// supported.\n\t//\n\t//    Orbit - left mouse / touch: one finger move\n\t//    Zoom - middle mouse, or mousewheel / touch: two finger spread or squish\n\t//    Pan - right mouse, or arrow keys / touch: three finter swipe\n\t//\n\t// This is a drop-in replacement for (most) TrackballControls used in examples.\n\t// That is, include this js file and wherever you see:\n\t//    \tcontrols = new THREE.TrackballControls( camera );\n\t//      controls.target.z = 150;\n\t// Simple substitute \"OrbitControls\" and the control should work as-is.\n\t\n\tTHREE.OrbitControls = function ( object, domElement ) {\n\t\n\t\tthis.object = object;\n\t\tthis.domElement = ( domElement !== undefined ) ? domElement : document;\n\t\n\t\t// API\n\t\n\t\t// Set to false to disable this control\n\t\tthis.enabled = true;\n\t\n\t\t// \"target\" sets the location of focus, where the control orbits around\n\t\t// and where it pans with respect to.\n\t\tthis.target = new THREE.Vector3();\n\t\n\t\t// center is old, deprecated; use \"target\" instead\n\t\tthis.center = this.target;\n\t\n\t\t// This option actually enables dollying in and out; left as \"zoom\" for\n\t\t// backwards compatibility\n\t\tthis.noZoom = false;\n\t\tthis.zoomSpeed = 1.0;\n\t\n\t\t// Limits to how far you can dolly in and out\n\t\tthis.minDistance = 0;\n\t\tthis.maxDistance = Infinity;\n\t\n\t\t// Set to true to disable this control\n\t\tthis.noRotate = false;\n\t\tthis.rotateSpeed = 1.0;\n\t\n\t\t// Set to true to disable this control\n\t\tthis.noPan = false;\n\t\tthis.keyPanSpeed = 7.0;\t// pixels moved per arrow key push\n\t\n\t\t// Set to true to automatically rotate around the target\n\t\tthis.autoRotate = false;\n\t\tthis.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60\n\t\n\t\t// How far you can orbit vertically, upper and lower limits.\n\t\t// Range is 0 to Math.PI radians.\n\t\tthis.minPolarAngle = 0; // radians\n\t\tthis.maxPolarAngle = Math.PI; // radians\n\t\n\t\t// How far you can orbit horizontally, upper and lower limits.\n\t\t// If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].\n\t\tthis.minAzimuthAngle = - Infinity; // radians\n\t\tthis.maxAzimuthAngle = Infinity; // radians\n\t\n\t\t// Set to true to disable use of the keys\n\t\tthis.noKeys = false;\n\t\n\t\t// The four arrow keys\n\t\tthis.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };\n\t\n\t\t// Mouse buttons\n\t\tthis.mouseButtons = { ORBIT: THREE.MOUSE.LEFT, ZOOM: THREE.MOUSE.MIDDLE, PAN: THREE.MOUSE.RIGHT };\n\t\n\t\t////////////\n\t\t// internals\n\t\n\t\tvar scope = this;\n\t\n\t\tvar EPS = 0.000001;\n\t\n\t\tvar rotateStart = new THREE.Vector2();\n\t\tvar rotateEnd = new THREE.Vector2();\n\t\tvar rotateDelta = new THREE.Vector2();\n\t\n\t\tvar panStart = new THREE.Vector2();\n\t\tvar panEnd = new THREE.Vector2();\n\t\tvar panDelta = new THREE.Vector2();\n\t\tvar panOffset = new THREE.Vector3();\n\t\n\t\tvar offset = new THREE.Vector3();\n\t\n\t\tvar dollyStart = new THREE.Vector2();\n\t\tvar dollyEnd = new THREE.Vector2();\n\t\tvar dollyDelta = new THREE.Vector2();\n\t\n\t\tvar theta;\n\t\tvar phi;\n\t\tvar phiDelta = 0;\n\t\tvar thetaDelta = 0;\n\t\tvar scale = 1;\n\t\tvar pan = new THREE.Vector3();\n\t\n\t\tvar lastPosition = new THREE.Vector3();\n\t\tvar lastQuaternion = new THREE.Quaternion();\n\t\n\t\tvar STATE = { NONE : -1, ROTATE : 0, DOLLY : 1, PAN : 2, TOUCH_ROTATE : 3, TOUCH_DOLLY : 4, TOUCH_PAN : 5 };\n\t\n\t\tvar state = STATE.NONE;\n\t\n\t\t// for reset\n\t\n\t\tthis.target0 = this.target.clone();\n\t\tthis.position0 = this.object.position.clone();\n\t\n\t\t// so camera.up is the orbit axis\n\t\n\t\tvar quat = new THREE.Quaternion().setFromUnitVectors( object.up, new THREE.Vector3( 0, 1, 0 ) );\n\t\tvar quatInverse = quat.clone().inverse();\n\t\n\t\t// events\n\t\n\t\tvar changeEvent = { type: 'change' };\n\t\tvar startEvent = { type: 'start'};\n\t\tvar endEvent = { type: 'end'};\n\t\n\t\tthis.rotateLeft = function ( angle ) {\n\t\n\t\t\tif ( angle === undefined ) {\n\t\n\t\t\t\tangle = getAutoRotationAngle();\n\t\n\t\t\t}\n\t\n\t\t\tthetaDelta -= angle;\n\t\n\t\t};\n\t\n\t\tthis.rotateUp = function ( angle ) {\n\t\n\t\t\tif ( angle === undefined ) {\n\t\n\t\t\t\tangle = getAutoRotationAngle();\n\t\n\t\t\t}\n\t\n\t\t\tphiDelta -= angle;\n\t\n\t\t};\n\t\n\t\t// pass in distance in world space to move left\n\t\tthis.panLeft = function ( distance ) {\n\t\n\t\t\tvar te = this.object.matrix.elements;\n\t\n\t\t\t// get X column of matrix\n\t\t\tpanOffset.set( te[ 0 ], te[ 1 ], te[ 2 ] );\n\t\t\tpanOffset.multiplyScalar( - distance );\n\t\n\t\t\tpan.add( panOffset );\n\t\n\t\t};\n\t\n\t\t// pass in distance in world space to move up\n\t\tthis.panUp = function ( distance ) {\n\t\n\t\t\tvar te = this.object.matrix.elements;\n\t\n\t\t\t// get Y column of matrix\n\t\t\tpanOffset.set( te[ 4 ], te[ 5 ], te[ 6 ] );\n\t\t\tpanOffset.multiplyScalar( distance );\n\t\n\t\t\tpan.add( panOffset );\n\t\n\t\t};\n\t\n\t\t// pass in x,y of change desired in pixel space,\n\t\t// right and down are positive\n\t\tthis.pan = function ( deltaX, deltaY ) {\n\t\n\t\t\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\t\n\t\t\tif ( scope.object.fov !== undefined ) {\n\t\n\t\t\t\t// perspective\n\t\t\t\tvar position = scope.object.position;\n\t\t\t\tvar offset = position.clone().sub( scope.target );\n\t\t\t\tvar targetDistance = offset.length();\n\t\n\t\t\t\t// half of the fov is center to top of screen\n\t\t\t\ttargetDistance *= Math.tan( ( scope.object.fov / 2 ) * Math.PI / 180.0 );\n\t\n\t\t\t\t// we actually don't use screenWidth, since perspective camera is fixed to screen height\n\t\t\t\tscope.panLeft( 2 * deltaX * targetDistance / element.clientHeight );\n\t\t\t\tscope.panUp( 2 * deltaY * targetDistance / element.clientHeight );\n\t\n\t\t\t} else if ( scope.object.top !== undefined ) {\n\t\n\t\t\t\t// orthographic\n\t\t\t\tscope.panLeft( deltaX * (scope.object.right - scope.object.left) / element.clientWidth );\n\t\t\t\tscope.panUp( deltaY * (scope.object.top - scope.object.bottom) / element.clientHeight );\n\t\n\t\t\t} else {\n\t\n\t\t\t\t// camera neither orthographic or perspective\n\t\t\t\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tthis.dollyIn = function ( dollyScale ) {\n\t\n\t\t\tif ( dollyScale === undefined ) {\n\t\n\t\t\t\tdollyScale = getZoomScale();\n\t\n\t\t\t}\n\t\n\t\t\tscale /= dollyScale;\n\t\n\t\t};\n\t\n\t\tthis.dollyOut = function ( dollyScale ) {\n\t\n\t\t\tif ( dollyScale === undefined ) {\n\t\n\t\t\t\tdollyScale = getZoomScale();\n\t\n\t\t\t}\n\t\n\t\t\tscale *= dollyScale;\n\t\n\t\t};\n\t\n\t\tthis.update = function () {\n\t\n\t\t\tvar position = this.object.position;\n\t\n\t\t\toffset.copy( position ).sub( this.target );\n\t\n\t\t\t// rotate offset to \"y-axis-is-up\" space\n\t\t\toffset.applyQuaternion( quat );\n\t\n\t\t\t// angle from z-axis around y-axis\n\t\n\t\t\ttheta = Math.atan2( offset.x, offset.z );\n\t\n\t\t\t// angle from y-axis\n\t\n\t\t\tphi = Math.atan2( Math.sqrt( offset.x * offset.x + offset.z * offset.z ), offset.y );\n\t\n\t\t\tif ( this.autoRotate && state === STATE.NONE ) {\n\t\n\t\t\t\tthis.rotateLeft( getAutoRotationAngle() );\n\t\n\t\t\t}\n\t\n\t\t\ttheta += thetaDelta;\n\t\t\tphi += phiDelta;\n\t\n\t\t\t// restrict theta to be between desired limits\n\t\t\ttheta = Math.max( this.minAzimuthAngle, Math.min( this.maxAzimuthAngle, theta ) );\n\t\n\t\t\t// restrict phi to be between desired limits\n\t\t\tphi = Math.max( this.minPolarAngle, Math.min( this.maxPolarAngle, phi ) );\n\t\n\t\t\t// restrict phi to be betwee EPS and PI-EPS\n\t\t\tphi = Math.max( EPS, Math.min( Math.PI - EPS, phi ) );\n\t\n\t\t\tvar radius = offset.length() * scale;\n\t\n\t\t\t// restrict radius to be between desired limits\n\t\t\tradius = Math.max( this.minDistance, Math.min( this.maxDistance, radius ) );\n\t\n\t\t\t// move target to panned location\n\t\t\tthis.target.add( pan );\n\t\n\t\t\toffset.x = radius * Math.sin( phi ) * Math.sin( theta );\n\t\t\toffset.y = radius * Math.cos( phi );\n\t\t\toffset.z = radius * Math.sin( phi ) * Math.cos( theta );\n\t\n\t\t\t// rotate offset back to \"camera-up-vector-is-up\" space\n\t\t\toffset.applyQuaternion( quatInverse );\n\t\n\t\t\tposition.copy( this.target ).add( offset );\n\t\n\t\t\tthis.object.lookAt( this.target );\n\t\n\t\t\tthetaDelta = 0;\n\t\t\tphiDelta = 0;\n\t\t\tscale = 1;\n\t\t\tpan.set( 0, 0, 0 );\n\t\n\t\t\t// update condition is:\n\t\t\t// min(camera displacement, camera rotation in radians)^2 > EPS\n\t\t\t// using small-angle approximation cos(x/2) = 1 - x^2 / 8\n\t\n\t\t\tif ( lastPosition.distanceToSquared( this.object.position ) > EPS\n\t\t\t    || 8 * (1 - lastQuaternion.dot(this.object.quaternion)) > EPS ) {\n\t\n\t\t\t\tthis.dispatchEvent( changeEvent );\n\t\n\t\t\t\tlastPosition.copy( this.object.position );\n\t\t\t\tlastQuaternion.copy (this.object.quaternion );\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\n\t\tthis.reset = function () {\n\t\n\t\t\tstate = STATE.NONE;\n\t\n\t\t\tthis.target.copy( this.target0 );\n\t\t\tthis.object.position.copy( this.position0 );\n\t\n\t\t\tthis.update();\n\t\n\t\t};\n\t\n\t\tthis.getPolarAngle = function () {\n\t\n\t\t\treturn phi;\n\t\n\t\t};\n\t\n\t\tthis.getAzimuthalAngle = function () {\n\t\n\t\t\treturn theta\n\t\n\t\t};\n\t\n\t\tfunction getAutoRotationAngle() {\n\t\n\t\t\treturn 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;\n\t\n\t\t}\n\t\n\t\tfunction getZoomScale() {\n\t\n\t\t\treturn Math.pow( 0.95, scope.zoomSpeed );\n\t\n\t\t}\n\t\n\t\tfunction onMouseDown( event ) {\n\t\n\t\t\tif (event.button !== THREE.MOUSE.LEFT) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\tif ( scope.enabled === false ) return;\n\t\t\tevent.preventDefault();\n\t\n\t\t\tif ( event.button === scope.mouseButtons.ORBIT ) {\n\t\t\t\tif ( scope.noRotate === true ) return;\n\t\n\t\t\t\tstate = STATE.ROTATE;\n\t\n\t\t\t\trotateStart.set( event.clientX, event.clientY );\n\t\n\t\t\t} else if ( event.button === scope.mouseButtons.ZOOM ) {\n\t\t\t\tif ( scope.noZoom === true ) return;\n\t\n\t\t\t\tstate = STATE.DOLLY;\n\t\n\t\t\t\tdollyStart.set( event.clientX, event.clientY );\n\t\n\t\t\t} else if ( event.button === scope.mouseButtons.PAN ) {\n\t\t\t\tif ( scope.noPan === true ) return;\n\t\n\t\t\t\tstate = STATE.PAN;\n\t\n\t\t\t\tpanStart.set( event.clientX, event.clientY );\n\t\n\t\t\t}\n\t\n\t\t\tif ( state !== STATE.NONE ) {\n\t\t\t\twindow.addEventListener( 'mousemove', onMouseMove, false );\n\t\t\t\twindow.addEventListener( 'mouseup', onMouseUp, false );\n\t\t\t\tscope.dispatchEvent( startEvent );\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tfunction onMouseMove( event ) {\n\t\n\t\t\tif ( scope.enabled === false ) return;\n\t\n\t\t\tevent.preventDefault();\n\t\n\t\t\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\t\n\t\t\tif ( state === STATE.ROTATE ) {\n\t\n\t\t\t\tif ( scope.noRotate === true ) return;\n\t\n\t\t\t\trotateEnd.set( event.clientX, event.clientY );\n\t\t\t\trotateDelta.subVectors( rotateEnd, rotateStart );\n\t\n\t\t\t\t// rotating across whole screen goes 360 degrees around\n\t\t\t\tscope.rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );\n\t\n\t\t\t\t// rotating up and down along whole screen attempts to go 360, but limited to 180\n\t\t\t\tscope.rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );\n\t\n\t\t\t\trotateStart.copy( rotateEnd );\n\t\n\t\t\t} else if ( state === STATE.DOLLY ) {\n\t\n\t\t\t\tif ( scope.noZoom === true ) return;\n\t\n\t\t\t\tdollyEnd.set( event.clientX, event.clientY );\n\t\t\t\tdollyDelta.subVectors( dollyEnd, dollyStart );\n\t\n\t\t\t\tif ( dollyDelta.y > 0 ) {\n\t\n\t\t\t\t\tscope.dollyIn();\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tscope.dollyOut();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tdollyStart.copy( dollyEnd );\n\t\n\t\t\t} else if ( state === STATE.PAN ) {\n\t\n\t\t\t\tif ( scope.noPan === true ) return;\n\t\n\t\t\t\tpanEnd.set( event.clientX, event.clientY );\n\t\t\t\tpanDelta.subVectors( panEnd, panStart );\n\t\n\t\t\t\tscope.pan( panDelta.x, panDelta.y );\n\t\n\t\t\t\tpanStart.copy( panEnd );\n\t\n\t\t\t}\n\t\n\t\t\tif ( state !== STATE.NONE ) scope.update();\n\t\n\t\t}\n\t\n\t\tfunction onMouseUp( /* event */ ) {\n\t\n\t\t\tif ( scope.enabled === false ) return;\n\t\n\t\t\t//window.removeEventListener( 'mousemove', onMouseMove, false );\n\t\t\twindow.removeEventListener( 'mouseup', onMouseUp, false );\n\t\t\tscope.dispatchEvent( endEvent );\n\t\t\tstate = STATE.NONE;\n\t\n\t\t}\n\t\n\t\tfunction onMouseWheel( event ) {\n\t\n\t\t\tif ( scope.enabled === false || scope.noZoom === true || state !== STATE.NONE ) return;\n\t\n\t\t\tevent.preventDefault();\n\t\t\tevent.stopPropagation();\n\t\n\t\t\tvar delta = 0;\n\t\n\t\t\tif ( event.wheelDelta !== undefined ) { // WebKit / Opera / Explorer 9\n\t\n\t\t\t\tdelta = event.wheelDelta;\n\t\n\t\t\t} else if ( event.detail !== undefined ) { // Firefox\n\t\n\t\t\t\tdelta = - event.detail;\n\t\n\t\t\t}\n\t\n\t\t\tif ( delta > 0 ) {\n\t\n\t\t\t\tscope.dollyOut();\n\t\n\t\t\t} else {\n\t\n\t\t\t\tscope.dollyIn();\n\t\n\t\t\t}\n\t\n\t\t\tscope.update();\n\t\t\tscope.dispatchEvent( startEvent );\n\t\t\tscope.dispatchEvent( endEvent );\n\t\n\t\t}\n\t\n\t\tfunction onKeyDown( event ) {\n\t\n\t\t\tif ( scope.enabled === false || scope.noKeys === true || scope.noPan === true ) return;\n\t\n\t\t\tswitch ( event.keyCode ) {\n\t\n\t\t\t\tcase scope.keys.UP:\n\t\t\t\t\tscope.pan( 0, scope.keyPanSpeed );\n\t\t\t\t\tscope.update();\n\t\t\t\t\tbreak;\n\t\n\t\t\t\tcase scope.keys.BOTTOM:\n\t\t\t\t\tscope.pan( 0, - scope.keyPanSpeed );\n\t\t\t\t\tscope.update();\n\t\t\t\t\tbreak;\n\t\n\t\t\t\tcase scope.keys.LEFT:\n\t\t\t\t\tscope.pan( scope.keyPanSpeed, 0 );\n\t\t\t\t\tscope.update();\n\t\t\t\t\tbreak;\n\t\n\t\t\t\tcase scope.keys.RIGHT:\n\t\t\t\t\tscope.pan( - scope.keyPanSpeed, 0 );\n\t\t\t\t\tscope.update();\n\t\t\t\t\tbreak;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tfunction touchstart( event ) {\n\t\n\t\t\tif ( scope.enabled === false ) return;\n\t\n\t\t\tswitch ( event.touches.length ) {\n\t\n\t\t\t\tcase 1:\t// one-fingered touch: rotate\n\t\n\t\t\t\t\tif ( scope.noRotate === true ) return;\n\t\n\t\t\t\t\tstate = STATE.TOUCH_ROTATE;\n\t\n\t\t\t\t\trotateStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\n\t\t\t\t\tbreak;\n\t\n\t\t\t\tcase 2:\t// two-fingered touch: dolly\n\t\n\t\t\t\t\tif ( scope.noZoom === true ) return;\n\t\n\t\t\t\t\tstate = STATE.TOUCH_DOLLY;\n\t\n\t\t\t\t\tvar dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\n\t\t\t\t\tvar dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\n\t\t\t\t\tvar distance = Math.sqrt( dx * dx + dy * dy );\n\t\t\t\t\tdollyStart.set( 0, distance );\n\t\t\t\t\tbreak;\n\t\n\t\t\t\tcase 3: // three-fingered touch: pan\n\t\n\t\t\t\t\tif ( scope.noPan === true ) return;\n\t\n\t\t\t\t\tstate = STATE.TOUCH_PAN;\n\t\n\t\t\t\t\tpanStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\n\t\t\t\t\tbreak;\n\t\n\t\t\t\tdefault:\n\t\n\t\t\t\t\tstate = STATE.NONE;\n\t\n\t\t\t}\n\t\n\t\t\tif ( state !== STATE.NONE ) scope.dispatchEvent( startEvent );\n\t\n\t\t}\n\t\n\t\tfunction touchmove( event ) {\n\t\n\t\t\tif ( scope.enabled === false ) return;\n\t\n\t\t\tevent.preventDefault();\n\t\t\tevent.stopPropagation();\n\t\n\t\t\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\t\n\t\t\tswitch ( event.touches.length ) {\n\t\n\t\t\t\tcase 1: // one-fingered touch: rotate\n\t\n\t\t\t\t\tif ( scope.noRotate === true ) return;\n\t\t\t\t\tif ( state !== STATE.TOUCH_ROTATE ) return;\n\t\n\t\t\t\t\trotateEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\n\t\t\t\t\trotateDelta.subVectors( rotateEnd, rotateStart );\n\t\n\t\t\t\t\t// rotating across whole screen goes 360 degrees around\n\t\t\t\t\tscope.rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );\n\t\t\t\t\t// rotating up and down along whole screen attempts to go 360, but limited to 180\n\t\t\t\t\tscope.rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );\n\t\n\t\t\t\t\trotateStart.copy( rotateEnd );\n\t\n\t\t\t\t\tscope.update();\n\t\t\t\t\tbreak;\n\t\n\t\t\t\tcase 2: // two-fingered touch: dolly\n\t\n\t\t\t\t\tif ( scope.noZoom === true ) return;\n\t\t\t\t\tif ( state !== STATE.TOUCH_DOLLY ) return;\n\t\n\t\t\t\t\tvar dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\n\t\t\t\t\tvar dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\n\t\t\t\t\tvar distance = Math.sqrt( dx * dx + dy * dy );\n\t\n\t\t\t\t\tdollyEnd.set( 0, distance );\n\t\t\t\t\tdollyDelta.subVectors( dollyEnd, dollyStart );\n\t\n\t\t\t\t\tif ( dollyDelta.y > 0 ) {\n\t\n\t\t\t\t\t\tscope.dollyOut();\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tscope.dollyIn();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tdollyStart.copy( dollyEnd );\n\t\n\t\t\t\t\tscope.update();\n\t\t\t\t\tbreak;\n\t\n\t\t\t\tcase 3: // three-fingered touch: pan\n\t\n\t\t\t\t\tif ( scope.noPan === true ) return;\n\t\t\t\t\tif ( state !== STATE.TOUCH_PAN ) return;\n\t\n\t\t\t\t\tpanEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\n\t\t\t\t\tpanDelta.subVectors( panEnd, panStart );\n\t\n\t\t\t\t\tscope.pan( panDelta.x, panDelta.y );\n\t\n\t\t\t\t\tpanStart.copy( panEnd );\n\t\n\t\t\t\t\tscope.update();\n\t\t\t\t\tbreak;\n\t\n\t\t\t\tdefault:\n\t\n\t\t\t\t\tstate = STATE.NONE;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tfunction touchend( /* event */ ) {\n\t\n\t\t\tif ( scope.enabled === false ) return;\n\t\n\t\t\tscope.dispatchEvent( endEvent );\n\t\t\tstate = STATE.NONE;\n\t\n\t\t}\n\t\n\t\t//this.domElement.addEventListener( 'contextmenu', function ( event ) { event.preventDefault(); }, false );\n\t\tthis.domElement.addEventListener( 'mousedown', onMouseDown, false );\n\t\tthis.domElement.addEventListener( 'mousewheel', onMouseWheel, false );\n\t\tthis.domElement.addEventListener( 'DOMMouseScroll', onMouseWheel, false ); // firefox\n\t\n\t\tthis.domElement.addEventListener( 'touchstart', touchstart, false );\n\t\tthis.domElement.addEventListener( 'touchend', touchend, false );\n\t\tthis.domElement.addEventListener( 'touchmove', touchmove, false );\n\t\n\t\twindow.addEventListener( 'keydown', onKeyDown, false );\n\t\n\t//window.addEventListener( 'mousemove', onMouseMove, true );\n\t\t// force an update at start\n\t\tthis.update();\n\t\n\t};\n\t\n\tTHREE.OrbitControls.prototype = Object.create( THREE.EventDispatcher.prototype );\n\tTHREE.OrbitControls.prototype.constructor = THREE.OrbitControls;\n\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*** IMPORTS FROM imports-loader ***/\n\tvar THREE = __webpack_require__(33);\n\t\n\t( function() {\n\t\n\t\tvar _oldConsole = console.log;\n\t\n\t\tvar supportedTypes = [];\n\t\n\t\tfunction addSupportedType( type, format ) {\n\t\n\t\t\tsupportedTypes.push( {\n\t\t\t\ttype: type,\n\t\t\t\tformat: format\n\t\t\t} );\n\t\n\t\t}\n\t\n\t\taddSupportedType( THREE.Matrix4, function( v ) {\n\t\n\t\t\tvar e = v.elements;\n\t\t\t\t\t\n\t\t\treturn [\n\t\t\t\t[ e[ 0 ], e[ 1 ], e[ 2 ], e[ 3 ] ],\n\t\t\t\t[ e[ 4 ], e[ 5 ], e[ 6 ], e[ 7 ] ],\n\t\t\t\t[ e[ 8 ], e[ 9 ], e[ 10 ], e[ 11 ] ],\n\t\t\t\t[ e[ 12 ], e[ 13 ], e[ 14 ], e[ 15 ] ]\n\t\t\t];\n\t\n\t\t} );\n\t\n\t\taddSupportedType( THREE.Matrix3, function( v ) {\n\t\n\t\t\tvar e = v.elements;\n\t\t\t\t\t\n\t\t\treturn [\n\t\t\t\t[ e[ 0 ], e[ 1 ], e[ 2 ] ],\n\t\t\t\t[ e[ 3 ], e[ 4 ], e[ 5 ] ],\n\t\t\t\t[ e[ 6 ], e[ 7 ], e[ 8 ] ]\n\t\t\t];\n\t\n\t\t} );\n\t\n\t\taddSupportedType( THREE.Vector2, function( v ) {\n\t\n\t\t\treturn {\n\t\t\t\tVector2: { x: v.x, y: v.y }\n\t\t\t};\n\t\n\t\t} );\n\t\n\t\taddSupportedType( THREE.Vector3, function( v ) {\n\t\n\t\t\treturn {\n\t\t\t\tVector3: { x: v.x, y: v.y, z: v.z }\n\t\t\t};\n\t\n\t\t} );\n\t\n\t\taddSupportedType( THREE.Vector4, function( v ) {\n\t\n\t\t\treturn {\n\t\t\t\tVector4: { x: v.x, y: v.y, z: v.z, w: v.w }\n\t\t\t};\n\t\n\t\t} );\n\t\n\t\taddSupportedType( THREE.Euler, function( v ) {\n\t\n\t\t\treturn {\n\t\t\t\tVector4: { x: v.x, y: v.y, z: v.z, order: v.order }\n\t\t\t};\n\t\n\t\t} );\n\t\n\t\taddSupportedType( THREE.Ray, function( v ) {\n\t\n\t\t\treturn { \n\t\t\t\t'Ray origin': { x: v.origin.x, y: v.origin.y, z: v.origin.z },\n\t\t\t\t'Ray direction': { x: v.direction.x, y: v.direction.y, z: v.direction.z }\n\t\t\t};\n\t\n\t\t} );\n\t\n\t\tconsole.log = function() {\n\t\n\t\t\tvar special = false;\n\t\n\t\t\t[].forEach.call( arguments, function( a ) { \n\t\t\t\tsupportedTypes.forEach( function( t ) {\n\t\t\t\t\tif( a instanceof t.type ) special = true;;\n\t\t\t\t} );\n\t\t\t} );\n\t\n\t\t\tif( special ) {\n\t\n\t\t\t\t[].forEach.call( arguments, function( a ) { \n\t\t\t\t\n\t\t\t\t\t_oldConsole.apply( console, [ a ] );\n\t\n\t\t\t\t\tsupportedTypes.forEach( function( t ) {\n\t\n\t\t\t\t\t\tif( a instanceof t.type ) {\n\t\n\t\t\t\t\t\t\tconsole.table( t.format( a ) );\n\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t} );\n\t\n\t\t\t\t} );\n\t\n\t\t\t} else {\n\t\n\t\t\t\t_oldConsole.apply( console, arguments );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t} )();\n\n/***/ },\n/* 18 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*** IMPORTS FROM imports-loader ***/\n\tvar THREE = __webpack_require__(33);\n\t\n\t/**\n\t * @author bchirls / http://bchirls.com/\n\t */\n\t\n\tTHREE.VRStereoEffect = function ( renderer, fullScreenElement, options ) {\n\t\n\t\t// internals\n\t\tvar self = this;\n\t\tvar width = 0, height = 0;\n\t\tvar hmdWidth, hmdHeight;\n\t\n\t\tvar hmdDevice;\n\t\tvar vrMode;\n\t\tvar vrPreview = false;\n\t\tvar eyeOffsetLeft = new THREE.Vector3();\n\t\tvar eyeOffsetRight = new THREE.Vector3();\n\t\n\t\tvar position = new THREE.Vector3();\n\t\tvar quaternion = new THREE.Quaternion();\n\t\tvar scale = new THREE.Vector3();\n\t\n\t\tvar cameraLeft = new THREE.PerspectiveCamera();\n\t\tvar cameraRight = new THREE.PerspectiveCamera();\n\t\tvar leftRenderRect = {\n\t\t\tx: 0, y: 0, width: 0, height: 0\n\t\t};\n\t\tvar rightRenderRect = {\n\t\t\tx: 0, y: 0, width: 0, height: 0\n\t\t};\n\t\n\t\tvar near = 2;\n\t\tvar far = 40000;\n\t\n\t\tvar requestFullscreen;\n\t\tvar fullScreenParam = {\n\t\t\tvrDisplay: null\n\t\t};\n\t\tvar fovScale;\n\t\n\t\tvar RADIANS = Math.PI / 180;\n\t\n\t\tvar poll = options && options.poll || 1000;\n\t\tvar pollTimeout;\n\t\n\t\tfunction perspectiveMatrixFromVRFieldOfView(fov, zNear, zFar) {\n\t\t\tvar outMat = new THREE.Matrix4(),\n\t\t\t\tout = outMat.elements,\n\t\t\t\tupTan = Math.tan(fov.upDegrees * RADIANS),\n\t\t\t\tdownTan = Math.tan(fov.downDegrees * RADIANS),\n\t\t\t\tleftTan = Math.tan(fov.leftDegrees * RADIANS),\n\t\t\t\trightTan = Math.tan(fov.rightDegrees * RADIANS),\n\t\n\t\t\t\txScale = 2 / (leftTan + rightTan),\n\t\t\t\tyScale = 2 / (upTan + downTan);\n\t\n\t\t\tout[0] = xScale;\n\t\t\tout[4] = 0;\n\t\t\tout[8] = -((leftTan - rightTan) * xScale * 0.5);\n\t\t\tout[12] = 0;\n\t\n\t\t\tout[1] = 0;\n\t\t\tout[5] = yScale;\n\t\t\tout[9] = ((upTan - downTan) * yScale * 0.5);\n\t\t\tout[13] = 0;\n\t\n\t\t\tout[2] = 0;\n\t\t\tout[6] = 0;\n\t\t\tout[10] = zFar / (zNear - zFar);\n\t\t\tout[14] = (zFar * zNear) / (zNear - zFar);\n\t\n\t\t\tout[3] = 0;\n\t\t\tout[7] = 0;\n\t\t\tout[11] = -1;\n\t\t\tout[15] = 0;\n\t\n\t\t\treturn outMat;\n\t\t}\n\t\n\t\tfunction resize() {\n\t\t\tvar w, h;\n\t\n\t\t\tif (hmdDevice && vrMode) {\n\t\t\t\tw = hmdWidth;// / Math.pow(window.devicePixelRatio || 1, 2);\n\t\t\t\th = hmdHeight;// / Math.pow(window.devicePixelRatio || 1, 2);\n\t\t\t} else {\n\t\t\t\tw = width || renderer.domElement.offsetWidth || window.innerWidth;\n\t\t\t\th = height || renderer.domElement.offsetHeight || window.innerHeight;\n\t\t\t}\n\t\n\t\t\trenderer.setSize(w, h);\n\t\t}\n\t\n\t\tfunction updateProjection() {\n\t\t\tvar fovLeft,\n\t\t\t\tfovRight,\n\t\n\t\t\t\tleftEyeParams,\n\t\t\t\trightEyeParams,\n\t\t\t\tleftEyeRect,\n\t\t\t\trightEyeRect,\n\t\n\t\t\t\tleftEyeViewport,\n\t\t\t\trightEyeViewport;\n\t\n\t\t\tif (!hmdDevice) {\n\t\t\t\tcameraLeft.fov = 80;\n\t\t\t\tcameraRight.fov = 80;\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\t// if (amount && hmdDevice.setFieldOfView) {\n\t\t\t// \tfovScale += amount;\n\t\t\t// \tfovScale = Math.max(0.1, fovScale);\n\t\n\t\t\t// \tfovLeft = hmdDevice.getRecommendedEyeFieldOfView('left');\n\t\n\t\t\t// \tfovLeft.upDegrees *= fovScale;\n\t\t\t// \tfovLeft.downDegrees *= fovScale;\n\t\t\t// \tfovLeft.leftDegrees *= fovScale;\n\t\t\t// \tfovLeft.rightDegrees *= fovScale;\n\t\n\t\t\t// \tfovRight = hmdDevice.getRecommendedEyeFieldOfView('right');\n\t\t\t// \tfovRight.upDegrees *= fovScale;\n\t\t\t// \tfovRight.downDegrees *= fovScale;\n\t\t\t// \tfovRight.leftDegrees *= fovScale;\n\t\t\t// \tfovRight.rightDegrees *= fovScale;\n\t\n\t\t\t// \thmdDevice.setFieldOfView(fovLeft, fovRight);\n\t\t\t// }\n\t\n\t\t\tif (hmdDevice.getEyeParameters) {\n\t\t\t\tleftEyeParams = hmdDevice.getEyeParameters('left');\n\t\t\t\trightEyeParams = hmdDevice.getEyeParameters('right');\n\t\t\t\tleftEyeRect = leftEyeParams.renderRect;\n\t\t\t\trightEyeRect = rightEyeParams.renderRect;\n\t\n\t\t\t\thmdWidth = rightEyeRect.x + rightEyeRect.width;\n\t\t\t\thmdHeight = Math.max(leftEyeRect.y + leftEyeRect.height, rightEyeRect.y + rightEyeRect.height);\n\t\n\t\t\t\tfovLeft = leftEyeParams.currentFieldOfView;\n\t\t\t\tfovRight = rightEyeParams.currentFieldOfView;\n\t\n\t\t\t\thmdDevice.setFieldOfView(fovLeft, fovRight, near, far);\n\t\n\t\t\t\teyeOffsetLeft.copy(leftEyeParams.eyeTranslation);\n\t\t\t\teyeOffsetRight.copy(rightEyeParams.eyeTranslation);\n\t\n\t\t\t\tleftRenderRect = leftEyeParams.renderRect;\n\t\t\t\trightRenderRect = rightEyeParams.renderRect;\n\t\t\t} else if (hmdDevice.getRecommendedEyeRenderRect) {\n\t\t\t\tleftEyeViewport = hmdDevice.getRecommendedEyeRenderRect('left');\n\t\t\t\trightEyeViewport = hmdDevice.getRecommendedEyeRenderRect('right');\n\t\n\t\t\t\thmdWidth = leftEyeViewport.width + rightEyeViewport.width;\n\t\t\t\thmdHeight = Math.max(leftEyeViewport.height, rightEyeViewport.height);\n\t\n\t\t\t\tif (hmdDevice.getCurrentEyeFieldOfView) {\n\t\t\t\t\tfovLeft = hmdDevice.getCurrentEyeFieldOfView('left');\n\t\t\t\t\tfovRight = hmdDevice.getCurrentEyeFieldOfView('right');\n\t\t\t\t} else {\n\t\t\t\t\tfovLeft = hmdDevice.getRecommendedEyeFieldOfView('left');\n\t\t\t\t\tfovRight = hmdDevice.getRecommendedEyeFieldOfView('right');\n\t\t\t\t}\n\t\n\t\t\t\teyeOffsetLeft.copy(hmdDevice.getEyeTranslation('left'));\n\t\t\t\teyeOffsetRight.copy(hmdDevice.getEyeTranslation('right'));\n\t\n\t\t\t\tleftRenderRect.x = leftEyeViewport.left;\n\t\t\t\tleftRenderRect.y = leftEyeViewport.top;\n\t\t\t\tleftRenderRect.width = leftEyeViewport.width;\n\t\t\t\tleftRenderRect.height = leftEyeViewport.height;\n\t\n\t\t\t\trightRenderRect.x = rightEyeViewport.left;\n\t\t\t\trightRenderRect.y = rightEyeViewport.top;\n\t\t\t\trightRenderRect.width = rightEyeViewport.width;\n\t\t\t\trightRenderRect.height = rightEyeViewport.height;\n\t\t\t}\n\t\n\t\t\tresize();\n\t\n\t\t\tcameraLeft.projectionMatrix = perspectiveMatrixFromVRFieldOfView(fovLeft, near, far);\n\t\t\tcameraRight.projectionMatrix = perspectiveMatrixFromVRFieldOfView(fovRight, near, far);\n\t\t}\n\t\n\t\tfunction gotVRDevices(devices) {\n\t\t\tvar i,\n\t\t\t\tdevice;\n\t\n\t\t\tfor (i = 0; i < devices.length; i++) {\n\t\t\t\tdevice = devices[i];\n\t\t\t\tif ( device instanceof HMDVRDevice ) {\n\t\n\t\t\t\t\tif ( hmdDevice && device.hardwareUnitId === hmdDevice.hardwareUnitId ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\n\t\t\t\t\thmdDevice = device;\n\t\t\t\t\tconsole.log('Using HMD Device:', hmdDevice.deviceName);\n\t\n\t\t\t\t\tif (hmdDevice.setTimewarp) {\n\t\t\t\t\t\t//hmdDevice.setTimewarp(false);\n\t\t\t\t\t}\n\t\n\t\t\t\t\tupdateProjection();\n\t\n\t\t\t\t\tfullScreenParam.vrDisplay = hmdDevice;\n\t\n\t\t\t\t\tself.dispatchEvent( {\n\t\t\t\t\t\ttype: \"devicechange\"\n\t\t\t\t\t} );\n\t\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tif (poll) {\n\t\t\t\tclearTimeout(pollTimeout);\n\t\t\t\tsetTimeout(self.scan, poll);\n\t\t\t}\n\t\t}\n\t\n\t\tfunction onFullscreenChange() {\n\t\t\tif (!document.webkitFullscreenElement &&\n\t\t\t\t\t!document.mozFullScreenElement &&\n\t\t\t\t\t!document.msFullscreenElement) {\n\t\t\t\tvrMode = false;\n\t\t\t}\n\t\n\t\t\tupdateProjection();\n\t\n\t\t\tself.dispatchEvent( {\n\t\t\t\ttype: \"fullscreenchange\"\n\t\t\t} );\n\t\t}\n\t\n\t\t// API\n\t\n\t\tthis.separation = 0.01;\n\t\n\t\t// initialization\n\t\n\t\trenderer.autoClear = false;\n\t\n\t\tif (!fullScreenElement) {\n\t\t\tfullScreenElement = renderer.domElement;\n\t\t}\n\t\trequestFullscreen = fullScreenElement.webkitRequestFullscreen ||\n\t\t\tfullScreenElement.mozRequestFullScreen ||\n\t\t\tfullScreenElement.msRequestFullscreen;\n\t\tif (requestFullscreen) {\n\t\t\trequestFullscreen = requestFullscreen.bind(fullScreenElement, fullScreenParam);\n\t\t}\n\t\n\t\tdocument.addEventListener('fullscreenchange', onFullscreenChange, false);\n\t\tdocument.addEventListener('webkitfullscreenchange', onFullscreenChange, false);\n\t\tdocument.addEventListener('mozfullscreenchange', onFullscreenChange, false);\n\t\tdocument.addEventListener('MSFullscreenChange', onFullscreenChange, false);\n\t\n\t\t//todo: method for adjusting HMD FOV\n\t\n\t\tthis.scan = function () {\n\t\t\tif (navigator.getVRDevices) {\n\t\t\t\tnavigator.getVRDevices().then(gotVRDevices);\n\t\t\t} else if (navigator.mozGetVRDevices) {\n\t\t\t\tnavigator.mozGetVRDevices(gotVRDevices);\n\t\t\t}\n\t\t};\n\t\n\t\tthis.requestFullScreen = function () {\n\t\t\tvrMode = true;\n\t\t\trequestFullscreen();\n\t\t};\n\t\n\t\tthis.exit = function () {\n\t\t\tvrMode = false;\n\t\t\tvrPreview = false;\n\t\t};\n\t\n\t\tthis.setSize = function ( w, h ) {\n\t\t\twidth = w;\n\t\t\theight = h;\n\t\n\t\t\tresize();\n\t\t};\n\t\n\t\tthis.vrPreview = function (val) {\n\t\t\tif (val !== undefined) {\n\t\t\t\tvrPreview = !!val;\n\t\t\t}\n\t\t\treturn vrPreview;\n\t\t};\n\t\n\t\tthis.isFullscreen = function () {\n\t\t\treturn vrMode;\n\t\t};\n\t\n\t\tthis.hmd = function () {\n\t\t\treturn hmdDevice;\n\t\t};\n\t\n\t\tthis.render = function ( leftScene, rightScene, camera, renderTarget, forceClear ) {\n\t\t\tvar w, h;\n\t\n\t\t\tif ( rightScene && rightScene instanceof THREE.Scene ) {\n\t\t\t\t//rightScene.updateMatrixWorld();\n\t\t\t} else {\n\t\t\t\tif ( (!camera || camera instanceof THREE.WebGLRenderTarget) && rightScene instanceof THREE.Camera ) {\n\t\t\t\t\tforceClear = renderTarget;\n\t\t\t\t\trenderTarget = camera;\n\t\t\t\t\tcamera = rightScene;\n\t\t\t\t}\n\t\t\t\trightScene = leftScene;\n\t\t\t}\n\t\n\t\t\t//leftScene.updateMatrixWorld();\n\t\n\t\t\tif ( camera.parent === undefined ) {\n\t\t\t\tcamera.updateMatrixWorld();\n\t\t\t}\n\t\n\t\t\tw = width || renderer.domElement.width;\n\t\t\th = height || renderer.domElement.height;\n\t\t\t// w /= window.devicePixelRatio || 1;\n\t\t\t// h /= window.devicePixelRatio || 1;\n\t\n\t\t\t/*\n\t\t\ttodo: make this work when CSS VR Rendering is fixed\n\t\t\thttp://blog.bitops.com/blog/2014/08/20/updated-firefox-vr-builds/\n\t\t\tif (renderer instanceof THREE.CSS3DRenderer) {\n\t\t\t\trenderer.render( leftScene, camera );\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t*/\n\t\n\t\t\tif (!vrMode && !vrPreview) {\n\t\t\t\trenderer.enableScissorTest( false );\n\t\t\t\trenderer.setViewport( 0, 0, w, h );\n\t\t\t\trenderer.render( leftScene, camera, renderTarget, true );\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\tcamera.matrixWorld.decompose( position, quaternion, scale );\n\t\n\t\t\tif (!hmdDevice) {\n\t\t\t\t// left\n\t\t\t\t//cameraLeft.fov = camera.fov;\n\t\t\t\tcameraLeft.aspect = 0.5 * camera.aspect;\n\t\t\t\tcameraLeft.near = camera.near;\n\t\t\t\tcameraLeft.far = camera.far;\n\t\t\t\tcameraLeft.updateProjectionMatrix();\n\t\n\t\t\t\t// right\n\t\n\t\t\t\t// cameraRight.fov = camera.fov;\n\t\t\t\tcameraRight.aspect = 0.5 * camera.aspect;\n\t\t\t\tcameraRight.near = camera.near;\n\t\t\t\tcameraRight.far = camera.far;\n\t\t\t\tcameraRight.updateProjectionMatrix();\n\t\t\t}\n\t\n\t\t\tcameraLeft.position.copy( position );\n\t\t\tcameraLeft.quaternion.copy( quaternion );\n\t\n\t\t\tcameraRight.position.copy( position );\n\t\t\tcameraRight.quaternion.copy( quaternion );\n\t\n\t\t\tif (hmdDevice) {\n\t\t\t\tcameraLeft.position.add( eyeOffsetLeft ) ;\n\t\t\t\tcameraRight.position.add( eyeOffsetRight );\n\t\t\t} else {\n\t\t\t\tcameraLeft.translateX( - this.separation );\n\t\t\t\tcameraRight.translateX( this.separation );\n\t\t\t}\n\t\n\t\t\tcameraLeft.updateMatrixWorld();\n\t\t\tcameraRight.updateMatrixWorld();\n\t\n\t\t\t//\n\t\n\t\t\trenderer.enableScissorTest(true);\n\t\n\t\t\tw = renderer.context.drawingBufferWidth / 2;\n\t\n\t\t\tif (renderTarget) {\n\t\t\t\trenderer.setRenderTarget(renderTarget);\n\t\t\t}\n\t\n\t\t\trightScene.traverseVisible(function (obj) {\n\t\t\t\tif (obj.material && obj.material.map) {\n\t\t\t\t\tif (obj.userData.stereo === 'vertical') {\n\t\t\t\t\t\tobj.material.map.offset.set(0, 0.5);\n\t\t\t\t\t} else if (obj.userData.stereo) {\n\t\t\t\t\t\tobj.material.map.offset.set(0.5, 0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t\trenderer.setScissor( w, 0, w, h );\n\t\t\trenderer.setViewport( w, 0, w, h );\n\t\t\trenderer.render( rightScene, cameraRight, renderTarget, forceClear );\n\t\n\t\t\tleftScene.traverseVisible(function (obj) {\n\t\t\t\tif (obj.userData.stereo && obj.material && obj.material.map) {\n\t\t\t\t\tobj.material.map.offset.set(0, 0);\n\t\t\t\t}\n\t\t\t});\n\t\t\trenderer.setScissor( 0, 0, w, h );\n\t\t\trenderer.setViewport( 0, 0, w, h );\n\t\t\trenderer.render( leftScene, cameraLeft, renderTarget, forceClear );\n\t\n\t\t\t//reset viewport, scissor\n\t\t\tw *= 2;\n\t\t\trenderer.setViewport( 0, 0, w, h );\n\t\t\trenderer.setScissor( 0, 0, w, h );\n\t\t\trenderer.enableScissorTest( false );\n\t\t};\n\t\n\t\tObject.defineProperty(this, 'near', {\n\t\t\tget: function () {\n\t\t\t\treturn near;\n\t\t\t},\n\t\t\tset: function (val) {\n\t\t\t\tval = parseFloat(val);\n\t\t\t\tif (val && !isNaN(val)) {\n\t\t\t\t\tnear = Math.max(0, val);\n\t\t\t\t\tupdateProjection();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\n\t\tObject.defineProperty(this, 'far', {\n\t\t\tget: function () {\n\t\t\t\treturn far;\n\t\t\t},\n\t\t\tset: function (val) {\n\t\t\t\tval = parseFloat(val);\n\t\t\t\tif (val && !isNaN(val)) {\n\t\t\t\t\tfar = Math.max(0, val);\n\t\t\t\t\tupdateProjection();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\n\t\tthis.scan();\n\t\tresize();\n\t};\n\t\n\tTHREE.VRStereoEffect.prototype = Object.create( THREE.EventDispatcher.prototype );\n\n\n/***/ },\n/* 19 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*** IMPORTS FROM imports-loader ***/\n\tvar THREE = __webpack_require__(33);\n\t\n\tTHREE.VRControls = function ( object, options ) {\n\t\n\t\tvar self = this;\n\t\n\t\t//HMD sensor stuff\n\t\tvar sensorDevice;\n\t\tvar vrState;\n\t\n\t\t//device orientation stuff\n\t\tvar deviceControls;\n\t\tvar zeroAngle = 0;\n\t\n\t\tvar mode = '';\n\t\n\t\tvar vrBrowser = navigator.getVRDevices || navigator.mozGetVRDevices;\n\t\n\t\tvar poll = options && options.poll || 1000;\n\t\tvar pollTimeout;\n\t\n\t\tfunction gotVRDevices( devices ) {\n\t\t\tvar i,\n\t\t\t\tdevice;\n\t\n\t\t\tfor ( i = 0; i < devices.length; ++i ) {\n\t\t\t\tdevice = devices[i];\n\t\t\t\tif ( devices[i] instanceof PositionSensorVRDevice ) {\n\t\n\t\t\t\t\tif ( sensorDevice && devices[i].hardwareUnitId === sensorDevice.hardwareUnitId ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tsensorDevice = device;\n\t\t\t\t\tconsole.log('Using Sensor Device:', sensorDevice.deviceName);\n\t\n\t\t\t\t\tif ( sensorDevice.zeroSensor ) {\n\t\t\t\t\t\tself.zeroSensor = sensorDevice.zeroSensor.bind(sensorDevice);\n\t\t\t\t\t} else if ( sensorDevice.resetSensor ) {\n\t\t\t\t\t\tself.zeroSensor = sensorDevice.resetSensor.bind(sensorDevice);\n\t\t\t\t\t}\n\t\t\t\t\tself.zeroSensor();\n\t\n\t\t\t\t\tmode = 'hmd';\n\t\n\t\t\t\t\tself.dispatchEvent( {\n\t\t\t\t\t\ttype: \"devicechange\"\n\t\t\t\t\t} );\n\t\n\t\t\t\t\tbreak; // We keep the first we encounter\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tif (poll) {\n\t\t\t\tclearTimeout(pollTimeout);\n\t\t\t\tsetTimeout(self.scan, poll);\n\t\t\t}\n\t\t}\n\t\n\t\tfunction deviceOrientationChange( event ) {\n\t\t\tif ( typeof event.gamma === 'number' ) {\n\t\t\t\tmode = 'deviceorientation';\n\t\t\t\twindow.removeEventListener( 'deviceorientation', deviceOrientationChange, false );\n\t\t\t\tdeviceControls = new THREE.DeviceOrientationControls( object );\n\t\t\t\tdeviceControls.connect();\n\t\t\t\tif (!this.freeze) {\n\t\t\t\t\tdeviceControls.update();\n\t\t\t\t}\n\t\n\t\t\t\tself.dispatchEvent( {\n\t\t\t\t\ttype: \"devicechange\"\n\t\t\t\t} );\n\t\t\t}\n\t\t}\n\t\n\t\tthis.update = function() {\n\t\t\t// Applies head rotation from sensor data.\n\t\t\tif (self.freeze) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\tif ( sensorDevice ) {\n\t\t\t\tvrState = sensorDevice.getState();\n\t\t\t\tif ( vrState ) {\n\t\t\t\t\tif ( vrState.orientation && vrState.hasOrientation !== false ) {\n\t\t\t\t\t\tobject.quaternion.copy( vrState.orientation );\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( vrState.position && vrState.hasPosition !== false ) {\n\t\t\t\t\t\t// vrState.position is null if using DK1 or if DK2 camera is not plugged in\n\t\t\t\t\t\tobject.position.copy( vrState.position );\n\t\t\t\t\t}\n\t\n\t\t\t\t\tobject.updateMatrixWorld();\n\t\t\t\t}\n\t\t\t} else if (deviceControls && deviceControls.deviceOrientation.gamma !== undefined) {\n\t\t\t\tdeviceControls.update();\n\t\t\t\tobject.rotateY(-zeroAngle);\n\t\t\t\tobject.updateMatrixWorld();\n\t\t\t}\n\t\t};\n\t\n\t\t//only useful when frozen\n\t\tthis.reset = function () {\n\t\t\tif ( object ) {\n\t\t\t\tobject.quaternion.set( 0, 0, 0, 1 );\n\t\t\t\tobject.position.set( 0, 0, 0 );\n\t\t\t}\n\t\t};\n\t\n\t\t//zeros only rotation on Y axis\n\t\t//todo: find out if it zeros out position. need a DK2 to test\n\t\tthis.zeroSensor = function () {\n\t\t\tif (sensorDevice && sensorDevice.zeroSensor) {\n\t\t\t\tsensorDevice.zeroSensor();\n\t\t\t}\n\t\t\tzeroAngle = object.rotation.y;\n\t\t\tself.update();\n\t\t};\n\t\n\t\tthis.freeze = false;\n\t\n\t\t//method to query which tech we're using\n\t\tthis.mode = function () {\n\t\t\treturn mode;\n\t\t};\n\t\n\t\tthis.scan = function () {\n\t\t\tif ( navigator.getVRDevices ) {\n\t\t\t\tnavigator.getVRDevices().then( gotVRDevices );\n\t\t\t} else if ( navigator.mozGetVRDevices ) {\n\t\t\t\tnavigator.mozGetVRDevices( gotVRDevices );\n\t\t\t}\n\t\t};\n\t\n\t\t//todo: connect/disconnect methods\n\t\t//todo: method to query orientation/position without changing object\n\t\t//todo: work without an object\n\t\n\t\tif ( vrBrowser ) {\n\t\t\tthis.scan();\n\t\t} else if ( \"DeviceOrientationEvent\" in window && THREE.DeviceOrientationControls) {\n\t\t\t//device orientation\n\t\t\twindow.addEventListener( \"deviceorientation\", deviceOrientationChange, false );\n\t\t}\n\t};\n\t\n\tTHREE.VRControls.prototype = Object.create( THREE.EventDispatcher.prototype );\n\n\n/***/ },\n/* 20 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar d        = __webpack_require__(41)\n\t  , callable = __webpack_require__(56)\n\t\n\t  , apply = Function.prototype.apply, call = Function.prototype.call\n\t  , create = Object.create, defineProperty = Object.defineProperty\n\t  , defineProperties = Object.defineProperties\n\t  , hasOwnProperty = Object.prototype.hasOwnProperty\n\t  , descriptor = { configurable: true, enumerable: false, writable: true }\n\t\n\t  , on, once, off, emit, methods, descriptors, base;\n\t\n\ton = function (type, listener) {\n\t\tvar data;\n\t\n\t\tcallable(listener);\n\t\n\t\tif (!hasOwnProperty.call(this, '__ee__')) {\n\t\t\tdata = descriptor.value = create(null);\n\t\t\tdefineProperty(this, '__ee__', descriptor);\n\t\t\tdescriptor.value = null;\n\t\t} else {\n\t\t\tdata = this.__ee__;\n\t\t}\n\t\tif (!data[type]) data[type] = listener;\n\t\telse if (typeof data[type] === 'object') data[type].push(listener);\n\t\telse data[type] = [data[type], listener];\n\t\n\t\treturn this;\n\t};\n\t\n\tonce = function (type, listener) {\n\t\tvar once, self;\n\t\n\t\tcallable(listener);\n\t\tself = this;\n\t\ton.call(this, type, once = function () {\n\t\t\toff.call(self, type, once);\n\t\t\tapply.call(listener, this, arguments);\n\t\t});\n\t\n\t\tonce.__eeOnceListener__ = listener;\n\t\treturn this;\n\t};\n\t\n\toff = function (type, listener) {\n\t\tvar data, listeners, candidate, i;\n\t\n\t\tcallable(listener);\n\t\n\t\tif (!hasOwnProperty.call(this, '__ee__')) return this;\n\t\tdata = this.__ee__;\n\t\tif (!data[type]) return this;\n\t\tlisteners = data[type];\n\t\n\t\tif (typeof listeners === 'object') {\n\t\t\tfor (i = 0; (candidate = listeners[i]); ++i) {\n\t\t\t\tif ((candidate === listener) ||\n\t\t\t\t\t\t(candidate.__eeOnceListener__ === listener)) {\n\t\t\t\t\tif (listeners.length === 2) data[type] = listeners[i ? 0 : 1];\n\t\t\t\t\telse listeners.splice(i, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif ((listeners === listener) ||\n\t\t\t\t\t(listeners.__eeOnceListener__ === listener)) {\n\t\t\t\tdelete data[type];\n\t\t\t}\n\t\t}\n\t\n\t\treturn this;\n\t};\n\t\n\temit = function (type) {\n\t\tvar i, l, listener, listeners, args;\n\t\n\t\tif (!hasOwnProperty.call(this, '__ee__')) return;\n\t\tlisteners = this.__ee__[type];\n\t\tif (!listeners) return;\n\t\n\t\tif (typeof listeners === 'object') {\n\t\t\tl = arguments.length;\n\t\t\targs = new Array(l - 1);\n\t\t\tfor (i = 1; i < l; ++i) args[i - 1] = arguments[i];\n\t\n\t\t\tlisteners = listeners.slice();\n\t\t\tfor (i = 0; (listener = listeners[i]); ++i) {\n\t\t\t\tapply.call(listener, this, args);\n\t\t\t}\n\t\t} else {\n\t\t\tswitch (arguments.length) {\n\t\t\tcase 1:\n\t\t\t\tcall.call(listeners, this);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tcall.call(listeners, this, arguments[1]);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tcall.call(listeners, this, arguments[1], arguments[2]);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tl = arguments.length;\n\t\t\t\targs = new Array(l - 1);\n\t\t\t\tfor (i = 1; i < l; ++i) {\n\t\t\t\t\targs[i - 1] = arguments[i];\n\t\t\t\t}\n\t\t\t\tapply.call(listeners, this, args);\n\t\t\t}\n\t\t}\n\t};\n\t\n\tmethods = {\n\t\ton: on,\n\t\tonce: once,\n\t\toff: off,\n\t\temit: emit\n\t};\n\t\n\tdescriptors = {\n\t\ton: d(on),\n\t\tonce: d(once),\n\t\toff: d(off),\n\t\temit: d(emit)\n\t};\n\t\n\tbase = defineProperties({}, descriptors);\n\t\n\tmodule.exports = exports = function (o) {\n\t\treturn (o == null) ? create(base) : defineProperties(Object(o), descriptors);\n\t};\n\texports.methods = methods;\n\n\n/***/ },\n/* 21 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = (function () {\n\t\t'use strict';\n\t\n\t\tvar materials = __webpack_require__(10),\n\t\t\tTHREE = __webpack_require__(33),\n\t\t\tgeometry = new THREE.BoxGeometry( 1, 1, 1 );\n\t\n\t\treturn function box(parent, options) {\n\t\t\tvar mesh;\n\t\n\t\t\tmesh = new THREE.Mesh(geometry, materials.standard());\n\t\t\tmesh.name = 'box';\n\t\n\t\t\tparent.add(mesh);\n\t\n\t\t\treturn mesh;\n\t\t};\n\t}());\n\n/***/ },\n/* 22 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = (function () {\n\t\t'use strict';\n\t\n\t\tvar materials = __webpack_require__(10),\n\t\t\tTHREE = __webpack_require__(33);\n\t\n\t\tfunction cylinder(parent, options) {\n\t\t\tvar geometry,\n\t\t\t\tmesh;\n\t\n\t\t\tgeometry = new THREE.CylinderGeometry(\n\t\t\t\toptions.radiusTop === undefined ? 0.5 : options.radiusTop,\n\t\t\t\toptions.radiusBottom === undefined ? 0.5 : options.radiusBottom,\n\t\t\t\toptions.height === undefined ? 1 : options.height,\n\t\t\t\toptions.radiusSegments === undefined ? 16 : options.radiusSegments,\n\t\t\t\toptions.heightSegments,\n\t\t\t\toptions.openEnded\n\t\t\t);\n\t\t\tmesh = new THREE.Mesh(geometry, materials.standard());\n\t\t\tmesh.name = 'cylinder';\n\t\n\t\t\tparent.add(mesh);\n\t\n\t\t\treturn mesh;\n\t\t}\n\t\n\t\treturn cylinder;\n\t}());\n\n/***/ },\n/* 23 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = (function () {\n\t\t'use strict';\n\t\n\t\tvar materials = __webpack_require__(10),\n\t\t\tTHREE = __webpack_require__(33);\n\t\n\t\tfunction floor(parent, options) {\n\t\t\tvar obj,\n\t\t\t\tgeometry;\n\t\n\t\t\tgeometry = new THREE.CircleGeometry( options.radius || 100, options.segments || 16 );\n\t\t\tgeometry.applyMatrix( new THREE.Matrix4().makeRotationX(-Math.PI / 2));\n\t\n\t\t\tobj = new THREE.Mesh(\n\t\t\t\tgeometry,\n\t\t\t\tmaterials.checkerboard({\n\t\t\t\t\trepeat: 100\n\t\t\t\t})\n\t\t\t);\n\t\t\tobj.name = 'floor';\n\t\n\t\t\tobj.receiveShadow = true;\n\t\n\t\t\tparent.add(obj);\n\t\n\t\t\treturn obj;\n\t\t}\n\t\n\t\treturn floor;\n\t}());\n\n/***/ },\n/* 24 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = (function () {\n\t\t'use strict';\n\t\n\t\tvar materials = __webpack_require__(10),\n\t\t\tTHREE = __webpack_require__(33);\n\t\n\t\treturn function image(parent, options) {\n\t\t\tvar geometry,\n\t\t\t\tmaterial,\n\t\t\t\tmesh,\n\t\t\t\tsrc,\n\t\t\t\ttex;\n\t\n\t\t\tif (typeof options === 'string') {\n\t\t\t\tsrc = options;\n\t\t\t} else if (options) {\n\t\t\t\tsrc = options.src;\n\t\t\t}\n\t\n\t\t\tif (src) {\n\t\t\t\ttex = materials.imageTexture(src, THREE.UVMapping, function (t, image) {\n\t\t\t\t\t//todo: don't do any of this if object has been deleted\n\t\t\t\t\tgeometry.applyMatrix(new THREE.Matrix4().makeScale(1, image.naturalHeight / image.naturalWidth, 1));\n\t\t\t\t\tmaterial.map = tex;\n\t\t\t\t\tmaterial.visible = true;\n\t\t\t\t\tmesh.visible = true;\n\t\t\t\t\tparent.add(mesh);\n\t\t\t\t});\n\t\t\t}\n\t\n\t\t\tgeometry = new THREE.PlaneBufferGeometry(1, 1, 8);\n\t\n\t\t\tmaterial = new THREE.MeshBasicMaterial({\n\t\t\t\tside: THREE.DoubleSide,\n\t\t\t\ttransparent: true,\n\t\t\t\tmap: tex\n\t\t\t});\n\t\n\t\t\tmesh = new THREE.Mesh( geometry, material );\n\t\n\t\t\tmesh.visible = false;\n\t\n\t\t\tparent.add(mesh);\n\t\n\t\t\treturn mesh;\n\t\t};\n\t}());\n\n/***/ },\n/* 25 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = (function () {\n\t\t'use strict';\n\t\n\t\tvar materials = __webpack_require__(10),\n\t\t\tTHREE = __webpack_require__(33),\n\t\t\tgeometry = new THREE.SphereGeometry(1000, 60, 60);\n\t\n\t\tgeometry.applyMatrix(new THREE.Matrix4().makeScale(-1, 1, 1));\n\t\tgeometry.applyMatrix(new THREE.Matrix4().makeRotationY(- Math.PI / 2));\n\t\n\t\treturn function panorama(parent, options) {\n\t\t\tvar material,\n\t\t\t\tmesh,\n\t\t\t\tsrc,\n\t\t\t\ttex;\n\t\n\t\t\tif (typeof options === 'string') {\n\t\t\t\tsrc = options;\n\t\t\t} else if (options) {\n\t\t\t\tsrc = options.src;\n\t\t\t}\n\t\n\t\t\tif (src) {\n\t\t\t\ttex = materials.imageTexture(src, THREE.UVMapping);\n\t\t\t}\n\t\n\t\t\tmaterial = new THREE.MeshBasicMaterial({\n\t\t\t\ttransparent: true,\n\t\t\t\tmap: tex\n\t\t\t});\n\t\n\t\t\tmesh = new THREE.Mesh(geometry, material);\n\t\n\t\t\tif (options && options.stereo) {\n\t\t\t\tif (options.stereo === 'vertical') {\n\t\t\t\t\ttex.repeat.y = 0.5;\n\t\t\t\t} else {\n\t\t\t\t\ttex.repeat.x = 0.5;\n\t\t\t\t}\n\t\t\t\tmesh.userData.stereo = options.stereo;\n\t\t\t}\n\t\n\t\t\tmesh.name = 'panorama';\n\t\n\t\t\tparent.add(mesh);\n\t\n\t\t\treturn mesh;\n\t\t};\n\t}());\n\n/***/ },\n/* 26 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = (function () {\n\t\t'use strict';\n\t\n\t\tvar materials = __webpack_require__(10),\n\t\t\tTHREE = __webpack_require__(33),\n\t\t\tSPE = __webpack_require__(40),\n\t\t\tassign = __webpack_require__(37),\n\t\n\t\t\tgroupFields = [\n\t\t\t\t'maxAge',\n\t\t\t\t'hasPerspective',\n\t\t\t\t'colorize',\n\t\t\t\t'blending',\n\t\t\t\t'transparent',\n\t\t\t\t'alphaTest',\n\t\t\t\t'depthWrite',\n\t\t\t\t'depthTest',\n\t\t\t\t'fixedTimeStep'\n\t\t\t];\n\t\n\t\treturn function particles(parent, options) {\n\t\t\tvar obj = new THREE.Object3D(),\n\t\t\t\tkey,\n\t\t\t\tgroupOptions = {},\n\t\t\t\temitterOptions = {};\n\t\n\t\t\tobj.name = 'particles';\n\t\n\t\t\tif (options) {\n\t\t\t\tgroupFields.forEach(function (field) {\n\t\t\t\t\tif (options[field] !== undefined) {\n\t\t\t\t\t\tgroupOptions[field] = options[field];\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\n\t\t\tvar particleGroup = new SPE.Group({\n\t\t\t\ttexture: materials.textures.cloud(),\n\t\t\t\t// texture: materials.imageTexture('http://squarefeet.github.io/ShaderParticleEngine/examples/img/cloudSml.png'),\n\t\t\t\tmaxAge: 20,\n\t\t\t\tblending: THREE.NormalBlending,\n\t\t\t\thasPerspective: 1\n\t\t\t});\n\t\n\t\t\tvar emitter = new SPE.Emitter({\n\t\t\t\tpositionSpread: new THREE.Vector3(4, 1, 24),\n\t\n\t\t\t\t//acceleration: new THREE.Vector3(0, 0, 0),\n\t\n\t\t\t\t// velocity: new THREE.Vector3(0, 0, 1),\n\t\n\t\t\t\tcolorStart: new THREE.Color('white'),\n\t\t\t\tsizeStart: 0.5,\n\t\t\t\tsizeStartSpread: 1.5 / 4,\n\t\t\t\t// opacityStart: 0,\n\t\t\t\t// opacityMiddle: 1,\n\t\t\t\t// opacityEnd: 0,\n\t\n\t\t\t\tparticleCount: 8000,\n\t\t\t\tisStatic: 0\n\t\t\t});\n\t\n\t\t\tparticleGroup.addEmitter(emitter);\n\t\t\tobj.add(particleGroup.mesh);\n\t\n\t\t\tparent.add(obj);\n\t\n\t\t\tvar lastTime = 0;\n\t\t\tthis.update = function (time) {\n\t\t\t\tvar delta = Math.min(500, time - lastTime);\n\t\t\t\tlastTime = time;\n\t\t\t\tparticleGroup.tick(delta);\n\t\t\t};\n\t\n\t\t\treturn obj;\n\t\t};\n\t}());\n\n/***/ },\n/* 27 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = (function () {\n\t\t'use strict';\n\t\n\t\tvar materials = __webpack_require__(10),\n\t\t\tTHREE = __webpack_require__(33),\n\t\t\tTAU = Math.PI * 2,\n\t\t\tHALF_PI = Math.PI / 2,\n\t\n\t\t\tdistance = 400000,\n\t\t\tscratchVector = new THREE.Vector3(),\n\t\n\t\t\tparams = [\n\t\t\t\t'luminance',\n\t\t\t\t'turbidity',\n\t\t\t\t'reileigh',\n\t\t\t\t'mieCoefficient',\n\t\t\t\t'mieDirectionalG'\n\t\t\t];\n\t\n\t\t__webpack_require__(39);\n\t\n\t\treturn function sky(parent, options) {\n\t\t\tvar obj = new THREE.Sky(),\n\t\t\t\tself = this,\n\t\t\t\tscene = parent,\n\t\t\t\tlight,\n\t\t\t\tsunPosition,\n\t\t\t\tazimuth = Math.PI / 6,\n\t\t\t\taltitude = Math.PI / 6;\n\t\n\t\t\tfunction mod(x, y) {\n\t\t\t\treturn x - y * Math.floor(x / y);\n\t\t\t}\n\t\n\t\t\tfunction update() {\n\t\t\t\tvar sinTheta,\n\t\t\t\t\tcosTheta,\n\t\t\t\t\tphi,\n\t\t\t\t\tsinPhi,\n\t\t\t\t\tcosPhi;\n\t\n\t\t\t\tsinTheta = Math.sin(altitude);\n\t\t\t\tcosTheta = Math.cos(altitude);\n\t\t\t\tphi = -HALF_PI - azimuth;\n\t\t\t\tsinPhi = Math.sin(phi);\n\t\t\t\tcosPhi = Math.cos(phi);\n\t\n\t\t\t\tsunPosition.set(\n\t\t\t\t\tdistance * cosPhi * cosTheta,\n\t\t\t\t\tdistance * sinTheta,\n\t\t\t\t\tdistance * sinPhi * cosTheta\n\t\t\t\t);\n\t\n\t\t\t\tif (light) {\n\t\t\t\t\tlight.intensity = 1.5 * Math.max(0.0, 1.0 - Math.exp(-((Math.PI / 1.95 - Math.abs(HALF_PI - altitude)) / 1.5)));\n\t\t\t\t\tlight.position.copy(sunPosition).normalize().multiplyScalar(100);\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tobj.mesh.name = 'sky';\n\t\n\t\t\tparent.add(obj.mesh);\n\t\n\t\t\twhile (!(scene instanceof THREE.Scene) && scene.parent) {\n\t\t\t\tscene = scene.parent;\n\t\t\t}\n\t\t\tlight = scene.getObjectByName('directional-light');\n\t\n\t\t\tthis.setOptions = function (options) {\n\t\t\t\tvar needUpdate = false,\n\t\t\t\t\taltitude,\n\t\t\t\t\tazimuth;\n\t\n\t\t\t\tif (options) {\n\t\t\t\t\tparams.forEach(function (param) {\n\t\t\t\t\t\tvar val = options[param];\n\t\t\t\t\t\tif (val !== undefined) {\n\t\t\t\t\t\t\tval = parseFloat(val);\n\t\t\t\t\t\t\tif (!isNaN(val)) {\n\t\t\t\t\t\t\t\tobj.uniforms[param].value = val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\n\t\t\t\t\tif (options.sunPosition instanceof THREE.Vector3) {\n\t\t\t\t\t\tobj.uniforms.sunPosition.value.copy(options.sunPosition);\n\t\t\t\t\t} else if (Array.isArray(options.sunPosition)) {\n\t\t\t\t\t\tobj.uniforms.sunPosition.value.set(obj.uniforms.sunPosition.value, options.sunPosition);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.altitude = options.altitude;\n\t\t\t\t\t\tself.azimuth = options.azimuth;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\tObject.defineProperty(this, 'azimuth', {\n\t\t\t\tset: function (val) {\n\t\t\t\t\tval = mod(parseFloat(val), TAU);\n\t\t\t\t\tif (!isNaN(val) && val !== azimuth) {\n\t\t\t\t\t\tazimuth = val;\n\t\t\t\t\t\tupdate();\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tget: function () {\n\t\t\t\t\treturn azimuth;\n\t\t\t\t}\n\t\t\t});\n\t\n\t\t\tObject.defineProperty(this, 'altitude', {\n\t\t\t\tset: function (val) {\n\t\t\t\t\tval = mod(parseFloat(val), TAU);\n\t\t\t\t\tif (!isNaN(val) && val !== altitude) {\n\t\t\t\t\t\taltitude = val;\n\t\t\t\t\t\tupdate();\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tget: function() {\n\t\t\t\t\treturn altitude;\n\t\t\t\t}\n\t\t\t});\n\t\n\t\t\tthis.setAltitude = function (val) {\n\t\t\t\tself.altitude = val;\n\t\t\t\treturn this;\n\t\t\t};\n\t\n\t\t\tthis.setAzimuth = function (val) {\n\t\t\t\tself.azimuth = val;\n\t\t\t\treturn this;\n\t\t\t};\n\t\n\t\t\tsunPosition = obj.uniforms.sunPosition.value;\n\t\t\tupdate();\n\t\n\t\t\tthis.setOptions(options);\n\t\n\t\t\treturn obj.mesh;\n\t\t};\n\t}());\n\n/***/ },\n/* 28 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = (function () {\n\t\t'use strict';\n\t\n\t\tvar materials = __webpack_require__(10),\n\t\t\tTHREE = __webpack_require__(33);\n\t\n\t\t__webpack_require__(38);\n\t\n\t\treturn function sound(parent, options) {\n\t\t\tvar obj,\n\t\t\t\tsrc,\n\t\t\t\tlistener,\n\t\t\t\tscene = parent;\n\t\n\t\t\tif (typeof options === 'string' || Array.isArray(options)) {\n\t\t\t\tsrc = options;\n\t\t\t} else if (options) {\n\t\t\t\tsrc = options.src;\n\t\t\t}\n\t\n\t\t\twhile (!(scene instanceof THREE.Scene) && scene.parent) {\n\t\t\t\tscene = scene.parent;\n\t\t\t}\n\t\n\t\t\tlistener = scene.getObjectByName('audio-listener');\n\t\t\tobj = new THREE.Audio(listener);\n\t\t\t// obj.setLoop(true);\n\t\t\tobj.load(src);\n\t\n\t\t\tthis.start = obj.start.bind(obj);\n\t\t\tthis.volume = obj.volume.bind(obj);\n\t\n\t\t\tparent.add(obj);\n\t\n\t\t\treturn obj;\n\t\t};\n\t}());\n\n/***/ },\n/* 29 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = (function () {\n\t\t'use strict';\n\t\n\t\tvar materials = __webpack_require__(10),\n\t\t\tTHREE = __webpack_require__(33);\n\t\n\t\treturn function box(parent, options) {\n\t\t\tvar geometry,\n\t\t\t\tmesh;\n\t\n\t\t\tgeometry = new THREE.SphereGeometry(\n\t\t\t\toptions.radius === undefined ? 0.5 : options.radius,\n\t\t\t\toptions.widthSegments === undefined ? 16 : options.widthSegments,\n\t\t\t\toptions.heightSegments === undefined ? 12 : options.heightSegments,\n\t\t\t\toptions.phiStart,\n\t\t\t\toptions.phiLength,\n\t\t\t\toptions.thetaStart,\n\t\t\t\toptions.thetaLength\n\t\t\t);\n\t\t\tmesh = new THREE.Mesh(geometry, materials.standard());\n\t\t\tmesh.name = 'sphere';\n\t\n\t\t\tparent.add(mesh);\n\t\n\t\t\treturn mesh;\n\t\t};\n\t}());\n\n/***/ },\n/* 30 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = (function () {\n\t\t'use strict';\n\t\n\t\tvar THREE = __webpack_require__(33),\n\t\t\tfontSizeRegex = /(\\d+)px/i,\n\t\t\tnewLineRegex = /[\\n\\r]/,\n\t\t\tspaceRegex = /[\\t ]/,\n\t\t\tlog2 = Math.log(2),\n\t\t\tgeometry = new THREE.PlaneBufferGeometry(1, 1);\n\t\n\t\treturn function text(parent, options) {\n\t\t\tvar self = this,\n\t\t\t\tmaterial,\n\t\t\t\tcanvas,\n\t\t\t\tctx,\n\t\t\t\tmesh,\n\t\t\t\tcontainer,\n\t\t\t\tsrc,\n\t\t\t\ttextWidth = 0,\n\t\t\t\ttextHeight = 0,\n\t\t\t\tprops = {\n\t\t\t\t\ttext: '',\n\t\t\t\t\tfont: '80px sans-serif',\n\t\t\t\t\ttextAlign: 'center',\n\t\t\t\t\ttextBaseline: '',\n\t\t\t\t\tdirection: '',\n\t\t\t\t\tfillStyle: 'white',\n\t\t\t\t\tresolution: 256, //pixels per meter\n\t\t\t\t\twrap: 5 //in meters\n\t\t\t\t},\n\t\t\t\ttex;\n\t\n\t\t\tfunction nextPowerOfTwo(n) {\n\t\t\t\treturn Math.pow(2, Math.ceil(Math.log(n) / log2));\n\t\t\t}\n\t\n\t\t\tfunction Line(word) {\n\t\t\t\tthis.spaceWidth = ctx.measureText(' ').width;\n\t\t\t\tthis.totalWidth = 0;\n\t\t\t\tthis.wordsWidth = 0;\n\t\t\t\tthis.words = [];\n\t\t\t\tthis.wrap = false;\n\t\t\t\tif (word) {\n\t\t\t\t\tthis.add(word);\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tLine.prototype.text = function () {\n\t\t\t\treturn this.words.join(' ');\n\t\t\t};\n\t\n\t\t\tLine.prototype.add = function(word) {\n\t\t\t\tvar wordWidth;\n\t\t\t\tif (this.words.length) {\n\t\t\t\t\tthis.totalWidth += this.spaceWidth;\n\t\t\t\t}\n\t\t\t\tthis.words.push(word);\n\t\t\t\twordWidth = Line.measure(word);\n\t\t\t\tthis.totalWidth += wordWidth;\n\t\t\t\tthis.wordsWidth += wordWidth;\n\t\t\t};\n\t\n\t\t\tLine.prototype.measure = function(word) {\n\t\t\t\tvar width = this.totalWidth;\n\t\t\t\tif (word) {\n\t\t\t\t\twidth += Line.measure(word);\n\t\t\t\t\tif (this.words.length) {\n\t\t\t\t\t\twidth += this.spaceWidth;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn width;\n\t\t\t};\n\t\n\t\t\tLine.measure = function(word) {\n\t\t\t\treturn ctx.measureText(word).width;\n\t\t\t};\n\t\n\t\t\tfunction update() {\n\t\t\t\t//text stuffs\n\t\t\t\tvar text,\n\t\t\t\t\tword = '',\n\t\t\t\t\tletter,\n\t\t\t\t\tisSpace,\n\t\t\t\t\tline,\n\t\t\t\t\tlines = [],\n\t\t\t\t\tparse,\n\t\n\t\t\t\t\t//layout\n\t\t\t\t\tdirection = getComputedStyle(document.body).direction,\n\t\t\t\t\tinherit,\n\t\t\t\t\tresolution = parseFloat(props.resolution) || 256,\n\t\t\t\t\twrap,\n\t\t\t\t\twrapped = false,\n\t\t\t\t\tfontSize,\n\t\t\t\t\tpadding,\n\t\n\t\t\t\t\t//measurements\n\t\t\t\t\tlineHeight,\n\t\t\t\t\ti, start, y, measure,\n\t\t\t\t\twidth,\n\t\t\t\t\theight = 0;\n\t\n\t\t\t\twrap = parseFloat(props.wrap);\n\t\t\t\tif (isNaN(wrap) || wrap < 0) {\n\t\t\t\t\twrap = 5;\n\t\t\t\t}\n\t\t\t\twidth = resolution * wrap;\n\t\n\t\t\t\tctx.font = props.font;\n\t\t\t\tparse = fontSizeRegex.exec(ctx.font);\n\t\t\t\tfontSize = parseFloat(parse && parse[1]) || 50;\n\t\n\t\t\t\tlineHeight = fontSize * 1.5;\n\t\n\t\t\t\tline = new Line();\n\t\n\t\t\t\ttext = props.text === 0 ? '0' : String(props.text || '');\n\t\t\t\tif (wrap) {\n\t\t\t\t\ttext = text.trim() + ' ';\n\t\t\t\t\tfor (i = 0; i < text.length; i++) {\n\t\t\t\t\t\tletter = text.charAt(i);\n\t\t\t\t\t\tif (newLineRegex.test(letter)) {\n\t\t\t\t\t\t\tline.add(word);\n\t\t\t\t\t\t\tlines.push(line);\n\t\t\t\t\t\t\tword = '';\n\t\t\t\t\t\t\tline = new Line();\n\t\t\t\t\t\t} else if (spaceRegex.test(letter)) {\n\t\t\t\t\t\t\tmeasure = line.measure(word);\n\t\t\t\t\t\t\tif (measure < width) {\n\t\t\t\t\t\t\t\tif (line) {\n\t\t\t\t\t\t\t\t\tline.add(word);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tline = new Line(word);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if (!line && Line.measure(word) >= width) {\n\t\t\t\t\t\t\t\t//one very long word\n\t\t\t\t\t\t\t\tlines.push(new Line(word));\n\t\t\t\t\t\t\t\tword = '';\n\t\t\t\t\t\t\t\tline = new Line();\n\t\t\t\t\t\t\t\twrapped = true;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tline.wrap = true;\n\t\t\t\t\t\t\t\tlines.push(line);\n\t\t\t\t\t\t\t\tline = new Line(word);\n\t\t\t\t\t\t\t\twrapped = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tword = '';\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tword += letter;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (line) {\n\t\t\t\t\t\tlines.push(line);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlines.push(new Line(text));\n\t\t\t\t}\n\t\n\t\t\t\tif (!width || !wrapped) {\n\t\t\t\t\twidth = lines.reduce(function (previous, line) {\n\t\t\t\t\t\treturn Math.max(previous, line.totalWidth);\n\t\t\t\t\t}, 0);\n\t\t\t\t}\n\t\t\t\twidth = Math.min(width, 2048);\n\t\n\t\t\t\theight = lines.length * lineHeight;\n\t\n\t\t\t\tif (options && options.mipmap === false) {\n\t\t\t\t\tcanvas.width = width;\n\t\t\t\t\tcanvas.height = height;\n\t\t\t\t} else {\n\t\t\t\t\tcanvas.width = nextPowerOfTwo(width);\n\t\t\t\t\tcanvas.height = nextPowerOfTwo(height);\n\t\t\t\t}\n\t\n\t\t\t\tmesh.scale.set(canvas.width / resolution, canvas.height / resolution, 1);\n\t\n\t\t\t\t//debug\n\t\t\t\t// ctx.fillStyle = 'rgba(100, 100, 100, 0.5)';\n\t\t\t\t// ctx.fillRect(0, 0, canvas.width, canvas.height);\n\t\t\t\t// document.body.appendChild(canvas);\n\t\t\t\t// canvas.style.cssText = 'position: absolute; width: auto !important; height: auto !important; max-width: 80%';\n\t\n\t\t\t\t/*\n\t\t\t\tset all these properties again because they get reset\n\t\t\t\twhen you resize the canvas\n\t\t\t\t*/\n\t\t\t\tctx.font = props.font;\n\t\t\t\tctx.textAlign = props.textAlign;\n\t\t\t\tctx.textBaseline = props.textBaseline;\n\t\t\t\tctx.direction = props.direction;\n\t\t\t\tctx.fillStyle = props.fillStyle;\n\t\t\t\t//todo: add maxWidth?\n\t\n\t\t\t\tpadding = (canvas.width - width) / 2;\n\t\t\t\ty = (canvas.height - height) / 2 + lineHeight / 2;\n\t\n\t\t\t\tinherit = (ctx.direction === '' || ctx.direction === 'inherit');\n\t\t\t\tif (ctx.textAlign === 'center') {\n\t\t\t\t\tstart = canvas.width / 2;\n\t\t\t\t} else if (ctx.textAlign === 'right' ||\n\t\t\t\t\tctx.textAlign === 'end' && (ctx.direction === 'ltr' || inherit && direction === 'ltr') ||\n\t\t\t\t\tctx.textAlign === 'start' && (ctx.direction === 'rtl' || inherit && direction === 'rtl')) {\n\t\n\t\t\t\t\tstart = canvas.width - padding;\n\t\t\t\t} else {\n\t\t\t\t\tstart = padding;\n\t\t\t\t}\n\t\n\t\t\t\tlines.forEach(function (line) {\n\t\t\t\t\tvar x,\n\t\t\t\t\t\tspace;\n\t\t\t\t\tif (props.textAlign === 'justify' && line.wrap && line.words.length > 1) {\n\t\t\t\t\t\tx = start;\n\t\t\t\t\t\tspace = (width - line.wordsWidth) / (line.words.length - 1);\n\t\t\t\t\t\tline.words.forEach(function (word) {\n\t\t\t\t\t\t\tctx.fillText(word, x, y);\n\t\t\t\t\t\t\tx += space + Line.measure(word);\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tctx.fillText(line.text(), start, y);\n\t\t\t\t\t}\n\t\t\t\t\ty += lineHeight;\n\t\t\t\t});\n\t\n\t\t\t\ttextWidth = width / resolution;\n\t\t\t\ttextHeight = lines.length * lineHeight / resolution;\n\t\n\t\t\t\ttex.needsUpdate = true;\n\t\n\t\t\t\tmesh.name = text.trim();\n\t\t\t}\n\t\n\t\t\tcanvas = document.createElement('canvas');\n\t\t\tctx = canvas.getContext('2d');\n\t\t\ttex = new THREE.Texture(canvas);\n\t\n\t\t\tif (canvas.width === nextPowerOfTwo(canvas.width) &&\n\t\t\t\tcanvas.height === nextPowerOfTwo(canvas.height)) {\n\t\n\t\t\t\ttex.minFilter = THREE.LinearMipMapLinearFilter;\n\t\t\t\ttex.generateMipmaps = true;\n\t\t\t}\n\t\n\t\t\tmaterial = new THREE.MeshBasicMaterial({\n\t\t\t\tside: THREE.DoubleSide,\n\t\t\t\ttransparent: true,\n\t\t\t\tmap: tex\n\t\t\t});\n\t\n\t\t\tmesh = new THREE.Mesh(geometry, material);\n\t\n\t\t\tcontainer = new THREE.Object3D();\n\t\t\tcontainer.name = 'text';\n\t\t\tcontainer.add(mesh);\n\t\t\tparent.add(container);\n\t\n\t\t\tif (typeof options === 'string') {\n\t\t\t\tprops.text = options;\n\t\t\t} else if (options) {\n\t\t\t\tObject.keys(props).forEach(function (key) {\n\t\t\t\t\tprops[key] = options[key] || props[key];\n\t\t\t\t});\n\t\t\t}\n\t\t\tupdate();\n\t\n\t\t\tObject.keys(props).forEach(function (key) {\n\t\t\t\tObject.defineProperty(self, key, {\n\t\t\t\t\tget: function () {\n\t\t\t\t\t\treturn props[key];\n\t\t\t\t\t},\n\t\t\t\t\tset: function (val) {\n\t\t\t\t\t\tprops[key] = val;\n\t\t\t\t\t\tupdate();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\n\t\t\tObject.defineProperty(self, 'width', {\n\t\t\t\tget: function () {\n\t\t\t\t\treturn textWidth;\n\t\t\t\t}\n\t\t\t});\n\t\n\t\t\tObject.defineProperty(self, 'height', {\n\t\t\t\tget: function () {\n\t\t\t\t\treturn textHeight;\n\t\t\t\t}\n\t\t\t});\n\t\n\t\t\tthis.material = material;\n\t\n\t\t\treturn container;\n\t\t};\n\t}());\n\n/***/ },\n/* 31 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = (function () {\n\t\t'use strict';\n\t\n\t\tvar materials = __webpack_require__(10),\n\t\t\tTHREE = __webpack_require__(33);\n\t\n\t\treturn function torus(parent, options) {\n\t\t\tvar geometry,\n\t\t\t\tmesh;\n\t\n\t\t\tgeometry = new THREE.TorusGeometry(\n\t\t\t\toptions.radius === undefined ? 0.5 : options.radius,\n\t\t\t\toptions.tube === undefined ? 0.125 : options.tube,\n\t\t\t\toptions.radialSegments === undefined ? 12 : options.radialSegments,\n\t\t\t\toptions.tubularSegments === undefined ? 16 : options.tubularSegments,\n\t\t\t\toptions.arc\n\t\t\t);\n\t\t\tmesh = new THREE.Mesh(geometry, materials.standard());\n\t\t\tmesh.name = 'torus';\n\t\n\t\t\tparent.add(mesh);\n\t\n\t\t\treturn mesh;\n\t\t};\n\t}());\n\n/***/ },\n/* 32 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = (function () {\n\t\t'use strict';\n\t\n\t\tvar THREE = __webpack_require__(33),\n\t\t\turlRegex = __webpack_require__(35),\n\t\t\textRegex = /\\.(webm|ogg|ogv|m4v|mp4|mov)/i,\n\t\t\tvideo;\n\t\n\t\tvideo = function (parent, options) {\n\t\t\tvar geometry,\n\t\t\t\tmaterial,\n\t\t\t\tmesh,\n\t\t\t\tvid,\n\t\t\t\ttex,\n\t\t\t\taspectRatio = 1,\n\t\t\t\tplaying = false,\n\t\t\t\tself = this;\n\t\n\t\t\tfunction isPowerOfTwo(num) {\n\t\t\t\treturn num > 0 && (num & (num-1)) === 0; // jshint ignore:line\n\t\t\t}\n\t\n\t\t\tfunction loadedMetadata() {\n\t\t\t\t//todo: don't do any of this if object has been deleted\n\t\n\t\t\t\tvar newAspectRatio = vid.videoWidth / vid.videoHeight;\n\t\t\t\tif (!options || !options.sphere) {\n\t\t\t\t\tgeometry.applyMatrix(new THREE.Matrix4().makeScale(1, aspectRatio / newAspectRatio, 1));\n\t\t\t\t}\n\t\t\t\taspectRatio = newAspectRatio;\n\t\n\t\t\t\tif (vid.videoWidth === vid.videoHeight &&\n\t\t\t\t\t\tisPowerOfTwo(vid.videoWidth) && isPowerOfTwo(vid.videoHeight)) {\n\t\n\t\t\t\t\ttex.minFilter = THREE.LinearMipMapLinearFilter;\n\t\t\t\t\ttex.generateMipmaps = true;\n\t\t\t\t} else {\n\t\t\t\t\ttex.minFilter = THREE.LinearFilter;\n\t\t\t\t\ttex.generateMipmaps = false;\n\t\t\t\t}\n\t\n\t\t\t\tmaterial.map = tex;\n\t\t\t\tmaterial.visible = true;\n\t\n\t\t\t\tif (playing) {\n\t\t\t\t\tvid.play();\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tfunction setSource(sources) {\n\t\t\t\tsources.forEach(function (src) {\n\t\t\t\t\tvar parse,\n\t\t\t\t\t\text,\n\t\t\t\t\t\tsource;\n\t\n\t\t\t\t\tif (!src) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tparse = urlRegex.exec(src);\n\t\t\t\t\tif (parse &&\n\t\t\t\t\t\t\t(parse[1] && parse[1] !== window.location.hostÎ© ||\n\t\t\t\t\t\t\t\tparse[2] && parse[2] !== window.location.port)) {\n\t\n\t\t\t\t\t\tif (vid.crossOrigin !== undefined) {\n\t\t\t\t\t\t\tvid.crossOrigin = 'anonymous';\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconsole.warn('Browser does not support cross-origin video');\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tsource = document.createElement('source');\n\t\t\t\t\tsource.src = src;\n\t\n\t\t\t\t\text = extRegex.exec(src);\n\t\t\t\t\tif (!ext || vid.canPlayType('video/' + ext[1])) {\n\t\t\t\t\t\tvid.appendChild(source);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\n\t\t\t/*\n\t\t\tPause the video when this browser tab is in the background or minimized.\n\t\t\tResume when it comes back in focus, but only if the user didn't pause manually.\n\t\t\t*/\n\t\t\tfunction visibilityChange() {\n\t\t\t\tif (document.hidden || document.mozHidden || document.msHidden || document.webkitHidden) {\n\t\t\t\t\tvid.pause();\n\t\t\t\t} else if (playing) {\n\t\t\t\t\tvid.play();\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tvid = document.createElement('video');\n\t\t\tvid.loop = true;\n\t\t\tvid.addEventListener('loadedmetadata', loadedMetadata, false);\n\t\n\t\t\tif (Array.isArray(options)) {\n\t\t\t\tsetSource(options);\n\t\t\t} if (typeof options === 'string') {\n\t\t\t\tsetSource([options]);\n\t\t\t} else if (typeof options.src === 'string') {\n\t\t\t\tsetSource([options.src]);\n\t\t\t} else if (Array.isArray(options.src)) {\n\t\t\t\tsetSource(options.src);\n\t\t\t}\n\t\n\t\t\tvid.load();\n\t\n\t\t\ttex = new THREE.VideoTexture(vid, THREE.UVMapping);\n\t\t\ttex.format = THREE.RGBFormat;\n\t\n\t\t\tif (options && options.sphere) {\n\t\t\t\tgeometry = new THREE.SphereGeometry(\n\t\t\t\t\t994, //radius\n\t\t\t\t\t60, //widthSegments\n\t\t\t\t\t60, //heightSegments\n\t\t\t\t\t(parseFloat(options.phiStart) || 0) * Math.PI * 2,\n\t\t\t\t\t(parseFloat(options.phiLength) || 1) * Math.PI * 2,\n\t\t\t\t\t(parseFloat(options.thetaStart) || 0) * Math.PI,\n\t\t\t\t\t(parseFloat(options.thetaLength) || 1) * Math.PI\n\t\t\t\t);\n\t\t\t\tgeometry.applyMatrix(new THREE.Matrix4().makeScale(-1, 1, 1));\n\t\t\t\tgeometry.applyMatrix(new THREE.Matrix4().makeRotationY(- Math.PI / 2));\n\t\t\t} else {\n\t\t\t\tgeometry = new THREE.PlaneBufferGeometry(1, 1, 8);\n\t\t\t}\n\t\n\t\t\tmaterial = new THREE.MeshBasicMaterial({\n\t\t\t\tside: THREE.DoubleSide,\n\t\t\t\tmap: tex,\n\t\t\t\tvisible: false\n\t\t\t});\n\t\n\t\t\tmesh = new THREE.Mesh(geometry, material);\n\t\n\t\t\tif (options && options.stereo) {\n\t\t\t\tif (options.stereo === 'vertical') {\n\t\t\t\t\ttex.repeat.y = 0.5;\n\t\t\t\t} else {\n\t\t\t\t\ttex.repeat.x = 0.5;\n\t\t\t\t}\n\t\t\t\tmesh.userData.stereo = options.stereo;\n\t\t\t}\n\t\n\t\t\tif (vid.readyState) {\n\t\t\t\tloadedMetadata();\n\t\t\t}\n\t\n\t\t\tthis.play = function play() {\n\t\t\t\tplaying = true;\n\t\t\t\tvid.play();\n\t\t\t\treturn this;\n\t\t\t};\n\t\n\t\t\tthis.pause = function pause() {\n\t\t\t\tplaying = false;\n\t\t\t\tvid.pause();\n\t\t\t\treturn this;\n\t\t\t};\n\t\n\t\t\tthis.canPlayType = video.canPlayType;\n\t\n\t\t\tObject.defineProperty(this, 'width', {\n\t\t\t\tget: function () {\n\t\t\t\t\treturn vid.videoWidth;\n\t\t\t\t}\n\t\t\t});\n\t\n\t\t\tObject.defineProperty(this, 'height', {\n\t\t\t\tget: function () {\n\t\t\t\t\treturn vid.videoHeight;\n\t\t\t\t}\n\t\t\t});\n\t\n\t\t\tObject.defineProperty(this, 'paused', {\n\t\t\t\tget: function () {\n\t\t\t\t\treturn !playing;\n\t\t\t\t}\n\t\t\t});\n\t\n\t\t\tObject.defineProperty(this, 'volume', {\n\t\t\t\tget: function () {\n\t\t\t\t\treturn vid.volume;\n\t\t\t\t},\n\t\t\t\tset: function (vol) {\n\t\t\t\t\tvid.volume = vol;\n\t\t\t\t}\n\t\t\t});\n\t\n\t\t\tObject.defineProperty(this, 'muted', {\n\t\t\t\tget: function () {\n\t\t\t\t\treturn vid.muted;\n\t\t\t\t},\n\t\t\t\tset: function (muted) {\n\t\t\t\t\tvid.muted = muted;\n\t\t\t\t}\n\t\t\t});\n\t\n\t\t\tObject.defineProperty(this, 'duration', {\n\t\t\t\tget: function () {\n\t\t\t\t\treturn vid.duration || 0;\n\t\t\t\t}\n\t\t\t});\n\t\n\t\t\tObject.defineProperty(this, 'currentTime', {\n\t\t\t\tget: function () {\n\t\t\t\t\treturn vid.currentTime;\n\t\t\t\t},\n\t\t\t\tset: function (currentTime) {\n\t\t\t\t\tif (vid.readyState && currentTime < vid.duration && currentTime >= 0) {\n\t\t\t\t\t\tvid.currentTime = currentTime;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\n\t\t\t[\n\t\t\t\t'loadedmetadata',\n\t\t\t\t'play',\n\t\t\t\t'pause',\n\t\t\t\t'playing',\n\t\t\t\t'progress'\n\t\t\t].forEach(function registerMediaEvent(event) {\n\t\t\t\tvid.addEventListener(event, self.emit.bind(self, event));\n\t\t\t});\n\t\n\t\t\t//sometimes video fails to play because it's too big. remove it and try again\n\t\t\tvid.addEventListener('error', function (evt) {\n\t\t\t\tif (vid.error.code === window.MediaError.MEDIA_ERR_DECODE && vid.childNodes.length > 1) {\n\t\t\t\t\tmaterial.visible = false;\n\t\t\t\t\tvid.removeChild(vid.firstChild);\n\t\t\t\t\tvid.load();\n\t\t\t\t}\n\t\n\t\t\t\tself.emit(event, evt);\n\t\t\t}, true);\n\t\n\t\t\tthis.element = vid;\n\t\n\t\t\twindow.addEventListener('touchstart', function touchStart() {\n\t\t\t\tif (playing) {\n\t\t\t\t\tvid.play();\n\t\t\t\t} else {\n\t\t\t\t\tvid.load();\n\t\t\t\t}\n\t\t\t\twindow.removeEventListener('touchstart', touchStart, true);\n\t\t\t}, true);\n\t\n\t\t\t//pause when window is hidden\n\t\t\tdocument.addEventListener('visibilitychange', visibilityChange);\n\t\t\tdocument.addEventListener('mozvisibilitychange', visibilityChange);\n\t\t\tdocument.addEventListener('msvisibilitychange', visibilityChange);\n\t\t\tdocument.addEventListener('webkitvisibilitychange', visibilityChange);\n\t\n\t\t\tmesh.name = 'video';\n\t\t\tparent.add(mesh);\n\t\n\t\t\treturn mesh;\n\t\t};\n\t\n\t\tvideo.canPlayType = function canPlayType(type) {\n\t\t\tvar element = document.createElement('video');\n\t\t\treturn element.canPlayType(type);\n\t\t};\n\t\n\t\treturn video;\n\t}());\n\n/***/ },\n/* 33 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar self = self || {};// File:src/Three.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tvar THREE = { REVISION: '71' };\r\n\t\r\n\t// browserify support\r\n\t\r\n\tif ( true ) {\r\n\t\r\n\t\tmodule.exports = THREE;\r\n\t\r\n\t}\r\n\t\r\n\t// polyfills\r\n\t\r\n\tif ( Math.sign === undefined ) {\r\n\t\r\n\t\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign\r\n\t\r\n\t\tMath.sign = function ( x ) {\r\n\t\r\n\t\t\treturn ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : +x;\r\n\t\r\n\t\t};\r\n\t\r\n\t}\r\n\t\r\n\t\r\n\t// set the default log handlers\r\n\tTHREE.log = function() { console.log.apply( console, arguments ); }\r\n\tTHREE.warn = function() { console.warn.apply( console, arguments ); }\r\n\tTHREE.error = function() { console.error.apply( console, arguments ); }\r\n\t\r\n\t\r\n\t// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent.button\r\n\t\r\n\tTHREE.MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };\r\n\t\r\n\t// GL STATE CONSTANTS\r\n\t\r\n\tTHREE.CullFaceNone = 0;\r\n\tTHREE.CullFaceBack = 1;\r\n\tTHREE.CullFaceFront = 2;\r\n\tTHREE.CullFaceFrontBack = 3;\r\n\t\r\n\tTHREE.FrontFaceDirectionCW = 0;\r\n\tTHREE.FrontFaceDirectionCCW = 1;\r\n\t\r\n\t// SHADOWING TYPES\r\n\t\r\n\tTHREE.BasicShadowMap = 0;\r\n\tTHREE.PCFShadowMap = 1;\r\n\tTHREE.PCFSoftShadowMap = 2;\r\n\t\r\n\t// MATERIAL CONSTANTS\r\n\t\r\n\t// side\r\n\t\r\n\tTHREE.FrontSide = 0;\r\n\tTHREE.BackSide = 1;\r\n\tTHREE.DoubleSide = 2;\r\n\t\r\n\t// shading\r\n\t\r\n\tTHREE.NoShading = 0;\r\n\tTHREE.FlatShading = 1;\r\n\tTHREE.SmoothShading = 2;\r\n\t\r\n\t// colors\r\n\t\r\n\tTHREE.NoColors = 0;\r\n\tTHREE.FaceColors = 1;\r\n\tTHREE.VertexColors = 2;\r\n\t\r\n\t// blending modes\r\n\t\r\n\tTHREE.NoBlending = 0;\r\n\tTHREE.NormalBlending = 1;\r\n\tTHREE.AdditiveBlending = 2;\r\n\tTHREE.SubtractiveBlending = 3;\r\n\tTHREE.MultiplyBlending = 4;\r\n\tTHREE.CustomBlending = 5;\r\n\t\r\n\t// custom blending equations\r\n\t// (numbers start from 100 not to clash with other\r\n\t//  mappings to OpenGL constants defined in Texture.js)\r\n\t\r\n\tTHREE.AddEquation = 100;\r\n\tTHREE.SubtractEquation = 101;\r\n\tTHREE.ReverseSubtractEquation = 102;\r\n\tTHREE.MinEquation = 103;\r\n\tTHREE.MaxEquation = 104;\r\n\t\r\n\t// custom blending destination factors\r\n\t\r\n\tTHREE.ZeroFactor = 200;\r\n\tTHREE.OneFactor = 201;\r\n\tTHREE.SrcColorFactor = 202;\r\n\tTHREE.OneMinusSrcColorFactor = 203;\r\n\tTHREE.SrcAlphaFactor = 204;\r\n\tTHREE.OneMinusSrcAlphaFactor = 205;\r\n\tTHREE.DstAlphaFactor = 206;\r\n\tTHREE.OneMinusDstAlphaFactor = 207;\r\n\t\r\n\t// custom blending source factors\r\n\t\r\n\t//THREE.ZeroFactor = 200;\r\n\t//THREE.OneFactor = 201;\r\n\t//THREE.SrcAlphaFactor = 204;\r\n\t//THREE.OneMinusSrcAlphaFactor = 205;\r\n\t//THREE.DstAlphaFactor = 206;\r\n\t//THREE.OneMinusDstAlphaFactor = 207;\r\n\tTHREE.DstColorFactor = 208;\r\n\tTHREE.OneMinusDstColorFactor = 209;\r\n\tTHREE.SrcAlphaSaturateFactor = 210;\r\n\t\r\n\t\r\n\t// TEXTURE CONSTANTS\r\n\t\r\n\tTHREE.MultiplyOperation = 0;\r\n\tTHREE.MixOperation = 1;\r\n\tTHREE.AddOperation = 2;\r\n\t\r\n\t// Mapping modes\r\n\t\r\n\tTHREE.UVMapping = 300;\r\n\t\r\n\tTHREE.CubeReflectionMapping = 301;\r\n\tTHREE.CubeRefractionMapping = 302;\r\n\t\r\n\tTHREE.EquirectangularReflectionMapping = 303;\r\n\tTHREE.EquirectangularRefractionMapping = 304;\r\n\t\r\n\tTHREE.SphericalReflectionMapping = 305;\r\n\t\r\n\t// Wrapping modes\r\n\t\r\n\tTHREE.RepeatWrapping = 1000;\r\n\tTHREE.ClampToEdgeWrapping = 1001;\r\n\tTHREE.MirroredRepeatWrapping = 1002;\r\n\t\r\n\t// Filters\r\n\t\r\n\tTHREE.NearestFilter = 1003;\r\n\tTHREE.NearestMipMapNearestFilter = 1004;\r\n\tTHREE.NearestMipMapLinearFilter = 1005;\r\n\tTHREE.LinearFilter = 1006;\r\n\tTHREE.LinearMipMapNearestFilter = 1007;\r\n\tTHREE.LinearMipMapLinearFilter = 1008;\r\n\t\r\n\t// Data types\r\n\t\r\n\tTHREE.UnsignedByteType = 1009;\r\n\tTHREE.ByteType = 1010;\r\n\tTHREE.ShortType = 1011;\r\n\tTHREE.UnsignedShortType = 1012;\r\n\tTHREE.IntType = 1013;\r\n\tTHREE.UnsignedIntType = 1014;\r\n\tTHREE.FloatType = 1015;\r\n\tTHREE.HalfFloatType = 1025;\r\n\t\r\n\t// Pixel types\r\n\t\r\n\t//THREE.UnsignedByteType = 1009;\r\n\tTHREE.UnsignedShort4444Type = 1016;\r\n\tTHREE.UnsignedShort5551Type = 1017;\r\n\tTHREE.UnsignedShort565Type = 1018;\r\n\t\r\n\t// Pixel formats\r\n\t\r\n\tTHREE.AlphaFormat = 1019;\r\n\tTHREE.RGBFormat = 1020;\r\n\tTHREE.RGBAFormat = 1021;\r\n\tTHREE.LuminanceFormat = 1022;\r\n\tTHREE.LuminanceAlphaFormat = 1023;\r\n\t// THREE.RGBEFormat handled as THREE.RGBAFormat in shaders\r\n\tTHREE.RGBEFormat = THREE.RGBAFormat; //1024;\r\n\t\r\n\t// DDS / ST3C Compressed texture formats\r\n\t\r\n\tTHREE.RGB_S3TC_DXT1_Format = 2001;\r\n\tTHREE.RGBA_S3TC_DXT1_Format = 2002;\r\n\tTHREE.RGBA_S3TC_DXT3_Format = 2003;\r\n\tTHREE.RGBA_S3TC_DXT5_Format = 2004;\r\n\t\r\n\t\r\n\t// PVRTC compressed texture formats\r\n\t\r\n\tTHREE.RGB_PVRTC_4BPPV1_Format = 2100;\r\n\tTHREE.RGB_PVRTC_2BPPV1_Format = 2101;\r\n\tTHREE.RGBA_PVRTC_4BPPV1_Format = 2102;\r\n\tTHREE.RGBA_PVRTC_2BPPV1_Format = 2103;\r\n\t\r\n\t\r\n\t// DEPRECATED\r\n\t\r\n\tTHREE.Projector = function () {\r\n\t\r\n\t\tTHREE.error( 'THREE.Projector has been moved to /examples/js/renderers/Projector.js.' );\r\n\t\r\n\t\tthis.projectVector = function ( vector, camera ) {\r\n\t\r\n\t\t\tTHREE.warn( 'THREE.Projector: .projectVector() is now vector.project().' );\r\n\t\t\tvector.project( camera );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.unprojectVector = function ( vector, camera ) {\r\n\t\r\n\t\t\tTHREE.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );\r\n\t\t\tvector.unproject( camera );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.pickingRay = function ( vector, camera ) {\r\n\t\r\n\t\t\tTHREE.error( 'THREE.Projector: .pickingRay() is now raycaster.setFromCamera().' );\r\n\t\r\n\t\t};\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.CanvasRenderer = function () {\r\n\t\r\n\t\tTHREE.error( 'THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js' );\r\n\t\r\n\t\tthis.domElement = document.createElement( 'canvas' );\r\n\t\tthis.clear = function () {};\r\n\t\tthis.render = function () {};\r\n\t\tthis.setClearColor = function () {};\r\n\t\tthis.setSize = function () {};\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/math/Color.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.Color = function ( color ) {\r\n\t\r\n\t\tif ( arguments.length === 3 ) {\r\n\t\r\n\t\t\treturn this.setRGB( arguments[ 0 ], arguments[ 1 ], arguments[ 2 ] );\r\n\t\r\n\t\t}\r\n\t\r\n\t\treturn this.set( color )\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Color.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Color,\r\n\t\r\n\t\tr: 1, g: 1, b: 1,\r\n\t\r\n\t\tset: function ( value ) {\r\n\t\r\n\t\t\tif ( value instanceof THREE.Color ) {\r\n\t\r\n\t\t\t\tthis.copy( value );\r\n\t\r\n\t\t\t} else if ( typeof value === 'number' ) {\r\n\t\r\n\t\t\t\tthis.setHex( value );\r\n\t\r\n\t\t\t} else if ( typeof value === 'string' ) {\r\n\t\r\n\t\t\t\tthis.setStyle( value );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetHex: function ( hex ) {\r\n\t\r\n\t\t\thex = Math.floor( hex );\r\n\t\r\n\t\t\tthis.r = ( hex >> 16 & 255 ) / 255;\r\n\t\t\tthis.g = ( hex >> 8 & 255 ) / 255;\r\n\t\t\tthis.b = ( hex & 255 ) / 255;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetRGB: function ( r, g, b ) {\r\n\t\r\n\t\t\tthis.r = r;\r\n\t\t\tthis.g = g;\r\n\t\t\tthis.b = b;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetHSL: function ( h, s, l ) {\r\n\t\r\n\t\t\t// h,s,l ranges are in 0.0 - 1.0\r\n\t\r\n\t\t\tif ( s === 0 ) {\r\n\t\r\n\t\t\t\tthis.r = this.g = this.b = l;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tvar hue2rgb = function ( p, q, t ) {\r\n\t\r\n\t\t\t\t\tif ( t < 0 ) t += 1;\r\n\t\t\t\t\tif ( t > 1 ) t -= 1;\r\n\t\t\t\t\tif ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;\r\n\t\t\t\t\tif ( t < 1 / 2 ) return q;\r\n\t\t\t\t\tif ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );\r\n\t\t\t\t\treturn p;\r\n\t\r\n\t\t\t\t};\r\n\t\r\n\t\t\t\tvar p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );\r\n\t\t\t\tvar q = ( 2 * l ) - p;\r\n\t\r\n\t\t\t\tthis.r = hue2rgb( q, p, h + 1 / 3 );\r\n\t\t\t\tthis.g = hue2rgb( q, p, h );\r\n\t\t\t\tthis.b = hue2rgb( q, p, h - 1 / 3 );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetStyle: function ( style ) {\r\n\t\r\n\t\t\t// rgb(255,0,0)\r\n\t\r\n\t\t\tif ( /^rgb\\((\\d+), ?(\\d+), ?(\\d+)\\)$/i.test( style ) ) {\r\n\t\r\n\t\t\t\tvar color = /^rgb\\((\\d+), ?(\\d+), ?(\\d+)\\)$/i.exec( style );\r\n\t\r\n\t\t\t\tthis.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;\r\n\t\t\t\tthis.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;\r\n\t\t\t\tthis.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// rgb(100%,0%,0%)\r\n\t\r\n\t\t\tif ( /^rgb\\((\\d+)\\%, ?(\\d+)\\%, ?(\\d+)\\%\\)$/i.test( style ) ) {\r\n\t\r\n\t\t\t\tvar color = /^rgb\\((\\d+)\\%, ?(\\d+)\\%, ?(\\d+)\\%\\)$/i.exec( style );\r\n\t\r\n\t\t\t\tthis.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;\r\n\t\t\t\tthis.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;\r\n\t\t\t\tthis.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// #ff0000\r\n\t\r\n\t\t\tif ( /^\\#([0-9a-f]{6})$/i.test( style ) ) {\r\n\t\r\n\t\t\t\tvar color = /^\\#([0-9a-f]{6})$/i.exec( style );\r\n\t\r\n\t\t\t\tthis.setHex( parseInt( color[ 1 ], 16 ) );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// #f00\r\n\t\r\n\t\t\tif ( /^\\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.test( style ) ) {\r\n\t\r\n\t\t\t\tvar color = /^\\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.exec( style );\r\n\t\r\n\t\t\t\tthis.setHex( parseInt( color[ 1 ] + color[ 1 ] + color[ 2 ] + color[ 2 ] + color[ 3 ] + color[ 3 ], 16 ) );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// red\r\n\t\r\n\t\t\tif ( /^(\\w+)$/i.test( style ) ) {\r\n\t\r\n\t\t\t\tthis.setHex( THREE.ColorKeywords[ style ] );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( color ) {\r\n\t\r\n\t\t\tthis.r = color.r;\r\n\t\t\tthis.g = color.g;\r\n\t\t\tthis.b = color.b;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopyGammaToLinear: function ( color, gammaFactor ) {\r\n\t\r\n\t\t\tif ( gammaFactor === undefined ) gammaFactor = 2.0;\r\n\t\r\n\t\t\tthis.r = Math.pow( color.r, gammaFactor );\r\n\t\t\tthis.g = Math.pow( color.g, gammaFactor );\r\n\t\t\tthis.b = Math.pow( color.b, gammaFactor );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopyLinearToGamma: function ( color, gammaFactor ) {\r\n\t\r\n\t\t\tif ( gammaFactor === undefined ) gammaFactor = 2.0;\r\n\t\r\n\t\t\tvar safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;\r\n\t\r\n\t\t\tthis.r = Math.pow( color.r, safeInverse );\r\n\t\t\tthis.g = Math.pow( color.g, safeInverse );\r\n\t\t\tthis.b = Math.pow( color.b, safeInverse );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tconvertGammaToLinear: function () {\r\n\t\r\n\t\t\tvar r = this.r, g = this.g, b = this.b;\r\n\t\r\n\t\t\tthis.r = r * r;\r\n\t\t\tthis.g = g * g;\r\n\t\t\tthis.b = b * b;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tconvertLinearToGamma: function () {\r\n\t\r\n\t\t\tthis.r = Math.sqrt( this.r );\r\n\t\t\tthis.g = Math.sqrt( this.g );\r\n\t\t\tthis.b = Math.sqrt( this.b );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetHex: function () {\r\n\t\r\n\t\t\treturn ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetHexString: function () {\r\n\t\r\n\t\t\treturn ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetHSL: function ( optionalTarget ) {\r\n\t\r\n\t\t\t// h,s,l ranges are in 0.0 - 1.0\r\n\t\r\n\t\t\tvar hsl = optionalTarget || { h: 0, s: 0, l: 0 };\r\n\t\r\n\t\t\tvar r = this.r, g = this.g, b = this.b;\r\n\t\r\n\t\t\tvar max = Math.max( r, g, b );\r\n\t\t\tvar min = Math.min( r, g, b );\r\n\t\r\n\t\t\tvar hue, saturation;\r\n\t\t\tvar lightness = ( min + max ) / 2.0;\r\n\t\r\n\t\t\tif ( min === max ) {\r\n\t\r\n\t\t\t\thue = 0;\r\n\t\t\t\tsaturation = 0;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tvar delta = max - min;\r\n\t\r\n\t\t\t\tsaturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );\r\n\t\r\n\t\t\t\tswitch ( max ) {\r\n\t\r\n\t\t\t\t\tcase r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;\r\n\t\t\t\t\tcase g: hue = ( b - r ) / delta + 2; break;\r\n\t\t\t\t\tcase b: hue = ( r - g ) / delta + 4; break;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\thue /= 6;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\thsl.h = hue;\r\n\t\t\thsl.s = saturation;\r\n\t\t\thsl.l = lightness;\r\n\t\r\n\t\t\treturn hsl;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetStyle: function () {\r\n\t\r\n\t\t\treturn 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';\r\n\t\r\n\t\t},\r\n\t\r\n\t\toffsetHSL: function ( h, s, l ) {\r\n\t\r\n\t\t\tvar hsl = this.getHSL();\r\n\t\r\n\t\t\thsl.h += h; hsl.s += s; hsl.l += l;\r\n\t\r\n\t\t\tthis.setHSL( hsl.h, hsl.s, hsl.l );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tadd: function ( color ) {\r\n\t\r\n\t\t\tthis.r += color.r;\r\n\t\t\tthis.g += color.g;\r\n\t\t\tthis.b += color.b;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\taddColors: function ( color1, color2 ) {\r\n\t\r\n\t\t\tthis.r = color1.r + color2.r;\r\n\t\t\tthis.g = color1.g + color2.g;\r\n\t\t\tthis.b = color1.b + color2.b;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\taddScalar: function ( s ) {\r\n\t\r\n\t\t\tthis.r += s;\r\n\t\t\tthis.g += s;\r\n\t\t\tthis.b += s;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmultiply: function ( color ) {\r\n\t\r\n\t\t\tthis.r *= color.r;\r\n\t\t\tthis.g *= color.g;\r\n\t\t\tthis.b *= color.b;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmultiplyScalar: function ( s ) {\r\n\t\r\n\t\t\tthis.r *= s;\r\n\t\t\tthis.g *= s;\r\n\t\t\tthis.b *= s;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlerp: function ( color, alpha ) {\r\n\t\r\n\t\t\tthis.r += ( color.r - this.r ) * alpha;\r\n\t\t\tthis.g += ( color.g - this.g ) * alpha;\r\n\t\t\tthis.b += ( color.b - this.b ) * alpha;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tequals: function ( c ) {\r\n\t\r\n\t\t\treturn ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfromArray: function ( array ) {\r\n\t\r\n\t\t\tthis.r = array[ 0 ];\r\n\t\t\tthis.g = array[ 1 ];\r\n\t\t\tthis.b = array[ 2 ];\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttoArray: function ( array, offset ) {\r\n\t\r\n\t\t\tif ( array === undefined ) array = [];\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\r\n\t\t\tarray[ offset ] = this.r;\r\n\t\t\tarray[ offset + 1 ] = this.g;\r\n\t\t\tarray[ offset + 2 ] = this.b;\r\n\t\r\n\t\t\treturn array;\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new THREE.Color().setRGB( this.r, this.g, this.b );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,\r\n\t'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,\r\n\t'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,\r\n\t'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,\r\n\t'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,\r\n\t'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,\r\n\t'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,\r\n\t'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,\r\n\t'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,\r\n\t'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,\r\n\t'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,\r\n\t'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,\r\n\t'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,\r\n\t'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,\r\n\t'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,\r\n\t'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,\r\n\t'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,\r\n\t'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,\r\n\t'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,\r\n\t'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,\r\n\t'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,\r\n\t'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,\r\n\t'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,\r\n\t'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };\r\n\t\r\n\t// File:src/math/Quaternion.js\r\n\t\r\n\t/**\r\n\t * @author mikael emtinger / http://gomo.se/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t * @author bhouston / http://exocortex.com\r\n\t */\r\n\t\r\n\tTHREE.Quaternion = function ( x, y, z, w ) {\r\n\t\r\n\t\tthis._x = x || 0;\r\n\t\tthis._y = y || 0;\r\n\t\tthis._z = z || 0;\r\n\t\tthis._w = ( w !== undefined ) ? w : 1;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Quaternion.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Quaternion,\r\n\t\r\n\t\t_x: 0,_y: 0, _z: 0, _w: 0,\r\n\t\r\n\t\tget x () {\r\n\t\r\n\t\t\treturn this._x;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tset x ( value ) {\r\n\t\r\n\t\t\tthis._x = value;\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t},\r\n\t\r\n\t\tget y () {\r\n\t\r\n\t\t\treturn this._y;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tset y ( value ) {\r\n\t\r\n\t\t\tthis._y = value;\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t},\r\n\t\r\n\t\tget z () {\r\n\t\r\n\t\t\treturn this._z;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tset z ( value ) {\r\n\t\r\n\t\t\tthis._z = value;\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t},\r\n\t\r\n\t\tget w () {\r\n\t\r\n\t\t\treturn this._w;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tset w ( value ) {\r\n\t\r\n\t\t\tthis._w = value;\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t},\r\n\t\r\n\t\tset: function ( x, y, z, w ) {\r\n\t\r\n\t\t\tthis._x = x;\r\n\t\t\tthis._y = y;\r\n\t\t\tthis._z = z;\r\n\t\t\tthis._w = w;\r\n\t\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( quaternion ) {\r\n\t\r\n\t\t\tthis._x = quaternion.x;\r\n\t\t\tthis._y = quaternion.y;\r\n\t\t\tthis._z = quaternion.z;\r\n\t\t\tthis._w = quaternion.w;\r\n\t\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromEuler: function ( euler, update ) {\r\n\t\r\n\t\t\tif ( euler instanceof THREE.Euler === false ) {\r\n\t\r\n\t\t\t\tthrow new Error( 'THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );\r\n\t\t\t}\r\n\t\r\n\t\t\t// http://www.mathworks.com/matlabcentral/fileexchange/\r\n\t\t\t// \t20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\r\n\t\t\t//\tcontent/SpinCalc.m\r\n\t\r\n\t\t\tvar c1 = Math.cos( euler._x / 2 );\r\n\t\t\tvar c2 = Math.cos( euler._y / 2 );\r\n\t\t\tvar c3 = Math.cos( euler._z / 2 );\r\n\t\t\tvar s1 = Math.sin( euler._x / 2 );\r\n\t\t\tvar s2 = Math.sin( euler._y / 2 );\r\n\t\t\tvar s3 = Math.sin( euler._z / 2 );\r\n\t\r\n\t\t\tif ( euler.order === 'XYZ' ) {\r\n\t\r\n\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\r\n\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\r\n\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\r\n\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\r\n\t\r\n\t\t\t} else if ( euler.order === 'YXZ' ) {\r\n\t\r\n\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\r\n\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\r\n\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\r\n\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\r\n\t\r\n\t\t\t} else if ( euler.order === 'ZXY' ) {\r\n\t\r\n\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\r\n\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\r\n\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\r\n\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\r\n\t\r\n\t\t\t} else if ( euler.order === 'ZYX' ) {\r\n\t\r\n\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\r\n\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\r\n\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\r\n\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\r\n\t\r\n\t\t\t} else if ( euler.order === 'YZX' ) {\r\n\t\r\n\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\r\n\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\r\n\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\r\n\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\r\n\t\r\n\t\t\t} else if ( euler.order === 'XZY' ) {\r\n\t\r\n\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\r\n\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\r\n\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\r\n\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( update !== false ) this.onChangeCallback();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromAxisAngle: function ( axis, angle ) {\r\n\t\r\n\t\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\r\n\t\r\n\t\t\t// assumes axis is normalized\r\n\t\r\n\t\t\tvar halfAngle = angle / 2, s = Math.sin( halfAngle );\r\n\t\r\n\t\t\tthis._x = axis.x * s;\r\n\t\t\tthis._y = axis.y * s;\r\n\t\t\tthis._z = axis.z * s;\r\n\t\t\tthis._w = Math.cos( halfAngle );\r\n\t\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromRotationMatrix: function ( m ) {\r\n\t\r\n\t\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\r\n\t\r\n\t\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\r\n\t\r\n\t\t\tvar te = m.elements,\r\n\t\r\n\t\t\t\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\r\n\t\t\t\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\r\n\t\t\t\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],\r\n\t\r\n\t\t\t\ttrace = m11 + m22 + m33,\r\n\t\t\t\ts;\r\n\t\r\n\t\t\tif ( trace > 0 ) {\r\n\t\r\n\t\t\t\ts = 0.5 / Math.sqrt( trace + 1.0 );\r\n\t\r\n\t\t\t\tthis._w = 0.25 / s;\r\n\t\t\t\tthis._x = ( m32 - m23 ) * s;\r\n\t\t\t\tthis._y = ( m13 - m31 ) * s;\r\n\t\t\t\tthis._z = ( m21 - m12 ) * s;\r\n\t\r\n\t\t\t} else if ( m11 > m22 && m11 > m33 ) {\r\n\t\r\n\t\t\t\ts = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );\r\n\t\r\n\t\t\t\tthis._w = ( m32 - m23 ) / s;\r\n\t\t\t\tthis._x = 0.25 * s;\r\n\t\t\t\tthis._y = ( m12 + m21 ) / s;\r\n\t\t\t\tthis._z = ( m13 + m31 ) / s;\r\n\t\r\n\t\t\t} else if ( m22 > m33 ) {\r\n\t\r\n\t\t\t\ts = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );\r\n\t\r\n\t\t\t\tthis._w = ( m13 - m31 ) / s;\r\n\t\t\t\tthis._x = ( m12 + m21 ) / s;\r\n\t\t\t\tthis._y = 0.25 * s;\r\n\t\t\t\tthis._z = ( m23 + m32 ) / s;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\ts = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );\r\n\t\r\n\t\t\t\tthis._w = ( m21 - m12 ) / s;\r\n\t\t\t\tthis._x = ( m13 + m31 ) / s;\r\n\t\t\t\tthis._y = ( m23 + m32 ) / s;\r\n\t\t\t\tthis._z = 0.25 * s;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromUnitVectors: function () {\r\n\t\r\n\t\t\t// http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final\r\n\t\r\n\t\t\t// assumes direction vectors vFrom and vTo are normalized\r\n\t\r\n\t\t\tvar v1, r;\r\n\t\r\n\t\t\tvar EPS = 0.000001;\r\n\t\r\n\t\t\treturn function ( vFrom, vTo ) {\r\n\t\r\n\t\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\r\n\t\r\n\t\t\t\tr = vFrom.dot( vTo ) + 1;\r\n\t\r\n\t\t\t\tif ( r < EPS ) {\r\n\t\r\n\t\t\t\t\tr = 0;\r\n\t\r\n\t\t\t\t\tif ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {\r\n\t\r\n\t\t\t\t\t\tv1.set( - vFrom.y, vFrom.x, 0 );\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tv1.set( 0, - vFrom.z, vFrom.y );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tv1.crossVectors( vFrom, vTo );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tthis._x = v1.x;\r\n\t\t\t\tthis._y = v1.y;\r\n\t\t\t\tthis._z = v1.z;\r\n\t\t\t\tthis._w = r;\r\n\t\r\n\t\t\t\tthis.normalize();\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tinverse: function () {\r\n\t\r\n\t\t\tthis.conjugate().normalize();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tconjugate: function () {\r\n\t\r\n\t\t\tthis._x *= - 1;\r\n\t\t\tthis._y *= - 1;\r\n\t\t\tthis._z *= - 1;\r\n\t\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdot: function ( v ) {\r\n\t\r\n\t\t\treturn this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlengthSq: function () {\r\n\t\r\n\t\t\treturn this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlength: function () {\r\n\t\r\n\t\t\treturn Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tnormalize: function () {\r\n\t\r\n\t\t\tvar l = this.length();\r\n\t\r\n\t\t\tif ( l === 0 ) {\r\n\t\r\n\t\t\t\tthis._x = 0;\r\n\t\t\t\tthis._y = 0;\r\n\t\t\t\tthis._z = 0;\r\n\t\t\t\tthis._w = 1;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tl = 1 / l;\r\n\t\r\n\t\t\t\tthis._x = this._x * l;\r\n\t\t\t\tthis._y = this._y * l;\r\n\t\t\t\tthis._z = this._z * l;\r\n\t\t\t\tthis._w = this._w * l;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmultiply: function ( q, p ) {\r\n\t\r\n\t\t\tif ( p !== undefined ) {\r\n\t\r\n\t\t\t\tTHREE.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );\r\n\t\t\t\treturn this.multiplyQuaternions( q, p );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this.multiplyQuaternions( this, q );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmultiplyQuaternions: function ( a, b ) {\r\n\t\r\n\t\t\t// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm\r\n\t\r\n\t\t\tvar qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;\r\n\t\t\tvar qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;\r\n\t\r\n\t\t\tthis._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\r\n\t\t\tthis._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\r\n\t\t\tthis._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\r\n\t\t\tthis._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\r\n\t\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmultiplyVector3: function ( vector ) {\r\n\t\r\n\t\t\tTHREE.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );\r\n\t\t\treturn vector.applyQuaternion( this );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tslerp: function ( qb, t ) {\r\n\t\r\n\t\t\tif ( t === 0 ) return this;\r\n\t\t\tif ( t === 1 ) return this.copy( qb );\r\n\t\r\n\t\t\tvar x = this._x, y = this._y, z = this._z, w = this._w;\r\n\t\r\n\t\t\t// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/\r\n\t\r\n\t\t\tvar cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;\r\n\t\r\n\t\t\tif ( cosHalfTheta < 0 ) {\r\n\t\r\n\t\t\t\tthis._w = - qb._w;\r\n\t\t\t\tthis._x = - qb._x;\r\n\t\t\t\tthis._y = - qb._y;\r\n\t\t\t\tthis._z = - qb._z;\r\n\t\r\n\t\t\t\tcosHalfTheta = - cosHalfTheta;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tthis.copy( qb );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( cosHalfTheta >= 1.0 ) {\r\n\t\r\n\t\t\t\tthis._w = w;\r\n\t\t\t\tthis._x = x;\r\n\t\t\t\tthis._y = y;\r\n\t\t\t\tthis._z = z;\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar halfTheta = Math.acos( cosHalfTheta );\r\n\t\t\tvar sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );\r\n\t\r\n\t\t\tif ( Math.abs( sinHalfTheta ) < 0.001 ) {\r\n\t\r\n\t\t\t\tthis._w = 0.5 * ( w + this._w );\r\n\t\t\t\tthis._x = 0.5 * ( x + this._x );\r\n\t\t\t\tthis._y = 0.5 * ( y + this._y );\r\n\t\t\t\tthis._z = 0.5 * ( z + this._z );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,\r\n\t\t\tratioB = Math.sin( t * halfTheta ) / sinHalfTheta;\r\n\t\r\n\t\t\tthis._w = ( w * ratioA + this._w * ratioB );\r\n\t\t\tthis._x = ( x * ratioA + this._x * ratioB );\r\n\t\t\tthis._y = ( y * ratioA + this._y * ratioB );\r\n\t\t\tthis._z = ( z * ratioA + this._z * ratioB );\r\n\t\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tequals: function ( quaternion ) {\r\n\t\r\n\t\t\treturn ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfromArray: function ( array, offset ) {\r\n\t\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\r\n\t\t\tthis._x = array[ offset ];\r\n\t\t\tthis._y = array[ offset + 1 ];\r\n\t\t\tthis._z = array[ offset + 2 ];\r\n\t\t\tthis._w = array[ offset + 3 ];\r\n\t\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttoArray: function ( array, offset ) {\r\n\t\r\n\t\t\tif ( array === undefined ) array = [];\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\r\n\t\t\tarray[ offset ] = this._x;\r\n\t\t\tarray[ offset + 1 ] = this._y;\r\n\t\t\tarray[ offset + 2 ] = this._z;\r\n\t\t\tarray[ offset + 3 ] = this._w;\r\n\t\r\n\t\t\treturn array;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tonChange: function ( callback ) {\r\n\t\r\n\t\t\tthis.onChangeCallback = callback;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tonChangeCallback: function () {},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new THREE.Quaternion( this._x, this._y, this._z, this._w );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Quaternion.slerp = function ( qa, qb, qm, t ) {\r\n\t\r\n\t\treturn qm.copy( qa ).slerp( qb, t );\r\n\t\r\n\t}\r\n\t\r\n\t// File:src/math/Vector2.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author philogb / http://blog.thejit.org/\r\n\t * @author egraether / http://egraether.com/\r\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\r\n\t */\r\n\t\r\n\tTHREE.Vector2 = function ( x, y ) {\r\n\t\r\n\t\tthis.x = x || 0;\r\n\t\tthis.y = y || 0;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Vector2.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Vector2,\r\n\t\r\n\t\tset: function ( x, y ) {\r\n\t\r\n\t\t\tthis.x = x;\r\n\t\t\tthis.y = y;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetX: function ( x ) {\r\n\t\r\n\t\t\tthis.x = x;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetY: function ( y ) {\r\n\t\r\n\t\t\tthis.y = y;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetComponent: function ( index, value ) {\r\n\t\r\n\t\t\tswitch ( index ) {\r\n\t\r\n\t\t\t\tcase 0: this.x = value; break;\r\n\t\t\t\tcase 1: this.y = value; break;\r\n\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetComponent: function ( index ) {\r\n\t\r\n\t\t\tswitch ( index ) {\r\n\t\r\n\t\t\t\tcase 0: return this.x;\r\n\t\t\t\tcase 1: return this.y;\r\n\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( v ) {\r\n\t\r\n\t\t\tthis.x = v.x;\r\n\t\t\tthis.y = v.y;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tadd: function ( v, w ) {\r\n\t\r\n\t\t\tif ( w !== undefined ) {\r\n\t\r\n\t\t\t\tTHREE.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\r\n\t\t\t\treturn this.addVectors( v, w );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.x += v.x;\r\n\t\t\tthis.y += v.y;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\taddScalar: function ( s ) {\r\n\t\r\n\t\t\tthis.x += s;\r\n\t\t\tthis.y += s;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\taddVectors: function ( a, b ) {\r\n\t\r\n\t\t\tthis.x = a.x + b.x;\r\n\t\t\tthis.y = a.y + b.y;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsub: function ( v, w ) {\r\n\t\r\n\t\t\tif ( w !== undefined ) {\r\n\t\r\n\t\t\t\tTHREE.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\r\n\t\t\t\treturn this.subVectors( v, w );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.x -= v.x;\r\n\t\t\tthis.y -= v.y;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsubScalar: function ( s ) {\r\n\t\r\n\t\t\tthis.x -= s;\r\n\t\t\tthis.y -= s;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsubVectors: function ( a, b ) {\r\n\t\r\n\t\t\tthis.x = a.x - b.x;\r\n\t\t\tthis.y = a.y - b.y;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmultiply: function ( v ) {\r\n\t\r\n\t\t\tthis.x *= v.x;\r\n\t\t\tthis.y *= v.y;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmultiplyScalar: function ( s ) {\r\n\t\r\n\t\t\tthis.x *= s;\r\n\t\t\tthis.y *= s;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdivide: function ( v ) {\r\n\t\r\n\t\t\tthis.x /= v.x;\r\n\t\t\tthis.y /= v.y;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdivideScalar: function ( scalar ) {\r\n\t\r\n\t\t\tif ( scalar !== 0 ) {\r\n\t\r\n\t\t\t\tvar invScalar = 1 / scalar;\r\n\t\r\n\t\t\t\tthis.x *= invScalar;\r\n\t\t\t\tthis.y *= invScalar;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tthis.x = 0;\r\n\t\t\t\tthis.y = 0;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmin: function ( v ) {\r\n\t\r\n\t\t\tif ( this.x > v.x ) {\r\n\t\r\n\t\t\t\tthis.x = v.x;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( this.y > v.y ) {\r\n\t\r\n\t\t\t\tthis.y = v.y;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmax: function ( v ) {\r\n\t\r\n\t\t\tif ( this.x < v.x ) {\r\n\t\r\n\t\t\t\tthis.x = v.x;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( this.y < v.y ) {\r\n\t\r\n\t\t\t\tthis.y = v.y;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclamp: function ( min, max ) {\r\n\t\r\n\t\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\r\n\t\r\n\t\t\tif ( this.x < min.x ) {\r\n\t\r\n\t\t\t\tthis.x = min.x;\r\n\t\r\n\t\t\t} else if ( this.x > max.x ) {\r\n\t\r\n\t\t\t\tthis.x = max.x;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( this.y < min.y ) {\r\n\t\r\n\t\t\t\tthis.y = min.y;\r\n\t\r\n\t\t\t} else if ( this.y > max.y ) {\r\n\t\r\n\t\t\t\tthis.y = max.y;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\tclampScalar: ( function () {\r\n\t\r\n\t\t\tvar min, max;\r\n\t\r\n\t\t\treturn function ( minVal, maxVal ) {\r\n\t\r\n\t\t\t\tif ( min === undefined ) {\r\n\t\r\n\t\t\t\t\tmin = new THREE.Vector2();\r\n\t\t\t\t\tmax = new THREE.Vector2();\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tmin.set( minVal, minVal );\r\n\t\t\t\tmax.set( maxVal, maxVal );\r\n\t\r\n\t\t\t\treturn this.clamp( min, max );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t} )(),\r\n\t\r\n\t\tfloor: function () {\r\n\t\r\n\t\t\tthis.x = Math.floor( this.x );\r\n\t\t\tthis.y = Math.floor( this.y );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tceil: function () {\r\n\t\r\n\t\t\tthis.x = Math.ceil( this.x );\r\n\t\t\tthis.y = Math.ceil( this.y );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tround: function () {\r\n\t\r\n\t\t\tthis.x = Math.round( this.x );\r\n\t\t\tthis.y = Math.round( this.y );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\troundToZero: function () {\r\n\t\r\n\t\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\r\n\t\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tnegate: function () {\r\n\t\r\n\t\t\tthis.x = - this.x;\r\n\t\t\tthis.y = - this.y;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdot: function ( v ) {\r\n\t\r\n\t\t\treturn this.x * v.x + this.y * v.y;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlengthSq: function () {\r\n\t\r\n\t\t\treturn this.x * this.x + this.y * this.y;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlength: function () {\r\n\t\r\n\t\t\treturn Math.sqrt( this.x * this.x + this.y * this.y );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tnormalize: function () {\r\n\t\r\n\t\t\treturn this.divideScalar( this.length() );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdistanceTo: function ( v ) {\r\n\t\r\n\t\t\treturn Math.sqrt( this.distanceToSquared( v ) );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdistanceToSquared: function ( v ) {\r\n\t\r\n\t\t\tvar dx = this.x - v.x, dy = this.y - v.y;\r\n\t\t\treturn dx * dx + dy * dy;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetLength: function ( l ) {\r\n\t\r\n\t\t\tvar oldLength = this.length();\r\n\t\r\n\t\t\tif ( oldLength !== 0 && l !== oldLength ) {\r\n\t\r\n\t\t\t\tthis.multiplyScalar( l / oldLength );\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlerp: function ( v, alpha ) {\r\n\t\r\n\t\t\tthis.x += ( v.x - this.x ) * alpha;\r\n\t\t\tthis.y += ( v.y - this.y ) * alpha;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlerpVectors: function ( v1, v2, alpha ) {\r\n\t\r\n\t\t\tthis.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tequals: function ( v ) {\r\n\t\r\n\t\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfromArray: function ( array, offset ) {\r\n\t\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\r\n\t\t\tthis.x = array[ offset ];\r\n\t\t\tthis.y = array[ offset + 1 ];\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttoArray: function ( array, offset ) {\r\n\t\r\n\t\t\tif ( array === undefined ) array = [];\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\r\n\t\t\tarray[ offset ] = this.x;\r\n\t\t\tarray[ offset + 1 ] = this.y;\r\n\t\r\n\t\t\treturn array;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfromAttribute: function ( attribute, index, offset ) {\r\n\t\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\r\n\t\t\tindex = index * attribute.itemSize + offset;\r\n\t\r\n\t\t\tthis.x = attribute.array[ index ];\r\n\t\t\tthis.y = attribute.array[ index + 1 ];\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new THREE.Vector2( this.x, this.y );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/math/Vector3.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author *kile / http://kile.stravaganza.org/\r\n\t * @author philogb / http://blog.thejit.org/\r\n\t * @author mikael emtinger / http://gomo.se/\r\n\t * @author egraether / http://egraether.com/\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t */\r\n\t\r\n\tTHREE.Vector3 = function ( x, y, z ) {\r\n\t\r\n\t\tthis.x = x || 0;\r\n\t\tthis.y = y || 0;\r\n\t\tthis.z = z || 0;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Vector3.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Vector3,\r\n\t\r\n\t\tset: function ( x, y, z ) {\r\n\t\r\n\t\t\tthis.x = x;\r\n\t\t\tthis.y = y;\r\n\t\t\tthis.z = z;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetX: function ( x ) {\r\n\t\r\n\t\t\tthis.x = x;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetY: function ( y ) {\r\n\t\r\n\t\t\tthis.y = y;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetZ: function ( z ) {\r\n\t\r\n\t\t\tthis.z = z;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetComponent: function ( index, value ) {\r\n\t\r\n\t\t\tswitch ( index ) {\r\n\t\r\n\t\t\t\tcase 0: this.x = value; break;\r\n\t\t\t\tcase 1: this.y = value; break;\r\n\t\t\t\tcase 2: this.z = value; break;\r\n\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetComponent: function ( index ) {\r\n\t\r\n\t\t\tswitch ( index ) {\r\n\t\r\n\t\t\t\tcase 0: return this.x;\r\n\t\t\t\tcase 1: return this.y;\r\n\t\t\t\tcase 2: return this.z;\r\n\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( v ) {\r\n\t\r\n\t\t\tthis.x = v.x;\r\n\t\t\tthis.y = v.y;\r\n\t\t\tthis.z = v.z;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tadd: function ( v, w ) {\r\n\t\r\n\t\t\tif ( w !== undefined ) {\r\n\t\r\n\t\t\t\tTHREE.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\r\n\t\t\t\treturn this.addVectors( v, w );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.x += v.x;\r\n\t\t\tthis.y += v.y;\r\n\t\t\tthis.z += v.z;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\taddScalar: function ( s ) {\r\n\t\r\n\t\t\tthis.x += s;\r\n\t\t\tthis.y += s;\r\n\t\t\tthis.z += s;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\taddVectors: function ( a, b ) {\r\n\t\r\n\t\t\tthis.x = a.x + b.x;\r\n\t\t\tthis.y = a.y + b.y;\r\n\t\t\tthis.z = a.z + b.z;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsub: function ( v, w ) {\r\n\t\r\n\t\t\tif ( w !== undefined ) {\r\n\t\r\n\t\t\t\tTHREE.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\r\n\t\t\t\treturn this.subVectors( v, w );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.x -= v.x;\r\n\t\t\tthis.y -= v.y;\r\n\t\t\tthis.z -= v.z;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\t\r\n\t\tsubScalar: function ( s ) {\r\n\t\r\n\t\t\tthis.x -= s;\r\n\t\t\tthis.y -= s;\r\n\t\t\tthis.z -= s;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsubVectors: function ( a, b ) {\r\n\t\r\n\t\t\tthis.x = a.x - b.x;\r\n\t\t\tthis.y = a.y - b.y;\r\n\t\t\tthis.z = a.z - b.z;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmultiply: function ( v, w ) {\r\n\t\r\n\t\t\tif ( w !== undefined ) {\r\n\t\r\n\t\t\t\tTHREE.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );\r\n\t\t\t\treturn this.multiplyVectors( v, w );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.x *= v.x;\r\n\t\t\tthis.y *= v.y;\r\n\t\t\tthis.z *= v.z;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmultiplyScalar: function ( scalar ) {\r\n\t\r\n\t\t\tthis.x *= scalar;\r\n\t\t\tthis.y *= scalar;\r\n\t\t\tthis.z *= scalar;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmultiplyVectors: function ( a, b ) {\r\n\t\r\n\t\t\tthis.x = a.x * b.x;\r\n\t\t\tthis.y = a.y * b.y;\r\n\t\t\tthis.z = a.z * b.z;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tapplyEuler: function () {\r\n\t\r\n\t\t\tvar quaternion;\r\n\t\r\n\t\t\treturn function ( euler ) {\r\n\t\r\n\t\t\t\tif ( euler instanceof THREE.Euler === false ) {\r\n\t\r\n\t\t\t\t\tTHREE.error( 'THREE.Vector3: .applyEuler() now expects a Euler rotation rather than a Vector3 and order.' );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( quaternion === undefined ) quaternion = new THREE.Quaternion();\r\n\t\r\n\t\t\t\tthis.applyQuaternion( quaternion.setFromEuler( euler ) );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tapplyAxisAngle: function () {\r\n\t\r\n\t\t\tvar quaternion;\r\n\t\r\n\t\t\treturn function ( axis, angle ) {\r\n\t\r\n\t\t\t\tif ( quaternion === undefined ) quaternion = new THREE.Quaternion();\r\n\t\r\n\t\t\t\tthis.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tapplyMatrix3: function ( m ) {\r\n\t\r\n\t\t\tvar x = this.x;\r\n\t\t\tvar y = this.y;\r\n\t\t\tvar z = this.z;\r\n\t\r\n\t\t\tvar e = m.elements;\r\n\t\r\n\t\t\tthis.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;\r\n\t\t\tthis.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;\r\n\t\t\tthis.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tapplyMatrix4: function ( m ) {\r\n\t\r\n\t\t\t// input: THREE.Matrix4 affine matrix\r\n\t\r\n\t\t\tvar x = this.x, y = this.y, z = this.z;\r\n\t\r\n\t\t\tvar e = m.elements;\r\n\t\r\n\t\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ];\r\n\t\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ];\r\n\t\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ];\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tapplyProjection: function ( m ) {\r\n\t\r\n\t\t\t// input: THREE.Matrix4 projection matrix\r\n\t\r\n\t\t\tvar x = this.x, y = this.y, z = this.z;\r\n\t\r\n\t\t\tvar e = m.elements;\r\n\t\t\tvar d = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] ); // perspective divide\r\n\t\r\n\t\t\tthis.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ] ) * d;\r\n\t\t\tthis.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ] ) * d;\r\n\t\t\tthis.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * d;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tapplyQuaternion: function ( q ) {\r\n\t\r\n\t\t\tvar x = this.x;\r\n\t\t\tvar y = this.y;\r\n\t\t\tvar z = this.z;\r\n\t\r\n\t\t\tvar qx = q.x;\r\n\t\t\tvar qy = q.y;\r\n\t\t\tvar qz = q.z;\r\n\t\t\tvar qw = q.w;\r\n\t\r\n\t\t\t// calculate quat * vector\r\n\t\r\n\t\t\tvar ix =  qw * x + qy * z - qz * y;\r\n\t\t\tvar iy =  qw * y + qz * x - qx * z;\r\n\t\t\tvar iz =  qw * z + qx * y - qy * x;\r\n\t\t\tvar iw = - qx * x - qy * y - qz * z;\r\n\t\r\n\t\t\t// calculate result * inverse quat\r\n\t\r\n\t\t\tthis.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;\r\n\t\t\tthis.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;\r\n\t\t\tthis.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tproject: function () {\r\n\t\r\n\t\t\tvar matrix;\r\n\t\r\n\t\t\treturn function ( camera ) {\r\n\t\r\n\t\t\t\tif ( matrix === undefined ) matrix = new THREE.Matrix4();\r\n\t\r\n\t\t\t\tmatrix.multiplyMatrices( camera.projectionMatrix, matrix.getInverse( camera.matrixWorld ) );\r\n\t\t\t\treturn this.applyProjection( matrix );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tunproject: function () {\r\n\t\r\n\t\t\tvar matrix;\r\n\t\r\n\t\t\treturn function ( camera ) {\r\n\t\r\n\t\t\t\tif ( matrix === undefined ) matrix = new THREE.Matrix4();\r\n\t\r\n\t\t\t\tmatrix.multiplyMatrices( camera.matrixWorld, matrix.getInverse( camera.projectionMatrix ) );\r\n\t\t\t\treturn this.applyProjection( matrix );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\ttransformDirection: function ( m ) {\r\n\t\r\n\t\t\t// input: THREE.Matrix4 affine matrix\r\n\t\t\t// vector interpreted as a direction\r\n\t\r\n\t\t\tvar x = this.x, y = this.y, z = this.z;\r\n\t\r\n\t\t\tvar e = m.elements;\r\n\t\r\n\t\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z;\r\n\t\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z;\r\n\t\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;\r\n\t\r\n\t\t\tthis.normalize();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdivide: function ( v ) {\r\n\t\r\n\t\t\tthis.x /= v.x;\r\n\t\t\tthis.y /= v.y;\r\n\t\t\tthis.z /= v.z;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdivideScalar: function ( scalar ) {\r\n\t\r\n\t\t\tif ( scalar !== 0 ) {\r\n\t\r\n\t\t\t\tvar invScalar = 1 / scalar;\r\n\t\r\n\t\t\t\tthis.x *= invScalar;\r\n\t\t\t\tthis.y *= invScalar;\r\n\t\t\t\tthis.z *= invScalar;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tthis.x = 0;\r\n\t\t\t\tthis.y = 0;\r\n\t\t\t\tthis.z = 0;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmin: function ( v ) {\r\n\t\r\n\t\t\tif ( this.x > v.x ) {\r\n\t\r\n\t\t\t\tthis.x = v.x;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( this.y > v.y ) {\r\n\t\r\n\t\t\t\tthis.y = v.y;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( this.z > v.z ) {\r\n\t\r\n\t\t\t\tthis.z = v.z;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmax: function ( v ) {\r\n\t\r\n\t\t\tif ( this.x < v.x ) {\r\n\t\r\n\t\t\t\tthis.x = v.x;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( this.y < v.y ) {\r\n\t\r\n\t\t\t\tthis.y = v.y;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( this.z < v.z ) {\r\n\t\r\n\t\t\t\tthis.z = v.z;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclamp: function ( min, max ) {\r\n\t\r\n\t\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\r\n\t\r\n\t\t\tif ( this.x < min.x ) {\r\n\t\r\n\t\t\t\tthis.x = min.x;\r\n\t\r\n\t\t\t} else if ( this.x > max.x ) {\r\n\t\r\n\t\t\t\tthis.x = max.x;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( this.y < min.y ) {\r\n\t\r\n\t\t\t\tthis.y = min.y;\r\n\t\r\n\t\t\t} else if ( this.y > max.y ) {\r\n\t\r\n\t\t\t\tthis.y = max.y;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( this.z < min.z ) {\r\n\t\r\n\t\t\t\tthis.z = min.z;\r\n\t\r\n\t\t\t} else if ( this.z > max.z ) {\r\n\t\r\n\t\t\t\tthis.z = max.z;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclampScalar: ( function () {\r\n\t\r\n\t\t\tvar min, max;\r\n\t\r\n\t\t\treturn function ( minVal, maxVal ) {\r\n\t\r\n\t\t\t\tif ( min === undefined ) {\r\n\t\r\n\t\t\t\t\tmin = new THREE.Vector3();\r\n\t\t\t\t\tmax = new THREE.Vector3();\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tmin.set( minVal, minVal, minVal );\r\n\t\t\t\tmax.set( maxVal, maxVal, maxVal );\r\n\t\r\n\t\t\t\treturn this.clamp( min, max );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t} )(),\r\n\t\r\n\t\tfloor: function () {\r\n\t\r\n\t\t\tthis.x = Math.floor( this.x );\r\n\t\t\tthis.y = Math.floor( this.y );\r\n\t\t\tthis.z = Math.floor( this.z );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tceil: function () {\r\n\t\r\n\t\t\tthis.x = Math.ceil( this.x );\r\n\t\t\tthis.y = Math.ceil( this.y );\r\n\t\t\tthis.z = Math.ceil( this.z );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tround: function () {\r\n\t\r\n\t\t\tthis.x = Math.round( this.x );\r\n\t\t\tthis.y = Math.round( this.y );\r\n\t\t\tthis.z = Math.round( this.z );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\troundToZero: function () {\r\n\t\r\n\t\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\r\n\t\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\r\n\t\t\tthis.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tnegate: function () {\r\n\t\r\n\t\t\tthis.x = - this.x;\r\n\t\t\tthis.y = - this.y;\r\n\t\t\tthis.z = - this.z;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdot: function ( v ) {\r\n\t\r\n\t\t\treturn this.x * v.x + this.y * v.y + this.z * v.z;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlengthSq: function () {\r\n\t\r\n\t\t\treturn this.x * this.x + this.y * this.y + this.z * this.z;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlength: function () {\r\n\t\r\n\t\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlengthManhattan: function () {\r\n\t\r\n\t\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tnormalize: function () {\r\n\t\r\n\t\t\treturn this.divideScalar( this.length() );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetLength: function ( l ) {\r\n\t\r\n\t\t\tvar oldLength = this.length();\r\n\t\r\n\t\t\tif ( oldLength !== 0 && l !== oldLength  ) {\r\n\t\r\n\t\t\t\tthis.multiplyScalar( l / oldLength );\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlerp: function ( v, alpha ) {\r\n\t\r\n\t\t\tthis.x += ( v.x - this.x ) * alpha;\r\n\t\t\tthis.y += ( v.y - this.y ) * alpha;\r\n\t\t\tthis.z += ( v.z - this.z ) * alpha;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlerpVectors: function ( v1, v2, alpha ) {\r\n\t\r\n\t\t\tthis.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcross: function ( v, w ) {\r\n\t\r\n\t\t\tif ( w !== undefined ) {\r\n\t\r\n\t\t\t\tTHREE.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );\r\n\t\t\t\treturn this.crossVectors( v, w );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar x = this.x, y = this.y, z = this.z;\r\n\t\r\n\t\t\tthis.x = y * v.z - z * v.y;\r\n\t\t\tthis.y = z * v.x - x * v.z;\r\n\t\t\tthis.z = x * v.y - y * v.x;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcrossVectors: function ( a, b ) {\r\n\t\r\n\t\t\tvar ax = a.x, ay = a.y, az = a.z;\r\n\t\t\tvar bx = b.x, by = b.y, bz = b.z;\r\n\t\r\n\t\t\tthis.x = ay * bz - az * by;\r\n\t\t\tthis.y = az * bx - ax * bz;\r\n\t\t\tthis.z = ax * by - ay * bx;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tprojectOnVector: function () {\r\n\t\r\n\t\t\tvar v1, dot;\r\n\t\r\n\t\t\treturn function ( vector ) {\r\n\t\r\n\t\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\r\n\t\r\n\t\t\t\tv1.copy( vector ).normalize();\r\n\t\r\n\t\t\t\tdot = this.dot( v1 );\r\n\t\r\n\t\t\t\treturn this.copy( v1 ).multiplyScalar( dot );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tprojectOnPlane: function () {\r\n\t\r\n\t\t\tvar v1;\r\n\t\r\n\t\t\treturn function ( planeNormal ) {\r\n\t\r\n\t\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\r\n\t\r\n\t\t\t\tv1.copy( this ).projectOnVector( planeNormal );\r\n\t\r\n\t\t\t\treturn this.sub( v1 );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\treflect: function () {\r\n\t\r\n\t\t\t// reflect incident vector off plane orthogonal to normal\r\n\t\t\t// normal is assumed to have unit length\r\n\t\r\n\t\t\tvar v1;\r\n\t\r\n\t\t\treturn function ( normal ) {\r\n\t\r\n\t\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\r\n\t\r\n\t\t\t\treturn this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tangleTo: function ( v ) {\r\n\t\r\n\t\t\tvar theta = this.dot( v ) / ( this.length() * v.length() );\r\n\t\r\n\t\t\t// clamp, to handle numerical problems\r\n\t\r\n\t\t\treturn Math.acos( THREE.Math.clamp( theta, - 1, 1 ) );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdistanceTo: function ( v ) {\r\n\t\r\n\t\t\treturn Math.sqrt( this.distanceToSquared( v ) );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdistanceToSquared: function ( v ) {\r\n\t\r\n\t\t\tvar dx = this.x - v.x;\r\n\t\t\tvar dy = this.y - v.y;\r\n\t\t\tvar dz = this.z - v.z;\r\n\t\r\n\t\t\treturn dx * dx + dy * dy + dz * dz;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetEulerFromRotationMatrix: function ( m, order ) {\r\n\t\r\n\t\t\tTHREE.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetEulerFromQuaternion: function ( q, order ) {\r\n\t\r\n\t\t\tTHREE.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetPositionFromMatrix: function ( m ) {\r\n\t\r\n\t\t\tTHREE.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );\r\n\t\r\n\t\t\treturn this.setFromMatrixPosition( m );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetScaleFromMatrix: function ( m ) {\r\n\t\r\n\t\t\tTHREE.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );\r\n\t\r\n\t\t\treturn this.setFromMatrixScale( m );\r\n\t\t},\r\n\t\r\n\t\tgetColumnFromMatrix: function ( index, matrix ) {\r\n\t\r\n\t\t\tTHREE.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );\r\n\t\r\n\t\t\treturn this.setFromMatrixColumn( index, matrix );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromMatrixPosition: function ( m ) {\r\n\t\r\n\t\t\tthis.x = m.elements[ 12 ];\r\n\t\t\tthis.y = m.elements[ 13 ];\r\n\t\t\tthis.z = m.elements[ 14 ];\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromMatrixScale: function ( m ) {\r\n\t\r\n\t\t\tvar sx = this.set( m.elements[ 0 ], m.elements[ 1 ], m.elements[  2 ] ).length();\r\n\t\t\tvar sy = this.set( m.elements[ 4 ], m.elements[ 5 ], m.elements[  6 ] ).length();\r\n\t\t\tvar sz = this.set( m.elements[ 8 ], m.elements[ 9 ], m.elements[ 10 ] ).length();\r\n\t\r\n\t\t\tthis.x = sx;\r\n\t\t\tthis.y = sy;\r\n\t\t\tthis.z = sz;\r\n\t\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\tsetFromMatrixColumn: function ( index, matrix ) {\r\n\t\t\t\r\n\t\t\tvar offset = index * 4;\r\n\t\r\n\t\t\tvar me = matrix.elements;\r\n\t\r\n\t\t\tthis.x = me[ offset ];\r\n\t\t\tthis.y = me[ offset + 1 ];\r\n\t\t\tthis.z = me[ offset + 2 ];\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tequals: function ( v ) {\r\n\t\r\n\t\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfromArray: function ( array, offset ) {\r\n\t\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\r\n\t\t\tthis.x = array[ offset ];\r\n\t\t\tthis.y = array[ offset + 1 ];\r\n\t\t\tthis.z = array[ offset + 2 ];\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttoArray: function ( array, offset ) {\r\n\t\r\n\t\t\tif ( array === undefined ) array = [];\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\r\n\t\t\tarray[ offset ] = this.x;\r\n\t\t\tarray[ offset + 1 ] = this.y;\r\n\t\t\tarray[ offset + 2 ] = this.z;\r\n\t\r\n\t\t\treturn array;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfromAttribute: function ( attribute, index, offset ) {\r\n\t\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\r\n\t\t\tindex = index * attribute.itemSize + offset;\r\n\t\r\n\t\t\tthis.x = attribute.array[ index ];\r\n\t\t\tthis.y = attribute.array[ index + 1 ];\r\n\t\t\tthis.z = attribute.array[ index + 2 ];\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new THREE.Vector3( this.x, this.y, this.z );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/math/Vector4.js\r\n\t\r\n\t/**\r\n\t * @author supereggbert / http://www.paulbrunt.co.uk/\r\n\t * @author philogb / http://blog.thejit.org/\r\n\t * @author mikael emtinger / http://gomo.se/\r\n\t * @author egraether / http://egraether.com/\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t */\r\n\t\r\n\tTHREE.Vector4 = function ( x, y, z, w ) {\r\n\t\r\n\t\tthis.x = x || 0;\r\n\t\tthis.y = y || 0;\r\n\t\tthis.z = z || 0;\r\n\t\tthis.w = ( w !== undefined ) ? w : 1;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Vector4.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Vector4,\r\n\t\r\n\t\tset: function ( x, y, z, w ) {\r\n\t\r\n\t\t\tthis.x = x;\r\n\t\t\tthis.y = y;\r\n\t\t\tthis.z = z;\r\n\t\t\tthis.w = w;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetX: function ( x ) {\r\n\t\r\n\t\t\tthis.x = x;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetY: function ( y ) {\r\n\t\r\n\t\t\tthis.y = y;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetZ: function ( z ) {\r\n\t\r\n\t\t\tthis.z = z;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetW: function ( w ) {\r\n\t\r\n\t\t\tthis.w = w;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetComponent: function ( index, value ) {\r\n\t\r\n\t\t\tswitch ( index ) {\r\n\t\r\n\t\t\t\tcase 0: this.x = value; break;\r\n\t\t\t\tcase 1: this.y = value; break;\r\n\t\t\t\tcase 2: this.z = value; break;\r\n\t\t\t\tcase 3: this.w = value; break;\r\n\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetComponent: function ( index ) {\r\n\t\r\n\t\t\tswitch ( index ) {\r\n\t\r\n\t\t\t\tcase 0: return this.x;\r\n\t\t\t\tcase 1: return this.y;\r\n\t\t\t\tcase 2: return this.z;\r\n\t\t\t\tcase 3: return this.w;\r\n\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( v ) {\r\n\t\r\n\t\t\tthis.x = v.x;\r\n\t\t\tthis.y = v.y;\r\n\t\t\tthis.z = v.z;\r\n\t\t\tthis.w = ( v.w !== undefined ) ? v.w : 1;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tadd: function ( v, w ) {\r\n\t\r\n\t\t\tif ( w !== undefined ) {\r\n\t\r\n\t\t\t\tTHREE.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\r\n\t\t\t\treturn this.addVectors( v, w );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.x += v.x;\r\n\t\t\tthis.y += v.y;\r\n\t\t\tthis.z += v.z;\r\n\t\t\tthis.w += v.w;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\taddScalar: function ( s ) {\r\n\t\r\n\t\t\tthis.x += s;\r\n\t\t\tthis.y += s;\r\n\t\t\tthis.z += s;\r\n\t\t\tthis.w += s;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\taddVectors: function ( a, b ) {\r\n\t\r\n\t\t\tthis.x = a.x + b.x;\r\n\t\t\tthis.y = a.y + b.y;\r\n\t\t\tthis.z = a.z + b.z;\r\n\t\t\tthis.w = a.w + b.w;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsub: function ( v, w ) {\r\n\t\r\n\t\t\tif ( w !== undefined ) {\r\n\t\r\n\t\t\t\tTHREE.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\r\n\t\t\t\treturn this.subVectors( v, w );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.x -= v.x;\r\n\t\t\tthis.y -= v.y;\r\n\t\t\tthis.z -= v.z;\r\n\t\t\tthis.w -= v.w;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsubScalar: function ( s ) {\r\n\t\r\n\t\t\tthis.x -= s;\r\n\t\t\tthis.y -= s;\r\n\t\t\tthis.z -= s;\r\n\t\t\tthis.w -= s;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsubVectors: function ( a, b ) {\r\n\t\r\n\t\t\tthis.x = a.x - b.x;\r\n\t\t\tthis.y = a.y - b.y;\r\n\t\t\tthis.z = a.z - b.z;\r\n\t\t\tthis.w = a.w - b.w;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmultiplyScalar: function ( scalar ) {\r\n\t\r\n\t\t\tthis.x *= scalar;\r\n\t\t\tthis.y *= scalar;\r\n\t\t\tthis.z *= scalar;\r\n\t\t\tthis.w *= scalar;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tapplyMatrix4: function ( m ) {\r\n\t\r\n\t\t\tvar x = this.x;\r\n\t\t\tvar y = this.y;\r\n\t\t\tvar z = this.z;\r\n\t\t\tvar w = this.w;\r\n\t\r\n\t\t\tvar e = m.elements;\r\n\t\r\n\t\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;\r\n\t\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;\r\n\t\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;\r\n\t\t\tthis.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdivideScalar: function ( scalar ) {\r\n\t\r\n\t\t\tif ( scalar !== 0 ) {\r\n\t\r\n\t\t\t\tvar invScalar = 1 / scalar;\r\n\t\r\n\t\t\t\tthis.x *= invScalar;\r\n\t\t\t\tthis.y *= invScalar;\r\n\t\t\t\tthis.z *= invScalar;\r\n\t\t\t\tthis.w *= invScalar;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tthis.x = 0;\r\n\t\t\t\tthis.y = 0;\r\n\t\t\t\tthis.z = 0;\r\n\t\t\t\tthis.w = 1;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetAxisAngleFromQuaternion: function ( q ) {\r\n\t\r\n\t\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm\r\n\t\r\n\t\t\t// q is assumed to be normalized\r\n\t\r\n\t\t\tthis.w = 2 * Math.acos( q.w );\r\n\t\r\n\t\t\tvar s = Math.sqrt( 1 - q.w * q.w );\r\n\t\r\n\t\t\tif ( s < 0.0001 ) {\r\n\t\r\n\t\t\t\t this.x = 1;\r\n\t\t\t\t this.y = 0;\r\n\t\t\t\t this.z = 0;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\t this.x = q.x / s;\r\n\t\t\t\t this.y = q.y / s;\r\n\t\t\t\t this.z = q.z / s;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetAxisAngleFromRotationMatrix: function ( m ) {\r\n\t\r\n\t\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm\r\n\t\r\n\t\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\r\n\t\r\n\t\t\tvar angle, x, y, z,\t\t// variables for result\r\n\t\t\t\tepsilon = 0.01,\t\t// margin to allow for rounding errors\r\n\t\t\t\tepsilon2 = 0.1,\t\t// margin to distinguish between 0 and 180 degrees\r\n\t\r\n\t\t\t\tte = m.elements,\r\n\t\r\n\t\t\t\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\r\n\t\t\t\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\r\n\t\t\t\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\r\n\t\r\n\t\t\tif ( ( Math.abs( m12 - m21 ) < epsilon )\r\n\t\t\t   && ( Math.abs( m13 - m31 ) < epsilon )\r\n\t\t\t   && ( Math.abs( m23 - m32 ) < epsilon ) ) {\r\n\t\r\n\t\t\t\t// singularity found\r\n\t\t\t\t// first check for identity matrix which must have +1 for all terms\r\n\t\t\t\t// in leading diagonal and zero in other terms\r\n\t\r\n\t\t\t\tif ( ( Math.abs( m12 + m21 ) < epsilon2 )\r\n\t\t\t\t   && ( Math.abs( m13 + m31 ) < epsilon2 )\r\n\t\t\t\t   && ( Math.abs( m23 + m32 ) < epsilon2 )\r\n\t\t\t\t   && ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {\r\n\t\r\n\t\t\t\t\t// this singularity is identity matrix so angle = 0\r\n\t\r\n\t\t\t\t\tthis.set( 1, 0, 0, 0 );\r\n\t\r\n\t\t\t\t\treturn this; // zero angle, arbitrary axis\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// otherwise this singularity is angle = 180\r\n\t\r\n\t\t\t\tangle = Math.PI;\r\n\t\r\n\t\t\t\tvar xx = ( m11 + 1 ) / 2;\r\n\t\t\t\tvar yy = ( m22 + 1 ) / 2;\r\n\t\t\t\tvar zz = ( m33 + 1 ) / 2;\r\n\t\t\t\tvar xy = ( m12 + m21 ) / 4;\r\n\t\t\t\tvar xz = ( m13 + m31 ) / 4;\r\n\t\t\t\tvar yz = ( m23 + m32 ) / 4;\r\n\t\r\n\t\t\t\tif ( ( xx > yy ) && ( xx > zz ) ) { // m11 is the largest diagonal term\r\n\t\r\n\t\t\t\t\tif ( xx < epsilon ) {\r\n\t\r\n\t\t\t\t\t\tx = 0;\r\n\t\t\t\t\t\ty = 0.707106781;\r\n\t\t\t\t\t\tz = 0.707106781;\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tx = Math.sqrt( xx );\r\n\t\t\t\t\t\ty = xy / x;\r\n\t\t\t\t\t\tz = xz / x;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else if ( yy > zz ) { // m22 is the largest diagonal term\r\n\t\r\n\t\t\t\t\tif ( yy < epsilon ) {\r\n\t\r\n\t\t\t\t\t\tx = 0.707106781;\r\n\t\t\t\t\t\ty = 0;\r\n\t\t\t\t\t\tz = 0.707106781;\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\ty = Math.sqrt( yy );\r\n\t\t\t\t\t\tx = xy / y;\r\n\t\t\t\t\t\tz = yz / y;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else { // m33 is the largest diagonal term so base result on this\r\n\t\r\n\t\t\t\t\tif ( zz < epsilon ) {\r\n\t\r\n\t\t\t\t\t\tx = 0.707106781;\r\n\t\t\t\t\t\ty = 0.707106781;\r\n\t\t\t\t\t\tz = 0;\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tz = Math.sqrt( zz );\r\n\t\t\t\t\t\tx = xz / z;\r\n\t\t\t\t\t\ty = yz / z;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tthis.set( x, y, z, angle );\r\n\t\r\n\t\t\t\treturn this; // return 180 deg rotation\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// as we have reached here there are no singularities so we can handle normally\r\n\t\r\n\t\t\tvar s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 )\r\n\t\t\t\t\t\t\t  + ( m13 - m31 ) * ( m13 - m31 )\r\n\t\t\t\t\t\t\t  + ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize\r\n\t\r\n\t\t\tif ( Math.abs( s ) < 0.001 ) s = 1;\r\n\t\r\n\t\t\t// prevent divide by zero, should not happen if matrix is orthogonal and should be\r\n\t\t\t// caught by singularity test above, but I've left it in just in case\r\n\t\r\n\t\t\tthis.x = ( m32 - m23 ) / s;\r\n\t\t\tthis.y = ( m13 - m31 ) / s;\r\n\t\t\tthis.z = ( m21 - m12 ) / s;\r\n\t\t\tthis.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmin: function ( v ) {\r\n\t\r\n\t\t\tif ( this.x > v.x ) {\r\n\t\r\n\t\t\t\tthis.x = v.x;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( this.y > v.y ) {\r\n\t\r\n\t\t\t\tthis.y = v.y;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( this.z > v.z ) {\r\n\t\r\n\t\t\t\tthis.z = v.z;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( this.w > v.w ) {\r\n\t\r\n\t\t\t\tthis.w = v.w;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmax: function ( v ) {\r\n\t\r\n\t\t\tif ( this.x < v.x ) {\r\n\t\r\n\t\t\t\tthis.x = v.x;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( this.y < v.y ) {\r\n\t\r\n\t\t\t\tthis.y = v.y;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( this.z < v.z ) {\r\n\t\r\n\t\t\t\tthis.z = v.z;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( this.w < v.w ) {\r\n\t\r\n\t\t\t\tthis.w = v.w;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclamp: function ( min, max ) {\r\n\t\r\n\t\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\r\n\t\r\n\t\t\tif ( this.x < min.x ) {\r\n\t\r\n\t\t\t\tthis.x = min.x;\r\n\t\r\n\t\t\t} else if ( this.x > max.x ) {\r\n\t\r\n\t\t\t\tthis.x = max.x;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( this.y < min.y ) {\r\n\t\r\n\t\t\t\tthis.y = min.y;\r\n\t\r\n\t\t\t} else if ( this.y > max.y ) {\r\n\t\r\n\t\t\t\tthis.y = max.y;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( this.z < min.z ) {\r\n\t\r\n\t\t\t\tthis.z = min.z;\r\n\t\r\n\t\t\t} else if ( this.z > max.z ) {\r\n\t\r\n\t\t\t\tthis.z = max.z;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( this.w < min.w ) {\r\n\t\r\n\t\t\t\tthis.w = min.w;\r\n\t\r\n\t\t\t} else if ( this.w > max.w ) {\r\n\t\r\n\t\t\t\tthis.w = max.w;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclampScalar: ( function () {\r\n\t\r\n\t\t\tvar min, max;\r\n\t\r\n\t\t\treturn function ( minVal, maxVal ) {\r\n\t\r\n\t\t\t\tif ( min === undefined ) {\r\n\t\r\n\t\t\t\t\tmin = new THREE.Vector4();\r\n\t\t\t\t\tmax = new THREE.Vector4();\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tmin.set( minVal, minVal, minVal, minVal );\r\n\t\t\t\tmax.set( maxVal, maxVal, maxVal, maxVal );\r\n\t\r\n\t\t\t\treturn this.clamp( min, max );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t} )(),\r\n\t\r\n\t  floor: function () {\r\n\t\r\n\t\t\tthis.x = Math.floor( this.x );\r\n\t\t\tthis.y = Math.floor( this.y );\r\n\t\t\tthis.z = Math.floor( this.z );\r\n\t\t\tthis.w = Math.floor( this.w );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t  },\r\n\t\r\n\t  ceil: function () {\r\n\t\r\n\t\t\tthis.x = Math.ceil( this.x );\r\n\t\t\tthis.y = Math.ceil( this.y );\r\n\t\t\tthis.z = Math.ceil( this.z );\r\n\t\t\tthis.w = Math.ceil( this.w );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t  },\r\n\t\r\n\t  round: function () {\r\n\t\r\n\t\t\tthis.x = Math.round( this.x );\r\n\t\t\tthis.y = Math.round( this.y );\r\n\t\t\tthis.z = Math.round( this.z );\r\n\t\t\tthis.w = Math.round( this.w );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t  },\r\n\t\r\n\t  roundToZero: function () {\r\n\t\r\n\t\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\r\n\t\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\r\n\t\t\tthis.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\r\n\t\t\tthis.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t  },\r\n\t\r\n\t\tnegate: function () {\r\n\t\r\n\t\t\tthis.x = - this.x;\r\n\t\t\tthis.y = - this.y;\r\n\t\t\tthis.z = - this.z;\r\n\t\t\tthis.w = - this.w;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdot: function ( v ) {\r\n\t\r\n\t\t\treturn this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlengthSq: function () {\r\n\t\r\n\t\t\treturn this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlength: function () {\r\n\t\r\n\t\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlengthManhattan: function () {\r\n\t\r\n\t\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tnormalize: function () {\r\n\t\r\n\t\t\treturn this.divideScalar( this.length() );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetLength: function ( l ) {\r\n\t\r\n\t\t\tvar oldLength = this.length();\r\n\t\r\n\t\t\tif ( oldLength !== 0 && l !== oldLength ) {\r\n\t\r\n\t\t\t\tthis.multiplyScalar( l / oldLength );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlerp: function ( v, alpha ) {\r\n\t\r\n\t\t\tthis.x += ( v.x - this.x ) * alpha;\r\n\t\t\tthis.y += ( v.y - this.y ) * alpha;\r\n\t\t\tthis.z += ( v.z - this.z ) * alpha;\r\n\t\t\tthis.w += ( v.w - this.w ) * alpha;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlerpVectors: function ( v1, v2, alpha ) {\r\n\t\r\n\t\t\tthis.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tequals: function ( v ) {\r\n\t\r\n\t\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfromArray: function ( array, offset ) {\r\n\t\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\r\n\t\t\tthis.x = array[ offset ];\r\n\t\t\tthis.y = array[ offset + 1 ];\r\n\t\t\tthis.z = array[ offset + 2 ];\r\n\t\t\tthis.w = array[ offset + 3 ];\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttoArray: function ( array, offset ) {\r\n\t\r\n\t\t\tif ( array === undefined ) array = [];\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\r\n\t\t\tarray[ offset ] = this.x;\r\n\t\t\tarray[ offset + 1 ] = this.y;\r\n\t\t\tarray[ offset + 2 ] = this.z;\r\n\t\t\tarray[ offset + 3 ] = this.w;\r\n\t\r\n\t\t\treturn array;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfromAttribute: function ( attribute, index, offset ) {\r\n\t\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\r\n\t\t\tindex = index * attribute.itemSize + offset;\r\n\t\r\n\t\t\tthis.x = attribute.array[ index ];\r\n\t\t\tthis.y = attribute.array[ index + 1 ];\r\n\t\t\tthis.z = attribute.array[ index + 2 ];\r\n\t\t\tthis.w = attribute.array[ index + 3 ];\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new THREE.Vector4( this.x, this.y, this.z, this.w );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/math/Euler.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t * @author bhouston / http://exocortex.com\r\n\t */\r\n\t\r\n\tTHREE.Euler = function ( x, y, z, order ) {\r\n\t\r\n\t\tthis._x = x || 0;\r\n\t\tthis._y = y || 0;\r\n\t\tthis._z = z || 0;\r\n\t\tthis._order = order || THREE.Euler.DefaultOrder;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];\r\n\t\r\n\tTHREE.Euler.DefaultOrder = 'XYZ';\r\n\t\r\n\tTHREE.Euler.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Euler,\r\n\t\r\n\t\t_x: 0, _y: 0, _z: 0, _order: THREE.Euler.DefaultOrder,\r\n\t\r\n\t\tget x () {\r\n\t\r\n\t\t\treturn this._x;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tset x ( value ) {\r\n\t\r\n\t\t\tthis._x = value;\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t},\r\n\t\r\n\t\tget y () {\r\n\t\r\n\t\t\treturn this._y;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tset y ( value ) {\r\n\t\r\n\t\t\tthis._y = value;\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t},\r\n\t\r\n\t\tget z () {\r\n\t\r\n\t\t\treturn this._z;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tset z ( value ) {\r\n\t\r\n\t\t\tthis._z = value;\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t},\r\n\t\r\n\t\tget order () {\r\n\t\r\n\t\t\treturn this._order;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tset order ( value ) {\r\n\t\r\n\t\t\tthis._order = value;\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t},\r\n\t\r\n\t\tset: function ( x, y, z, order ) {\r\n\t\r\n\t\t\tthis._x = x;\r\n\t\t\tthis._y = y;\r\n\t\t\tthis._z = z;\r\n\t\t\tthis._order = order || this._order;\r\n\t\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( euler ) {\r\n\t\r\n\t\t\tthis._x = euler._x;\r\n\t\t\tthis._y = euler._y;\r\n\t\t\tthis._z = euler._z;\r\n\t\t\tthis._order = euler._order;\r\n\t\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromRotationMatrix: function ( m, order, update ) {\r\n\t\r\n\t\t\tvar clamp = THREE.Math.clamp;\r\n\t\r\n\t\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\r\n\t\r\n\t\t\tvar te = m.elements;\r\n\t\t\tvar m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];\r\n\t\t\tvar m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];\r\n\t\t\tvar m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\r\n\t\r\n\t\t\torder = order || this._order;\r\n\t\r\n\t\t\tif ( order === 'XYZ' ) {\r\n\t\r\n\t\t\t\tthis._y = Math.asin( clamp( m13, - 1, 1 ) );\r\n\t\r\n\t\t\t\tif ( Math.abs( m13 ) < 0.99999 ) {\r\n\t\r\n\t\t\t\t\tthis._x = Math.atan2( - m23, m33 );\r\n\t\t\t\t\tthis._z = Math.atan2( - m12, m11 );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tthis._x = Math.atan2( m32, m22 );\r\n\t\t\t\t\tthis._z = 0;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else if ( order === 'YXZ' ) {\r\n\t\r\n\t\t\t\tthis._x = Math.asin( - clamp( m23, - 1, 1 ) );\r\n\t\r\n\t\t\t\tif ( Math.abs( m23 ) < 0.99999 ) {\r\n\t\r\n\t\t\t\t\tthis._y = Math.atan2( m13, m33 );\r\n\t\t\t\t\tthis._z = Math.atan2( m21, m22 );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tthis._y = Math.atan2( - m31, m11 );\r\n\t\t\t\t\tthis._z = 0;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else if ( order === 'ZXY' ) {\r\n\t\r\n\t\t\t\tthis._x = Math.asin( clamp( m32, - 1, 1 ) );\r\n\t\r\n\t\t\t\tif ( Math.abs( m32 ) < 0.99999 ) {\r\n\t\r\n\t\t\t\t\tthis._y = Math.atan2( - m31, m33 );\r\n\t\t\t\t\tthis._z = Math.atan2( - m12, m22 );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tthis._y = 0;\r\n\t\t\t\t\tthis._z = Math.atan2( m21, m11 );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else if ( order === 'ZYX' ) {\r\n\t\r\n\t\t\t\tthis._y = Math.asin( - clamp( m31, - 1, 1 ) );\r\n\t\r\n\t\t\t\tif ( Math.abs( m31 ) < 0.99999 ) {\r\n\t\r\n\t\t\t\t\tthis._x = Math.atan2( m32, m33 );\r\n\t\t\t\t\tthis._z = Math.atan2( m21, m11 );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tthis._x = 0;\r\n\t\t\t\t\tthis._z = Math.atan2( - m12, m22 );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else if ( order === 'YZX' ) {\r\n\t\r\n\t\t\t\tthis._z = Math.asin( clamp( m21, - 1, 1 ) );\r\n\t\r\n\t\t\t\tif ( Math.abs( m21 ) < 0.99999 ) {\r\n\t\r\n\t\t\t\t\tthis._x = Math.atan2( - m23, m22 );\r\n\t\t\t\t\tthis._y = Math.atan2( - m31, m11 );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tthis._x = 0;\r\n\t\t\t\t\tthis._y = Math.atan2( m13, m33 );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else if ( order === 'XZY' ) {\r\n\t\r\n\t\t\t\tthis._z = Math.asin( - clamp( m12, - 1, 1 ) );\r\n\t\r\n\t\t\t\tif ( Math.abs( m12 ) < 0.99999 ) {\r\n\t\r\n\t\t\t\t\tthis._x = Math.atan2( m32, m22 );\r\n\t\t\t\t\tthis._y = Math.atan2( m13, m11 );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tthis._x = Math.atan2( - m23, m33 );\r\n\t\t\t\t\tthis._y = 0;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tTHREE.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order )\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis._order = order;\r\n\t\r\n\t\t\tif ( update !== false ) this.onChangeCallback();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromQuaternion: function () {\r\n\t\r\n\t\t\tvar matrix;\r\n\t\r\n\t\t\treturn function ( q, order, update ) {\r\n\t\r\n\t\t\t\tif ( matrix === undefined ) matrix = new THREE.Matrix4();\r\n\t\t\t\tmatrix.makeRotationFromQuaternion( q );\r\n\t\t\t\tthis.setFromRotationMatrix( matrix, order, update );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tsetFromVector3: function ( v, order ) {\r\n\t\r\n\t\t\treturn this.set( v.x, v.y, v.z, order || this._order );\r\n\t\r\n\t\t},\r\n\t\r\n\t\treorder: function () {\r\n\t\r\n\t\t\t// WARNING: this discards revolution information -bhouston\r\n\t\r\n\t\t\tvar q = new THREE.Quaternion();\r\n\t\r\n\t\t\treturn function ( newOrder ) {\r\n\t\r\n\t\t\t\tq.setFromEuler( this );\r\n\t\t\t\tthis.setFromQuaternion( q, newOrder );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tequals: function ( euler ) {\r\n\t\r\n\t\t\treturn ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfromArray: function ( array ) {\r\n\t\r\n\t\t\tthis._x = array[ 0 ];\r\n\t\t\tthis._y = array[ 1 ];\r\n\t\t\tthis._z = array[ 2 ];\r\n\t\t\tif ( array[ 3 ] !== undefined ) this._order = array[ 3 ];\r\n\t\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttoArray: function ( array, offset ) {\r\n\t\r\n\t\t\tif ( array === undefined ) array = [];\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\r\n\t\t\tarray[ offset ] = this._x;\r\n\t\t\tarray[ offset + 1 ] = this._y;\r\n\t\t\tarray[ offset + 2 ] = this._z;\r\n\t\t\tarray[ offset + 3 ] = this._order;\r\n\t\r\n\t\t\treturn array;\r\n\t\t},\r\n\t\r\n\t\ttoVector3: function ( optionalResult ) {\r\n\t\r\n\t\t\tif ( optionalResult ) {\r\n\t\r\n\t\t\t\treturn optionalResult.set( this._x, this._y, this._z );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\treturn new THREE.Vector3( this._x, this._y, this._z );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tonChange: function ( callback ) {\r\n\t\r\n\t\t\tthis.onChangeCallback = callback;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tonChangeCallback: function () {},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new THREE.Euler( this._x, this._y, this._z, this._order );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/math/Line3.js\r\n\t\r\n\t/**\r\n\t * @author bhouston / http://exocortex.com\r\n\t */\r\n\t\r\n\tTHREE.Line3 = function ( start, end ) {\r\n\t\r\n\t\tthis.start = ( start !== undefined ) ? start : new THREE.Vector3();\r\n\t\tthis.end = ( end !== undefined ) ? end : new THREE.Vector3();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Line3.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Line3,\r\n\t\r\n\t\tset: function ( start, end ) {\r\n\t\r\n\t\t\tthis.start.copy( start );\r\n\t\t\tthis.end.copy( end );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( line ) {\r\n\t\r\n\t\t\tthis.start.copy( line.start );\r\n\t\t\tthis.end.copy( line.end );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcenter: function ( optionalTarget ) {\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\t\treturn result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdelta: function ( optionalTarget ) {\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\t\treturn result.subVectors( this.end, this.start );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdistanceSq: function () {\r\n\t\r\n\t\t\treturn this.start.distanceToSquared( this.end );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdistance: function () {\r\n\t\r\n\t\t\treturn this.start.distanceTo( this.end );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tat: function ( t, optionalTarget ) {\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\r\n\t\t\treturn this.delta( result ).multiplyScalar( t ).add( this.start );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclosestPointToPointParameter: function () {\r\n\t\r\n\t\t\tvar startP = new THREE.Vector3();\r\n\t\t\tvar startEnd = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function ( point, clampToLine ) {\r\n\t\r\n\t\t\t\tstartP.subVectors( point, this.start );\r\n\t\t\t\tstartEnd.subVectors( this.end, this.start );\r\n\t\r\n\t\t\t\tvar startEnd2 = startEnd.dot( startEnd );\r\n\t\t\t\tvar startEnd_startP = startEnd.dot( startP );\r\n\t\r\n\t\t\t\tvar t = startEnd_startP / startEnd2;\r\n\t\r\n\t\t\t\tif ( clampToLine ) {\r\n\t\r\n\t\t\t\t\tt = THREE.Math.clamp( t, 0, 1 );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn t;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tclosestPointToPoint: function ( point, clampToLine, optionalTarget ) {\r\n\t\r\n\t\t\tvar t = this.closestPointToPointParameter( point, clampToLine );\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\r\n\t\t\treturn this.delta( result ).multiplyScalar( t ).add( this.start );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tapplyMatrix4: function ( matrix ) {\r\n\t\r\n\t\t\tthis.start.applyMatrix4( matrix );\r\n\t\t\tthis.end.applyMatrix4( matrix );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tequals: function ( line ) {\r\n\t\r\n\t\t\treturn line.start.equals( this.start ) && line.end.equals( this.end );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new THREE.Line3().copy( this );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/math/Box2.js\r\n\t\r\n\t/**\r\n\t * @author bhouston / http://exocortex.com\r\n\t */\r\n\t\r\n\tTHREE.Box2 = function ( min, max ) {\r\n\t\r\n\t\tthis.min = ( min !== undefined ) ? min : new THREE.Vector2( Infinity, Infinity );\r\n\t\tthis.max = ( max !== undefined ) ? max : new THREE.Vector2( - Infinity, - Infinity );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Box2.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Box2,\r\n\t\r\n\t\tset: function ( min, max ) {\r\n\t\r\n\t\t\tthis.min.copy( min );\r\n\t\t\tthis.max.copy( max );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromPoints: function ( points ) {\r\n\t\r\n\t\t\tthis.makeEmpty();\r\n\t\r\n\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tthis.expandByPoint( points[ i ] )\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromCenterAndSize: function () {\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector2();\r\n\t\r\n\t\t\treturn function ( center, size ) {\r\n\t\r\n\t\t\t\tvar halfSize = v1.copy( size ).multiplyScalar( 0.5 );\r\n\t\t\t\tthis.min.copy( center ).sub( halfSize );\r\n\t\t\t\tthis.max.copy( center ).add( halfSize );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tcopy: function ( box ) {\r\n\t\r\n\t\t\tthis.min.copy( box.min );\r\n\t\t\tthis.max.copy( box.max );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmakeEmpty: function () {\r\n\t\r\n\t\t\tthis.min.x = this.min.y = Infinity;\r\n\t\t\tthis.max.x = this.max.y = - Infinity;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tempty: function () {\r\n\t\r\n\t\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\r\n\t\r\n\t\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcenter: function ( optionalTarget ) {\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector2();\r\n\t\t\treturn result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsize: function ( optionalTarget ) {\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector2();\r\n\t\t\treturn result.subVectors( this.max, this.min );\r\n\t\r\n\t\t},\r\n\t\r\n\t\texpandByPoint: function ( point ) {\r\n\t\r\n\t\t\tthis.min.min( point );\r\n\t\t\tthis.max.max( point );\r\n\t\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\texpandByVector: function ( vector ) {\r\n\t\r\n\t\t\tthis.min.sub( vector );\r\n\t\t\tthis.max.add( vector );\r\n\t\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\texpandByScalar: function ( scalar ) {\r\n\t\r\n\t\t\tthis.min.addScalar( - scalar );\r\n\t\t\tthis.max.addScalar( scalar );\r\n\t\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\tcontainsPoint: function ( point ) {\r\n\t\r\n\t\t\tif ( point.x < this.min.x || point.x > this.max.x ||\r\n\t\t\t     point.y < this.min.y || point.y > this.max.y ) {\r\n\t\r\n\t\t\t\treturn false;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn true;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcontainsBox: function ( box ) {\r\n\t\r\n\t\t\tif ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&\r\n\t\t\t     ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) ) {\r\n\t\r\n\t\t\t\treturn true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn false;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetParameter: function ( point, optionalTarget ) {\r\n\t\r\n\t\t\t// This can potentially have a divide by zero if the box\r\n\t\t\t// has a size dimension of 0.\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector2();\r\n\t\r\n\t\t\treturn result.set(\r\n\t\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\r\n\t\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y )\r\n\t\t\t);\r\n\t\r\n\t\t},\r\n\t\r\n\t\tisIntersectionBox: function ( box ) {\r\n\t\r\n\t\t\t// using 6 splitting planes to rule out intersections.\r\n\t\r\n\t\t\tif ( box.max.x < this.min.x || box.min.x > this.max.x ||\r\n\t\t\t     box.max.y < this.min.y || box.min.y > this.max.y ) {\r\n\t\r\n\t\t\t\treturn false;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn true;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclampPoint: function ( point, optionalTarget ) {\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector2();\r\n\t\t\treturn result.copy( point ).clamp( this.min, this.max );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdistanceToPoint: function () {\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector2();\r\n\t\r\n\t\t\treturn function ( point ) {\r\n\t\r\n\t\t\t\tvar clampedPoint = v1.copy( point ).clamp( this.min, this.max );\r\n\t\t\t\treturn clampedPoint.sub( point ).length();\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tintersect: function ( box ) {\r\n\t\r\n\t\t\tthis.min.max( box.min );\r\n\t\t\tthis.max.min( box.max );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tunion: function ( box ) {\r\n\t\r\n\t\t\tthis.min.min( box.min );\r\n\t\t\tthis.max.max( box.max );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttranslate: function ( offset ) {\r\n\t\r\n\t\t\tthis.min.add( offset );\r\n\t\t\tthis.max.add( offset );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tequals: function ( box ) {\r\n\t\r\n\t\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new THREE.Box2().copy( this );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/math/Box3.js\r\n\t\r\n\t/**\r\n\t * @author bhouston / http://exocortex.com\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t */\r\n\t\r\n\tTHREE.Box3 = function ( min, max ) {\r\n\t\r\n\t\tthis.min = ( min !== undefined ) ? min : new THREE.Vector3( Infinity, Infinity, Infinity );\r\n\t\tthis.max = ( max !== undefined ) ? max : new THREE.Vector3( - Infinity, - Infinity, - Infinity );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Box3.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Box3,\r\n\t\r\n\t\tset: function ( min, max ) {\r\n\t\r\n\t\t\tthis.min.copy( min );\r\n\t\t\tthis.max.copy( max );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromPoints: function ( points ) {\r\n\t\r\n\t\t\tthis.makeEmpty();\r\n\t\r\n\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tthis.expandByPoint( points[ i ] )\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromCenterAndSize: function () {\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function ( center, size ) {\r\n\t\r\n\t\t\t\tvar halfSize = v1.copy( size ).multiplyScalar( 0.5 );\r\n\t\r\n\t\t\t\tthis.min.copy( center ).sub( halfSize );\r\n\t\t\t\tthis.max.copy( center ).add( halfSize );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tsetFromObject: function () {\r\n\t\r\n\t\t\t// Computes the world-axis-aligned bounding box of an object (including its children),\r\n\t\t\t// accounting for both the object's, and childrens', world transforms\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function ( object ) {\r\n\t\r\n\t\t\t\tvar scope = this;\r\n\t\r\n\t\t\t\tobject.updateMatrixWorld( true );\r\n\t\r\n\t\t\t\tthis.makeEmpty();\r\n\t\r\n\t\t\t\tobject.traverse( function ( node ) {\r\n\t\r\n\t\t\t\t\tvar geometry = node.geometry;\r\n\t\r\n\t\t\t\t\tif ( geometry !== undefined ) {\r\n\t\r\n\t\t\t\t\t\tif ( geometry instanceof THREE.Geometry ) {\r\n\t\r\n\t\t\t\t\t\t\tvar vertices = geometry.vertices;\r\n\t\r\n\t\t\t\t\t\t\tfor ( var i = 0, il = vertices.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\tv1.copy( vertices[ i ] );\r\n\t\r\n\t\t\t\t\t\t\t\tv1.applyMatrix4( node.matrixWorld );\r\n\t\r\n\t\t\t\t\t\t\t\tscope.expandByPoint( v1 );\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t} else if ( geometry instanceof THREE.BufferGeometry && geometry.attributes[ 'position' ] !== undefined ) {\r\n\t\r\n\t\t\t\t\t\t\tvar positions = geometry.attributes[ 'position' ].array;\r\n\t\r\n\t\t\t\t\t\t\tfor ( var i = 0, il = positions.length; i < il; i += 3 ) {\r\n\t\r\n\t\t\t\t\t\t\t\tv1.set( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );\r\n\t\r\n\t\t\t\t\t\t\t\tv1.applyMatrix4( node.matrixWorld );\r\n\t\r\n\t\t\t\t\t\t\t\tscope.expandByPoint( v1 );\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tcopy: function ( box ) {\r\n\t\r\n\t\t\tthis.min.copy( box.min );\r\n\t\t\tthis.max.copy( box.max );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmakeEmpty: function () {\r\n\t\r\n\t\t\tthis.min.x = this.min.y = this.min.z = Infinity;\r\n\t\t\tthis.max.x = this.max.y = this.max.z = - Infinity;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tempty: function () {\r\n\t\r\n\t\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\r\n\t\r\n\t\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcenter: function ( optionalTarget ) {\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\t\treturn result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsize: function ( optionalTarget ) {\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\t\treturn result.subVectors( this.max, this.min );\r\n\t\r\n\t\t},\r\n\t\r\n\t\texpandByPoint: function ( point ) {\r\n\t\r\n\t\t\tthis.min.min( point );\r\n\t\t\tthis.max.max( point );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\texpandByVector: function ( vector ) {\r\n\t\r\n\t\t\tthis.min.sub( vector );\r\n\t\t\tthis.max.add( vector );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\texpandByScalar: function ( scalar ) {\r\n\t\r\n\t\t\tthis.min.addScalar( - scalar );\r\n\t\t\tthis.max.addScalar( scalar );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcontainsPoint: function ( point ) {\r\n\t\r\n\t\t\tif ( point.x < this.min.x || point.x > this.max.x ||\r\n\t\t\t     point.y < this.min.y || point.y > this.max.y ||\r\n\t\t\t     point.z < this.min.z || point.z > this.max.z ) {\r\n\t\r\n\t\t\t\treturn false;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn true;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcontainsBox: function ( box ) {\r\n\t\r\n\t\t\tif ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&\r\n\t\t\t\t ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) &&\r\n\t\t\t\t ( this.min.z <= box.min.z ) && ( box.max.z <= this.max.z ) ) {\r\n\t\r\n\t\t\t\treturn true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn false;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetParameter: function ( point, optionalTarget ) {\r\n\t\r\n\t\t\t// This can potentially have a divide by zero if the box\r\n\t\t\t// has a size dimension of 0.\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\r\n\t\t\treturn result.set(\r\n\t\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\r\n\t\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y ),\r\n\t\t\t\t( point.z - this.min.z ) / ( this.max.z - this.min.z )\r\n\t\t\t);\r\n\t\r\n\t\t},\r\n\t\r\n\t\tisIntersectionBox: function ( box ) {\r\n\t\r\n\t\t\t// using 6 splitting planes to rule out intersections.\r\n\t\r\n\t\t\tif ( box.max.x < this.min.x || box.min.x > this.max.x ||\r\n\t\t\t     box.max.y < this.min.y || box.min.y > this.max.y ||\r\n\t\t\t     box.max.z < this.min.z || box.min.z > this.max.z ) {\r\n\t\r\n\t\t\t\treturn false;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn true;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclampPoint: function ( point, optionalTarget ) {\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\t\treturn result.copy( point ).clamp( this.min, this.max );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdistanceToPoint: function () {\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function ( point ) {\r\n\t\r\n\t\t\t\tvar clampedPoint = v1.copy( point ).clamp( this.min, this.max );\r\n\t\t\t\treturn clampedPoint.sub( point ).length();\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tgetBoundingSphere: function () {\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function ( optionalTarget ) {\r\n\t\r\n\t\t\t\tvar result = optionalTarget || new THREE.Sphere();\r\n\t\r\n\t\t\t\tresult.center = this.center();\r\n\t\t\t\tresult.radius = this.size( v1 ).length() * 0.5;\r\n\t\r\n\t\t\t\treturn result;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tintersect: function ( box ) {\r\n\t\r\n\t\t\tthis.min.max( box.min );\r\n\t\t\tthis.max.min( box.max );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tunion: function ( box ) {\r\n\t\r\n\t\t\tthis.min.min( box.min );\r\n\t\t\tthis.max.max( box.max );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tapplyMatrix4: function () {\r\n\t\r\n\t\t\tvar points = [\r\n\t\t\t\tnew THREE.Vector3(),\r\n\t\t\t\tnew THREE.Vector3(),\r\n\t\t\t\tnew THREE.Vector3(),\r\n\t\t\t\tnew THREE.Vector3(),\r\n\t\t\t\tnew THREE.Vector3(),\r\n\t\t\t\tnew THREE.Vector3(),\r\n\t\t\t\tnew THREE.Vector3(),\r\n\t\t\t\tnew THREE.Vector3()\r\n\t\t\t];\r\n\t\r\n\t\t\treturn function ( matrix ) {\r\n\t\r\n\t\t\t\t// NOTE: I am using a binary pattern to specify all 2^3 combinations below\r\n\t\t\t\tpoints[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000\r\n\t\t\t\tpoints[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001\r\n\t\t\t\tpoints[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010\r\n\t\t\t\tpoints[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011\r\n\t\t\t\tpoints[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100\r\n\t\t\t\tpoints[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101\r\n\t\t\t\tpoints[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110\r\n\t\t\t\tpoints[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix );  // 111\r\n\t\r\n\t\t\t\tthis.makeEmpty();\r\n\t\t\t\tthis.setFromPoints( points );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\ttranslate: function ( offset ) {\r\n\t\r\n\t\t\tthis.min.add( offset );\r\n\t\t\tthis.max.add( offset );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tequals: function ( box ) {\r\n\t\r\n\t\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new THREE.Box3().copy( this );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/math/Matrix3.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t * @author bhouston / http://exocortex.com\r\n\t */\r\n\t\r\n\tTHREE.Matrix3 = function () {\r\n\t\r\n\t\tthis.elements = new Float32Array( [\r\n\t\r\n\t\t\t1, 0, 0,\r\n\t\t\t0, 1, 0,\r\n\t\t\t0, 0, 1\r\n\t\r\n\t\t] );\r\n\t\r\n\t\tif ( arguments.length > 0 ) {\r\n\t\r\n\t\t\tTHREE.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Matrix3.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Matrix3,\r\n\t\r\n\t\tset: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\r\n\t\t\tte[ 0 ] = n11; te[ 3 ] = n12; te[ 6 ] = n13;\r\n\t\t\tte[ 1 ] = n21; te[ 4 ] = n22; te[ 7 ] = n23;\r\n\t\t\tte[ 2 ] = n31; te[ 5 ] = n32; te[ 8 ] = n33;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tidentity: function () {\r\n\t\r\n\t\t\tthis.set(\r\n\t\r\n\t\t\t\t1, 0, 0,\r\n\t\t\t\t0, 1, 0,\r\n\t\t\t\t0, 0, 1\r\n\t\r\n\t\t\t);\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( m ) {\r\n\t\r\n\t\t\tvar me = m.elements;\r\n\t\r\n\t\t\tthis.set(\r\n\t\r\n\t\t\t\tme[ 0 ], me[ 3 ], me[ 6 ],\r\n\t\t\t\tme[ 1 ], me[ 4 ], me[ 7 ],\r\n\t\t\t\tme[ 2 ], me[ 5 ], me[ 8 ]\r\n\t\r\n\t\t\t);\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmultiplyVector3: function ( vector ) {\r\n\t\r\n\t\t\tTHREE.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );\r\n\t\t\treturn vector.applyMatrix3( this );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmultiplyVector3Array: function ( a ) {\r\n\t\r\n\t\t\tTHREE.warn( 'THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );\r\n\t\t\treturn this.applyToVector3Array( a );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tapplyToVector3Array: function () {\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function ( array, offset, length ) {\r\n\t\r\n\t\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\t\t\tif ( length === undefined ) length = array.length;\r\n\t\r\n\t\t\t\tfor ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {\r\n\t\r\n\t\t\t\t\tv1.x = array[ j ];\r\n\t\t\t\t\tv1.y = array[ j + 1 ];\r\n\t\t\t\t\tv1.z = array[ j + 2 ];\r\n\t\r\n\t\t\t\t\tv1.applyMatrix3( this );\r\n\t\r\n\t\t\t\t\tarray[ j ]     = v1.x;\r\n\t\t\t\t\tarray[ j + 1 ] = v1.y;\r\n\t\t\t\t\tarray[ j + 2 ] = v1.z;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn array;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tmultiplyScalar: function ( s ) {\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\r\n\t\t\tte[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;\r\n\t\t\tte[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;\r\n\t\t\tte[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdeterminant: function () {\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\r\n\t\t\tvar a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],\r\n\t\t\t\td = te[ 3 ], e = te[ 4 ], f = te[ 5 ],\r\n\t\t\t\tg = te[ 6 ], h = te[ 7 ], i = te[ 8 ];\r\n\t\r\n\t\t\treturn a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetInverse: function ( matrix, throwOnInvertible ) {\r\n\t\r\n\t\t\t// input: THREE.Matrix4\r\n\t\t\t// ( based on http://code.google.com/p/webgl-mjs/ )\r\n\t\r\n\t\t\tvar me = matrix.elements;\r\n\t\t\tvar te = this.elements;\r\n\t\r\n\t\t\tte[ 0 ] =   me[ 10 ] * me[ 5 ] - me[ 6 ] * me[ 9 ];\r\n\t\t\tte[ 1 ] = - me[ 10 ] * me[ 1 ] + me[ 2 ] * me[ 9 ];\r\n\t\t\tte[ 2 ] =   me[ 6 ] * me[ 1 ] - me[ 2 ] * me[ 5 ];\r\n\t\t\tte[ 3 ] = - me[ 10 ] * me[ 4 ] + me[ 6 ] * me[ 8 ];\r\n\t\t\tte[ 4 ] =   me[ 10 ] * me[ 0 ] - me[ 2 ] * me[ 8 ];\r\n\t\t\tte[ 5 ] = - me[ 6 ] * me[ 0 ] + me[ 2 ] * me[ 4 ];\r\n\t\t\tte[ 6 ] =   me[ 9 ] * me[ 4 ] - me[ 5 ] * me[ 8 ];\r\n\t\t\tte[ 7 ] = - me[ 9 ] * me[ 0 ] + me[ 1 ] * me[ 8 ];\r\n\t\t\tte[ 8 ] =   me[ 5 ] * me[ 0 ] - me[ 1 ] * me[ 4 ];\r\n\t\r\n\t\t\tvar det = me[ 0 ] * te[ 0 ] + me[ 1 ] * te[ 3 ] + me[ 2 ] * te[ 6 ];\r\n\t\r\n\t\t\t// no inverse\r\n\t\r\n\t\t\tif ( det === 0 ) {\r\n\t\r\n\t\t\t\tvar msg = \"Matrix3.getInverse(): can't invert matrix, determinant is 0\";\r\n\t\r\n\t\t\t\tif ( throwOnInvertible || false ) {\r\n\t\r\n\t\t\t\t\tthrow new Error( msg );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tTHREE.warn( msg );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tthis.identity();\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.multiplyScalar( 1.0 / det );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttranspose: function () {\r\n\t\r\n\t\t\tvar tmp, m = this.elements;\r\n\t\r\n\t\t\ttmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;\r\n\t\t\ttmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;\r\n\t\t\ttmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tflattenToArrayOffset: function ( array, offset ) {\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\r\n\t\t\tarray[ offset     ] = te[ 0 ];\r\n\t\t\tarray[ offset + 1 ] = te[ 1 ];\r\n\t\t\tarray[ offset + 2 ] = te[ 2 ];\r\n\t\r\n\t\t\tarray[ offset + 3 ] = te[ 3 ];\r\n\t\t\tarray[ offset + 4 ] = te[ 4 ];\r\n\t\t\tarray[ offset + 5 ] = te[ 5 ];\r\n\t\r\n\t\t\tarray[ offset + 6 ] = te[ 6 ];\r\n\t\t\tarray[ offset + 7 ] = te[ 7 ];\r\n\t\t\tarray[ offset + 8 ]  = te[ 8 ];\r\n\t\r\n\t\t\treturn array;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetNormalMatrix: function ( m ) {\r\n\t\r\n\t\t\t// input: THREE.Matrix4\r\n\t\r\n\t\t\tthis.getInverse( m ).transpose();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttransposeIntoArray: function ( r ) {\r\n\t\r\n\t\t\tvar m = this.elements;\r\n\t\r\n\t\t\tr[ 0 ] = m[ 0 ];\r\n\t\t\tr[ 1 ] = m[ 3 ];\r\n\t\t\tr[ 2 ] = m[ 6 ];\r\n\t\t\tr[ 3 ] = m[ 1 ];\r\n\t\t\tr[ 4 ] = m[ 4 ];\r\n\t\t\tr[ 5 ] = m[ 7 ];\r\n\t\t\tr[ 6 ] = m[ 2 ];\r\n\t\t\tr[ 7 ] = m[ 5 ];\r\n\t\t\tr[ 8 ] = m[ 8 ];\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfromArray: function ( array ) {\r\n\t\r\n\t\t\tthis.elements.set( array );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttoArray: function () {\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\r\n\t\t\treturn [\r\n\t\t\t\tte[ 0 ], te[ 1 ], te[ 2 ],\r\n\t\t\t\tte[ 3 ], te[ 4 ], te[ 5 ],\r\n\t\t\t\tte[ 6 ], te[ 7 ], te[ 8 ]\r\n\t\t\t];\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new THREE.Matrix3().fromArray( this.elements );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/math/Matrix4.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author supereggbert / http://www.paulbrunt.co.uk/\r\n\t * @author philogb / http://blog.thejit.org/\r\n\t * @author jordi_ros / http://plattsoft.com\r\n\t * @author D1plo1d / http://github.com/D1plo1d\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author mikael emtinger / http://gomo.se/\r\n\t * @author timknip / http://www.floorplanner.com/\r\n\t * @author bhouston / http://exocortex.com\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t */\r\n\t\r\n\tTHREE.Matrix4 = function () {\r\n\t\r\n\t\tthis.elements = new Float32Array( [\r\n\t\r\n\t\t\t1, 0, 0, 0,\r\n\t\t\t0, 1, 0, 0,\r\n\t\t\t0, 0, 1, 0,\r\n\t\t\t0, 0, 0, 1\r\n\t\r\n\t\t] );\r\n\t\r\n\t\tif ( arguments.length > 0 ) {\r\n\t\r\n\t\t\tTHREE.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Matrix4.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Matrix4,\r\n\t\r\n\t\tset: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\r\n\t\t\tte[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;\r\n\t\t\tte[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;\r\n\t\t\tte[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;\r\n\t\t\tte[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tidentity: function () {\r\n\t\r\n\t\t\tthis.set(\r\n\t\r\n\t\t\t\t1, 0, 0, 0,\r\n\t\t\t\t0, 1, 0, 0,\r\n\t\t\t\t0, 0, 1, 0,\r\n\t\t\t\t0, 0, 0, 1\r\n\t\r\n\t\t\t);\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( m ) {\r\n\t\r\n\t\t\tthis.elements.set( m.elements );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\textractPosition: function ( m ) {\r\n\t\r\n\t\t\tTHREE.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );\r\n\t\t\treturn this.copyPosition( m );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopyPosition: function ( m ) {\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\t\tvar me = m.elements;\r\n\t\r\n\t\t\tte[ 12 ] = me[ 12 ];\r\n\t\t\tte[ 13 ] = me[ 13 ];\r\n\t\t\tte[ 14 ] = me[ 14 ];\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\textractBasis: function ( xAxis, yAxis, zAxis ) {\r\n\t \r\n\t\t\tvar te = this.elements;\r\n\t \r\n\t\t\txAxis.set( te[ 0 ], te[ 1 ], te[ 2 ] );\r\n\t\t\tyAxis.set( te[ 4 ], te[ 5 ], te[ 6 ] );\r\n\t\t\tzAxis.set( te[ 8 ], te[ 9 ], te[ 10 ] );\r\n\t \r\n\t\t\treturn this;\r\n\t \t\t\r\n\t\t},\r\n\t \r\n\t\tmakeBasis: function ( xAxis, yAxis, zAxis ) {\r\n\t\r\n\t\t\tthis.set(\r\n\t\t\t\txAxis.x, yAxis.x, zAxis.x, 0,\r\n\t\t\t\txAxis.y, yAxis.y, zAxis.y, 0,\r\n\t\t\t\txAxis.z, yAxis.z, zAxis.z, 0,\r\n\t\t\t\t0,       0,       0,       1\r\n\t\t\t);\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\textractRotation: function () {\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function ( m ) {\r\n\t\r\n\t\t\t\tvar te = this.elements;\r\n\t\t\t\tvar me = m.elements;\r\n\t\r\n\t\t\t\tvar scaleX = 1 / v1.set( me[ 0 ], me[ 1 ], me[ 2 ] ).length();\r\n\t\t\t\tvar scaleY = 1 / v1.set( me[ 4 ], me[ 5 ], me[ 6 ] ).length();\r\n\t\t\t\tvar scaleZ = 1 / v1.set( me[ 8 ], me[ 9 ], me[ 10 ] ).length();\r\n\t\r\n\t\t\t\tte[ 0 ] = me[ 0 ] * scaleX;\r\n\t\t\t\tte[ 1 ] = me[ 1 ] * scaleX;\r\n\t\t\t\tte[ 2 ] = me[ 2 ] * scaleX;\r\n\t\r\n\t\t\t\tte[ 4 ] = me[ 4 ] * scaleY;\r\n\t\t\t\tte[ 5 ] = me[ 5 ] * scaleY;\r\n\t\t\t\tte[ 6 ] = me[ 6 ] * scaleY;\r\n\t\r\n\t\t\t\tte[ 8 ] = me[ 8 ] * scaleZ;\r\n\t\t\t\tte[ 9 ] = me[ 9 ] * scaleZ;\r\n\t\t\t\tte[ 10 ] = me[ 10 ] * scaleZ;\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tmakeRotationFromEuler: function ( euler ) {\r\n\t\r\n\t\t\tif ( euler instanceof THREE.Euler === false ) {\r\n\t\r\n\t\t\t\tTHREE.error( 'THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\r\n\t\t\tvar x = euler.x, y = euler.y, z = euler.z;\r\n\t\t\tvar a = Math.cos( x ), b = Math.sin( x );\r\n\t\t\tvar c = Math.cos( y ), d = Math.sin( y );\r\n\t\t\tvar e = Math.cos( z ), f = Math.sin( z );\r\n\t\r\n\t\t\tif ( euler.order === 'XYZ' ) {\r\n\t\r\n\t\t\t\tvar ae = a * e, af = a * f, be = b * e, bf = b * f;\r\n\t\r\n\t\t\t\tte[ 0 ] = c * e;\r\n\t\t\t\tte[ 4 ] = - c * f;\r\n\t\t\t\tte[ 8 ] = d;\r\n\t\r\n\t\t\t\tte[ 1 ] = af + be * d;\r\n\t\t\t\tte[ 5 ] = ae - bf * d;\r\n\t\t\t\tte[ 9 ] = - b * c;\r\n\t\r\n\t\t\t\tte[ 2 ] = bf - ae * d;\r\n\t\t\t\tte[ 6 ] = be + af * d;\r\n\t\t\t\tte[ 10 ] = a * c;\r\n\t\r\n\t\t\t} else if ( euler.order === 'YXZ' ) {\r\n\t\r\n\t\t\t\tvar ce = c * e, cf = c * f, de = d * e, df = d * f;\r\n\t\r\n\t\t\t\tte[ 0 ] = ce + df * b;\r\n\t\t\t\tte[ 4 ] = de * b - cf;\r\n\t\t\t\tte[ 8 ] = a * d;\r\n\t\r\n\t\t\t\tte[ 1 ] = a * f;\r\n\t\t\t\tte[ 5 ] = a * e;\r\n\t\t\t\tte[ 9 ] = - b;\r\n\t\r\n\t\t\t\tte[ 2 ] = cf * b - de;\r\n\t\t\t\tte[ 6 ] = df + ce * b;\r\n\t\t\t\tte[ 10 ] = a * c;\r\n\t\r\n\t\t\t} else if ( euler.order === 'ZXY' ) {\r\n\t\r\n\t\t\t\tvar ce = c * e, cf = c * f, de = d * e, df = d * f;\r\n\t\r\n\t\t\t\tte[ 0 ] = ce - df * b;\r\n\t\t\t\tte[ 4 ] = - a * f;\r\n\t\t\t\tte[ 8 ] = de + cf * b;\r\n\t\r\n\t\t\t\tte[ 1 ] = cf + de * b;\r\n\t\t\t\tte[ 5 ] = a * e;\r\n\t\t\t\tte[ 9 ] = df - ce * b;\r\n\t\r\n\t\t\t\tte[ 2 ] = - a * d;\r\n\t\t\t\tte[ 6 ] = b;\r\n\t\t\t\tte[ 10 ] = a * c;\r\n\t\r\n\t\t\t} else if ( euler.order === 'ZYX' ) {\r\n\t\r\n\t\t\t\tvar ae = a * e, af = a * f, be = b * e, bf = b * f;\r\n\t\r\n\t\t\t\tte[ 0 ] = c * e;\r\n\t\t\t\tte[ 4 ] = be * d - af;\r\n\t\t\t\tte[ 8 ] = ae * d + bf;\r\n\t\r\n\t\t\t\tte[ 1 ] = c * f;\r\n\t\t\t\tte[ 5 ] = bf * d + ae;\r\n\t\t\t\tte[ 9 ] = af * d - be;\r\n\t\r\n\t\t\t\tte[ 2 ] = - d;\r\n\t\t\t\tte[ 6 ] = b * c;\r\n\t\t\t\tte[ 10 ] = a * c;\r\n\t\r\n\t\t\t} else if ( euler.order === 'YZX' ) {\r\n\t\r\n\t\t\t\tvar ac = a * c, ad = a * d, bc = b * c, bd = b * d;\r\n\t\r\n\t\t\t\tte[ 0 ] = c * e;\r\n\t\t\t\tte[ 4 ] = bd - ac * f;\r\n\t\t\t\tte[ 8 ] = bc * f + ad;\r\n\t\r\n\t\t\t\tte[ 1 ] = f;\r\n\t\t\t\tte[ 5 ] = a * e;\r\n\t\t\t\tte[ 9 ] = - b * e;\r\n\t\r\n\t\t\t\tte[ 2 ] = - d * e;\r\n\t\t\t\tte[ 6 ] = ad * f + bc;\r\n\t\t\t\tte[ 10 ] = ac - bd * f;\r\n\t\r\n\t\t\t} else if ( euler.order === 'XZY' ) {\r\n\t\r\n\t\t\t\tvar ac = a * c, ad = a * d, bc = b * c, bd = b * d;\r\n\t\r\n\t\t\t\tte[ 0 ] = c * e;\r\n\t\t\t\tte[ 4 ] = - f;\r\n\t\t\t\tte[ 8 ] = d * e;\r\n\t\r\n\t\t\t\tte[ 1 ] = ac * f + bd;\r\n\t\t\t\tte[ 5 ] = a * e;\r\n\t\t\t\tte[ 9 ] = ad * f - bc;\r\n\t\r\n\t\t\t\tte[ 2 ] = bc * f - ad;\r\n\t\t\t\tte[ 6 ] = b * e;\r\n\t\t\t\tte[ 10 ] = bd * f + ac;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// last column\r\n\t\t\tte[ 3 ] = 0;\r\n\t\t\tte[ 7 ] = 0;\r\n\t\t\tte[ 11 ] = 0;\r\n\t\r\n\t\t\t// bottom row\r\n\t\t\tte[ 12 ] = 0;\r\n\t\t\tte[ 13 ] = 0;\r\n\t\t\tte[ 14 ] = 0;\r\n\t\t\tte[ 15 ] = 1;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetRotationFromQuaternion: function ( q ) {\r\n\t\r\n\t\t\tTHREE.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );\r\n\t\r\n\t\t\treturn this.makeRotationFromQuaternion( q );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmakeRotationFromQuaternion: function ( q ) {\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\r\n\t\t\tvar x = q.x, y = q.y, z = q.z, w = q.w;\r\n\t\t\tvar x2 = x + x, y2 = y + y, z2 = z + z;\r\n\t\t\tvar xx = x * x2, xy = x * y2, xz = x * z2;\r\n\t\t\tvar yy = y * y2, yz = y * z2, zz = z * z2;\r\n\t\t\tvar wx = w * x2, wy = w * y2, wz = w * z2;\r\n\t\r\n\t\t\tte[ 0 ] = 1 - ( yy + zz );\r\n\t\t\tte[ 4 ] = xy - wz;\r\n\t\t\tte[ 8 ] = xz + wy;\r\n\t\r\n\t\t\tte[ 1 ] = xy + wz;\r\n\t\t\tte[ 5 ] = 1 - ( xx + zz );\r\n\t\t\tte[ 9 ] = yz - wx;\r\n\t\r\n\t\t\tte[ 2 ] = xz - wy;\r\n\t\t\tte[ 6 ] = yz + wx;\r\n\t\t\tte[ 10 ] = 1 - ( xx + yy );\r\n\t\r\n\t\t\t// last column\r\n\t\t\tte[ 3 ] = 0;\r\n\t\t\tte[ 7 ] = 0;\r\n\t\t\tte[ 11 ] = 0;\r\n\t\r\n\t\t\t// bottom row\r\n\t\t\tte[ 12 ] = 0;\r\n\t\t\tte[ 13 ] = 0;\r\n\t\t\tte[ 14 ] = 0;\r\n\t\t\tte[ 15 ] = 1;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlookAt: function () {\r\n\t\r\n\t\t\tvar x = new THREE.Vector3();\r\n\t\t\tvar y = new THREE.Vector3();\r\n\t\t\tvar z = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function ( eye, target, up ) {\r\n\t\r\n\t\t\t\tvar te = this.elements;\r\n\t\r\n\t\t\t\tz.subVectors( eye, target ).normalize();\r\n\t\r\n\t\t\t\tif ( z.length() === 0 ) {\r\n\t\r\n\t\t\t\t\tz.z = 1;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tx.crossVectors( up, z ).normalize();\r\n\t\r\n\t\t\t\tif ( x.length() === 0 ) {\r\n\t\r\n\t\t\t\t\tz.x += 0.0001;\r\n\t\t\t\t\tx.crossVectors( up, z ).normalize();\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\ty.crossVectors( z, x );\r\n\t\r\n\t\r\n\t\t\t\tte[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;\r\n\t\t\t\tte[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;\r\n\t\t\t\tte[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tmultiply: function ( m, n ) {\r\n\t\r\n\t\t\tif ( n !== undefined ) {\r\n\t\r\n\t\t\t\tTHREE.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );\r\n\t\t\t\treturn this.multiplyMatrices( m, n );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this.multiplyMatrices( this, m );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmultiplyMatrices: function ( a, b ) {\r\n\t\r\n\t\t\tvar ae = a.elements;\r\n\t\t\tvar be = b.elements;\r\n\t\t\tvar te = this.elements;\r\n\t\r\n\t\t\tvar a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];\r\n\t\t\tvar a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];\r\n\t\t\tvar a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];\r\n\t\t\tvar a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];\r\n\t\r\n\t\t\tvar b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];\r\n\t\t\tvar b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];\r\n\t\t\tvar b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];\r\n\t\t\tvar b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];\r\n\t\r\n\t\t\tte[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\r\n\t\t\tte[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\r\n\t\t\tte[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\r\n\t\t\tte[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\r\n\t\r\n\t\t\tte[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\r\n\t\t\tte[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\r\n\t\t\tte[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\r\n\t\t\tte[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\r\n\t\r\n\t\t\tte[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\r\n\t\t\tte[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\r\n\t\t\tte[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\r\n\t\t\tte[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\r\n\t\r\n\t\t\tte[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\r\n\t\t\tte[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\r\n\t\t\tte[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\r\n\t\t\tte[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmultiplyToArray: function ( a, b, r ) {\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\r\n\t\t\tthis.multiplyMatrices( a, b );\r\n\t\r\n\t\t\tr[ 0 ] = te[ 0 ]; r[ 1 ] = te[ 1 ]; r[ 2 ] = te[ 2 ]; r[ 3 ] = te[ 3 ];\r\n\t\t\tr[ 4 ] = te[ 4 ]; r[ 5 ] = te[ 5 ]; r[ 6 ] = te[ 6 ]; r[ 7 ] = te[ 7 ];\r\n\t\t\tr[ 8 ]  = te[ 8 ]; r[ 9 ]  = te[ 9 ]; r[ 10 ] = te[ 10 ]; r[ 11 ] = te[ 11 ];\r\n\t\t\tr[ 12 ] = te[ 12 ]; r[ 13 ] = te[ 13 ]; r[ 14 ] = te[ 14 ]; r[ 15 ] = te[ 15 ];\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmultiplyScalar: function ( s ) {\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\r\n\t\t\tte[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;\r\n\t\t\tte[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;\r\n\t\t\tte[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;\r\n\t\t\tte[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmultiplyVector3: function ( vector ) {\r\n\t\r\n\t\t\tTHREE.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.' );\r\n\t\t\treturn vector.applyProjection( this );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmultiplyVector4: function ( vector ) {\r\n\t\r\n\t\t\tTHREE.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\r\n\t\t\treturn vector.applyMatrix4( this );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmultiplyVector3Array: function ( a ) {\r\n\t\r\n\t\t\tTHREE.warn( 'THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );\r\n\t\t\treturn this.applyToVector3Array( a );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tapplyToVector3Array: function () {\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function ( array, offset, length ) {\r\n\t\r\n\t\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\t\t\tif ( length === undefined ) length = array.length;\r\n\t\r\n\t\t\t\tfor ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {\r\n\t\r\n\t\t\t\t\tv1.x = array[ j ];\r\n\t\t\t\t\tv1.y = array[ j + 1 ];\r\n\t\t\t\t\tv1.z = array[ j + 2 ];\r\n\t\r\n\t\t\t\t\tv1.applyMatrix4( this );\r\n\t\r\n\t\t\t\t\tarray[ j ]     = v1.x;\r\n\t\t\t\t\tarray[ j + 1 ] = v1.y;\r\n\t\t\t\t\tarray[ j + 2 ] = v1.z;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn array;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\trotateAxis: function ( v ) {\r\n\t\r\n\t\t\tTHREE.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );\r\n\t\r\n\t\t\tv.transformDirection( this );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcrossVector: function ( vector ) {\r\n\t\r\n\t\t\tTHREE.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\r\n\t\t\treturn vector.applyMatrix4( this );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdeterminant: function () {\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\r\n\t\t\tvar n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];\r\n\t\t\tvar n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];\r\n\t\t\tvar n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];\r\n\t\t\tvar n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];\r\n\t\r\n\t\t\t//TODO: make this more efficient\r\n\t\t\t//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )\r\n\t\r\n\t\t\treturn (\r\n\t\t\t\tn41 * (\r\n\t\t\t\t\t+ n14 * n23 * n32\r\n\t\t\t\t\t - n13 * n24 * n32\r\n\t\t\t\t\t - n14 * n22 * n33\r\n\t\t\t\t\t + n12 * n24 * n33\r\n\t\t\t\t\t + n13 * n22 * n34\r\n\t\t\t\t\t - n12 * n23 * n34\r\n\t\t\t\t) +\r\n\t\t\t\tn42 * (\r\n\t\t\t\t\t+ n11 * n23 * n34\r\n\t\t\t\t\t - n11 * n24 * n33\r\n\t\t\t\t\t + n14 * n21 * n33\r\n\t\t\t\t\t - n13 * n21 * n34\r\n\t\t\t\t\t + n13 * n24 * n31\r\n\t\t\t\t\t - n14 * n23 * n31\r\n\t\t\t\t) +\r\n\t\t\t\tn43 * (\r\n\t\t\t\t\t+ n11 * n24 * n32\r\n\t\t\t\t\t - n11 * n22 * n34\r\n\t\t\t\t\t - n14 * n21 * n32\r\n\t\t\t\t\t + n12 * n21 * n34\r\n\t\t\t\t\t + n14 * n22 * n31\r\n\t\t\t\t\t - n12 * n24 * n31\r\n\t\t\t\t) +\r\n\t\t\t\tn44 * (\r\n\t\t\t\t\t- n13 * n22 * n31\r\n\t\t\t\t\t - n11 * n23 * n32\r\n\t\t\t\t\t + n11 * n22 * n33\r\n\t\t\t\t\t + n13 * n21 * n32\r\n\t\t\t\t\t - n12 * n21 * n33\r\n\t\t\t\t\t + n12 * n23 * n31\r\n\t\t\t\t)\r\n\t\r\n\t\t\t);\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttranspose: function () {\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\t\tvar tmp;\r\n\t\r\n\t\t\ttmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;\r\n\t\t\ttmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;\r\n\t\t\ttmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;\r\n\t\r\n\t\t\ttmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;\r\n\t\t\ttmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;\r\n\t\t\ttmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tflattenToArrayOffset: function ( array, offset ) {\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\r\n\t\t\tarray[ offset     ] = te[ 0 ];\r\n\t\t\tarray[ offset + 1 ] = te[ 1 ];\r\n\t\t\tarray[ offset + 2 ] = te[ 2 ];\r\n\t\t\tarray[ offset + 3 ] = te[ 3 ];\r\n\t\r\n\t\t\tarray[ offset + 4 ] = te[ 4 ];\r\n\t\t\tarray[ offset + 5 ] = te[ 5 ];\r\n\t\t\tarray[ offset + 6 ] = te[ 6 ];\r\n\t\t\tarray[ offset + 7 ] = te[ 7 ];\r\n\t\r\n\t\t\tarray[ offset + 8 ]  = te[ 8 ];\r\n\t\t\tarray[ offset + 9 ]  = te[ 9 ];\r\n\t\t\tarray[ offset + 10 ] = te[ 10 ];\r\n\t\t\tarray[ offset + 11 ] = te[ 11 ];\r\n\t\r\n\t\t\tarray[ offset + 12 ] = te[ 12 ];\r\n\t\t\tarray[ offset + 13 ] = te[ 13 ];\r\n\t\t\tarray[ offset + 14 ] = te[ 14 ];\r\n\t\t\tarray[ offset + 15 ] = te[ 15 ];\r\n\t\r\n\t\t\treturn array;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetPosition: function () {\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function () {\r\n\t\r\n\t\t\t\tTHREE.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );\r\n\t\r\n\t\t\t\tvar te = this.elements;\r\n\t\t\t\treturn v1.set( te[ 12 ], te[ 13 ], te[ 14 ] );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tsetPosition: function ( v ) {\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\r\n\t\t\tte[ 12 ] = v.x;\r\n\t\t\tte[ 13 ] = v.y;\r\n\t\t\tte[ 14 ] = v.z;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetInverse: function ( m, throwOnInvertible ) {\r\n\t\r\n\t\t\t// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\r\n\t\t\tvar te = this.elements;\r\n\t\t\tvar me = m.elements;\r\n\t\r\n\t\t\tvar n11 = me[ 0 ], n12 = me[ 4 ], n13 = me[ 8 ], n14 = me[ 12 ];\r\n\t\t\tvar n21 = me[ 1 ], n22 = me[ 5 ], n23 = me[ 9 ], n24 = me[ 13 ];\r\n\t\t\tvar n31 = me[ 2 ], n32 = me[ 6 ], n33 = me[ 10 ], n34 = me[ 14 ];\r\n\t\t\tvar n41 = me[ 3 ], n42 = me[ 7 ], n43 = me[ 11 ], n44 = me[ 15 ];\r\n\t\r\n\t\t\tte[ 0 ] = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44;\r\n\t\t\tte[ 4 ] = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44;\r\n\t\t\tte[ 8 ] = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44;\r\n\t\t\tte[ 12 ] = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;\r\n\t\t\tte[ 1 ] = n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44;\r\n\t\t\tte[ 5 ] = n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44;\r\n\t\t\tte[ 9 ] = n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44;\r\n\t\t\tte[ 13 ] = n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34;\r\n\t\t\tte[ 2 ] = n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44;\r\n\t\t\tte[ 6 ] = n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44;\r\n\t\t\tte[ 10 ] = n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44;\r\n\t\t\tte[ 14 ] = n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34;\r\n\t\t\tte[ 3 ] = n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43;\r\n\t\t\tte[ 7 ] = n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43;\r\n\t\t\tte[ 11 ] = n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43;\r\n\t\t\tte[ 15 ] = n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33;\r\n\t\r\n\t\t\tvar det = n11 * te[ 0 ] + n21 * te[ 4 ] + n31 * te[ 8 ] + n41 * te[ 12 ];\r\n\t\r\n\t\t\tif ( det == 0 ) {\r\n\t\r\n\t\t\t\tvar msg = \"THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0\";\r\n\t\r\n\t\t\t\tif ( throwOnInvertible || false ) {\r\n\t\r\n\t\t\t\t\tthrow new Error( msg );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tTHREE.warn( msg );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tthis.identity();\r\n\t\r\n\t\t\t\treturn this;\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.multiplyScalar( 1 / det );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttranslate: function ( v ) {\r\n\t\r\n\t\t\tTHREE.error( 'THREE.Matrix4: .translate() has been removed.' );\r\n\t\r\n\t\t},\r\n\t\r\n\t\trotateX: function ( angle ) {\r\n\t\r\n\t\t\tTHREE.error( 'THREE.Matrix4: .rotateX() has been removed.' );\r\n\t\r\n\t\t},\r\n\t\r\n\t\trotateY: function ( angle ) {\r\n\t\r\n\t\t\tTHREE.error( 'THREE.Matrix4: .rotateY() has been removed.' );\r\n\t\r\n\t\t},\r\n\t\r\n\t\trotateZ: function ( angle ) {\r\n\t\r\n\t\t\tTHREE.error( 'THREE.Matrix4: .rotateZ() has been removed.' );\r\n\t\r\n\t\t},\r\n\t\r\n\t\trotateByAxis: function ( axis, angle ) {\r\n\t\r\n\t\t\tTHREE.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tscale: function ( v ) {\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\t\tvar x = v.x, y = v.y, z = v.z;\r\n\t\r\n\t\t\tte[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;\r\n\t\t\tte[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;\r\n\t\t\tte[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;\r\n\t\t\tte[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetMaxScaleOnAxis: function () {\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\r\n\t\t\tvar scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];\r\n\t\t\tvar scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];\r\n\t\t\tvar scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];\r\n\t\r\n\t\t\treturn Math.sqrt( Math.max( scaleXSq, Math.max( scaleYSq, scaleZSq ) ) );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmakeTranslation: function ( x, y, z ) {\r\n\t\r\n\t\t\tthis.set(\r\n\t\r\n\t\t\t\t1, 0, 0, x,\r\n\t\t\t\t0, 1, 0, y,\r\n\t\t\t\t0, 0, 1, z,\r\n\t\t\t\t0, 0, 0, 1\r\n\t\r\n\t\t\t);\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmakeRotationX: function ( theta ) {\r\n\t\r\n\t\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\r\n\t\r\n\t\t\tthis.set(\r\n\t\r\n\t\t\t\t1, 0,  0, 0,\r\n\t\t\t\t0, c, - s, 0,\r\n\t\t\t\t0, s,  c, 0,\r\n\t\t\t\t0, 0,  0, 1\r\n\t\r\n\t\t\t);\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmakeRotationY: function ( theta ) {\r\n\t\r\n\t\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\r\n\t\r\n\t\t\tthis.set(\r\n\t\r\n\t\t\t\t c, 0, s, 0,\r\n\t\t\t\t 0, 1, 0, 0,\r\n\t\t\t\t- s, 0, c, 0,\r\n\t\t\t\t 0, 0, 0, 1\r\n\t\r\n\t\t\t);\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmakeRotationZ: function ( theta ) {\r\n\t\r\n\t\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\r\n\t\r\n\t\t\tthis.set(\r\n\t\r\n\t\t\t\tc, - s, 0, 0,\r\n\t\t\t\ts,  c, 0, 0,\r\n\t\t\t\t0,  0, 1, 0,\r\n\t\t\t\t0,  0, 0, 1\r\n\t\r\n\t\t\t);\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmakeRotationAxis: function ( axis, angle ) {\r\n\t\r\n\t\t\t// Based on http://www.gamedev.net/reference/articles/article1199.asp\r\n\t\r\n\t\t\tvar c = Math.cos( angle );\r\n\t\t\tvar s = Math.sin( angle );\r\n\t\t\tvar t = 1 - c;\r\n\t\t\tvar x = axis.x, y = axis.y, z = axis.z;\r\n\t\t\tvar tx = t * x, ty = t * y;\r\n\t\r\n\t\t\tthis.set(\r\n\t\r\n\t\t\t\ttx * x + c, tx * y - s * z, tx * z + s * y, 0,\r\n\t\t\t\ttx * y + s * z, ty * y + c, ty * z - s * x, 0,\r\n\t\t\t\ttx * z - s * y, ty * z + s * x, t * z * z + c, 0,\r\n\t\t\t\t0, 0, 0, 1\r\n\t\r\n\t\t\t);\r\n\t\r\n\t\t\t return this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmakeScale: function ( x, y, z ) {\r\n\t\r\n\t\t\tthis.set(\r\n\t\r\n\t\t\t\tx, 0, 0, 0,\r\n\t\t\t\t0, y, 0, 0,\r\n\t\t\t\t0, 0, z, 0,\r\n\t\t\t\t0, 0, 0, 1\r\n\t\r\n\t\t\t);\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcompose: function ( position, quaternion, scale ) {\r\n\t\r\n\t\t\tthis.makeRotationFromQuaternion( quaternion );\r\n\t\t\tthis.scale( scale );\r\n\t\t\tthis.setPosition( position );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdecompose: function () {\r\n\t\r\n\t\t\tvar vector = new THREE.Vector3();\r\n\t\t\tvar matrix = new THREE.Matrix4();\r\n\t\r\n\t\t\treturn function ( position, quaternion, scale ) {\r\n\t\r\n\t\t\t\tvar te = this.elements;\r\n\t\r\n\t\t\t\tvar sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();\r\n\t\t\t\tvar sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();\r\n\t\t\t\tvar sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();\r\n\t\r\n\t\t\t\t// if determine is negative, we need to invert one scale\r\n\t\t\t\tvar det = this.determinant();\r\n\t\t\t\tif ( det < 0 ) {\r\n\t\t\t\t\tsx = - sx;\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tposition.x = te[ 12 ];\r\n\t\t\t\tposition.y = te[ 13 ];\r\n\t\t\t\tposition.z = te[ 14 ];\r\n\t\r\n\t\t\t\t// scale the rotation part\r\n\t\r\n\t\t\t\tmatrix.elements.set( this.elements ); // at this point matrix is incomplete so we can't use .copy()\r\n\t\r\n\t\t\t\tvar invSX = 1 / sx;\r\n\t\t\t\tvar invSY = 1 / sy;\r\n\t\t\t\tvar invSZ = 1 / sz;\r\n\t\r\n\t\t\t\tmatrix.elements[ 0 ] *= invSX;\r\n\t\t\t\tmatrix.elements[ 1 ] *= invSX;\r\n\t\t\t\tmatrix.elements[ 2 ] *= invSX;\r\n\t\r\n\t\t\t\tmatrix.elements[ 4 ] *= invSY;\r\n\t\t\t\tmatrix.elements[ 5 ] *= invSY;\r\n\t\t\t\tmatrix.elements[ 6 ] *= invSY;\r\n\t\r\n\t\t\t\tmatrix.elements[ 8 ] *= invSZ;\r\n\t\t\t\tmatrix.elements[ 9 ] *= invSZ;\r\n\t\t\t\tmatrix.elements[ 10 ] *= invSZ;\r\n\t\r\n\t\t\t\tquaternion.setFromRotationMatrix( matrix );\r\n\t\r\n\t\t\t\tscale.x = sx;\r\n\t\t\t\tscale.y = sy;\r\n\t\t\t\tscale.z = sz;\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tmakeFrustum: function ( left, right, bottom, top, near, far ) {\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\t\tvar x = 2 * near / ( right - left );\r\n\t\t\tvar y = 2 * near / ( top - bottom );\r\n\t\r\n\t\t\tvar a = ( right + left ) / ( right - left );\r\n\t\t\tvar b = ( top + bottom ) / ( top - bottom );\r\n\t\t\tvar c = - ( far + near ) / ( far - near );\r\n\t\t\tvar d = - 2 * far * near / ( far - near );\r\n\t\r\n\t\t\tte[ 0 ] = x;\tte[ 4 ] = 0;\tte[ 8 ] = a;\tte[ 12 ] = 0;\r\n\t\t\tte[ 1 ] = 0;\tte[ 5 ] = y;\tte[ 9 ] = b;\tte[ 13 ] = 0;\r\n\t\t\tte[ 2 ] = 0;\tte[ 6 ] = 0;\tte[ 10 ] = c;\tte[ 14 ] = d;\r\n\t\t\tte[ 3 ] = 0;\tte[ 7 ] = 0;\tte[ 11 ] = - 1;\tte[ 15 ] = 0;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmakePerspective: function ( fov, aspect, near, far ) {\r\n\t\r\n\t\t\tvar ymax = near * Math.tan( THREE.Math.degToRad( fov * 0.5 ) );\r\n\t\t\tvar ymin = - ymax;\r\n\t\t\tvar xmin = ymin * aspect;\r\n\t\t\tvar xmax = ymax * aspect;\r\n\t\r\n\t\t\treturn this.makeFrustum( xmin, xmax, ymin, ymax, near, far );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmakeOrthographic: function ( left, right, top, bottom, near, far ) {\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\t\tvar w = right - left;\r\n\t\t\tvar h = top - bottom;\r\n\t\t\tvar p = far - near;\r\n\t\r\n\t\t\tvar x = ( right + left ) / w;\r\n\t\t\tvar y = ( top + bottom ) / h;\r\n\t\t\tvar z = ( far + near ) / p;\r\n\t\r\n\t\t\tte[ 0 ] = 2 / w;\tte[ 4 ] = 0;\tte[ 8 ] = 0;\tte[ 12 ] = - x;\r\n\t\t\tte[ 1 ] = 0;\tte[ 5 ] = 2 / h;\tte[ 9 ] = 0;\tte[ 13 ] = - y;\r\n\t\t\tte[ 2 ] = 0;\tte[ 6 ] = 0;\tte[ 10 ] = - 2 / p;\tte[ 14 ] = - z;\r\n\t\t\tte[ 3 ] = 0;\tte[ 7 ] = 0;\tte[ 11 ] = 0;\tte[ 15 ] = 1;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfromArray: function ( array ) {\r\n\t\r\n\t\t\tthis.elements.set( array );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttoArray: function () {\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\r\n\t\t\treturn [\r\n\t\t\t\tte[ 0 ], te[ 1 ], te[ 2 ], te[ 3 ],\r\n\t\t\t\tte[ 4 ], te[ 5 ], te[ 6 ], te[ 7 ],\r\n\t\t\t\tte[ 8 ], te[ 9 ], te[ 10 ], te[ 11 ],\r\n\t\t\t\tte[ 12 ], te[ 13 ], te[ 14 ], te[ 15 ]\r\n\t\t\t];\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new THREE.Matrix4().fromArray( this.elements );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/math/Ray.js\r\n\t\r\n\t/**\r\n\t * @author bhouston / http://exocortex.com\r\n\t */\r\n\t\r\n\tTHREE.Ray = function ( origin, direction ) {\r\n\t\r\n\t\tthis.origin = ( origin !== undefined ) ? origin : new THREE.Vector3();\r\n\t\tthis.direction = ( direction !== undefined ) ? direction : new THREE.Vector3();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Ray.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Ray,\r\n\t\r\n\t\tset: function ( origin, direction ) {\r\n\t\r\n\t\t\tthis.origin.copy( origin );\r\n\t\t\tthis.direction.copy( direction );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( ray ) {\r\n\t\r\n\t\t\tthis.origin.copy( ray.origin );\r\n\t\t\tthis.direction.copy( ray.direction );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tat: function ( t, optionalTarget ) {\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\r\n\t\t\treturn result.copy( this.direction ).multiplyScalar( t ).add( this.origin );\r\n\t\r\n\t\t},\r\n\t\r\n\t\trecast: function () {\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function ( t ) {\r\n\t\r\n\t\t\t\tthis.origin.copy( this.at( t, v1 ) );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tclosestPointToPoint: function ( point, optionalTarget ) {\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\t\tresult.subVectors( point, this.origin );\r\n\t\t\tvar directionDistance = result.dot( this.direction );\r\n\t\r\n\t\t\tif ( directionDistance < 0 ) {\r\n\t\r\n\t\t\t\treturn result.copy( this.origin );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdistanceToPoint: function () {\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function ( point ) {\r\n\t\r\n\t\t\t\tvar directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );\r\n\t\r\n\t\t\t\t// point behind the ray\r\n\t\r\n\t\t\t\tif ( directionDistance < 0 ) {\r\n\t\r\n\t\t\t\t\treturn this.origin.distanceTo( point );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tv1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\r\n\t\r\n\t\t\t\treturn v1.distanceTo( point );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tdistanceSqToSegment: function () {\r\n\t\r\n\t\t\tvar segCenter = new THREE.Vector3();\r\n\t\t\tvar segDir = new THREE.Vector3();\r\n\t\t\tvar diff = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function ( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {\r\n\t\r\n\t\t\t\t// from http://www.geometrictools.com/LibMathematics/Distance/Wm5DistRay3Segment3.cpp\r\n\t\t\t\t// It returns the min distance between the ray and the segment\r\n\t\t\t\t// defined by v0 and v1\r\n\t\t\t\t// It can also set two optional targets :\r\n\t\t\t\t// - The closest point on the ray\r\n\t\t\t\t// - The closest point on the segment\r\n\t\r\n\t\t\t\tsegCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );\r\n\t\t\t\tsegDir.copy( v1 ).sub( v0 ).normalize();\r\n\t\t\t\tdiff.copy( this.origin ).sub( segCenter );\r\n\t\r\n\t\t\t\tvar segExtent = v0.distanceTo( v1 ) * 0.5;\r\n\t\t\t\tvar a01 = - this.direction.dot( segDir );\r\n\t\t\t\tvar b0 = diff.dot( this.direction );\r\n\t\t\t\tvar b1 = - diff.dot( segDir );\r\n\t\t\t\tvar c = diff.lengthSq();\r\n\t\t\t\tvar det = Math.abs( 1 - a01 * a01 );\r\n\t\t\t\tvar s0, s1, sqrDist, extDet;\r\n\t\r\n\t\t\t\tif ( det > 0 ) {\r\n\t\r\n\t\t\t\t\t// The ray and segment are not parallel.\r\n\t\r\n\t\t\t\t\ts0 = a01 * b1 - b0;\r\n\t\t\t\t\ts1 = a01 * b0 - b1;\r\n\t\t\t\t\textDet = segExtent * det;\r\n\t\r\n\t\t\t\t\tif ( s0 >= 0 ) {\r\n\t\r\n\t\t\t\t\t\tif ( s1 >= - extDet ) {\r\n\t\r\n\t\t\t\t\t\t\tif ( s1 <= extDet ) {\r\n\t\r\n\t\t\t\t\t\t\t\t// region 0\r\n\t\t\t\t\t\t\t\t// Minimum at interior points of ray and segment.\r\n\t\r\n\t\t\t\t\t\t\t\tvar invDet = 1 / det;\r\n\t\t\t\t\t\t\t\ts0 *= invDet;\r\n\t\t\t\t\t\t\t\ts1 *= invDet;\r\n\t\t\t\t\t\t\t\tsqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;\r\n\t\r\n\t\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\t\t// region 1\r\n\t\r\n\t\t\t\t\t\t\t\ts1 = segExtent;\r\n\t\t\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\r\n\t\t\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\t// region 5\r\n\t\r\n\t\t\t\t\t\t\ts1 = - segExtent;\r\n\t\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\r\n\t\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tif ( s1 <= - extDet ) {\r\n\t\r\n\t\t\t\t\t\t\t// region 4\r\n\t\r\n\t\t\t\t\t\t\ts0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );\r\n\t\t\t\t\t\t\ts1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\r\n\t\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\r\n\t\r\n\t\t\t\t\t\t} else if ( s1 <= extDet ) {\r\n\t\r\n\t\t\t\t\t\t\t// region 3\r\n\t\r\n\t\t\t\t\t\t\ts0 = 0;\r\n\t\t\t\t\t\t\ts1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );\r\n\t\t\t\t\t\t\tsqrDist = s1 * ( s1 + 2 * b1 ) + c;\r\n\t\r\n\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\t// region 2\r\n\t\r\n\t\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * segExtent + b0 ) );\r\n\t\t\t\t\t\t\ts1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\r\n\t\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t// Ray and segment are parallel.\r\n\t\r\n\t\t\t\t\ts1 = ( a01 > 0 ) ? - segExtent : segExtent;\r\n\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\r\n\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( optionalPointOnRay ) {\r\n\t\r\n\t\t\t\t\toptionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( optionalPointOnSegment ) {\r\n\t\r\n\t\t\t\t\toptionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn sqrDist;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\r\n\t\tisIntersectionSphere: function ( sphere ) {\r\n\t\r\n\t\t\treturn this.distanceToPoint( sphere.center ) <= sphere.radius;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tintersectSphere: function () {\r\n\t\r\n\t\t\t// from http://www.scratchapixel.com/lessons/3d-basic-lessons/lesson-7-intersecting-simple-shapes/ray-sphere-intersection/\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function ( sphere, optionalTarget ) {\r\n\t\r\n\t\t\t\tv1.subVectors( sphere.center, this.origin );\r\n\t\r\n\t\t\t\tvar tca = v1.dot( this.direction );\r\n\t\r\n\t\t\t\tvar d2 = v1.dot( v1 ) - tca * tca;\r\n\t\r\n\t\t\t\tvar radius2 = sphere.radius * sphere.radius;\r\n\t\r\n\t\t\t\tif ( d2 > radius2 ) return null;\r\n\t\r\n\t\t\t\tvar thc = Math.sqrt( radius2 - d2 );\r\n\t\r\n\t\t\t\t// t0 = first intersect point - entrance on front of sphere\r\n\t\t\t\tvar t0 = tca - thc;\r\n\t\r\n\t\t\t\t// t1 = second intersect point - exit point on back of sphere\r\n\t\t\t\tvar t1 = tca + thc;\r\n\t\r\n\t\t\t\t// test to see if both t0 and t1 are behind the ray - if so, return null\r\n\t\t\t\tif ( t0 < 0 && t1 < 0 ) return null;\r\n\t\r\n\t\t\t\t// test to see if t0 is behind the ray:\r\n\t\t\t\t// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,\r\n\t\t\t\t// in order to always return an intersect point that is in front of the ray.\r\n\t\t\t\tif ( t0 < 0 ) return this.at( t1, optionalTarget );\r\n\t\r\n\t\t\t\t// else t0 is in front of the ray, so return the first collision point scaled by t0 \r\n\t\t\t\treturn this.at( t0, optionalTarget );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tisIntersectionPlane: function ( plane ) {\r\n\t\r\n\t\t\t// check if the ray lies on the plane first\r\n\t\r\n\t\t\tvar distToPoint = plane.distanceToPoint( this.origin );\r\n\t\r\n\t\t\tif ( distToPoint === 0 ) {\r\n\t\r\n\t\t\t\treturn true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar denominator = plane.normal.dot( this.direction );\r\n\t\r\n\t\t\tif ( denominator * distToPoint < 0 ) {\r\n\t\r\n\t\t\t\treturn true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// ray origin is behind the plane (and is pointing behind it)\r\n\t\r\n\t\t\treturn false;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdistanceToPlane: function ( plane ) {\r\n\t\r\n\t\t\tvar denominator = plane.normal.dot( this.direction );\r\n\t\t\tif ( denominator == 0 ) {\r\n\t\r\n\t\t\t\t// line is coplanar, return origin\r\n\t\t\t\tif ( plane.distanceToPoint( this.origin ) == 0 ) {\r\n\t\r\n\t\t\t\t\treturn 0;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// Null is preferable to undefined since undefined means.... it is undefined\r\n\t\r\n\t\t\t\treturn null;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;\r\n\t\r\n\t\t\t// Return if the ray never intersects the plane\r\n\t\r\n\t\t\treturn t >= 0 ? t :  null;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tintersectPlane: function ( plane, optionalTarget ) {\r\n\t\r\n\t\t\tvar t = this.distanceToPlane( plane );\r\n\t\r\n\t\t\tif ( t === null ) {\r\n\t\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this.at( t, optionalTarget );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tisIntersectionBox: function () {\r\n\t\r\n\t\t\tvar v = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function ( box ) {\r\n\t\r\n\t\t\t\treturn this.intersectBox( box, v ) !== null;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tintersectBox: function ( box, optionalTarget ) {\r\n\t\r\n\t\t\t// http://www.scratchapixel.com/lessons/3d-basic-lessons/lesson-7-intersecting-simple-shapes/ray-box-intersection/\r\n\t\r\n\t\t\tvar tmin,tmax,tymin,tymax,tzmin,tzmax;\r\n\t\r\n\t\t\tvar invdirx = 1 / this.direction.x,\r\n\t\t\t\tinvdiry = 1 / this.direction.y,\r\n\t\t\t\tinvdirz = 1 / this.direction.z;\r\n\t\r\n\t\t\tvar origin = this.origin;\r\n\t\r\n\t\t\tif ( invdirx >= 0 ) {\r\n\t\r\n\t\t\t\ttmin = ( box.min.x - origin.x ) * invdirx;\r\n\t\t\t\ttmax = ( box.max.x - origin.x ) * invdirx;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\ttmin = ( box.max.x - origin.x ) * invdirx;\r\n\t\t\t\ttmax = ( box.min.x - origin.x ) * invdirx;\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( invdiry >= 0 ) {\r\n\t\r\n\t\t\t\ttymin = ( box.min.y - origin.y ) * invdiry;\r\n\t\t\t\ttymax = ( box.max.y - origin.y ) * invdiry;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\ttymin = ( box.max.y - origin.y ) * invdiry;\r\n\t\t\t\ttymax = ( box.min.y - origin.y ) * invdiry;\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;\r\n\t\r\n\t\t\t// These lines also handle the case where tmin or tmax is NaN\r\n\t\t\t// (result of 0 * Infinity). x !== x returns true if x is NaN\r\n\t\r\n\t\t\tif ( tymin > tmin || tmin !== tmin ) tmin = tymin;\r\n\t\r\n\t\t\tif ( tymax < tmax || tmax !== tmax ) tmax = tymax;\r\n\t\r\n\t\t\tif ( invdirz >= 0 ) {\r\n\t\r\n\t\t\t\ttzmin = ( box.min.z - origin.z ) * invdirz;\r\n\t\t\t\ttzmax = ( box.max.z - origin.z ) * invdirz;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\ttzmin = ( box.max.z - origin.z ) * invdirz;\r\n\t\t\t\ttzmax = ( box.min.z - origin.z ) * invdirz;\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;\r\n\t\r\n\t\t\tif ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;\r\n\t\r\n\t\t\tif ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;\r\n\t\r\n\t\t\t//return point closest to the ray (positive side)\r\n\t\r\n\t\t\tif ( tmax < 0 ) return null;\r\n\t\r\n\t\t\treturn this.at( tmin >= 0 ? tmin : tmax, optionalTarget );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tintersectTriangle: function () {\r\n\t\r\n\t\t\t// Compute the offset origin, edges, and normal.\r\n\t\t\tvar diff = new THREE.Vector3();\r\n\t\t\tvar edge1 = new THREE.Vector3();\r\n\t\t\tvar edge2 = new THREE.Vector3();\r\n\t\t\tvar normal = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function ( a, b, c, backfaceCulling, optionalTarget ) {\r\n\t\r\n\t\t\t\t// from http://www.geometrictools.com/LibMathematics/Intersection/Wm5IntrRay3Triangle3.cpp\r\n\t\r\n\t\t\t\tedge1.subVectors( b, a );\r\n\t\t\t\tedge2.subVectors( c, a );\r\n\t\t\t\tnormal.crossVectors( edge1, edge2 );\r\n\t\r\n\t\t\t\t// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,\r\n\t\t\t\t// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by\r\n\t\t\t\t//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))\r\n\t\t\t\t//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))\r\n\t\t\t\t//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)\r\n\t\t\t\tvar DdN = this.direction.dot( normal );\r\n\t\t\t\tvar sign;\r\n\t\r\n\t\t\t\tif ( DdN > 0 ) {\r\n\t\r\n\t\t\t\t\tif ( backfaceCulling ) return null;\r\n\t\t\t\t\tsign = 1;\r\n\t\r\n\t\t\t\t} else if ( DdN < 0 ) {\r\n\t\r\n\t\t\t\t\tsign = - 1;\r\n\t\t\t\t\tDdN = - DdN;\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\treturn null;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tdiff.subVectors( this.origin, a );\r\n\t\t\t\tvar DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );\r\n\t\r\n\t\t\t\t// b1 < 0, no intersection\r\n\t\t\t\tif ( DdQxE2 < 0 ) {\r\n\t\r\n\t\t\t\t\treturn null;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );\r\n\t\r\n\t\t\t\t// b2 < 0, no intersection\r\n\t\t\t\tif ( DdE1xQ < 0 ) {\r\n\t\r\n\t\t\t\t\treturn null;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// b1+b2 > 1, no intersection\r\n\t\t\t\tif ( DdQxE2 + DdE1xQ > DdN ) {\r\n\t\r\n\t\t\t\t\treturn null;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// Line intersects triangle, check if ray does.\r\n\t\t\t\tvar QdN = - sign * diff.dot( normal );\r\n\t\r\n\t\t\t\t// t < 0, no intersection\r\n\t\t\t\tif ( QdN < 0 ) {\r\n\t\r\n\t\t\t\t\treturn null;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// Ray intersects triangle.\r\n\t\t\t\treturn this.at( QdN / DdN, optionalTarget );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tapplyMatrix4: function ( matrix4 ) {\r\n\t\r\n\t\t\tthis.direction.add( this.origin ).applyMatrix4( matrix4 );\r\n\t\t\tthis.origin.applyMatrix4( matrix4 );\r\n\t\t\tthis.direction.sub( this.origin );\r\n\t\t\tthis.direction.normalize();\r\n\t\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\tequals: function ( ray ) {\r\n\t\r\n\t\t\treturn ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new THREE.Ray().copy( this );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/math/Sphere.js\r\n\t\r\n\t/**\r\n\t * @author bhouston / http://exocortex.com\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.Sphere = function ( center, radius ) {\r\n\t\r\n\t\tthis.center = ( center !== undefined ) ? center : new THREE.Vector3();\r\n\t\tthis.radius = ( radius !== undefined ) ? radius : 0;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Sphere.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Sphere,\r\n\t\r\n\t\tset: function ( center, radius ) {\r\n\t\r\n\t\t\tthis.center.copy( center );\r\n\t\t\tthis.radius = radius;\r\n\t\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\tsetFromPoints: function () {\r\n\t\r\n\t\t\tvar box = new THREE.Box3();\r\n\t\r\n\t\t\treturn function ( points, optionalCenter ) {\r\n\t\r\n\t\t\t\tvar center = this.center;\r\n\t\r\n\t\t\t\tif ( optionalCenter !== undefined ) {\r\n\t\r\n\t\t\t\t\tcenter.copy( optionalCenter );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tbox.setFromPoints( points ).center( center );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar maxRadiusSq = 0;\r\n\t\r\n\t\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tthis.radius = Math.sqrt( maxRadiusSq );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tcopy: function ( sphere ) {\r\n\t\r\n\t\t\tthis.center.copy( sphere.center );\r\n\t\t\tthis.radius = sphere.radius;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tempty: function () {\r\n\t\r\n\t\t\treturn ( this.radius <= 0 );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcontainsPoint: function ( point ) {\r\n\t\r\n\t\t\treturn ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdistanceToPoint: function ( point ) {\r\n\t\r\n\t\t\treturn ( point.distanceTo( this.center ) - this.radius );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tintersectsSphere: function ( sphere ) {\r\n\t\r\n\t\t\tvar radiusSum = this.radius + sphere.radius;\r\n\t\r\n\t\t\treturn sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclampPoint: function ( point, optionalTarget ) {\r\n\t\r\n\t\t\tvar deltaLengthSq = this.center.distanceToSquared( point );\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\t\tresult.copy( point );\r\n\t\r\n\t\t\tif ( deltaLengthSq > ( this.radius * this.radius ) ) {\r\n\t\r\n\t\t\t\tresult.sub( this.center ).normalize();\r\n\t\t\t\tresult.multiplyScalar( this.radius ).add( this.center );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn result;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetBoundingBox: function ( optionalTarget ) {\r\n\t\r\n\t\t\tvar box = optionalTarget || new THREE.Box3();\r\n\t\r\n\t\t\tbox.set( this.center, this.center );\r\n\t\t\tbox.expandByScalar( this.radius );\r\n\t\r\n\t\t\treturn box;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tapplyMatrix4: function ( matrix ) {\r\n\t\r\n\t\t\tthis.center.applyMatrix4( matrix );\r\n\t\t\tthis.radius = this.radius * matrix.getMaxScaleOnAxis();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttranslate: function ( offset ) {\r\n\t\r\n\t\t\tthis.center.add( offset );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tequals: function ( sphere ) {\r\n\t\r\n\t\t\treturn sphere.center.equals( this.center ) && ( sphere.radius === this.radius );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new THREE.Sphere().copy( this );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/math/Frustum.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author bhouston / http://exocortex.com\r\n\t */\r\n\t\r\n\tTHREE.Frustum = function ( p0, p1, p2, p3, p4, p5 ) {\r\n\t\r\n\t\tthis.planes = [\r\n\t\r\n\t\t\t( p0 !== undefined ) ? p0 : new THREE.Plane(),\r\n\t\t\t( p1 !== undefined ) ? p1 : new THREE.Plane(),\r\n\t\t\t( p2 !== undefined ) ? p2 : new THREE.Plane(),\r\n\t\t\t( p3 !== undefined ) ? p3 : new THREE.Plane(),\r\n\t\t\t( p4 !== undefined ) ? p4 : new THREE.Plane(),\r\n\t\t\t( p5 !== undefined ) ? p5 : new THREE.Plane()\r\n\t\r\n\t\t];\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Frustum.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Frustum,\r\n\t\r\n\t\tset: function ( p0, p1, p2, p3, p4, p5 ) {\r\n\t\r\n\t\t\tvar planes = this.planes;\r\n\t\r\n\t\t\tplanes[ 0 ].copy( p0 );\r\n\t\t\tplanes[ 1 ].copy( p1 );\r\n\t\t\tplanes[ 2 ].copy( p2 );\r\n\t\t\tplanes[ 3 ].copy( p3 );\r\n\t\t\tplanes[ 4 ].copy( p4 );\r\n\t\t\tplanes[ 5 ].copy( p5 );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( frustum ) {\r\n\t\r\n\t\t\tvar planes = this.planes;\r\n\t\r\n\t\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\t\r\n\t\t\t\tplanes[ i ].copy( frustum.planes[ i ] );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromMatrix: function ( m ) {\r\n\t\r\n\t\t\tvar planes = this.planes;\r\n\t\t\tvar me = m.elements;\r\n\t\t\tvar me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];\r\n\t\t\tvar me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];\r\n\t\t\tvar me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];\r\n\t\t\tvar me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];\r\n\t\r\n\t\t\tplanes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();\r\n\t\t\tplanes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();\r\n\t\t\tplanes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();\r\n\t\t\tplanes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();\r\n\t\t\tplanes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();\r\n\t\t\tplanes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tintersectsObject: function () {\r\n\t\r\n\t\t\tvar sphere = new THREE.Sphere();\r\n\t\r\n\t\t\treturn function ( object ) {\r\n\t\r\n\t\t\t\tvar geometry = object.geometry;\r\n\t\r\n\t\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\r\n\t\r\n\t\t\t\tsphere.copy( geometry.boundingSphere );\r\n\t\t\t\tsphere.applyMatrix4( object.matrixWorld );\r\n\t\r\n\t\t\t\treturn this.intersectsSphere( sphere );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tintersectsSphere: function ( sphere ) {\r\n\t\r\n\t\t\tvar planes = this.planes;\r\n\t\t\tvar center = sphere.center;\r\n\t\t\tvar negRadius = - sphere.radius;\r\n\t\r\n\t\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\t\r\n\t\t\t\tvar distance = planes[ i ].distanceToPoint( center );\r\n\t\r\n\t\t\t\tif ( distance < negRadius ) {\r\n\t\r\n\t\t\t\t\treturn false;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn true;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tintersectsBox: function () {\r\n\t\r\n\t\t\tvar p1 = new THREE.Vector3(),\r\n\t\t\t\tp2 = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function ( box ) {\r\n\t\r\n\t\t\t\tvar planes = this.planes;\r\n\t\r\n\t\t\t\tfor ( var i = 0; i < 6 ; i ++ ) {\r\n\t\r\n\t\t\t\t\tvar plane = planes[ i ];\r\n\t\r\n\t\t\t\t\tp1.x = plane.normal.x > 0 ? box.min.x : box.max.x;\r\n\t\t\t\t\tp2.x = plane.normal.x > 0 ? box.max.x : box.min.x;\r\n\t\t\t\t\tp1.y = plane.normal.y > 0 ? box.min.y : box.max.y;\r\n\t\t\t\t\tp2.y = plane.normal.y > 0 ? box.max.y : box.min.y;\r\n\t\t\t\t\tp1.z = plane.normal.z > 0 ? box.min.z : box.max.z;\r\n\t\t\t\t\tp2.z = plane.normal.z > 0 ? box.max.z : box.min.z;\r\n\t\r\n\t\t\t\t\tvar d1 = plane.distanceToPoint( p1 );\r\n\t\t\t\t\tvar d2 = plane.distanceToPoint( p2 );\r\n\t\r\n\t\t\t\t\t// if both outside plane, no intersection\r\n\t\r\n\t\t\t\t\tif ( d1 < 0 && d2 < 0 ) {\r\n\t\r\n\t\t\t\t\t\treturn false;\r\n\t\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn true;\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\r\n\t\tcontainsPoint: function ( point ) {\r\n\t\r\n\t\t\tvar planes = this.planes;\r\n\t\r\n\t\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\t\r\n\t\t\t\tif ( planes[ i ].distanceToPoint( point ) < 0 ) {\r\n\t\r\n\t\t\t\t\treturn false;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn true;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new THREE.Frustum().copy( this );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/math/Plane.js\r\n\t\r\n\t/**\r\n\t * @author bhouston / http://exocortex.com\r\n\t */\r\n\t\r\n\tTHREE.Plane = function ( normal, constant ) {\r\n\t\r\n\t\tthis.normal = ( normal !== undefined ) ? normal : new THREE.Vector3( 1, 0, 0 );\r\n\t\tthis.constant = ( constant !== undefined ) ? constant : 0;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Plane.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Plane,\r\n\t\r\n\t\tset: function ( normal, constant ) {\r\n\t\r\n\t\t\tthis.normal.copy( normal );\r\n\t\t\tthis.constant = constant;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetComponents: function ( x, y, z, w ) {\r\n\t\r\n\t\t\tthis.normal.set( x, y, z );\r\n\t\t\tthis.constant = w;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromNormalAndCoplanarPoint: function ( normal, point ) {\r\n\t\r\n\t\t\tthis.normal.copy( normal );\r\n\t\t\tthis.constant = - point.dot( this.normal );\t// must be this.normal, not normal, as this.normal is normalized\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromCoplanarPoints: function () {\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector3();\r\n\t\t\tvar v2 = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function ( a, b, c ) {\r\n\t\r\n\t\t\t\tvar normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();\r\n\t\r\n\t\t\t\t// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?\r\n\t\r\n\t\t\t\tthis.setFromNormalAndCoplanarPoint( normal, a );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\r\n\t\tcopy: function ( plane ) {\r\n\t\r\n\t\t\tthis.normal.copy( plane.normal );\r\n\t\t\tthis.constant = plane.constant;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tnormalize: function () {\r\n\t\r\n\t\t\t// Note: will lead to a divide by zero if the plane is invalid.\r\n\t\r\n\t\t\tvar inverseNormalLength = 1.0 / this.normal.length();\r\n\t\t\tthis.normal.multiplyScalar( inverseNormalLength );\r\n\t\t\tthis.constant *= inverseNormalLength;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tnegate: function () {\r\n\t\r\n\t\t\tthis.constant *= - 1;\r\n\t\t\tthis.normal.negate();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdistanceToPoint: function ( point ) {\r\n\t\r\n\t\t\treturn this.normal.dot( point ) + this.constant;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdistanceToSphere: function ( sphere ) {\r\n\t\r\n\t\t\treturn this.distanceToPoint( sphere.center ) - sphere.radius;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tprojectPoint: function ( point, optionalTarget ) {\r\n\t\r\n\t\t\treturn this.orthoPoint( point, optionalTarget ).sub( point ).negate();\r\n\t\r\n\t\t},\r\n\t\r\n\t\torthoPoint: function ( point, optionalTarget ) {\r\n\t\r\n\t\t\tvar perpendicularMagnitude = this.distanceToPoint( point );\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\t\treturn result.copy( this.normal ).multiplyScalar( perpendicularMagnitude );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tisIntersectionLine: function ( line ) {\r\n\t\r\n\t\t\t// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.\r\n\t\r\n\t\t\tvar startSign = this.distanceToPoint( line.start );\r\n\t\t\tvar endSign = this.distanceToPoint( line.end );\r\n\t\r\n\t\t\treturn ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tintersectLine: function () {\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function ( line, optionalTarget ) {\r\n\t\r\n\t\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\r\n\t\t\t\tvar direction = line.delta( v1 );\r\n\t\r\n\t\t\t\tvar denominator = this.normal.dot( direction );\r\n\t\r\n\t\t\t\tif ( denominator == 0 ) {\r\n\t\r\n\t\t\t\t\t// line is coplanar, return origin\r\n\t\t\t\t\tif ( this.distanceToPoint( line.start ) == 0 ) {\r\n\t\r\n\t\t\t\t\t\treturn result.copy( line.start );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t// Unsure if this is the correct method to handle this case.\r\n\t\t\t\t\treturn undefined;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;\r\n\t\r\n\t\t\t\tif ( t < 0 || t > 1 ) {\r\n\t\r\n\t\t\t\t\treturn undefined;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn result.copy( direction ).multiplyScalar( t ).add( line.start );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\r\n\t\tcoplanarPoint: function ( optionalTarget ) {\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\t\treturn result.copy( this.normal ).multiplyScalar( - this.constant );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tapplyMatrix4: function () {\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector3();\r\n\t\t\tvar v2 = new THREE.Vector3();\r\n\t\t\tvar m1 = new THREE.Matrix3();\r\n\t\r\n\t\t\treturn function ( matrix, optionalNormalMatrix ) {\r\n\t\r\n\t\t\t\t// compute new normal based on theory here:\r\n\t\t\t\t// http://www.songho.ca/opengl/gl_normaltransform.html\r\n\t\t\t\tvar normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );\r\n\t\t\t\tvar newNormal = v1.copy( this.normal ).applyMatrix3( normalMatrix );\r\n\t\r\n\t\t\t\tvar newCoplanarPoint = this.coplanarPoint( v2 );\r\n\t\t\t\tnewCoplanarPoint.applyMatrix4( matrix );\r\n\t\r\n\t\t\t\tthis.setFromNormalAndCoplanarPoint( newNormal, newCoplanarPoint );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\ttranslate: function ( offset ) {\r\n\t\r\n\t\t\tthis.constant = this.constant - offset.dot( this.normal );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tequals: function ( plane ) {\r\n\t\r\n\t\t\treturn plane.normal.equals( this.normal ) && ( plane.constant == this.constant );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new THREE.Plane().copy( this );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/math/Math.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.Math = {\r\n\t\r\n\t\tgenerateUUID: function () {\r\n\t\r\n\t\t\t// http://www.broofa.com/Tools/Math.uuid.htm\r\n\t\r\n\t\t\tvar chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split( '' );\r\n\t\t\tvar uuid = new Array( 36 );\r\n\t\t\tvar rnd = 0, r;\r\n\t\r\n\t\t\treturn function () {\r\n\t\r\n\t\t\t\tfor ( var i = 0; i < 36; i ++ ) {\r\n\t\r\n\t\t\t\t\tif ( i == 8 || i == 13 || i == 18 || i == 23 ) {\r\n\t\r\n\t\t\t\t\t\tuuid[ i ] = '-';\r\n\t\r\n\t\t\t\t\t} else if ( i == 14 ) {\r\n\t\r\n\t\t\t\t\t\tuuid[ i ] = '4';\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tif ( rnd <= 0x02 ) rnd = 0x2000000 + ( Math.random() * 0x1000000 ) | 0;\r\n\t\t\t\t\t\tr = rnd & 0xf;\r\n\t\t\t\t\t\trnd = rnd >> 4;\r\n\t\t\t\t\t\tuuid[ i ] = chars[ ( i == 19 ) ? ( r & 0x3 ) | 0x8 : r ];\r\n\t\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn uuid.join( '' );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\t// Clamp value to range <a, b>\r\n\t\r\n\t\tclamp: function ( x, a, b ) {\r\n\t\r\n\t\t\treturn ( x < a ) ? a : ( ( x > b ) ? b : x );\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// Clamp value to range <a, inf)\r\n\t\r\n\t\tclampBottom: function ( x, a ) {\r\n\t\r\n\t\t\treturn x < a ? a : x;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// Linear mapping from range <a1, a2> to range <b1, b2>\r\n\t\r\n\t\tmapLinear: function ( x, a1, a2, b1, b2 ) {\r\n\t\r\n\t\t\treturn b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// http://en.wikipedia.org/wiki/Smoothstep\r\n\t\r\n\t\tsmoothstep: function ( x, min, max ) {\r\n\t\r\n\t\t\tif ( x <= min ) return 0;\r\n\t\t\tif ( x >= max ) return 1;\r\n\t\r\n\t\t\tx = ( x - min ) / ( max - min );\r\n\t\r\n\t\t\treturn x * x * ( 3 - 2 * x );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsmootherstep: function ( x, min, max ) {\r\n\t\r\n\t\t\tif ( x <= min ) return 0;\r\n\t\t\tif ( x >= max ) return 1;\r\n\t\r\n\t\t\tx = ( x - min ) / ( max - min );\r\n\t\r\n\t\t\treturn x * x * x * ( x * ( x * 6 - 15 ) + 10 );\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// Random float from <0, 1> with 16 bits of randomness\r\n\t\t// (standard Math.random() creates repetitive patterns when applied over larger space)\r\n\t\r\n\t\trandom16: function () {\r\n\t\r\n\t\t\treturn ( 65280 * Math.random() + 255 * Math.random() ) / 65535;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// Random integer from <low, high> interval\r\n\t\r\n\t\trandInt: function ( low, high ) {\r\n\t\r\n\t\t\treturn Math.floor( this.randFloat( low, high ) );\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// Random float from <low, high> interval\r\n\t\r\n\t\trandFloat: function ( low, high ) {\r\n\t\r\n\t\t\treturn low + Math.random() * ( high - low );\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// Random float from <-range/2, range/2> interval\r\n\t\r\n\t\trandFloatSpread: function ( range ) {\r\n\t\r\n\t\t\treturn range * ( 0.5 - Math.random() );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdegToRad: function () {\r\n\t\r\n\t\t\tvar degreeToRadiansFactor = Math.PI / 180;\r\n\t\r\n\t\t\treturn function ( degrees ) {\r\n\t\r\n\t\t\t\treturn degrees * degreeToRadiansFactor;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tradToDeg: function () {\r\n\t\r\n\t\t\tvar radianToDegreesFactor = 180 / Math.PI;\r\n\t\r\n\t\t\treturn function ( radians ) {\r\n\t\r\n\t\t\t\treturn radians * radianToDegreesFactor;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tisPowerOfTwo: function ( value ) {\r\n\t\r\n\t\t\treturn ( value & ( value - 1 ) ) === 0 && value !== 0;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tnextPowerOfTwo: function ( value ) {\r\n\t\r\n\t\t\tvalue --;\r\n\t\t\tvalue |= value >> 1;\r\n\t\t\tvalue |= value >> 2;\r\n\t\t\tvalue |= value >> 4;\r\n\t\t\tvalue |= value >> 8;\r\n\t\t\tvalue |= value >> 16;\r\n\t\t\tvalue ++;\r\n\t\r\n\t\t\treturn value;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/math/Spline.js\r\n\t\r\n\t/**\r\n\t * Spline from Tween.js, slightly optimized (and trashed)\r\n\t * http://sole.github.com/tween.js/examples/05_spline.html\r\n\t *\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.Spline = function ( points ) {\r\n\t\r\n\t\tthis.points = points;\r\n\t\r\n\t\tvar c = [], v3 = { x: 0, y: 0, z: 0 },\r\n\t\tpoint, intPoint, weight, w2, w3,\r\n\t\tpa, pb, pc, pd;\r\n\t\r\n\t\tthis.initFromArray = function ( a ) {\r\n\t\r\n\t\t\tthis.points = [];\r\n\t\r\n\t\t\tfor ( var i = 0; i < a.length; i ++ ) {\r\n\t\r\n\t\t\t\tthis.points[ i ] = { x: a[ i ][ 0 ], y: a[ i ][ 1 ], z: a[ i ][ 2 ] };\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.getPoint = function ( k ) {\r\n\t\r\n\t\t\tpoint = ( this.points.length - 1 ) * k;\r\n\t\t\tintPoint = Math.floor( point );\r\n\t\t\tweight = point - intPoint;\r\n\t\r\n\t\t\tc[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;\r\n\t\t\tc[ 1 ] = intPoint;\r\n\t\t\tc[ 2 ] = intPoint  > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;\r\n\t\t\tc[ 3 ] = intPoint  > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;\r\n\t\r\n\t\t\tpa = this.points[ c[ 0 ] ];\r\n\t\t\tpb = this.points[ c[ 1 ] ];\r\n\t\t\tpc = this.points[ c[ 2 ] ];\r\n\t\t\tpd = this.points[ c[ 3 ] ];\r\n\t\r\n\t\t\tw2 = weight * weight;\r\n\t\t\tw3 = weight * w2;\r\n\t\r\n\t\t\tv3.x = interpolate( pa.x, pb.x, pc.x, pd.x, weight, w2, w3 );\r\n\t\t\tv3.y = interpolate( pa.y, pb.y, pc.y, pd.y, weight, w2, w3 );\r\n\t\t\tv3.z = interpolate( pa.z, pb.z, pc.z, pd.z, weight, w2, w3 );\r\n\t\r\n\t\t\treturn v3;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.getControlPointsArray = function () {\r\n\t\r\n\t\t\tvar i, p, l = this.points.length,\r\n\t\t\t\tcoords = [];\r\n\t\r\n\t\t\tfor ( i = 0; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tp = this.points[ i ];\r\n\t\t\t\tcoords[ i ] = [ p.x, p.y, p.z ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn coords;\r\n\t\r\n\t\t};\r\n\t\r\n\t\t// approximate length by summing linear segments\r\n\t\r\n\t\tthis.getLength = function ( nSubDivisions ) {\r\n\t\r\n\t\t\tvar i, index, nSamples, position,\r\n\t\t\t\tpoint = 0, intPoint = 0, oldIntPoint = 0,\r\n\t\t\t\toldPosition = new THREE.Vector3(),\r\n\t\t\t\ttmpVec = new THREE.Vector3(),\r\n\t\t\t\tchunkLengths = [],\r\n\t\t\t\ttotalLength = 0;\r\n\t\r\n\t\t\t// first point has 0 length\r\n\t\r\n\t\t\tchunkLengths[ 0 ] = 0;\r\n\t\r\n\t\t\tif ( ! nSubDivisions ) nSubDivisions = 100;\r\n\t\r\n\t\t\tnSamples = this.points.length * nSubDivisions;\r\n\t\r\n\t\t\toldPosition.copy( this.points[ 0 ] );\r\n\t\r\n\t\t\tfor ( i = 1; i < nSamples; i ++ ) {\r\n\t\r\n\t\t\t\tindex = i / nSamples;\r\n\t\r\n\t\t\t\tposition = this.getPoint( index );\r\n\t\t\t\ttmpVec.copy( position );\r\n\t\r\n\t\t\t\ttotalLength += tmpVec.distanceTo( oldPosition );\r\n\t\r\n\t\t\t\toldPosition.copy( position );\r\n\t\r\n\t\t\t\tpoint = ( this.points.length - 1 ) * index;\r\n\t\t\t\tintPoint = Math.floor( point );\r\n\t\r\n\t\t\t\tif ( intPoint != oldIntPoint ) {\r\n\t\r\n\t\t\t\t\tchunkLengths[ intPoint ] = totalLength;\r\n\t\t\t\t\toldIntPoint = intPoint;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// last point ends with total length\r\n\t\r\n\t\t\tchunkLengths[ chunkLengths.length ] = totalLength;\r\n\t\r\n\t\t\treturn { chunks: chunkLengths, total: totalLength };\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.reparametrizeByArcLength = function ( samplingCoef ) {\r\n\t\r\n\t\t\tvar i, j,\r\n\t\t\t\tindex, indexCurrent, indexNext,\r\n\t\t\t\trealDistance,\r\n\t\t\t\tsampling, position,\r\n\t\t\t\tnewpoints = [],\r\n\t\t\t\ttmpVec = new THREE.Vector3(),\r\n\t\t\t\tsl = this.getLength();\r\n\t\r\n\t\t\tnewpoints.push( tmpVec.copy( this.points[ 0 ] ).clone() );\r\n\t\r\n\t\t\tfor ( i = 1; i < this.points.length; i ++ ) {\r\n\t\r\n\t\t\t\t//tmpVec.copy( this.points[ i - 1 ] );\r\n\t\t\t\t//linearDistance = tmpVec.distanceTo( this.points[ i ] );\r\n\t\r\n\t\t\t\trealDistance = sl.chunks[ i ] - sl.chunks[ i - 1 ];\r\n\t\r\n\t\t\t\tsampling = Math.ceil( samplingCoef * realDistance / sl.total );\r\n\t\r\n\t\t\t\tindexCurrent = ( i - 1 ) / ( this.points.length - 1 );\r\n\t\t\t\tindexNext = i / ( this.points.length - 1 );\r\n\t\r\n\t\t\t\tfor ( j = 1; j < sampling - 1; j ++ ) {\r\n\t\r\n\t\t\t\t\tindex = indexCurrent + j * ( 1 / sampling ) * ( indexNext - indexCurrent );\r\n\t\r\n\t\t\t\t\tposition = this.getPoint( index );\r\n\t\t\t\t\tnewpoints.push( tmpVec.copy( position ).clone() );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tnewpoints.push( tmpVec.copy( this.points[ i ] ).clone() );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.points = newpoints;\r\n\t\r\n\t\t};\r\n\t\r\n\t\t// Catmull-Rom\r\n\t\r\n\t\tfunction interpolate( p0, p1, p2, p3, t, t2, t3 ) {\r\n\t\r\n\t\t\tvar v0 = ( p2 - p0 ) * 0.5,\r\n\t\t\t\tv1 = ( p3 - p1 ) * 0.5;\r\n\t\r\n\t\t\treturn ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;\r\n\t\r\n\t\t};\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/math/Triangle.js\r\n\t\r\n\t/**\r\n\t * @author bhouston / http://exocortex.com\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.Triangle = function ( a, b, c ) {\r\n\t\r\n\t\tthis.a = ( a !== undefined ) ? a : new THREE.Vector3();\r\n\t\tthis.b = ( b !== undefined ) ? b : new THREE.Vector3();\r\n\t\tthis.c = ( c !== undefined ) ? c : new THREE.Vector3();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Triangle.normal = function () {\r\n\t\r\n\t\tvar v0 = new THREE.Vector3();\r\n\t\r\n\t\treturn function ( a, b, c, optionalTarget ) {\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\r\n\t\t\tresult.subVectors( c, b );\r\n\t\t\tv0.subVectors( a, b );\r\n\t\t\tresult.cross( v0 );\r\n\t\r\n\t\t\tvar resultLengthSq = result.lengthSq();\r\n\t\t\tif ( resultLengthSq > 0 ) {\r\n\t\r\n\t\t\t\treturn result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn result.set( 0, 0, 0 );\r\n\t\r\n\t\t};\r\n\t\r\n\t}();\r\n\t\r\n\t// static/instance method to calculate barycoordinates\r\n\t// based on: http://www.blackpawn.com/texts/pointinpoly/default.html\r\n\tTHREE.Triangle.barycoordFromPoint = function () {\r\n\t\r\n\t\tvar v0 = new THREE.Vector3();\r\n\t\tvar v1 = new THREE.Vector3();\r\n\t\tvar v2 = new THREE.Vector3();\r\n\t\r\n\t\treturn function ( point, a, b, c, optionalTarget ) {\r\n\t\r\n\t\t\tv0.subVectors( c, a );\r\n\t\t\tv1.subVectors( b, a );\r\n\t\t\tv2.subVectors( point, a );\r\n\t\r\n\t\t\tvar dot00 = v0.dot( v0 );\r\n\t\t\tvar dot01 = v0.dot( v1 );\r\n\t\t\tvar dot02 = v0.dot( v2 );\r\n\t\t\tvar dot11 = v1.dot( v1 );\r\n\t\t\tvar dot12 = v1.dot( v2 );\r\n\t\r\n\t\t\tvar denom = ( dot00 * dot11 - dot01 * dot01 );\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\r\n\t\t\t// colinear or singular triangle\r\n\t\t\tif ( denom == 0 ) {\r\n\t\t\t\t// arbitrary location outside of triangle?\r\n\t\t\t\t// not sure if this is the best idea, maybe should be returning undefined\r\n\t\t\t\treturn result.set( - 2, - 1, - 1 );\r\n\t\t\t}\r\n\t\r\n\t\t\tvar invDenom = 1 / denom;\r\n\t\t\tvar u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;\r\n\t\t\tvar v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;\r\n\t\r\n\t\t\t// barycoordinates must always sum to 1\r\n\t\t\treturn result.set( 1 - u - v, v, u );\r\n\t\r\n\t\t};\r\n\t\r\n\t}();\r\n\t\r\n\tTHREE.Triangle.containsPoint = function () {\r\n\t\r\n\t\tvar v1 = new THREE.Vector3();\r\n\t\r\n\t\treturn function ( point, a, b, c ) {\r\n\t\r\n\t\t\tvar result = THREE.Triangle.barycoordFromPoint( point, a, b, c, v1 );\r\n\t\r\n\t\t\treturn ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );\r\n\t\r\n\t\t};\r\n\t\r\n\t}();\r\n\t\r\n\tTHREE.Triangle.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Triangle,\r\n\t\r\n\t\tset: function ( a, b, c ) {\r\n\t\r\n\t\t\tthis.a.copy( a );\r\n\t\t\tthis.b.copy( b );\r\n\t\t\tthis.c.copy( c );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromPointsAndIndices: function ( points, i0, i1, i2 ) {\r\n\t\r\n\t\t\tthis.a.copy( points[ i0 ] );\r\n\t\t\tthis.b.copy( points[ i1 ] );\r\n\t\t\tthis.c.copy( points[ i2 ] );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( triangle ) {\r\n\t\r\n\t\t\tthis.a.copy( triangle.a );\r\n\t\t\tthis.b.copy( triangle.b );\r\n\t\t\tthis.c.copy( triangle.c );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tarea: function () {\r\n\t\r\n\t\t\tvar v0 = new THREE.Vector3();\r\n\t\t\tvar v1 = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function () {\r\n\t\r\n\t\t\t\tv0.subVectors( this.c, this.b );\r\n\t\t\t\tv1.subVectors( this.a, this.b );\r\n\t\r\n\t\t\t\treturn v0.cross( v1 ).length() * 0.5;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tmidpoint: function ( optionalTarget ) {\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\t\treturn result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tnormal: function ( optionalTarget ) {\r\n\t\r\n\t\t\treturn THREE.Triangle.normal( this.a, this.b, this.c, optionalTarget );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tplane: function ( optionalTarget ) {\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Plane();\r\n\t\r\n\t\t\treturn result.setFromCoplanarPoints( this.a, this.b, this.c );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tbarycoordFromPoint: function ( point, optionalTarget ) {\r\n\t\r\n\t\t\treturn THREE.Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcontainsPoint: function ( point ) {\r\n\t\r\n\t\t\treturn THREE.Triangle.containsPoint( point, this.a, this.b, this.c );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tequals: function ( triangle ) {\r\n\t\r\n\t\t\treturn triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new THREE.Triangle().copy( this );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/core/Clock.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.Clock = function ( autoStart ) {\r\n\t\r\n\t\tthis.autoStart = ( autoStart !== undefined ) ? autoStart : true;\r\n\t\r\n\t\tthis.startTime = 0;\r\n\t\tthis.oldTime = 0;\r\n\t\tthis.elapsedTime = 0;\r\n\t\r\n\t\tthis.running = false;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Clock.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Clock,\r\n\t\r\n\t\tstart: function () {\r\n\t\r\n\t\t\tthis.startTime = self.performance !== undefined && self.performance.now !== undefined\r\n\t\t\t\t\t\t ? self.performance.now()\r\n\t\t\t\t\t\t : Date.now();\r\n\t\r\n\t\t\tthis.oldTime = this.startTime;\r\n\t\t\tthis.running = true;\r\n\t\t},\r\n\t\r\n\t\tstop: function () {\r\n\t\r\n\t\t\tthis.getElapsedTime();\r\n\t\t\tthis.running = false;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetElapsedTime: function () {\r\n\t\r\n\t\t\tthis.getDelta();\r\n\t\t\treturn this.elapsedTime;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetDelta: function () {\r\n\t\r\n\t\t\tvar diff = 0;\r\n\t\r\n\t\t\tif ( this.autoStart && ! this.running ) {\r\n\t\r\n\t\t\t\tthis.start();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( this.running ) {\r\n\t\r\n\t\t\t\tvar newTime = self.performance !== undefined && self.performance.now !== undefined\r\n\t\t\t\t\t\t ? self.performance.now()\r\n\t\t\t\t\t\t : Date.now();\r\n\t\r\n\t\t\t\tdiff = 0.001 * ( newTime - this.oldTime );\r\n\t\t\t\tthis.oldTime = newTime;\r\n\t\r\n\t\t\t\tthis.elapsedTime += diff;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn diff;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/core/EventDispatcher.js\r\n\t\r\n\t/**\r\n\t * https://github.com/mrdoob/eventdispatcher.js/\r\n\t */\r\n\t\r\n\tTHREE.EventDispatcher = function () {}\r\n\t\r\n\tTHREE.EventDispatcher.prototype = {\r\n\t\r\n\t\tconstructor: THREE.EventDispatcher,\r\n\t\r\n\t\tapply: function ( object ) {\r\n\t\r\n\t\t\tobject.addEventListener = THREE.EventDispatcher.prototype.addEventListener;\r\n\t\t\tobject.hasEventListener = THREE.EventDispatcher.prototype.hasEventListener;\r\n\t\t\tobject.removeEventListener = THREE.EventDispatcher.prototype.removeEventListener;\r\n\t\t\tobject.dispatchEvent = THREE.EventDispatcher.prototype.dispatchEvent;\r\n\t\r\n\t\t},\r\n\t\r\n\t\taddEventListener: function ( type, listener ) {\r\n\t\r\n\t\t\tif ( this._listeners === undefined ) this._listeners = {};\r\n\t\r\n\t\t\tvar listeners = this._listeners;\r\n\t\r\n\t\t\tif ( listeners[ type ] === undefined ) {\r\n\t\r\n\t\t\t\tlisteners[ type ] = [];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( listeners[ type ].indexOf( listener ) === - 1 ) {\r\n\t\r\n\t\t\t\tlisteners[ type ].push( listener );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\thasEventListener: function ( type, listener ) {\r\n\t\r\n\t\t\tif ( this._listeners === undefined ) return false;\r\n\t\r\n\t\t\tvar listeners = this._listeners;\r\n\t\r\n\t\t\tif ( listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1 ) {\r\n\t\r\n\t\t\t\treturn true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn false;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tremoveEventListener: function ( type, listener ) {\r\n\t\r\n\t\t\tif ( this._listeners === undefined ) return;\r\n\t\r\n\t\t\tvar listeners = this._listeners;\r\n\t\t\tvar listenerArray = listeners[ type ];\r\n\t\r\n\t\t\tif ( listenerArray !== undefined ) {\r\n\t\r\n\t\t\t\tvar index = listenerArray.indexOf( listener );\r\n\t\r\n\t\t\t\tif ( index !== - 1 ) {\r\n\t\r\n\t\t\t\t\tlistenerArray.splice( index, 1 );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdispatchEvent: function ( event ) {\r\n\t\r\n\t\t\tif ( this._listeners === undefined ) return;\r\n\t\r\n\t\t\tvar listeners = this._listeners;\r\n\t\t\tvar listenerArray = listeners[ event.type ];\r\n\t\r\n\t\t\tif ( listenerArray !== undefined ) {\r\n\t\r\n\t\t\t\tevent.target = this;\r\n\t\r\n\t\t\t\tvar array = [];\r\n\t\t\t\tvar length = listenerArray.length;\r\n\t\r\n\t\t\t\tfor ( var i = 0; i < length; i ++ ) {\r\n\t\r\n\t\t\t\t\tarray[ i ] = listenerArray[ i ];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tfor ( var i = 0; i < length; i ++ ) {\r\n\t\r\n\t\t\t\t\tarray[ i ].call( this, event );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/core/Raycaster.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author bhouston / http://exocortex.com/\r\n\t * @author stephomi / http://stephaneginier.com/\r\n\t */\r\n\t\r\n\t( function ( THREE ) {\r\n\t\r\n\t\tTHREE.Raycaster = function ( origin, direction, near, far ) {\r\n\t\r\n\t\t\tthis.ray = new THREE.Ray( origin, direction );\r\n\t\t\t// direction is assumed to be normalized (for accurate distance calculations)\r\n\t\r\n\t\t\tthis.near = near || 0;\r\n\t\t\tthis.far = far || Infinity;\r\n\t\r\n\t\t\tthis.params = {\r\n\t\t\t\tSprite: {},\r\n\t\t\t\tMesh: {},\r\n\t\t\t\tPointCloud: { threshold: 1 },\r\n\t\t\t\tLOD: {},\r\n\t\t\t\tLine: {}\r\n\t\t\t};\r\n\t\r\n\t\t};\r\n\t\r\n\t\tvar descSort = function ( a, b ) {\r\n\t\r\n\t\t\treturn a.distance - b.distance;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tvar intersectObject = function ( object, raycaster, intersects, recursive ) {\r\n\t\r\n\t\t\tobject.raycast( raycaster, intersects );\r\n\t\r\n\t\t\tif ( recursive === true ) {\r\n\t\r\n\t\t\t\tvar children = object.children;\r\n\t\r\n\t\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\tintersectObject( children[ i ], raycaster, intersects, true );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\t//\r\n\t\r\n\t\tTHREE.Raycaster.prototype = {\r\n\t\r\n\t\t\tconstructor: THREE.Raycaster,\r\n\t\r\n\t\t\tprecision: 0.0001,\r\n\t\t\tlinePrecision: 1,\r\n\t\r\n\t\t\tset: function ( origin, direction ) {\r\n\t\r\n\t\t\t\t// direction is assumed to be normalized (for accurate distance calculations)\r\n\t\r\n\t\t\t\tthis.ray.set( origin, direction );\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\t\tsetFromCamera: function ( coords, camera ) {\r\n\t\r\n\t\t\t\t// camera is assumed _not_ to be a child of a transformed object\r\n\t\r\n\t\t\t\tif ( camera instanceof THREE.PerspectiveCamera ) {\r\n\t\r\n\t\t\t\t\tthis.ray.origin.copy( camera.position );\r\n\t\t\t\t\tthis.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( camera.position ).normalize();\r\n\t\r\n\t\t\t\t} else if ( camera instanceof THREE.OrthographicCamera ) {\r\n\t\r\n\t\t\t\t\tthis.ray.origin.set( coords.x, coords.y, - 1 ).unproject( camera );\r\n\t\t\t\t\tthis.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tTHREE.error( 'THREE.Raycaster: Unsupported camera type.' );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\t\tintersectObject: function ( object, recursive ) {\r\n\t\r\n\t\t\t\tvar intersects = [];\r\n\t\r\n\t\t\t\tintersectObject( object, this, intersects, recursive );\r\n\t\r\n\t\t\t\tintersects.sort( descSort );\r\n\t\r\n\t\t\t\treturn intersects;\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\t\tintersectObjects: function ( objects, recursive ) {\r\n\t\r\n\t\t\t\tvar intersects = [];\r\n\t\r\n\t\t\t\tif ( objects instanceof Array === false ) {\r\n\t\r\n\t\t\t\t\tTHREE.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );\r\n\t\t\t\t\treturn intersects;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tfor ( var i = 0, l = objects.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\tintersectObject( objects[ i ], this, intersects, recursive );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tintersects.sort( descSort );\r\n\t\r\n\t\t\t\treturn intersects;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t}( THREE ) );\r\n\t\r\n\t// File:src/core/Object3D.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author mikael emtinger / http://gomo.se/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t */\r\n\t\r\n\tTHREE.Object3D = function () {\r\n\t\r\n\t\tObject.defineProperty( this, 'id', { value: THREE.Object3DIdCount ++ } );\r\n\t\r\n\t\tthis.uuid = THREE.Math.generateUUID();\r\n\t\r\n\t\tthis.name = '';\r\n\t\tthis.type = 'Object3D';\r\n\t\r\n\t\tthis.parent = undefined;\r\n\t\tthis.children = [];\r\n\t\r\n\t\tthis.up = THREE.Object3D.DefaultUp.clone();\r\n\t\r\n\t\tvar position = new THREE.Vector3();\r\n\t\tvar rotation = new THREE.Euler();\r\n\t\tvar quaternion = new THREE.Quaternion();\r\n\t\tvar scale = new THREE.Vector3( 1, 1, 1 );\r\n\t\r\n\t\tvar onRotationChange = function () {\r\n\t\t\tquaternion.setFromEuler( rotation, false );\r\n\t\t};\r\n\t\r\n\t\tvar onQuaternionChange = function () {\r\n\t\t\trotation.setFromQuaternion( quaternion, undefined, false );\r\n\t\t};\r\n\t\r\n\t\trotation.onChange( onRotationChange );\r\n\t\tquaternion.onChange( onQuaternionChange );\r\n\t\r\n\t\tObject.defineProperties( this, {\r\n\t\t\tposition: {\r\n\t\t\t\tenumerable: true,\r\n\t\t\t\tvalue: position\r\n\t\t\t},\r\n\t\t\trotation: {\r\n\t\t\t\tenumerable: true,\r\n\t\t\t\tvalue: rotation\r\n\t\t\t},\r\n\t\t\tquaternion: {\r\n\t\t\t\tenumerable: true,\r\n\t\t\t\tvalue: quaternion\r\n\t\t\t},\r\n\t\t\tscale: {\r\n\t\t\t\tenumerable: true,\r\n\t\t\t\tvalue: scale\r\n\t\t\t}\r\n\t\t} );\r\n\t\r\n\t\tthis.rotationAutoUpdate = true;\r\n\t\r\n\t\tthis.matrix = new THREE.Matrix4();\r\n\t\tthis.matrixWorld = new THREE.Matrix4();\r\n\t\r\n\t\tthis.matrixAutoUpdate = true;\r\n\t\tthis.matrixWorldNeedsUpdate = false;\r\n\t\r\n\t\tthis.visible = true;\r\n\t\r\n\t\tthis.castShadow = false;\r\n\t\tthis.receiveShadow = false;\r\n\t\r\n\t\tthis.frustumCulled = true;\r\n\t\tthis.renderOrder = 0;\r\n\t\r\n\t\tthis.userData = {};\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Object3D.DefaultUp = new THREE.Vector3( 0, 1, 0 );\r\n\t\r\n\tTHREE.Object3D.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Object3D,\r\n\t\r\n\t\tget eulerOrder () {\r\n\t\r\n\t\t\tTHREE.warn( 'THREE.Object3D: .eulerOrder has been moved to .rotation.order.' );\r\n\t\r\n\t\t\treturn this.rotation.order;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tset eulerOrder ( value ) {\r\n\t\r\n\t\t\tTHREE.warn( 'THREE.Object3D: .eulerOrder has been moved to .rotation.order.' );\r\n\t\r\n\t\t\tthis.rotation.order = value;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tget useQuaternion () {\r\n\t\r\n\t\t\tTHREE.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tset useQuaternion ( value ) {\r\n\t\r\n\t\t\tTHREE.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tapplyMatrix: function ( matrix ) {\r\n\t\r\n\t\t\tthis.matrix.multiplyMatrices( matrix, this.matrix );\r\n\t\r\n\t\t\tthis.matrix.decompose( this.position, this.quaternion, this.scale );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetRotationFromAxisAngle: function ( axis, angle ) {\r\n\t\r\n\t\t\t// assumes axis is normalized\r\n\t\r\n\t\t\tthis.quaternion.setFromAxisAngle( axis, angle );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetRotationFromEuler: function ( euler ) {\r\n\t\r\n\t\t\tthis.quaternion.setFromEuler( euler, true );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetRotationFromMatrix: function ( m ) {\r\n\t\r\n\t\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\r\n\t\r\n\t\t\tthis.quaternion.setFromRotationMatrix( m );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetRotationFromQuaternion: function ( q ) {\r\n\t\r\n\t\t\t// assumes q is normalized\r\n\t\r\n\t\t\tthis.quaternion.copy( q );\r\n\t\r\n\t\t},\r\n\t\r\n\t\trotateOnAxis: function () {\r\n\t\r\n\t\t\t// rotate object on axis in object space\r\n\t\t\t// axis is assumed to be normalized\r\n\t\r\n\t\t\tvar q1 = new THREE.Quaternion();\r\n\t\r\n\t\t\treturn function ( axis, angle ) {\r\n\t\r\n\t\t\t\tq1.setFromAxisAngle( axis, angle );\r\n\t\r\n\t\t\t\tthis.quaternion.multiply( q1 );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\trotateX: function () {\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector3( 1, 0, 0 );\r\n\t\r\n\t\t\treturn function ( angle ) {\r\n\t\r\n\t\t\t\treturn this.rotateOnAxis( v1, angle );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\trotateY: function () {\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector3( 0, 1, 0 );\r\n\t\r\n\t\t\treturn function ( angle ) {\r\n\t\r\n\t\t\t\treturn this.rotateOnAxis( v1, angle );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\trotateZ: function () {\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector3( 0, 0, 1 );\r\n\t\r\n\t\t\treturn function ( angle ) {\r\n\t\r\n\t\t\t\treturn this.rotateOnAxis( v1, angle );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\ttranslateOnAxis: function () {\r\n\t\r\n\t\t\t// translate object by distance along axis in object space\r\n\t\t\t// axis is assumed to be normalized\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function ( axis, distance ) {\r\n\t\r\n\t\t\t\tv1.copy( axis ).applyQuaternion( this.quaternion );\r\n\t\r\n\t\t\t\tthis.position.add( v1.multiplyScalar( distance ) );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\ttranslate: function ( distance, axis ) {\r\n\t\r\n\t\t\tTHREE.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );\r\n\t\t\treturn this.translateOnAxis( axis, distance );\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttranslateX: function () {\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector3( 1, 0, 0 );\r\n\t\r\n\t\t\treturn function ( distance ) {\r\n\t\r\n\t\t\t\treturn this.translateOnAxis( v1, distance );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\ttranslateY: function () {\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector3( 0, 1, 0 );\r\n\t\r\n\t\t\treturn function ( distance ) {\r\n\t\r\n\t\t\t\treturn this.translateOnAxis( v1, distance );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\ttranslateZ: function () {\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector3( 0, 0, 1 );\r\n\t\r\n\t\t\treturn function ( distance ) {\r\n\t\r\n\t\t\t\treturn this.translateOnAxis( v1, distance );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tlocalToWorld: function ( vector ) {\r\n\t\r\n\t\t\treturn vector.applyMatrix4( this.matrixWorld );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tworldToLocal: function () {\r\n\t\r\n\t\t\tvar m1 = new THREE.Matrix4();\r\n\t\r\n\t\t\treturn function ( vector ) {\r\n\t\r\n\t\t\t\treturn vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tlookAt: function () {\r\n\t\r\n\t\t\t// This routine does not support objects with rotated and/or translated parent(s)\r\n\t\r\n\t\t\tvar m1 = new THREE.Matrix4();\r\n\t\r\n\t\t\treturn function ( vector ) {\r\n\t\r\n\t\t\t\tm1.lookAt( vector, this.position, this.up );\r\n\t\r\n\t\t\t\tthis.quaternion.setFromRotationMatrix( m1 );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tadd: function ( object ) {\r\n\t\r\n\t\t\tif ( arguments.length > 1 ) {\r\n\t\r\n\t\t\t\tfor ( var i = 0; i < arguments.length; i ++ ) {\r\n\t\r\n\t\t\t\t\tthis.add( arguments[ i ] );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t\tif ( object === this ) {\r\n\t\r\n\t\t\t\tTHREE.error( \"THREE.Object3D.add: object can't be added as a child of itself.\", object );\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( object instanceof THREE.Object3D ) {\r\n\t\r\n\t\t\t\tif ( object.parent !== undefined ) {\r\n\t\r\n\t\t\t\t\tobject.parent.remove( object );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tobject.parent = this;\r\n\t\t\t\tobject.dispatchEvent( { type: 'added' } );\r\n\t\r\n\t\t\t\tthis.children.push( object );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tTHREE.error( \"THREE.Object3D.add: object not an instance of THREE.Object3D.\", object );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tremove: function ( object ) {\r\n\t\r\n\t\t\tif ( arguments.length > 1 ) {\r\n\t\r\n\t\t\t\tfor ( var i = 0; i < arguments.length; i ++ ) {\r\n\t\r\n\t\t\t\t\tthis.remove( arguments[ i ] );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t\tvar index = this.children.indexOf( object );\r\n\t\r\n\t\t\tif ( index !== - 1 ) {\r\n\t\r\n\t\t\t\tobject.parent = undefined;\r\n\t\r\n\t\t\t\tobject.dispatchEvent( { type: 'removed' } );\r\n\t\r\n\t\t\t\tthis.children.splice( index, 1 );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetChildByName: function ( name ) {\r\n\t\r\n\t\t\tTHREE.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );\r\n\t\t\treturn this.getObjectByName( name );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetObjectById: function ( id ) {\r\n\t\r\n\t\t\treturn this.getObjectByProperty( 'id', id );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetObjectByName: function ( name ) {\r\n\t\r\n\t\t\treturn this.getObjectByProperty( 'name', name );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetObjectByProperty: function ( name, value ) {\r\n\t\r\n\t\t\tif ( this[ name ] === value ) return this;\r\n\t\r\n\t\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tvar child = this.children[ i ];\r\n\t\t\t\tvar object = child.getObjectByProperty( name, value );\r\n\t\r\n\t\t\t\tif ( object !== undefined ) {\r\n\t\r\n\t\t\t\t\treturn object;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn undefined;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetWorldPosition: function ( optionalTarget ) {\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\r\n\t\t\tthis.updateMatrixWorld( true );\r\n\t\r\n\t\t\treturn result.setFromMatrixPosition( this.matrixWorld );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetWorldQuaternion: function () {\r\n\t\r\n\t\t\tvar position = new THREE.Vector3();\r\n\t\t\tvar scale = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function ( optionalTarget ) {\r\n\t\r\n\t\t\t\tvar result = optionalTarget || new THREE.Quaternion();\r\n\t\r\n\t\t\t\tthis.updateMatrixWorld( true );\r\n\t\r\n\t\t\t\tthis.matrixWorld.decompose( position, result, scale );\r\n\t\r\n\t\t\t\treturn result;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tgetWorldRotation: function () {\r\n\t\r\n\t\t\tvar quaternion = new THREE.Quaternion();\r\n\t\r\n\t\t\treturn function ( optionalTarget ) {\r\n\t\r\n\t\t\t\tvar result = optionalTarget || new THREE.Euler();\r\n\t\r\n\t\t\t\tthis.getWorldQuaternion( quaternion );\r\n\t\r\n\t\t\t\treturn result.setFromQuaternion( quaternion, this.rotation.order, false );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tgetWorldScale: function () {\r\n\t\r\n\t\t\tvar position = new THREE.Vector3();\r\n\t\t\tvar quaternion = new THREE.Quaternion();\r\n\t\r\n\t\t\treturn function ( optionalTarget ) {\r\n\t\r\n\t\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\r\n\t\t\t\tthis.updateMatrixWorld( true );\r\n\t\r\n\t\t\t\tthis.matrixWorld.decompose( position, quaternion, result );\r\n\t\r\n\t\t\t\treturn result;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tgetWorldDirection: function () {\r\n\t\r\n\t\t\tvar quaternion = new THREE.Quaternion();\r\n\t\r\n\t\t\treturn function ( optionalTarget ) {\r\n\t\r\n\t\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\r\n\t\t\t\tthis.getWorldQuaternion( quaternion );\r\n\t\r\n\t\t\t\treturn result.set( 0, 0, 1 ).applyQuaternion( quaternion );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\traycast: function () {},\r\n\t\r\n\t\ttraverse: function ( callback ) {\r\n\t\r\n\t\t\tcallback( this );\r\n\t\r\n\t\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tthis.children[ i ].traverse( callback );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttraverseVisible: function ( callback ) {\r\n\t\r\n\t\t\tif ( this.visible === false ) return;\r\n\t\r\n\t\t\tcallback( this );\r\n\t\r\n\t\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tthis.children[ i ].traverseVisible( callback );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttraverseAncestors: function ( callback ) {\r\n\t\r\n\t\t\tif ( this.parent ) {\r\n\t\r\n\t\t\t\tcallback( this.parent );\r\n\t\r\n\t\t\t\tthis.parent.traverseAncestors( callback );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tupdateMatrix: function () {\r\n\t\r\n\t\t\tthis.matrix.compose( this.position, this.quaternion, this.scale );\r\n\t\r\n\t\t\tthis.matrixWorldNeedsUpdate = true;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tupdateMatrixWorld: function ( force ) {\r\n\t\r\n\t\t\tif ( this.matrixAutoUpdate === true ) this.updateMatrix();\r\n\t\r\n\t\t\tif ( this.matrixWorldNeedsUpdate === true || force === true ) {\r\n\t\r\n\t\t\t\tif ( this.parent === undefined ) {\r\n\t\r\n\t\t\t\t\tthis.matrixWorld.copy( this.matrix );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tthis.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tthis.matrixWorldNeedsUpdate = false;\r\n\t\r\n\t\t\t\tforce = true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// update children\r\n\t\r\n\t\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tthis.children[ i ].updateMatrixWorld( force );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttoJSON: function () {\r\n\t\r\n\t\t\tvar output = {\r\n\t\t\t\tmetadata: {\r\n\t\t\t\t\tversion: 4.3,\r\n\t\t\t\t\ttype: 'Object',\r\n\t\t\t\t\tgenerator: 'ObjectExporter'\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\r\n\t\t\t//\r\n\t\r\n\t\t\tvar geometries = {};\r\n\t\r\n\t\t\tvar parseGeometry = function ( geometry ) {\r\n\t\r\n\t\t\t\tif ( output.geometries === undefined ) {\r\n\t\r\n\t\t\t\t\toutput.geometries = [];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( geometries[ geometry.uuid ] === undefined ) {\r\n\t\r\n\t\t\t\t\tvar json = geometry.toJSON();\r\n\t\r\n\t\t\t\t\tdelete json.metadata;\r\n\t\r\n\t\t\t\t\tgeometries[ geometry.uuid ] = json;\r\n\t\r\n\t\t\t\t\toutput.geometries.push( json );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn geometry.uuid;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t\t//\r\n\t\r\n\t\t\tvar materials = {};\r\n\t\r\n\t\t\tvar parseMaterial = function ( material ) {\r\n\t\r\n\t\t\t\tif ( output.materials === undefined ) {\r\n\t\r\n\t\t\t\t\toutput.materials = [];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( materials[ material.uuid ] === undefined ) {\r\n\t\r\n\t\t\t\t\tvar json = material.toJSON();\r\n\t\r\n\t\t\t\t\tdelete json.metadata;\r\n\t\r\n\t\t\t\t\tmaterials[ material.uuid ] = json;\r\n\t\r\n\t\t\t\t\toutput.materials.push( json );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn material.uuid;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t\t//\r\n\t\r\n\t\t\tvar parseObject = function ( object ) {\r\n\t\r\n\t\t\t\tvar data = {};\r\n\t\r\n\t\t\t\tdata.uuid = object.uuid;\r\n\t\t\t\tdata.type = object.type;\r\n\t\r\n\t\t\t\tif ( object.name !== '' ) data.name = object.name;\r\n\t\t\t\tif ( JSON.stringify( object.userData ) !== '{}' ) data.userData = object.userData;\r\n\t\t\t\tif ( object.visible !== true ) data.visible = object.visible;\r\n\t\r\n\t\t\t\tif ( object instanceof THREE.PerspectiveCamera ) {\r\n\t\r\n\t\t\t\t\tdata.fov = object.fov;\r\n\t\t\t\t\tdata.aspect = object.aspect;\r\n\t\t\t\t\tdata.near = object.near;\r\n\t\t\t\t\tdata.far = object.far;\r\n\t\r\n\t\t\t\t} else if ( object instanceof THREE.OrthographicCamera ) {\r\n\t\r\n\t\t\t\t\tdata.left = object.left;\r\n\t\t\t\t\tdata.right = object.right;\r\n\t\t\t\t\tdata.top = object.top;\r\n\t\t\t\t\tdata.bottom = object.bottom;\r\n\t\t\t\t\tdata.near = object.near;\r\n\t\t\t\t\tdata.far = object.far;\r\n\t\r\n\t\t\t\t} else if ( object instanceof THREE.AmbientLight ) {\r\n\t\r\n\t\t\t\t\tdata.color = object.color.getHex();\r\n\t\r\n\t\t\t\t} else if ( object instanceof THREE.DirectionalLight ) {\r\n\t\r\n\t\t\t\t\tdata.color = object.color.getHex();\r\n\t\t\t\t\tdata.intensity = object.intensity;\r\n\t\r\n\t\t\t\t} else if ( object instanceof THREE.PointLight ) {\r\n\t\r\n\t\t\t\t\tdata.color = object.color.getHex();\r\n\t\t\t\t\tdata.intensity = object.intensity;\r\n\t\t\t\t\tdata.distance = object.distance;\r\n\t\t\t\t\tdata.decay = object.decay;\r\n\t\r\n\t\t\t\t} else if ( object instanceof THREE.SpotLight ) {\r\n\t\r\n\t\t\t\t\tdata.color = object.color.getHex();\r\n\t\t\t\t\tdata.intensity = object.intensity;\r\n\t\t\t\t\tdata.distance = object.distance;\r\n\t\t\t\t\tdata.angle = object.angle;\r\n\t\t\t\t\tdata.exponent = object.exponent;\r\n\t\t\t\t\tdata.decay = object.decay;\r\n\t\r\n\t\t\t\t} else if ( object instanceof THREE.HemisphereLight ) {\r\n\t\r\n\t\t\t\t\tdata.color = object.color.getHex();\r\n\t\t\t\t\tdata.groundColor = object.groundColor.getHex();\r\n\t\r\n\t\t\t\t} else if ( object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.PointCloud ) {\r\n\t\r\n\t\t\t\t\tdata.geometry = parseGeometry( object.geometry );\r\n\t\t\t\t\tdata.material = parseMaterial( object.material );\r\n\t\r\n\t\t\t\t\tif ( object instanceof THREE.Line ) data.mode = object.mode;\r\n\t\r\n\t\t\t\t} else if ( object instanceof THREE.Sprite ) {\r\n\t\r\n\t\t\t\t\tdata.material = parseMaterial( object.material );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tdata.matrix = object.matrix.toArray();\r\n\t\r\n\t\t\t\tif ( object.children.length > 0 ) {\r\n\t\r\n\t\t\t\t\tdata.children = [];\r\n\t\r\n\t\t\t\t\tfor ( var i = 0; i < object.children.length; i ++ ) {\r\n\t\r\n\t\t\t\t\t\tdata.children.push( parseObject( object.children[ i ] ) );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn data;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\toutput.object = parseObject( this );\r\n\t\r\n\t\t\treturn output;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function ( object, recursive ) {\r\n\t\r\n\t\t\tif ( object === undefined ) object = new THREE.Object3D();\r\n\t\t\tif ( recursive === undefined ) recursive = true;\r\n\t\r\n\t\t\tobject.name = this.name;\r\n\t\r\n\t\t\tobject.up.copy( this.up );\r\n\t\r\n\t\t\tobject.position.copy( this.position );\r\n\t\t\tobject.quaternion.copy( this.quaternion );\r\n\t\t\tobject.scale.copy( this.scale );\r\n\t\r\n\t\t\tobject.rotationAutoUpdate = this.rotationAutoUpdate;\r\n\t\r\n\t\t\tobject.matrix.copy( this.matrix );\r\n\t\t\tobject.matrixWorld.copy( this.matrixWorld );\r\n\t\r\n\t\t\tobject.matrixAutoUpdate = this.matrixAutoUpdate;\r\n\t\t\tobject.matrixWorldNeedsUpdate = this.matrixWorldNeedsUpdate;\r\n\t\r\n\t\t\tobject.visible = this.visible;\r\n\t\r\n\t\t\tobject.castShadow = this.castShadow;\r\n\t\t\tobject.receiveShadow = this.receiveShadow;\r\n\t\r\n\t\t\tobject.frustumCulled = this.frustumCulled;\r\n\t\r\n\t\t\tobject.userData = JSON.parse( JSON.stringify( this.userData ) );\r\n\t\r\n\t\t\tif ( recursive === true ) {\r\n\t\r\n\t\t\t\tfor ( var i = 0; i < this.children.length; i ++ ) {\r\n\t\r\n\t\t\t\t\tvar child = this.children[ i ];\r\n\t\t\t\t\tobject.add( child.clone() );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn object;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.EventDispatcher.prototype.apply( THREE.Object3D.prototype );\r\n\t\r\n\tTHREE.Object3DIdCount = 0;\r\n\t\r\n\t// File:src/core/Face3.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.Face3 = function ( a, b, c, normal, color, materialIndex ) {\r\n\t\r\n\t\tthis.a = a;\r\n\t\tthis.b = b;\r\n\t\tthis.c = c;\r\n\t\r\n\t\tthis.normal = normal instanceof THREE.Vector3 ? normal : new THREE.Vector3();\r\n\t\tthis.vertexNormals = normal instanceof Array ? normal : [];\r\n\t\r\n\t\tthis.color = color instanceof THREE.Color ? color : new THREE.Color();\r\n\t\tthis.vertexColors = color instanceof Array ? color : [];\r\n\t\r\n\t\tthis.vertexTangents = [];\r\n\t\r\n\t\tthis.materialIndex = materialIndex !== undefined ? materialIndex : 0;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Face3.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Face3,\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\tvar face = new THREE.Face3( this.a, this.b, this.c );\r\n\t\r\n\t\t\tface.normal.copy( this.normal );\r\n\t\t\tface.color.copy( this.color );\r\n\t\r\n\t\t\tface.materialIndex = this.materialIndex;\r\n\t\r\n\t\t\tfor ( var i = 0, il = this.vertexNormals.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tface.vertexNormals[ i ] = this.vertexNormals[ i ].clone();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfor ( var i = 0, il = this.vertexColors.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tface.vertexColors[ i ] = this.vertexColors[ i ].clone();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfor ( var i = 0, il = this.vertexTangents.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tface.vertexTangents[ i ] = this.vertexTangents[ i ].clone();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn face;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/core/Face4.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.Face4 = function ( a, b, c, d, normal, color, materialIndex ) {\r\n\t\r\n\t\tTHREE.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' )\r\n\t\treturn new THREE.Face3( a, b, c, normal, color, materialIndex );\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/core/BufferAttribute.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.BufferAttribute = function ( array, itemSize ) {\r\n\t\r\n\t\tthis.array = array;\r\n\t\tthis.itemSize = itemSize;\r\n\t\r\n\t\tthis.needsUpdate = false;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.BufferAttribute.prototype = {\r\n\t\r\n\t\tconstructor: THREE.BufferAttribute,\r\n\t\r\n\t\tget length () {\r\n\t\r\n\t\t\treturn this.array.length;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopyAt: function ( index1, attribute, index2 ) {\r\n\t\r\n\t\t\tindex1 *= this.itemSize;\r\n\t\t\tindex2 *= attribute.itemSize;\r\n\t\r\n\t\t\tfor ( var i = 0, l = this.itemSize; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tthis.array[ index1 + i ] = attribute.array[ index2 + i ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tset: function ( value, offset ) {\r\n\t\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\r\n\t\t\tthis.array.set( value, offset );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetX: function ( index, x ) {\r\n\t\r\n\t\t\tthis.array[ index * this.itemSize ] = x;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetY: function ( index, y ) {\r\n\t\r\n\t\t\tthis.array[ index * this.itemSize + 1 ] = y;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetZ: function ( index, z ) {\r\n\t\r\n\t\t\tthis.array[ index * this.itemSize + 2 ] = z;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetXY: function ( index, x, y ) {\r\n\t\r\n\t\t\tindex *= this.itemSize;\r\n\t\r\n\t\t\tthis.array[ index     ] = x;\r\n\t\t\tthis.array[ index + 1 ] = y;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetXYZ: function ( index, x, y, z ) {\r\n\t\r\n\t\t\tindex *= this.itemSize;\r\n\t\r\n\t\t\tthis.array[ index     ] = x;\r\n\t\t\tthis.array[ index + 1 ] = y;\r\n\t\t\tthis.array[ index + 2 ] = z;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetXYZW: function ( index, x, y, z, w ) {\r\n\t\r\n\t\t\tindex *= this.itemSize;\r\n\t\r\n\t\t\tthis.array[ index     ] = x;\r\n\t\t\tthis.array[ index + 1 ] = y;\r\n\t\t\tthis.array[ index + 2 ] = z;\r\n\t\t\tthis.array[ index + 3 ] = w;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new THREE.BufferAttribute( new this.array.constructor( this.array ), this.itemSize );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t//\r\n\t\r\n\tTHREE.Int8Attribute = function ( data, itemSize ) {\r\n\t\r\n\t\tTHREE.warn( 'THREE.Int8Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );\r\n\t\treturn new THREE.BufferAttribute( data, itemSize );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Uint8Attribute = function ( data, itemSize ) {\r\n\t\r\n\t\tTHREE.warn( 'THREE.Uint8Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );\r\n\t\treturn new THREE.BufferAttribute( data, itemSize );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Uint8ClampedAttribute = function ( data, itemSize ) {\r\n\t\r\n\t\tTHREE.warn( 'THREE.Uint8ClampedAttribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );\r\n\t\treturn new THREE.BufferAttribute( data, itemSize );\r\n\t\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Int16Attribute = function ( data, itemSize ) {\r\n\t\r\n\t\tTHREE.warn( 'THREE.Int16Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );\r\n\t\treturn new THREE.BufferAttribute( data, itemSize );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Uint16Attribute = function ( data, itemSize ) {\r\n\t\r\n\t\tTHREE.warn( 'THREE.Uint16Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );\r\n\t\treturn new THREE.BufferAttribute( data, itemSize );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Int32Attribute = function ( data, itemSize ) {\r\n\t\r\n\t\tTHREE.warn( 'THREE.Int32Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );\r\n\t\treturn new THREE.BufferAttribute( data, itemSize );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Uint32Attribute = function ( data, itemSize ) {\r\n\t\r\n\t\tTHREE.warn( 'THREE.Uint32Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );\r\n\t\treturn new THREE.BufferAttribute( data, itemSize );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Float32Attribute = function ( data, itemSize ) {\r\n\t\r\n\t\tTHREE.warn( 'THREE.Float32Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );\r\n\t\treturn new THREE.BufferAttribute( data, itemSize );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Float64Attribute = function ( data, itemSize ) {\r\n\t\r\n\t\tTHREE.warn( 'THREE.Float64Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );\r\n\t\treturn new THREE.BufferAttribute( data, itemSize );\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/core/DynamicBufferAttribute.js\r\n\t\r\n\t/**\r\n\t * @author benaadams / https://twitter.com/ben_a_adams\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.DynamicBufferAttribute = function ( array, itemSize ) {\r\n\t\r\n\t\tTHREE.BufferAttribute.call( this, array, itemSize );\r\n\t\r\n\t\tthis.updateRange = { offset: 0, count: -1 };\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.DynamicBufferAttribute.prototype = Object.create( THREE.BufferAttribute.prototype );\r\n\tTHREE.DynamicBufferAttribute.prototype.constructor = THREE.DynamicBufferAttribute;\r\n\t\r\n\tTHREE.DynamicBufferAttribute.prototype.clone = function () {\r\n\t\r\n\t\treturn new THREE.DynamicBufferAttribute( new this.array.constructor( this.array ), this.itemSize );\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/core/BufferGeometry.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.BufferGeometry = function () {\r\n\t\r\n\t\tObject.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );\r\n\t\r\n\t\tthis.uuid = THREE.Math.generateUUID();\r\n\t\r\n\t\tthis.name = '';\r\n\t\tthis.type = 'BufferGeometry';\r\n\t\r\n\t\tthis.attributes = {};\r\n\t\tthis.attributesKeys = [];\r\n\t\r\n\t\tthis.drawcalls = [];\r\n\t\tthis.offsets = this.drawcalls; // backwards compatibility\r\n\t\r\n\t\tthis.boundingBox = null;\r\n\t\tthis.boundingSphere = null;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.BufferGeometry.prototype = {\r\n\t\r\n\t\tconstructor: THREE.BufferGeometry,\r\n\t\r\n\t\taddAttribute: function ( name, attribute ) {\r\n\t\r\n\t\t\tif ( attribute instanceof THREE.BufferAttribute === false ) {\r\n\t\r\n\t\t\t\tTHREE.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );\r\n\t\r\n\t\t\t\tthis.attributes[ name ] = { array: arguments[ 1 ], itemSize: arguments[ 2 ] };\r\n\t\r\n\t\t\t\treturn;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.attributes[ name ] = attribute;\r\n\t\t\tthis.attributesKeys = Object.keys( this.attributes );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetAttribute: function ( name ) {\r\n\t\r\n\t\t\treturn this.attributes[ name ];\r\n\t\r\n\t\t},\r\n\t\r\n\t\taddDrawCall: function ( start, count, indexOffset ) {\r\n\t\r\n\t\t\tthis.drawcalls.push( {\r\n\t\r\n\t\t\t\tstart: start,\r\n\t\t\t\tcount: count,\r\n\t\t\t\tindex: indexOffset !== undefined ? indexOffset : 0\r\n\t\r\n\t\t\t} );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tapplyMatrix: function ( matrix ) {\r\n\t\r\n\t\t\tvar position = this.attributes.position;\r\n\t\r\n\t\t\tif ( position !== undefined ) {\r\n\t\r\n\t\t\t\tmatrix.applyToVector3Array( position.array );\r\n\t\t\t\tposition.needsUpdate = true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar normal = this.attributes.normal;\r\n\t\r\n\t\t\tif ( normal !== undefined ) {\r\n\t\r\n\t\t\t\tvar normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );\r\n\t\r\n\t\t\t\tnormalMatrix.applyToVector3Array( normal.array );\r\n\t\t\t\tnormal.needsUpdate = true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( this.boundingBox !== null ) {\r\n\t\r\n\t\t\t\tthis.computeBoundingBox();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( this.boundingSphere !== null ) {\r\n\t\r\n\t\t\t\tthis.computeBoundingSphere();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcenter: function () {\r\n\t\r\n\t\t\tthis.computeBoundingBox();\r\n\t\r\n\t\t\tvar offset = this.boundingBox.center().negate();\r\n\t\r\n\t\t\tthis.applyMatrix( new THREE.Matrix4().setPosition( offset ) );\r\n\t\r\n\t\t\treturn offset;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfromGeometry: function ( geometry, settings ) {\r\n\t\r\n\t\t\tsettings = settings || { 'vertexColors': THREE.NoColors };\r\n\t\r\n\t\t\tvar vertices = geometry.vertices;\r\n\t\t\tvar faces = geometry.faces;\r\n\t\t\tvar faceVertexUvs = geometry.faceVertexUvs;\r\n\t\t\tvar vertexColors = settings.vertexColors;\r\n\t\t\tvar hasFaceVertexUv = faceVertexUvs[ 0 ].length > 0;\r\n\t\t\tvar hasFaceVertexNormals = faces[ 0 ].vertexNormals.length == 3;\r\n\t\r\n\t\t\tvar positions = new Float32Array( faces.length * 3 * 3 );\r\n\t\t\tthis.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );\r\n\t\r\n\t\t\tvar normals = new Float32Array( faces.length * 3 * 3 );\r\n\t\t\tthis.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );\r\n\t\r\n\t\t\tif ( vertexColors !== THREE.NoColors ) {\r\n\t\r\n\t\t\t\tvar colors = new Float32Array( faces.length * 3 * 3 );\r\n\t\t\t\tthis.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( hasFaceVertexUv === true ) {\r\n\t\r\n\t\t\t\tvar uvs = new Float32Array( faces.length * 3 * 2 );\r\n\t\t\t\tthis.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfor ( var i = 0, i2 = 0, i3 = 0; i < faces.length; i ++, i2 += 6, i3 += 9 ) {\r\n\t\r\n\t\t\t\tvar face = faces[ i ];\r\n\t\r\n\t\t\t\tvar a = vertices[ face.a ];\r\n\t\t\t\tvar b = vertices[ face.b ];\r\n\t\t\t\tvar c = vertices[ face.c ];\r\n\t\r\n\t\t\t\tpositions[ i3     ] = a.x;\r\n\t\t\t\tpositions[ i3 + 1 ] = a.y;\r\n\t\t\t\tpositions[ i3 + 2 ] = a.z;\r\n\t\r\n\t\t\t\tpositions[ i3 + 3 ] = b.x;\r\n\t\t\t\tpositions[ i3 + 4 ] = b.y;\r\n\t\t\t\tpositions[ i3 + 5 ] = b.z;\r\n\t\r\n\t\t\t\tpositions[ i3 + 6 ] = c.x;\r\n\t\t\t\tpositions[ i3 + 7 ] = c.y;\r\n\t\t\t\tpositions[ i3 + 8 ] = c.z;\r\n\t\r\n\t\t\t\tif ( hasFaceVertexNormals === true ) {\r\n\t\r\n\t\t\t\t\tvar na = face.vertexNormals[ 0 ];\r\n\t\t\t\t\tvar nb = face.vertexNormals[ 1 ];\r\n\t\t\t\t\tvar nc = face.vertexNormals[ 2 ];\r\n\t\r\n\t\t\t\t\tnormals[ i3     ] = na.x;\r\n\t\t\t\t\tnormals[ i3 + 1 ] = na.y;\r\n\t\t\t\t\tnormals[ i3 + 2 ] = na.z;\r\n\t\r\n\t\t\t\t\tnormals[ i3 + 3 ] = nb.x;\r\n\t\t\t\t\tnormals[ i3 + 4 ] = nb.y;\r\n\t\t\t\t\tnormals[ i3 + 5 ] = nb.z;\r\n\t\r\n\t\t\t\t\tnormals[ i3 + 6 ] = nc.x;\r\n\t\t\t\t\tnormals[ i3 + 7 ] = nc.y;\r\n\t\t\t\t\tnormals[ i3 + 8 ] = nc.z;\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tvar n = face.normal;\r\n\t\r\n\t\t\t\t\tnormals[ i3     ] = n.x;\r\n\t\t\t\t\tnormals[ i3 + 1 ] = n.y;\r\n\t\t\t\t\tnormals[ i3 + 2 ] = n.z;\r\n\t\r\n\t\t\t\t\tnormals[ i3 + 3 ] = n.x;\r\n\t\t\t\t\tnormals[ i3 + 4 ] = n.y;\r\n\t\t\t\t\tnormals[ i3 + 5 ] = n.z;\r\n\t\r\n\t\t\t\t\tnormals[ i3 + 6 ] = n.x;\r\n\t\t\t\t\tnormals[ i3 + 7 ] = n.y;\r\n\t\t\t\t\tnormals[ i3 + 8 ] = n.z;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( vertexColors === THREE.FaceColors ) {\r\n\t\r\n\t\t\t\t\tvar fc = face.color;\r\n\t\r\n\t\t\t\t\tcolors[ i3     ] = fc.r;\r\n\t\t\t\t\tcolors[ i3 + 1 ] = fc.g;\r\n\t\t\t\t\tcolors[ i3 + 2 ] = fc.b;\r\n\t\r\n\t\t\t\t\tcolors[ i3 + 3 ] = fc.r;\r\n\t\t\t\t\tcolors[ i3 + 4 ] = fc.g;\r\n\t\t\t\t\tcolors[ i3 + 5 ] = fc.b;\r\n\t\r\n\t\t\t\t\tcolors[ i3 + 6 ] = fc.r;\r\n\t\t\t\t\tcolors[ i3 + 7 ] = fc.g;\r\n\t\t\t\t\tcolors[ i3 + 8 ] = fc.b;\r\n\t\r\n\t\t\t\t} else if ( vertexColors === THREE.VertexColors ) {\r\n\t\r\n\t\t\t\t\tvar vca = face.vertexColors[ 0 ];\r\n\t\t\t\t\tvar vcb = face.vertexColors[ 1 ];\r\n\t\t\t\t\tvar vcc = face.vertexColors[ 2 ];\r\n\t\r\n\t\t\t\t\tcolors[ i3     ] = vca.r;\r\n\t\t\t\t\tcolors[ i3 + 1 ] = vca.g;\r\n\t\t\t\t\tcolors[ i3 + 2 ] = vca.b;\r\n\t\r\n\t\t\t\t\tcolors[ i3 + 3 ] = vcb.r;\r\n\t\t\t\t\tcolors[ i3 + 4 ] = vcb.g;\r\n\t\t\t\t\tcolors[ i3 + 5 ] = vcb.b;\r\n\t\r\n\t\t\t\t\tcolors[ i3 + 6 ] = vcc.r;\r\n\t\t\t\t\tcolors[ i3 + 7 ] = vcc.g;\r\n\t\t\t\t\tcolors[ i3 + 8 ] = vcc.b;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( hasFaceVertexUv === true ) {\r\n\t\r\n\t\t\t\t\tvar uva = faceVertexUvs[ 0 ][ i ][ 0 ];\r\n\t\t\t\t\tvar uvb = faceVertexUvs[ 0 ][ i ][ 1 ];\r\n\t\t\t\t\tvar uvc = faceVertexUvs[ 0 ][ i ][ 2 ];\r\n\t\r\n\t\t\t\t\tuvs[ i2     ] = uva.x;\r\n\t\t\t\t\tuvs[ i2 + 1 ] = uva.y;\r\n\t\r\n\t\t\t\t\tuvs[ i2 + 2 ] = uvb.x;\r\n\t\t\t\t\tuvs[ i2 + 3 ] = uvb.y;\r\n\t\r\n\t\t\t\t\tuvs[ i2 + 4 ] = uvc.x;\r\n\t\t\t\t\tuvs[ i2 + 5 ] = uvc.y;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.computeBoundingSphere()\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcomputeBoundingBox: function () {\r\n\t\r\n\t\t\tvar vector = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function () {\r\n\t\r\n\t\t\t\tif ( this.boundingBox === null ) {\r\n\t\r\n\t\t\t\t\tthis.boundingBox = new THREE.Box3();\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar positions = this.attributes.position.array;\r\n\t\r\n\t\t\t\tif ( positions ) {\r\n\t\r\n\t\t\t\t\tvar bb = this.boundingBox;\r\n\t\t\t\t\tbb.makeEmpty();\r\n\t\r\n\t\t\t\t\tfor ( var i = 0, il = positions.length; i < il; i += 3 ) {\r\n\t\r\n\t\t\t\t\t\tvector.set( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );\r\n\t\t\t\t\t\tbb.expandByPoint( vector );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( positions === undefined || positions.length === 0 ) {\r\n\t\r\n\t\t\t\t\tthis.boundingBox.min.set( 0, 0, 0 );\r\n\t\t\t\t\tthis.boundingBox.max.set( 0, 0, 0 );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {\r\n\t\r\n\t\t\t\t\tTHREE.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.' );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tcomputeBoundingSphere: function () {\r\n\t\r\n\t\t\tvar box = new THREE.Box3();\r\n\t\t\tvar vector = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function () {\r\n\t\r\n\t\t\t\tif ( this.boundingSphere === null ) {\r\n\t\r\n\t\t\t\t\tthis.boundingSphere = new THREE.Sphere();\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar positions = this.attributes.position.array;\r\n\t\r\n\t\t\t\tif ( positions ) {\r\n\t\r\n\t\t\t\t\tbox.makeEmpty();\r\n\t\r\n\t\t\t\t\tvar center = this.boundingSphere.center;\r\n\t\r\n\t\t\t\t\tfor ( var i = 0, il = positions.length; i < il; i += 3 ) {\r\n\t\r\n\t\t\t\t\t\tvector.set( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );\r\n\t\t\t\t\t\tbox.expandByPoint( vector );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tbox.center( center );\r\n\t\r\n\t\t\t\t\t// hoping to find a boundingSphere with a radius smaller than the\r\n\t\t\t\t\t// boundingSphere of the boundingBox:  sqrt(3) smaller in the best case\r\n\t\r\n\t\t\t\t\tvar maxRadiusSq = 0;\r\n\t\r\n\t\t\t\t\tfor ( var i = 0, il = positions.length; i < il; i += 3 ) {\r\n\t\r\n\t\t\t\t\t\tvector.set( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );\r\n\t\t\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tthis.boundingSphere.radius = Math.sqrt( maxRadiusSq );\r\n\t\r\n\t\t\t\t\tif ( isNaN( this.boundingSphere.radius ) ) {\r\n\t\r\n\t\t\t\t\t\tTHREE.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.' );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tcomputeFaceNormals: function () {\r\n\t\r\n\t\t\t// backwards compatibility\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcomputeVertexNormals: function () {\r\n\t\r\n\t\t\tvar attributes = this.attributes;\r\n\t\r\n\t\t\tif ( attributes.position ) {\r\n\t\r\n\t\t\t\tvar positions = attributes.position.array;\r\n\t\r\n\t\t\t\tif ( attributes.normal === undefined ) {\r\n\t\r\n\t\t\t\t\tthis.addAttribute( 'normal', new THREE.BufferAttribute( new Float32Array( positions.length ), 3 ) );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t// reset existing normals to zero\r\n\t\r\n\t\t\t\t\tvar normals = attributes.normal.array;\r\n\t\r\n\t\t\t\t\tfor ( var i = 0, il = normals.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\t\tnormals[ i ] = 0;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar normals = attributes.normal.array;\r\n\t\r\n\t\t\t\tvar vA, vB, vC,\r\n\t\r\n\t\t\t\tpA = new THREE.Vector3(),\r\n\t\t\t\tpB = new THREE.Vector3(),\r\n\t\t\t\tpC = new THREE.Vector3(),\r\n\t\r\n\t\t\t\tcb = new THREE.Vector3(),\r\n\t\t\t\tab = new THREE.Vector3();\r\n\t\r\n\t\t\t\t// indexed elements\r\n\t\r\n\t\t\t\tif ( attributes.index ) {\r\n\t\r\n\t\t\t\t\tvar indices = attributes.index.array;\r\n\t\r\n\t\t\t\t\tvar offsets = ( this.offsets.length > 0 ? this.offsets : [ { start: 0, count: indices.length, index: 0 } ] );\r\n\t\r\n\t\t\t\t\tfor ( var j = 0, jl = offsets.length; j < jl; ++ j ) {\r\n\t\r\n\t\t\t\t\t\tvar start = offsets[ j ].start;\r\n\t\t\t\t\t\tvar count = offsets[ j ].count;\r\n\t\t\t\t\t\tvar index = offsets[ j ].index;\r\n\t\r\n\t\t\t\t\t\tfor ( var i = start, il = start + count; i < il; i += 3 ) {\r\n\t\r\n\t\t\t\t\t\t\tvA = ( index + indices[ i     ] ) * 3;\r\n\t\t\t\t\t\t\tvB = ( index + indices[ i + 1 ] ) * 3;\r\n\t\t\t\t\t\t\tvC = ( index + indices[ i + 2 ] ) * 3;\r\n\t\r\n\t\t\t\t\t\t\tpA.fromArray( positions, vA );\r\n\t\t\t\t\t\t\tpB.fromArray( positions, vB );\r\n\t\t\t\t\t\t\tpC.fromArray( positions, vC );\r\n\t\r\n\t\t\t\t\t\t\tcb.subVectors( pC, pB );\r\n\t\t\t\t\t\t\tab.subVectors( pA, pB );\r\n\t\t\t\t\t\t\tcb.cross( ab );\r\n\t\r\n\t\t\t\t\t\t\tnormals[ vA     ] += cb.x;\r\n\t\t\t\t\t\t\tnormals[ vA + 1 ] += cb.y;\r\n\t\t\t\t\t\t\tnormals[ vA + 2 ] += cb.z;\r\n\t\r\n\t\t\t\t\t\t\tnormals[ vB     ] += cb.x;\r\n\t\t\t\t\t\t\tnormals[ vB + 1 ] += cb.y;\r\n\t\t\t\t\t\t\tnormals[ vB + 2 ] += cb.z;\r\n\t\r\n\t\t\t\t\t\t\tnormals[ vC     ] += cb.x;\r\n\t\t\t\t\t\t\tnormals[ vC + 1 ] += cb.y;\r\n\t\t\t\t\t\t\tnormals[ vC + 2 ] += cb.z;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t// non-indexed elements (unconnected triangle soup)\r\n\t\r\n\t\t\t\t\tfor ( var i = 0, il = positions.length; i < il; i += 9 ) {\r\n\t\r\n\t\t\t\t\t\tpA.fromArray( positions, i );\r\n\t\t\t\t\t\tpB.fromArray( positions, i + 3 );\r\n\t\t\t\t\t\tpC.fromArray( positions, i + 6 );\r\n\t\r\n\t\t\t\t\t\tcb.subVectors( pC, pB );\r\n\t\t\t\t\t\tab.subVectors( pA, pB );\r\n\t\t\t\t\t\tcb.cross( ab );\r\n\t\r\n\t\t\t\t\t\tnormals[ i     ] = cb.x;\r\n\t\t\t\t\t\tnormals[ i + 1 ] = cb.y;\r\n\t\t\t\t\t\tnormals[ i + 2 ] = cb.z;\r\n\t\r\n\t\t\t\t\t\tnormals[ i + 3 ] = cb.x;\r\n\t\t\t\t\t\tnormals[ i + 4 ] = cb.y;\r\n\t\t\t\t\t\tnormals[ i + 5 ] = cb.z;\r\n\t\r\n\t\t\t\t\t\tnormals[ i + 6 ] = cb.x;\r\n\t\t\t\t\t\tnormals[ i + 7 ] = cb.y;\r\n\t\t\t\t\t\tnormals[ i + 8 ] = cb.z;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tthis.normalizeNormals();\r\n\t\r\n\t\t\t\tattributes.normal.needsUpdate = true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcomputeTangents: function () {\r\n\t\r\n\t\t\t// based on http://www.terathon.com/code/tangent.html\r\n\t\t\t// (per vertex tangents)\r\n\t\r\n\t\t\tif ( this.attributes.index === undefined ||\r\n\t\t\t\t this.attributes.position === undefined ||\r\n\t\t\t\t this.attributes.normal === undefined ||\r\n\t\t\t\t this.attributes.uv === undefined ) {\r\n\t\r\n\t\t\t\tTHREE.warn( 'THREE.BufferGeometry: Missing required attributes (index, position, normal or uv) in BufferGeometry.computeTangents()' );\r\n\t\t\t\treturn;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar indices = this.attributes.index.array;\r\n\t\t\tvar positions = this.attributes.position.array;\r\n\t\t\tvar normals = this.attributes.normal.array;\r\n\t\t\tvar uvs = this.attributes.uv.array;\r\n\t\r\n\t\t\tvar nVertices = positions.length / 3;\r\n\t\r\n\t\t\tif ( this.attributes.tangent === undefined ) {\r\n\t\r\n\t\t\t\tthis.addAttribute( 'tangent', new THREE.BufferAttribute( new Float32Array( 4 * nVertices ), 4 ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar tangents = this.attributes.tangent.array;\r\n\t\r\n\t\t\tvar tan1 = [], tan2 = [];\r\n\t\r\n\t\t\tfor ( var k = 0; k < nVertices; k ++ ) {\r\n\t\r\n\t\t\t\ttan1[ k ] = new THREE.Vector3();\r\n\t\t\t\ttan2[ k ] = new THREE.Vector3();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar vA = new THREE.Vector3(),\r\n\t\t\t\tvB = new THREE.Vector3(),\r\n\t\t\t\tvC = new THREE.Vector3(),\r\n\t\r\n\t\t\t\tuvA = new THREE.Vector2(),\r\n\t\t\t\tuvB = new THREE.Vector2(),\r\n\t\t\t\tuvC = new THREE.Vector2(),\r\n\t\r\n\t\t\t\tx1, x2, y1, y2, z1, z2,\r\n\t\t\t\ts1, s2, t1, t2, r;\r\n\t\r\n\t\t\tvar sdir = new THREE.Vector3(), tdir = new THREE.Vector3();\r\n\t\r\n\t\t\tfunction handleTriangle( a, b, c ) {\r\n\t\r\n\t\t\t\tvA.fromArray( positions, a * 3 );\r\n\t\t\t\tvB.fromArray( positions, b * 3 );\r\n\t\t\t\tvC.fromArray( positions, c * 3 );\r\n\t\r\n\t\t\t\tuvA.fromArray( uvs, a * 2 );\r\n\t\t\t\tuvB.fromArray( uvs, b * 2 );\r\n\t\t\t\tuvC.fromArray( uvs, c * 2 );\r\n\t\r\n\t\t\t\tx1 = vB.x - vA.x;\r\n\t\t\t\tx2 = vC.x - vA.x;\r\n\t\r\n\t\t\t\ty1 = vB.y - vA.y;\r\n\t\t\t\ty2 = vC.y - vA.y;\r\n\t\r\n\t\t\t\tz1 = vB.z - vA.z;\r\n\t\t\t\tz2 = vC.z - vA.z;\r\n\t\r\n\t\t\t\ts1 = uvB.x - uvA.x;\r\n\t\t\t\ts2 = uvC.x - uvA.x;\r\n\t\r\n\t\t\t\tt1 = uvB.y - uvA.y;\r\n\t\t\t\tt2 = uvC.y - uvA.y;\r\n\t\r\n\t\t\t\tr = 1.0 / ( s1 * t2 - s2 * t1 );\r\n\t\r\n\t\t\t\tsdir.set(\r\n\t\t\t\t\t( t2 * x1 - t1 * x2 ) * r,\r\n\t\t\t\t\t( t2 * y1 - t1 * y2 ) * r,\r\n\t\t\t\t\t( t2 * z1 - t1 * z2 ) * r\r\n\t\t\t\t);\r\n\t\r\n\t\t\t\ttdir.set(\r\n\t\t\t\t\t( s1 * x2 - s2 * x1 ) * r,\r\n\t\t\t\t\t( s1 * y2 - s2 * y1 ) * r,\r\n\t\t\t\t\t( s1 * z2 - s2 * z1 ) * r\r\n\t\t\t\t);\r\n\t\r\n\t\t\t\ttan1[ a ].add( sdir );\r\n\t\t\t\ttan1[ b ].add( sdir );\r\n\t\t\t\ttan1[ c ].add( sdir );\r\n\t\r\n\t\t\t\ttan2[ a ].add( tdir );\r\n\t\t\t\ttan2[ b ].add( tdir );\r\n\t\t\t\ttan2[ c ].add( tdir );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar i, il;\r\n\t\t\tvar j, jl;\r\n\t\t\tvar iA, iB, iC;\r\n\t\r\n\t\t\tif ( this.drawcalls.length === 0 ) {\r\n\t\r\n\t\t\t\tthis.addDrawCall( 0, indices.length, 0 );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar drawcalls = this.drawcalls;\r\n\t\r\n\t\t\tfor ( j = 0, jl = drawcalls.length; j < jl; ++ j ) {\r\n\t\r\n\t\t\t\tvar start = drawcalls[ j ].start;\r\n\t\t\t\tvar count = drawcalls[ j ].count;\r\n\t\t\t\tvar index = drawcalls[ j ].index;\r\n\t\r\n\t\t\t\tfor ( i = start, il = start + count; i < il; i += 3 ) {\r\n\t\r\n\t\t\t\t\tiA = index + indices[ i ];\r\n\t\t\t\t\tiB = index + indices[ i + 1 ];\r\n\t\t\t\t\tiC = index + indices[ i + 2 ];\r\n\t\r\n\t\t\t\t\thandleTriangle( iA, iB, iC );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar tmp = new THREE.Vector3(), tmp2 = new THREE.Vector3();\r\n\t\t\tvar n = new THREE.Vector3(), n2 = new THREE.Vector3();\r\n\t\t\tvar w, t, test;\r\n\t\r\n\t\t\tfunction handleVertex( v ) {\r\n\t\r\n\t\t\t\tn.fromArray( normals, v * 3 );\r\n\t\t\t\tn2.copy( n );\r\n\t\r\n\t\t\t\tt = tan1[ v ];\r\n\t\r\n\t\t\t\t// Gram-Schmidt orthogonalize\r\n\t\r\n\t\t\t\ttmp.copy( t );\r\n\t\t\t\ttmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();\r\n\t\r\n\t\t\t\t// Calculate handedness\r\n\t\r\n\t\t\t\ttmp2.crossVectors( n2, t );\r\n\t\t\t\ttest = tmp2.dot( tan2[ v ] );\r\n\t\t\t\tw = ( test < 0.0 ) ? - 1.0 : 1.0;\r\n\t\r\n\t\t\t\ttangents[ v * 4     ] = tmp.x;\r\n\t\t\t\ttangents[ v * 4 + 1 ] = tmp.y;\r\n\t\t\t\ttangents[ v * 4 + 2 ] = tmp.z;\r\n\t\t\t\ttangents[ v * 4 + 3 ] = w;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfor ( j = 0, jl = drawcalls.length; j < jl; ++ j ) {\r\n\t\r\n\t\t\t\tvar start = drawcalls[ j ].start;\r\n\t\t\t\tvar count = drawcalls[ j ].count;\r\n\t\t\t\tvar index = drawcalls[ j ].index;\r\n\t\r\n\t\t\t\tfor ( i = start, il = start + count; i < il; i += 3 ) {\r\n\t\r\n\t\t\t\t\tiA = index + indices[ i ];\r\n\t\t\t\t\tiB = index + indices[ i + 1 ];\r\n\t\t\t\t\tiC = index + indices[ i + 2 ];\r\n\t\r\n\t\t\t\t\thandleVertex( iA );\r\n\t\t\t\t\thandleVertex( iB );\r\n\t\t\t\t\thandleVertex( iC );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\t/*\r\n\t\tCompute the draw offset for large models by chunking the index buffer into chunks of 65k addressable vertices.\r\n\t\tThis method will effectively rewrite the index buffer and remap all attributes to match the new indices.\r\n\t\tWARNING: This method will also expand the vertex count to prevent sprawled triangles across draw offsets.\r\n\t\tsize - Defaults to 65535, but allows for larger or smaller chunks.\r\n\t\t*/\r\n\t\tcomputeOffsets: function ( size ) {\r\n\t\r\n\t\t\tif ( size === undefined ) size = 65535; // WebGL limits type of index buffer values to 16-bit.\r\n\t\r\n\t\t\tvar indices = this.attributes.index.array;\r\n\t\t\tvar vertices = this.attributes.position.array;\r\n\t\r\n\t\t\tvar facesCount = ( indices.length / 3 );\r\n\t\r\n\t\t\t/*\r\n\t\t\tconsole.log(\"Computing buffers in offsets of \"+size+\" -> indices:\"+indices.length+\" vertices:\"+vertices.length);\r\n\t\t\tconsole.log(\"Faces to process: \"+(indices.length/3));\r\n\t\t\tconsole.log(\"Reordering \"+verticesCount+\" vertices.\");\r\n\t\t\t*/\r\n\t\r\n\t\t\tvar sortedIndices = new Uint16Array( indices.length ); //16-bit buffers\r\n\t\t\tvar indexPtr = 0;\r\n\t\t\tvar vertexPtr = 0;\r\n\t\r\n\t\t\tvar offsets = [ { start:0, count:0, index:0 } ];\r\n\t\t\tvar offset = offsets[ 0 ];\r\n\t\r\n\t\t\tvar duplicatedVertices = 0;\r\n\t\t\tvar newVerticeMaps = 0;\r\n\t\t\tvar faceVertices = new Int32Array( 6 );\r\n\t\t\tvar vertexMap = new Int32Array( vertices.length );\r\n\t\t\tvar revVertexMap = new Int32Array( vertices.length );\r\n\t\t\tfor ( var j = 0; j < vertices.length; j ++ ) { vertexMap[ j ] = - 1; revVertexMap[ j ] = - 1; }\r\n\t\r\n\t\t\t/*\r\n\t\t\t\tTraverse every face and reorder vertices in the proper offsets of 65k.\r\n\t\t\t\tWe can have more than 65k entries in the index buffer per offset, but only reference 65k values.\r\n\t\t\t*/\r\n\t\t\tfor ( var findex = 0; findex < facesCount; findex ++ ) {\r\n\t\t\t\tnewVerticeMaps = 0;\r\n\t\r\n\t\t\t\tfor ( var vo = 0; vo < 3; vo ++ ) {\r\n\t\t\t\t\tvar vid = indices[ findex * 3 + vo ];\r\n\t\t\t\t\tif ( vertexMap[ vid ] == - 1 ) {\r\n\t\t\t\t\t\t//Unmapped vertice\r\n\t\t\t\t\t\tfaceVertices[ vo * 2 ] = vid;\r\n\t\t\t\t\t\tfaceVertices[ vo * 2 + 1 ] = - 1;\r\n\t\t\t\t\t\tnewVerticeMaps ++;\r\n\t\t\t\t\t} else if ( vertexMap[ vid ] < offset.index ) {\r\n\t\t\t\t\t\t//Reused vertices from previous block (duplicate)\r\n\t\t\t\t\t\tfaceVertices[ vo * 2 ] = vid;\r\n\t\t\t\t\t\tfaceVertices[ vo * 2 + 1 ] = - 1;\r\n\t\t\t\t\t\tduplicatedVertices ++;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t//Reused vertice in the current block\r\n\t\t\t\t\t\tfaceVertices[ vo * 2 ] = vid;\r\n\t\t\t\t\t\tfaceVertices[ vo * 2 + 1 ] = vertexMap[ vid ];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar faceMax = vertexPtr + newVerticeMaps;\r\n\t\t\t\tif ( faceMax > ( offset.index + size ) ) {\r\n\t\t\t\t\tvar new_offset = { start:indexPtr, count:0, index:vertexPtr };\r\n\t\t\t\t\toffsets.push( new_offset );\r\n\t\t\t\t\toffset = new_offset;\r\n\t\r\n\t\t\t\t\t//Re-evaluate reused vertices in light of new offset.\r\n\t\t\t\t\tfor ( var v = 0; v < 6; v += 2 ) {\r\n\t\t\t\t\t\tvar new_vid = faceVertices[ v + 1 ];\r\n\t\t\t\t\t\tif ( new_vid > - 1 && new_vid < offset.index )\r\n\t\t\t\t\t\t\tfaceVertices[ v + 1 ] = - 1;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t//Reindex the face.\r\n\t\t\t\tfor ( var v = 0; v < 6; v += 2 ) {\r\n\t\t\t\t\tvar vid = faceVertices[ v ];\r\n\t\t\t\t\tvar new_vid = faceVertices[ v + 1 ];\r\n\t\r\n\t\t\t\t\tif ( new_vid === - 1 )\r\n\t\t\t\t\t\tnew_vid = vertexPtr ++;\r\n\t\r\n\t\t\t\t\tvertexMap[ vid ] = new_vid;\r\n\t\t\t\t\trevVertexMap[ new_vid ] = vid;\r\n\t\t\t\t\tsortedIndices[ indexPtr ++ ] = new_vid - offset.index; //XXX overflows at 16bit\r\n\t\t\t\t\toffset.count ++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\r\n\t\t\t/* Move all attribute values to map to the new computed indices , also expand the vertice stack to match our new vertexPtr. */\r\n\t\t\tthis.reorderBuffers( sortedIndices, revVertexMap, vertexPtr );\r\n\t\t\tthis.offsets = offsets; // TODO: Deprecate\r\n\t\t\tthis.drawcalls = offsets;\r\n\t\r\n\t\t\t/*\r\n\t\t\tvar orderTime = Date.now();\r\n\t\t\tconsole.log(\"Reorder time: \"+(orderTime-s)+\"ms\");\r\n\t\t\tconsole.log(\"Duplicated \"+duplicatedVertices+\" vertices.\");\r\n\t\t\tconsole.log(\"Compute Buffers time: \"+(Date.now()-s)+\"ms\");\r\n\t\t\tconsole.log(\"Draw offsets: \"+offsets.length);\r\n\t\t\t*/\r\n\t\r\n\t\t\treturn offsets;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmerge: function ( geometry, offset ) {\r\n\t\r\n\t\t\tif ( geometry instanceof THREE.BufferGeometry === false ) {\r\n\t\r\n\t\t\t\tTHREE.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );\r\n\t\t\t\treturn;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\r\n\t\t\tvar attributes = this.attributes;\r\n\t\r\n\t\t\tfor ( var key in attributes ) {\r\n\t\r\n\t\t\t\tif ( geometry.attributes[ key ] === undefined ) continue;\r\n\t\r\n\t\t\t\tvar attribute1 = attributes[ key ];\r\n\t\t\t\tvar attributeArray1 = attribute1.array;\r\n\t\r\n\t\t\t\tvar attribute2 = geometry.attributes[ key ];\r\n\t\t\t\tvar attributeArray2 = attribute2.array;\r\n\t\r\n\t\t\t\tvar attributeSize = attribute2.itemSize;\r\n\t\r\n\t\t\t\tfor ( var i = 0, j = attributeSize * offset; i < attributeArray2.length; i ++, j ++ ) {\r\n\t\r\n\t\t\t\t\tattributeArray1[ j ] = attributeArray2[ i ];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tnormalizeNormals: function () {\r\n\t\r\n\t\t\tvar normals = this.attributes.normal.array;\r\n\t\r\n\t\t\tvar x, y, z, n;\r\n\t\r\n\t\t\tfor ( var i = 0, il = normals.length; i < il; i += 3 ) {\r\n\t\r\n\t\t\t\tx = normals[ i ];\r\n\t\t\t\ty = normals[ i + 1 ];\r\n\t\t\t\tz = normals[ i + 2 ];\r\n\t\r\n\t\t\t\tn = 1.0 / Math.sqrt( x * x + y * y + z * z );\r\n\t\r\n\t\t\t\tnormals[ i     ] *= n;\r\n\t\t\t\tnormals[ i + 1 ] *= n;\r\n\t\t\t\tnormals[ i + 2 ] *= n;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\t/*\r\n\t\t\treoderBuffers:\r\n\t\t\tReorder attributes based on a new indexBuffer and indexMap.\r\n\t\t\tindexBuffer - Uint16Array of the new ordered indices.\r\n\t\t\tindexMap - Int32Array where the position is the new vertex ID and the value the old vertex ID for each vertex.\r\n\t\t\tvertexCount - Amount of total vertices considered in this reordering (in case you want to grow the vertice stack).\r\n\t\t*/\r\n\t\treorderBuffers: function ( indexBuffer, indexMap, vertexCount ) {\r\n\t\r\n\t\t\t/* Create a copy of all attributes for reordering. */\r\n\t\t\tvar sortedAttributes = {};\r\n\t\t\tfor ( var attr in this.attributes ) {\r\n\t\t\t\tif ( attr == 'index' )\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\tvar sourceArray = this.attributes[ attr ].array;\r\n\t\t\t\tsortedAttributes[ attr ] = new sourceArray.constructor( this.attributes[ attr ].itemSize * vertexCount );\r\n\t\t\t}\r\n\t\r\n\t\t\t/* Move attribute positions based on the new index map */\r\n\t\t\tfor ( var new_vid = 0; new_vid < vertexCount; new_vid ++ ) {\r\n\t\t\t\tvar vid = indexMap[ new_vid ];\r\n\t\t\t\tfor ( var attr in this.attributes ) {\r\n\t\t\t\t\tif ( attr == 'index' )\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\tvar attrArray = this.attributes[ attr ].array;\r\n\t\t\t\t\tvar attrSize = this.attributes[ attr ].itemSize;\r\n\t\t\t\t\tvar sortedAttr = sortedAttributes[ attr ];\r\n\t\t\t\t\tfor ( var k = 0; k < attrSize; k ++ )\r\n\t\t\t\t\t\tsortedAttr[ new_vid * attrSize + k ] = attrArray[ vid * attrSize + k ];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\r\n\t\t\t/* Carry the new sorted buffers locally */\r\n\t\t\tthis.attributes[ 'index' ].array = indexBuffer;\r\n\t\t\tfor ( var attr in this.attributes ) {\r\n\t\t\t\tif ( attr == 'index' )\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\tthis.attributes[ attr ].array = sortedAttributes[ attr ];\r\n\t\t\t\tthis.attributes[ attr ].numItems = this.attributes[ attr ].itemSize * vertexCount;\r\n\t\t\t}\r\n\t\t},\r\n\t\r\n\t\ttoJSON: function () {\r\n\t\r\n\t\t\tvar output = {\r\n\t\t\t\tmetadata: {\r\n\t\t\t\t\tversion: 4.0,\r\n\t\t\t\t\ttype: 'BufferGeometry',\r\n\t\t\t\t\tgenerator: 'BufferGeometryExporter'\r\n\t\t\t\t},\r\n\t\t\t\tuuid: this.uuid,\r\n\t\t\t\ttype: this.type,\r\n\t\t\t\tdata: {\r\n\t\t\t\t\tattributes: {}\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\r\n\t\t\tvar attributes = this.attributes;\r\n\t\t\tvar offsets = this.offsets;\r\n\t\t\tvar boundingSphere = this.boundingSphere;\r\n\t\r\n\t\t\tfor ( var key in attributes ) {\r\n\t\r\n\t\t\t\tvar attribute = attributes[ key ];\r\n\t\r\n\t\t\t\tvar array = Array.prototype.slice.call( attribute.array );\r\n\t\r\n\t\t\t\toutput.data.attributes[ key ] = {\r\n\t\t\t\t\titemSize: attribute.itemSize,\r\n\t\t\t\t\ttype: attribute.array.constructor.name,\r\n\t\t\t\t\tarray: array\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( offsets.length > 0 ) {\r\n\t\r\n\t\t\t\toutput.data.offsets = JSON.parse( JSON.stringify( offsets ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( boundingSphere !== null ) {\r\n\t\r\n\t\t\t\toutput.data.boundingSphere = {\r\n\t\t\t\t\tcenter: boundingSphere.center.toArray(),\r\n\t\t\t\t\tradius: boundingSphere.radius\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn output;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\tvar geometry = new THREE.BufferGeometry();\r\n\t\r\n\t\t\tfor ( var attr in this.attributes ) {\r\n\t\r\n\t\t\t\tvar sourceAttr = this.attributes[ attr ];\r\n\t\t\t\tgeometry.addAttribute( attr, sourceAttr.clone() );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfor ( var i = 0, il = this.offsets.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tvar offset = this.offsets[ i ];\r\n\t\r\n\t\t\t\tgeometry.offsets.push( {\r\n\t\r\n\t\t\t\t\tstart: offset.start,\r\n\t\t\t\t\tindex: offset.index,\r\n\t\t\t\t\tcount: offset.count\r\n\t\r\n\t\t\t\t} );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn geometry;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdispose: function () {\r\n\t\r\n\t\t\tthis.dispatchEvent( { type: 'dispose' } );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.EventDispatcher.prototype.apply( THREE.BufferGeometry.prototype );\r\n\t\r\n\t// File:src/core/Geometry.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author kile / http://kile.stravaganza.org/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author mikael emtinger / http://gomo.se/\r\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\r\n\t * @author bhouston / http://exocortex.com\r\n\t */\r\n\t\r\n\tTHREE.Geometry = function () {\r\n\t\r\n\t\tObject.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );\r\n\t\r\n\t\tthis.uuid = THREE.Math.generateUUID();\r\n\t\r\n\t\tthis.name = '';\r\n\t\tthis.type = 'Geometry';\r\n\t\r\n\t\tthis.vertices = [];\r\n\t\tthis.colors = [];  // one-to-one vertex colors, used in Points and Line\r\n\t\r\n\t\tthis.faces = [];\r\n\t\r\n\t\tthis.faceVertexUvs = [ [] ];\r\n\t\r\n\t\tthis.morphTargets = [];\r\n\t\tthis.morphColors = [];\r\n\t\tthis.morphNormals = [];\r\n\t\r\n\t\tthis.skinWeights = [];\r\n\t\tthis.skinIndices = [];\r\n\t\r\n\t\tthis.lineDistances = [];\r\n\t\r\n\t\tthis.boundingBox = null;\r\n\t\tthis.boundingSphere = null;\r\n\t\r\n\t\tthis.hasTangents = false;\r\n\t\r\n\t\tthis.dynamic = true; // the intermediate typed arrays will be deleted when set to false\r\n\t\r\n\t\t// update flags\r\n\t\r\n\t\tthis.verticesNeedUpdate = false;\r\n\t\tthis.elementsNeedUpdate = false;\r\n\t\tthis.uvsNeedUpdate = false;\r\n\t\tthis.normalsNeedUpdate = false;\r\n\t\tthis.tangentsNeedUpdate = false;\r\n\t\tthis.colorsNeedUpdate = false;\r\n\t\tthis.lineDistancesNeedUpdate = false;\r\n\t\r\n\t\tthis.groupsNeedUpdate = false;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Geometry.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Geometry,\r\n\t\r\n\t\tapplyMatrix: function ( matrix ) {\r\n\t\r\n\t\t\tvar normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );\r\n\t\r\n\t\t\tfor ( var i = 0, il = this.vertices.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tvar vertex = this.vertices[ i ];\r\n\t\t\t\tvertex.applyMatrix4( matrix );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfor ( var i = 0, il = this.faces.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tvar face = this.faces[ i ];\r\n\t\t\t\tface.normal.applyMatrix3( normalMatrix ).normalize();\r\n\t\r\n\t\t\t\tfor ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\r\n\t\r\n\t\t\t\t\tface.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( this.boundingBox !== null ) {\r\n\t\r\n\t\t\t\tthis.computeBoundingBox();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( this.boundingSphere !== null ) {\r\n\t\r\n\t\t\t\tthis.computeBoundingSphere();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.verticesNeedUpdate = true;\r\n\t\t\tthis.normalsNeedUpdate = true;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfromBufferGeometry: function ( geometry ) {\r\n\t\r\n\t\t\tvar scope = this;\r\n\t\r\n\t\t\tvar attributes = geometry.attributes;\r\n\t\r\n\t\t\tvar vertices = attributes.position.array;\r\n\t\t\tvar indices = attributes.index !== undefined ? attributes.index.array : undefined;\r\n\t\t\tvar normals = attributes.normal !== undefined ? attributes.normal.array : undefined;\r\n\t\t\tvar colors = attributes.color !== undefined ? attributes.color.array : undefined;\r\n\t\t\tvar uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;\r\n\t\r\n\t\t\tvar tempNormals = [];\r\n\t\t\tvar tempUVs = [];\r\n\t\r\n\t\t\tfor ( var i = 0, j = 0; i < vertices.length; i += 3, j += 2 ) {\r\n\t\r\n\t\t\t\tscope.vertices.push( new THREE.Vector3( vertices[ i ], vertices[ i + 1 ], vertices[ i + 2 ] ) );\r\n\t\r\n\t\t\t\tif ( normals !== undefined ) {\r\n\t\r\n\t\t\t\t\ttempNormals.push( new THREE.Vector3( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] ) );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( colors !== undefined ) {\r\n\t\r\n\t\t\t\t\tscope.colors.push( new THREE.Color( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( uvs !== undefined ) {\r\n\t\r\n\t\t\t\t\ttempUVs.push( new THREE.Vector2( uvs[ j ], uvs[ j + 1 ] ) );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar addFace = function ( a, b, c ) {\r\n\t\r\n\t\t\t\tvar vertexNormals = normals !== undefined ? [ tempNormals[ a ].clone(), tempNormals[ b ].clone(), tempNormals[ c ].clone() ] : [];\r\n\t\t\t\tvar vertexColors = colors !== undefined ? [ scope.colors[ a ].clone(), scope.colors[ b ].clone(), scope.colors[ c ].clone() ] : [];\r\n\t\r\n\t\t\t\tscope.faces.push( new THREE.Face3( a, b, c, vertexNormals, vertexColors ) );\r\n\t\r\n\t\t\t\tif ( uvs !== undefined ) {\r\n\t\r\n\t\t\t\t\tscope.faceVertexUvs[ 0 ].push( [ tempUVs[ a ].clone(), tempUVs[ b ].clone(), tempUVs[ c ].clone() ] );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t\tif ( indices !== undefined ) {\r\n\t\r\n\t\t\t\tvar drawcalls = geometry.drawcalls;\r\n\t\r\n\t\t\t\tif ( drawcalls.length > 0 ) {\r\n\t\r\n\t\t\t\t\tfor ( var i = 0; i < drawcalls.length; i ++ ) {\r\n\t\r\n\t\t\t\t\t\tvar drawcall = drawcalls[ i ];\r\n\t\r\n\t\t\t\t\t\tvar start = drawcall.start;\r\n\t\t\t\t\t\tvar count = drawcall.count;\r\n\t\t\t\t\t\tvar index = drawcall.index;\r\n\t\r\n\t\t\t\t\t\tfor ( var j = start, jl = start + count; j < jl; j += 3 ) {\r\n\t\r\n\t\t\t\t\t\t\taddFace( index + indices[ j ], index + indices[ j + 1 ], index + indices[ j + 2 ] );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tfor ( var i = 0; i < indices.length; i += 3 ) {\r\n\t\r\n\t\t\t\t\t\taddFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tfor ( var i = 0; i < vertices.length / 3; i += 3 ) {\r\n\t\r\n\t\t\t\t\taddFace( i, i + 1, i + 2 );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.computeFaceNormals();\r\n\t\r\n\t\t\tif ( geometry.boundingBox !== null ) {\r\n\t\r\n\t\t\t\tthis.boundingBox = geometry.boundingBox.clone();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( geometry.boundingSphere !== null ) {\r\n\t\r\n\t\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcenter: function () {\r\n\t\r\n\t\t\tthis.computeBoundingBox();\r\n\t\r\n\t\t\tvar offset = this.boundingBox.center().negate();\r\n\t\r\n\t\t\tthis.applyMatrix( new THREE.Matrix4().setPosition( offset ) );\r\n\t\r\n\t\t\treturn offset;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcomputeFaceNormals: function () {\r\n\t\r\n\t\t\tvar cb = new THREE.Vector3(), ab = new THREE.Vector3();\r\n\t\r\n\t\t\tfor ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\t\r\n\t\t\t\tvar face = this.faces[ f ];\r\n\t\r\n\t\t\t\tvar vA = this.vertices[ face.a ];\r\n\t\t\t\tvar vB = this.vertices[ face.b ];\r\n\t\t\t\tvar vC = this.vertices[ face.c ];\r\n\t\r\n\t\t\t\tcb.subVectors( vC, vB );\r\n\t\t\t\tab.subVectors( vA, vB );\r\n\t\t\t\tcb.cross( ab );\r\n\t\r\n\t\t\t\tcb.normalize();\r\n\t\r\n\t\t\t\tface.normal.copy( cb );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcomputeVertexNormals: function ( areaWeighted ) {\r\n\t\r\n\t\t\tvar v, vl, f, fl, face, vertices;\r\n\t\r\n\t\t\tvertices = new Array( this.vertices.length );\r\n\t\r\n\t\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\r\n\t\r\n\t\t\t\tvertices[ v ] = new THREE.Vector3();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( areaWeighted ) {\r\n\t\r\n\t\t\t\t// vertex normals weighted by triangle areas\r\n\t\t\t\t// http://www.iquilezles.org/www/articles/normals/normals.htm\r\n\t\r\n\t\t\t\tvar vA, vB, vC;\r\n\t\t\t\tvar cb = new THREE.Vector3(), ab = new THREE.Vector3();\r\n\t\r\n\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\t\r\n\t\t\t\t\tface = this.faces[ f ];\r\n\t\r\n\t\t\t\t\tvA = this.vertices[ face.a ];\r\n\t\t\t\t\tvB = this.vertices[ face.b ];\r\n\t\t\t\t\tvC = this.vertices[ face.c ];\r\n\t\r\n\t\t\t\t\tcb.subVectors( vC, vB );\r\n\t\t\t\t\tab.subVectors( vA, vB );\r\n\t\t\t\t\tcb.cross( ab );\r\n\t\r\n\t\t\t\t\tvertices[ face.a ].add( cb );\r\n\t\t\t\t\tvertices[ face.b ].add( cb );\r\n\t\t\t\t\tvertices[ face.c ].add( cb );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\t\r\n\t\t\t\t\tface = this.faces[ f ];\r\n\t\r\n\t\t\t\t\tvertices[ face.a ].add( face.normal );\r\n\t\t\t\t\tvertices[ face.b ].add( face.normal );\r\n\t\t\t\t\tvertices[ face.c ].add( face.normal );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\r\n\t\r\n\t\t\t\tvertices[ v ].normalize();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\t\r\n\t\t\t\tface = this.faces[ f ];\r\n\t\r\n\t\t\t\tface.vertexNormals[ 0 ] = vertices[ face.a ].clone();\r\n\t\t\t\tface.vertexNormals[ 1 ] = vertices[ face.b ].clone();\r\n\t\t\t\tface.vertexNormals[ 2 ] = vertices[ face.c ].clone();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcomputeMorphNormals: function () {\r\n\t\r\n\t\t\tvar i, il, f, fl, face;\r\n\t\r\n\t\t\t// save original normals\r\n\t\t\t// - create temp variables on first access\r\n\t\t\t//   otherwise just copy (for faster repeated calls)\r\n\t\r\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\t\r\n\t\t\t\tface = this.faces[ f ];\r\n\t\r\n\t\t\t\tif ( ! face.__originalFaceNormal ) {\r\n\t\r\n\t\t\t\t\tface.__originalFaceNormal = face.normal.clone();\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tface.__originalFaceNormal.copy( face.normal );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];\r\n\t\r\n\t\t\t\tfor ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\tif ( ! face.__originalVertexNormals[ i ] ) {\r\n\t\r\n\t\t\t\t\t\tface.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tface.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// use temp geometry to compute face and vertex normals for each morph\r\n\t\r\n\t\t\tvar tmpGeo = new THREE.Geometry();\r\n\t\t\ttmpGeo.faces = this.faces;\r\n\t\r\n\t\t\tfor ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t// create on first access\r\n\t\r\n\t\t\t\tif ( ! this.morphNormals[ i ] ) {\r\n\t\r\n\t\t\t\t\tthis.morphNormals[ i ] = {};\r\n\t\t\t\t\tthis.morphNormals[ i ].faceNormals = [];\r\n\t\t\t\t\tthis.morphNormals[ i ].vertexNormals = [];\r\n\t\r\n\t\t\t\t\tvar dstNormalsFace = this.morphNormals[ i ].faceNormals;\r\n\t\t\t\t\tvar dstNormalsVertex = this.morphNormals[ i ].vertexNormals;\r\n\t\r\n\t\t\t\t\tvar faceNormal, vertexNormals;\r\n\t\r\n\t\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\t\r\n\t\t\t\t\t\tfaceNormal = new THREE.Vector3();\r\n\t\t\t\t\t\tvertexNormals = { a: new THREE.Vector3(), b: new THREE.Vector3(), c: new THREE.Vector3() };\r\n\t\r\n\t\t\t\t\t\tdstNormalsFace.push( faceNormal );\r\n\t\t\t\t\t\tdstNormalsVertex.push( vertexNormals );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar morphNormals = this.morphNormals[ i ];\r\n\t\r\n\t\t\t\t// set vertices to morph target\r\n\t\r\n\t\t\t\ttmpGeo.vertices = this.morphTargets[ i ].vertices;\r\n\t\r\n\t\t\t\t// compute morph normals\r\n\t\r\n\t\t\t\ttmpGeo.computeFaceNormals();\r\n\t\t\t\ttmpGeo.computeVertexNormals();\r\n\t\r\n\t\t\t\t// store morph normals\r\n\t\r\n\t\t\t\tvar faceNormal, vertexNormals;\r\n\t\r\n\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\t\r\n\t\t\t\t\tface = this.faces[ f ];\r\n\t\r\n\t\t\t\t\tfaceNormal = morphNormals.faceNormals[ f ];\r\n\t\t\t\t\tvertexNormals = morphNormals.vertexNormals[ f ];\r\n\t\r\n\t\t\t\t\tfaceNormal.copy( face.normal );\r\n\t\r\n\t\t\t\t\tvertexNormals.a.copy( face.vertexNormals[ 0 ] );\r\n\t\t\t\t\tvertexNormals.b.copy( face.vertexNormals[ 1 ] );\r\n\t\t\t\t\tvertexNormals.c.copy( face.vertexNormals[ 2 ] );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// restore original normals\r\n\t\r\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\t\r\n\t\t\t\tface = this.faces[ f ];\r\n\t\r\n\t\t\t\tface.normal = face.__originalFaceNormal;\r\n\t\t\t\tface.vertexNormals = face.__originalVertexNormals;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcomputeTangents: function () {\r\n\t\r\n\t\t\t// based on http://www.terathon.com/code/tangent.html\r\n\t\t\t// tangents go to vertices\r\n\t\r\n\t\t\tvar f, fl, v, vl, i, vertexIndex,\r\n\t\t\t\tface, uv, vA, vB, vC, uvA, uvB, uvC,\r\n\t\t\t\tx1, x2, y1, y2, z1, z2,\r\n\t\t\t\ts1, s2, t1, t2, r, t, test,\r\n\t\t\t\ttan1 = [], tan2 = [],\r\n\t\t\t\tsdir = new THREE.Vector3(), tdir = new THREE.Vector3(),\r\n\t\t\t\ttmp = new THREE.Vector3(), tmp2 = new THREE.Vector3(),\r\n\t\t\t\tn = new THREE.Vector3(), w;\r\n\t\r\n\t\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\r\n\t\r\n\t\t\t\ttan1[ v ] = new THREE.Vector3();\r\n\t\t\t\ttan2[ v ] = new THREE.Vector3();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfunction handleTriangle( context, a, b, c, ua, ub, uc ) {\r\n\t\r\n\t\t\t\tvA = context.vertices[ a ];\r\n\t\t\t\tvB = context.vertices[ b ];\r\n\t\t\t\tvC = context.vertices[ c ];\r\n\t\r\n\t\t\t\tuvA = uv[ ua ];\r\n\t\t\t\tuvB = uv[ ub ];\r\n\t\t\t\tuvC = uv[ uc ];\r\n\t\r\n\t\t\t\tx1 = vB.x - vA.x;\r\n\t\t\t\tx2 = vC.x - vA.x;\r\n\t\t\t\ty1 = vB.y - vA.y;\r\n\t\t\t\ty2 = vC.y - vA.y;\r\n\t\t\t\tz1 = vB.z - vA.z;\r\n\t\t\t\tz2 = vC.z - vA.z;\r\n\t\r\n\t\t\t\ts1 = uvB.x - uvA.x;\r\n\t\t\t\ts2 = uvC.x - uvA.x;\r\n\t\t\t\tt1 = uvB.y - uvA.y;\r\n\t\t\t\tt2 = uvC.y - uvA.y;\r\n\t\r\n\t\t\t\tr = 1.0 / ( s1 * t2 - s2 * t1 );\r\n\t\t\t\tsdir.set( ( t2 * x1 - t1 * x2 ) * r,\r\n\t\t\t\t\t\t  ( t2 * y1 - t1 * y2 ) * r,\r\n\t\t\t\t\t\t  ( t2 * z1 - t1 * z2 ) * r );\r\n\t\t\t\ttdir.set( ( s1 * x2 - s2 * x1 ) * r,\r\n\t\t\t\t\t\t  ( s1 * y2 - s2 * y1 ) * r,\r\n\t\t\t\t\t\t  ( s1 * z2 - s2 * z1 ) * r );\r\n\t\r\n\t\t\t\ttan1[ a ].add( sdir );\r\n\t\t\t\ttan1[ b ].add( sdir );\r\n\t\t\t\ttan1[ c ].add( sdir );\r\n\t\r\n\t\t\t\ttan2[ a ].add( tdir );\r\n\t\t\t\ttan2[ b ].add( tdir );\r\n\t\t\t\ttan2[ c ].add( tdir );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\t\r\n\t\t\t\tface = this.faces[ f ];\r\n\t\t\t\tuv = this.faceVertexUvs[ 0 ][ f ]; // use UV layer 0 for tangents\r\n\t\r\n\t\t\t\thandleTriangle( this, face.a, face.b, face.c, 0, 1, 2 );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar faceIndex = [ 'a', 'b', 'c', 'd' ];\r\n\t\r\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\t\r\n\t\t\t\tface = this.faces[ f ];\r\n\t\r\n\t\t\t\tfor ( i = 0; i < Math.min( face.vertexNormals.length, 3 ); i ++ ) {\r\n\t\r\n\t\t\t\t\tn.copy( face.vertexNormals[ i ] );\r\n\t\r\n\t\t\t\t\tvertexIndex = face[ faceIndex[ i ] ];\r\n\t\r\n\t\t\t\t\tt = tan1[ vertexIndex ];\r\n\t\r\n\t\t\t\t\t// Gram-Schmidt orthogonalize\r\n\t\r\n\t\t\t\t\ttmp.copy( t );\r\n\t\t\t\t\ttmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();\r\n\t\r\n\t\t\t\t\t// Calculate handedness\r\n\t\r\n\t\t\t\t\ttmp2.crossVectors( face.vertexNormals[ i ], t );\r\n\t\t\t\t\ttest = tmp2.dot( tan2[ vertexIndex ] );\r\n\t\t\t\t\tw = ( test < 0.0 ) ? - 1.0 : 1.0;\r\n\t\r\n\t\t\t\t\tface.vertexTangents[ i ] = new THREE.Vector4( tmp.x, tmp.y, tmp.z, w );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.hasTangents = true;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcomputeLineDistances: function () {\r\n\t\r\n\t\t\tvar d = 0;\r\n\t\t\tvar vertices = this.vertices;\r\n\t\r\n\t\t\tfor ( var i = 0, il = vertices.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tif ( i > 0 ) {\r\n\t\r\n\t\t\t\t\td += vertices[ i ].distanceTo( vertices[ i - 1 ] );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tthis.lineDistances[ i ] = d;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcomputeBoundingBox: function () {\r\n\t\r\n\t\t\tif ( this.boundingBox === null ) {\r\n\t\r\n\t\t\t\tthis.boundingBox = new THREE.Box3();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.boundingBox.setFromPoints( this.vertices );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcomputeBoundingSphere: function () {\r\n\t\r\n\t\t\tif ( this.boundingSphere === null ) {\r\n\t\r\n\t\t\t\tthis.boundingSphere = new THREE.Sphere();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.boundingSphere.setFromPoints( this.vertices );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmerge: function ( geometry, matrix, materialIndexOffset ) {\r\n\t\r\n\t\t\tif ( geometry instanceof THREE.Geometry === false ) {\r\n\t\r\n\t\t\t\tTHREE.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );\r\n\t\t\t\treturn;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar normalMatrix,\r\n\t\t\tvertexOffset = this.vertices.length,\r\n\t\t\tvertices1 = this.vertices,\r\n\t\t\tvertices2 = geometry.vertices,\r\n\t\t\tfaces1 = this.faces,\r\n\t\t\tfaces2 = geometry.faces,\r\n\t\t\tuvs1 = this.faceVertexUvs[ 0 ],\r\n\t\t\tuvs2 = geometry.faceVertexUvs[ 0 ];\r\n\t\r\n\t\t\tif ( materialIndexOffset === undefined ) materialIndexOffset = 0;\r\n\t\r\n\t\t\tif ( matrix !== undefined ) {\r\n\t\r\n\t\t\t\tnormalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// vertices\r\n\t\r\n\t\t\tfor ( var i = 0, il = vertices2.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tvar vertex = vertices2[ i ];\r\n\t\r\n\t\t\t\tvar vertexCopy = vertex.clone();\r\n\t\r\n\t\t\t\tif ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );\r\n\t\r\n\t\t\t\tvertices1.push( vertexCopy );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// faces\r\n\t\r\n\t\t\tfor ( i = 0, il = faces2.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tvar face = faces2[ i ], faceCopy, normal, color,\r\n\t\t\t\tfaceVertexNormals = face.vertexNormals,\r\n\t\t\t\tfaceVertexColors = face.vertexColors;\r\n\t\r\n\t\t\t\tfaceCopy = new THREE.Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );\r\n\t\t\t\tfaceCopy.normal.copy( face.normal );\r\n\t\r\n\t\t\t\tif ( normalMatrix !== undefined ) {\r\n\t\r\n\t\t\t\t\tfaceCopy.normal.applyMatrix3( normalMatrix ).normalize();\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tfor ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {\r\n\t\r\n\t\t\t\t\tnormal = faceVertexNormals[ j ].clone();\r\n\t\r\n\t\t\t\t\tif ( normalMatrix !== undefined ) {\r\n\t\r\n\t\t\t\t\t\tnormal.applyMatrix3( normalMatrix ).normalize();\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tfaceCopy.vertexNormals.push( normal );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tfaceCopy.color.copy( face.color );\r\n\t\r\n\t\t\t\tfor ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {\r\n\t\r\n\t\t\t\t\tcolor = faceVertexColors[ j ];\r\n\t\t\t\t\tfaceCopy.vertexColors.push( color.clone() );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tfaceCopy.materialIndex = face.materialIndex + materialIndexOffset;\r\n\t\r\n\t\t\t\tfaces1.push( faceCopy );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// uvs\r\n\t\r\n\t\t\tfor ( i = 0, il = uvs2.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tvar uv = uvs2[ i ], uvCopy = [];\r\n\t\r\n\t\t\t\tif ( uv === undefined ) {\r\n\t\r\n\t\t\t\t\tcontinue;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tfor ( var j = 0, jl = uv.length; j < jl; j ++ ) {\r\n\t\r\n\t\t\t\t\tuvCopy.push( uv[ j ].clone() );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tuvs1.push( uvCopy );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmergeMesh: function ( mesh ) {\r\n\t\r\n\t\t\tif ( mesh instanceof THREE.Mesh === false ) {\r\n\t\r\n\t\t\t\tTHREE.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );\r\n\t\t\t\treturn;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tmesh.matrixAutoUpdate && mesh.updateMatrix();\r\n\t\r\n\t\t\tthis.merge( mesh.geometry, mesh.matrix );\r\n\t\r\n\t\t},\r\n\t\r\n\t\t/*\r\n\t\t * Checks for duplicate vertices with hashmap.\r\n\t\t * Duplicated vertices are removed\r\n\t\t * and faces' vertices are updated.\r\n\t\t */\r\n\t\r\n\t\tmergeVertices: function () {\r\n\t\r\n\t\t\tvar verticesMap = {}; // Hashmap for looking up vertice by position coordinates (and making sure they are unique)\r\n\t\t\tvar unique = [], changes = [];\r\n\t\r\n\t\t\tvar v, key;\r\n\t\t\tvar precisionPoints = 4; // number of decimal points, eg. 4 for epsilon of 0.0001\r\n\t\t\tvar precision = Math.pow( 10, precisionPoints );\r\n\t\t\tvar i, il, face;\r\n\t\t\tvar indices, j, jl;\r\n\t\r\n\t\t\tfor ( i = 0, il = this.vertices.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tv = this.vertices[ i ];\r\n\t\t\t\tkey = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );\r\n\t\r\n\t\t\t\tif ( verticesMap[ key ] === undefined ) {\r\n\t\r\n\t\t\t\t\tverticesMap[ key ] = i;\r\n\t\t\t\t\tunique.push( this.vertices[ i ] );\r\n\t\t\t\t\tchanges[ i ] = unique.length - 1;\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);\r\n\t\t\t\t\tchanges[ i ] = changes[ verticesMap[ key ] ];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\r\n\t\t\t// if faces are completely degenerate after merging vertices, we\r\n\t\t\t// have to remove them from the geometry.\r\n\t\t\tvar faceIndicesToRemove = [];\r\n\t\r\n\t\t\tfor ( i = 0, il = this.faces.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tface = this.faces[ i ];\r\n\t\r\n\t\t\t\tface.a = changes[ face.a ];\r\n\t\t\t\tface.b = changes[ face.b ];\r\n\t\t\t\tface.c = changes[ face.c ];\r\n\t\r\n\t\t\t\tindices = [ face.a, face.b, face.c ];\r\n\t\r\n\t\t\t\tvar dupIndex = - 1;\r\n\t\r\n\t\t\t\t// if any duplicate vertices are found in a Face3\r\n\t\t\t\t// we have to remove the face as nothing can be saved\r\n\t\t\t\tfor ( var n = 0; n < 3; n ++ ) {\r\n\t\t\t\t\tif ( indices[ n ] == indices[ ( n + 1 ) % 3 ] ) {\r\n\t\r\n\t\t\t\t\t\tdupIndex = n;\r\n\t\t\t\t\t\tfaceIndicesToRemove.push( i );\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfor ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {\r\n\t\t\t\tvar idx = faceIndicesToRemove[ i ];\r\n\t\r\n\t\t\t\tthis.faces.splice( idx, 1 );\r\n\t\r\n\t\t\t\tfor ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {\r\n\t\r\n\t\t\t\t\tthis.faceVertexUvs[ j ].splice( idx, 1 );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// Use unique set of vertices\r\n\t\r\n\t\t\tvar diff = this.vertices.length - unique.length;\r\n\t\t\tthis.vertices = unique;\r\n\t\t\treturn diff;\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttoJSON: function () {\r\n\t\r\n\t\t\tvar output = {\r\n\t\t\t\tmetadata: {\r\n\t\t\t\t\tversion: 4.0,\r\n\t\t\t\t\ttype: 'BufferGeometry',\r\n\t\t\t\t\tgenerator: 'BufferGeometryExporter'\r\n\t\t\t\t},\r\n\t\t\t\tuuid: this.uuid,\r\n\t\t\t\ttype: this.type\r\n\t\t\t};\r\n\t\r\n\t\t\tif ( this.name !== \"\" ) output.name = this.name;\r\n\t\r\n\t\t\tif ( this.parameters !== undefined ) {\r\n\t\r\n\t\t\t\tvar parameters = this.parameters;\r\n\t\r\n\t\t\t\tfor ( var key in parameters ) {\r\n\t\r\n\t\t\t\t\tif ( parameters[ key ] !== undefined ) output[ key ] = parameters[ key ];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn output;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar vertices = [];\r\n\t\r\n\t\t\tfor ( var i = 0; i < this.vertices.length; i ++ ) {\r\n\t\r\n\t\t\t\tvar vertex = this.vertices[ i ];\r\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar faces = [];\r\n\t\t\tvar normals = [];\r\n\t\t\tvar normalsHash = {};\r\n\t\t\tvar colors = [];\r\n\t\t\tvar colorsHash = {};\r\n\t\t\tvar uvs = [];\r\n\t\t\tvar uvsHash = {};\r\n\t\r\n\t\t\tfor ( var i = 0; i < this.faces.length; i ++ ) {\r\n\t\r\n\t\t\t\tvar face = this.faces[ i ];\r\n\t\r\n\t\t\t\tvar hasMaterial = false; // face.materialIndex !== undefined;\r\n\t\t\t\tvar hasFaceUv = false; // deprecated\r\n\t\t\t\tvar hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;\r\n\t\t\t\tvar hasFaceNormal = face.normal.length() > 0;\r\n\t\t\t\tvar hasFaceVertexNormal = face.vertexNormals.length > 0;\r\n\t\t\t\tvar hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;\r\n\t\t\t\tvar hasFaceVertexColor = face.vertexColors.length > 0;\r\n\t\r\n\t\t\t\tvar faceType = 0;\r\n\t\r\n\t\t\t\tfaceType = setBit( faceType, 0, 0 );\r\n\t\t\t\tfaceType = setBit( faceType, 1, hasMaterial );\r\n\t\t\t\tfaceType = setBit( faceType, 2, hasFaceUv );\r\n\t\t\t\tfaceType = setBit( faceType, 3, hasFaceVertexUv );\r\n\t\t\t\tfaceType = setBit( faceType, 4, hasFaceNormal );\r\n\t\t\t\tfaceType = setBit( faceType, 5, hasFaceVertexNormal );\r\n\t\t\t\tfaceType = setBit( faceType, 6, hasFaceColor );\r\n\t\t\t\tfaceType = setBit( faceType, 7, hasFaceVertexColor );\r\n\t\r\n\t\t\t\tfaces.push( faceType );\r\n\t\t\t\tfaces.push( face.a, face.b, face.c );\r\n\t\r\n\t\r\n\t\t\t\t/*\r\n\t\t\t\tif ( hasMaterial ) {\r\n\t\r\n\t\t\t\t\tfaces.push( face.materialIndex );\r\n\t\r\n\t\t\t\t}\r\n\t\t\t\t*/\r\n\t\r\n\t\t\t\tif ( hasFaceVertexUv ) {\r\n\t\r\n\t\t\t\t\tvar faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];\r\n\t\r\n\t\t\t\t\tfaces.push(\r\n\t\t\t\t\t\tgetUvIndex( faceVertexUvs[ 0 ] ),\r\n\t\t\t\t\t\tgetUvIndex( faceVertexUvs[ 1 ] ),\r\n\t\t\t\t\t\tgetUvIndex( faceVertexUvs[ 2 ] )\r\n\t\t\t\t\t);\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( hasFaceNormal ) {\r\n\t\r\n\t\t\t\t\tfaces.push( getNormalIndex( face.normal ) );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( hasFaceVertexNormal ) {\r\n\t\r\n\t\t\t\t\tvar vertexNormals = face.vertexNormals;\r\n\t\r\n\t\t\t\t\tfaces.push(\r\n\t\t\t\t\t\tgetNormalIndex( vertexNormals[ 0 ] ),\r\n\t\t\t\t\t\tgetNormalIndex( vertexNormals[ 1 ] ),\r\n\t\t\t\t\t\tgetNormalIndex( vertexNormals[ 2 ] )\r\n\t\t\t\t\t);\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( hasFaceColor ) {\r\n\t\r\n\t\t\t\t\tfaces.push( getColorIndex( face.color ) );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( hasFaceVertexColor ) {\r\n\t\r\n\t\t\t\t\tvar vertexColors = face.vertexColors;\r\n\t\r\n\t\t\t\t\tfaces.push(\r\n\t\t\t\t\t\tgetColorIndex( vertexColors[ 0 ] ),\r\n\t\t\t\t\t\tgetColorIndex( vertexColors[ 1 ] ),\r\n\t\t\t\t\t\tgetColorIndex( vertexColors[ 2 ] )\r\n\t\t\t\t\t);\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfunction setBit( value, position, enabled ) {\r\n\t\r\n\t\t\t\treturn enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfunction getNormalIndex( normal ) {\r\n\t\r\n\t\t\t\tvar hash = normal.x.toString() + normal.y.toString() + normal.z.toString();\r\n\t\r\n\t\t\t\tif ( normalsHash[ hash ] !== undefined ) {\r\n\t\r\n\t\t\t\t\treturn normalsHash[ hash ];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tnormalsHash[ hash ] = normals.length / 3;\r\n\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\r\n\t\r\n\t\t\t\treturn normalsHash[ hash ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfunction getColorIndex( color ) {\r\n\t\r\n\t\t\t\tvar hash = color.r.toString() + color.g.toString() + color.b.toString();\r\n\t\r\n\t\t\t\tif ( colorsHash[ hash ] !== undefined ) {\r\n\t\r\n\t\t\t\t\treturn colorsHash[ hash ];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tcolorsHash[ hash ] = colors.length;\r\n\t\t\t\tcolors.push( color.getHex() );\r\n\t\r\n\t\t\t\treturn colorsHash[ hash ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfunction getUvIndex( uv ) {\r\n\t\r\n\t\t\t\tvar hash = uv.x.toString() + uv.y.toString();\r\n\t\r\n\t\t\t\tif ( uvsHash[ hash ] !== undefined ) {\r\n\t\r\n\t\t\t\t\treturn uvsHash[ hash ];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tuvsHash[ hash ] = uvs.length / 2;\r\n\t\t\t\tuvs.push( uv.x, uv.y );\r\n\t\r\n\t\t\t\treturn uvsHash[ hash ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\toutput.data = {};\r\n\t\r\n\t\t\toutput.data.vertices = vertices;\r\n\t\t\toutput.data.normals = normals;\r\n\t\t\tif ( colors.length > 0 ) output.data.colors = colors;\r\n\t\t\tif ( uvs.length > 0 ) output.data.uvs = [ uvs ]; // temporal backward compatibility\r\n\t\t\toutput.data.faces = faces;\r\n\t\r\n\t\t\t//\r\n\t\r\n\t\t\treturn output;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\tvar geometry = new THREE.Geometry();\r\n\t\r\n\t\t\tvar vertices = this.vertices;\r\n\t\r\n\t\t\tfor ( var i = 0, il = vertices.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tgeometry.vertices.push( vertices[ i ].clone() );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar faces = this.faces;\r\n\t\r\n\t\t\tfor ( var i = 0, il = faces.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tgeometry.faces.push( faces[ i ].clone() );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfor ( var i = 0, il = this.faceVertexUvs.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tvar faceVertexUvs = this.faceVertexUvs[ i ];\r\n\t\r\n\t\t\t\tif ( geometry.faceVertexUvs[ i ] === undefined ) {\r\n\t\r\n\t\t\t\t\tgeometry.faceVertexUvs[ i ] = [];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tfor ( var j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {\r\n\t\r\n\t\t\t\t\tvar uvs = faceVertexUvs[ j ], uvsCopy = [];\r\n\t\r\n\t\t\t\t\tfor ( var k = 0, kl = uvs.length; k < kl; k ++ ) {\r\n\t\r\n\t\t\t\t\t\tvar uv = uvs[ k ];\r\n\t\r\n\t\t\t\t\t\tuvsCopy.push( uv.clone() );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tgeometry.faceVertexUvs[ i ].push( uvsCopy );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn geometry;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdispose: function () {\r\n\t\r\n\t\t\tthis.dispatchEvent( { type: 'dispose' } );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.EventDispatcher.prototype.apply( THREE.Geometry.prototype );\r\n\t\r\n\tTHREE.GeometryIdCount = 0;\r\n\t\r\n\t// File:src/cameras/Camera.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author mikael emtinger / http://gomo.se/\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t*/\r\n\t\r\n\tTHREE.Camera = function () {\r\n\t\r\n\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t\tthis.type = 'Camera';\r\n\t\r\n\t\tthis.matrixWorldInverse = new THREE.Matrix4();\r\n\t\tthis.projectionMatrix = new THREE.Matrix4();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Camera.prototype = Object.create( THREE.Object3D.prototype );\r\n\tTHREE.Camera.prototype.constructor = THREE.Camera;\r\n\t\r\n\tTHREE.Camera.prototype.getWorldDirection = function () {\r\n\t\r\n\t\tvar quaternion = new THREE.Quaternion();\r\n\t\r\n\t\treturn function ( optionalTarget ) {\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\r\n\t\t\tthis.getWorldQuaternion( quaternion );\r\n\t\r\n\t\t\treturn result.set( 0, 0, - 1 ).applyQuaternion( quaternion );\r\n\t\r\n\t\t}\r\n\t\r\n\t}();\r\n\t\r\n\tTHREE.Camera.prototype.lookAt = function () {\r\n\t\r\n\t\t// This routine does not support cameras with rotated and/or translated parent(s)\r\n\t\r\n\t\tvar m1 = new THREE.Matrix4();\r\n\t\r\n\t\treturn function ( vector ) {\r\n\t\r\n\t\t\tm1.lookAt( this.position, vector, this.up );\r\n\t\r\n\t\t\tthis.quaternion.setFromRotationMatrix( m1 );\r\n\t\r\n\t\t};\r\n\t\r\n\t}();\r\n\t\r\n\tTHREE.Camera.prototype.clone = function ( camera ) {\r\n\t\r\n\t\tif ( camera === undefined ) camera = new THREE.Camera();\r\n\t\r\n\t\tTHREE.Object3D.prototype.clone.call( this, camera );\r\n\t\r\n\t\tcamera.matrixWorldInverse.copy( this.matrixWorldInverse );\r\n\t\tcamera.projectionMatrix.copy( this.projectionMatrix );\r\n\t\r\n\t\treturn camera;\r\n\t};\r\n\t\r\n\t// File:src/cameras/CubeCamera.js\r\n\t\r\n\t/**\r\n\t * Camera for rendering cube maps\r\n\t *\t- renders scene into axis-aligned cube\r\n\t *\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.CubeCamera = function ( near, far, cubeResolution ) {\r\n\t\r\n\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t\tthis.type = 'CubeCamera';\r\n\t\r\n\t\tvar fov = 90, aspect = 1;\r\n\t\r\n\t\tvar cameraPX = new THREE.PerspectiveCamera( fov, aspect, near, far );\r\n\t\tcameraPX.up.set( 0, - 1, 0 );\r\n\t\tcameraPX.lookAt( new THREE.Vector3( 1, 0, 0 ) );\r\n\t\tthis.add( cameraPX );\r\n\t\r\n\t\tvar cameraNX = new THREE.PerspectiveCamera( fov, aspect, near, far );\r\n\t\tcameraNX.up.set( 0, - 1, 0 );\r\n\t\tcameraNX.lookAt( new THREE.Vector3( - 1, 0, 0 ) );\r\n\t\tthis.add( cameraNX );\r\n\t\r\n\t\tvar cameraPY = new THREE.PerspectiveCamera( fov, aspect, near, far );\r\n\t\tcameraPY.up.set( 0, 0, 1 );\r\n\t\tcameraPY.lookAt( new THREE.Vector3( 0, 1, 0 ) );\r\n\t\tthis.add( cameraPY );\r\n\t\r\n\t\tvar cameraNY = new THREE.PerspectiveCamera( fov, aspect, near, far );\r\n\t\tcameraNY.up.set( 0, 0, - 1 );\r\n\t\tcameraNY.lookAt( new THREE.Vector3( 0, - 1, 0 ) );\r\n\t\tthis.add( cameraNY );\r\n\t\r\n\t\tvar cameraPZ = new THREE.PerspectiveCamera( fov, aspect, near, far );\r\n\t\tcameraPZ.up.set( 0, - 1, 0 );\r\n\t\tcameraPZ.lookAt( new THREE.Vector3( 0, 0, 1 ) );\r\n\t\tthis.add( cameraPZ );\r\n\t\r\n\t\tvar cameraNZ = new THREE.PerspectiveCamera( fov, aspect, near, far );\r\n\t\tcameraNZ.up.set( 0, - 1, 0 );\r\n\t\tcameraNZ.lookAt( new THREE.Vector3( 0, 0, - 1 ) );\r\n\t\tthis.add( cameraNZ );\r\n\t\r\n\t\tthis.renderTarget = new THREE.WebGLRenderTargetCube( cubeResolution, cubeResolution, { format: THREE.RGBFormat, magFilter: THREE.LinearFilter, minFilter: THREE.LinearFilter } );\r\n\t\r\n\t\tthis.updateCubeMap = function ( renderer, scene ) {\r\n\t\r\n\t\t\tvar renderTarget = this.renderTarget;\r\n\t\t\tvar generateMipmaps = renderTarget.generateMipmaps;\r\n\t\r\n\t\t\trenderTarget.generateMipmaps = false;\r\n\t\r\n\t\t\trenderTarget.activeCubeFace = 0;\r\n\t\t\trenderer.render( scene, cameraPX, renderTarget );\r\n\t\r\n\t\t\trenderTarget.activeCubeFace = 1;\r\n\t\t\trenderer.render( scene, cameraNX, renderTarget );\r\n\t\r\n\t\t\trenderTarget.activeCubeFace = 2;\r\n\t\t\trenderer.render( scene, cameraPY, renderTarget );\r\n\t\r\n\t\t\trenderTarget.activeCubeFace = 3;\r\n\t\t\trenderer.render( scene, cameraNY, renderTarget );\r\n\t\r\n\t\t\trenderTarget.activeCubeFace = 4;\r\n\t\t\trenderer.render( scene, cameraPZ, renderTarget );\r\n\t\r\n\t\t\trenderTarget.generateMipmaps = generateMipmaps;\r\n\t\r\n\t\t\trenderTarget.activeCubeFace = 5;\r\n\t\t\trenderer.render( scene, cameraNZ, renderTarget );\r\n\t\r\n\t\t};\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.CubeCamera.prototype = Object.create( THREE.Object3D.prototype );\r\n\tTHREE.CubeCamera.prototype.constructor = THREE.CubeCamera;\r\n\t\r\n\t// File:src/cameras/OrthographicCamera.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.OrthographicCamera = function ( left, right, top, bottom, near, far ) {\r\n\t\r\n\t\tTHREE.Camera.call( this );\r\n\t\r\n\t\tthis.type = 'OrthographicCamera';\r\n\t\r\n\t\tthis.zoom = 1;\r\n\t\r\n\t\tthis.left = left;\r\n\t\tthis.right = right;\r\n\t\tthis.top = top;\r\n\t\tthis.bottom = bottom;\r\n\t\r\n\t\tthis.near = ( near !== undefined ) ? near : 0.1;\r\n\t\tthis.far = ( far !== undefined ) ? far : 2000;\r\n\t\r\n\t\tthis.updateProjectionMatrix();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.OrthographicCamera.prototype = Object.create( THREE.Camera.prototype );\r\n\tTHREE.OrthographicCamera.prototype.constructor = THREE.OrthographicCamera;\r\n\t\r\n\tTHREE.OrthographicCamera.prototype.updateProjectionMatrix = function () {\r\n\t\r\n\t\tvar dx = ( this.right - this.left ) / ( 2 * this.zoom );\r\n\t\tvar dy = ( this.top - this.bottom ) / ( 2 * this.zoom );\r\n\t\tvar cx = ( this.right + this.left ) / 2;\r\n\t\tvar cy = ( this.top + this.bottom ) / 2;\r\n\t\r\n\t\tthis.projectionMatrix.makeOrthographic( cx - dx, cx + dx, cy + dy, cy - dy, this.near, this.far );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.OrthographicCamera.prototype.clone = function () {\r\n\t\r\n\t\tvar camera = new THREE.OrthographicCamera();\r\n\t\r\n\t\tTHREE.Camera.prototype.clone.call( this, camera );\r\n\t\r\n\t\tcamera.zoom = this.zoom;\r\n\t\r\n\t\tcamera.left = this.left;\r\n\t\tcamera.right = this.right;\r\n\t\tcamera.top = this.top;\r\n\t\tcamera.bottom = this.bottom;\r\n\t\r\n\t\tcamera.near = this.near;\r\n\t\tcamera.far = this.far;\r\n\t\r\n\t\tcamera.projectionMatrix.copy( this.projectionMatrix );\r\n\t\r\n\t\treturn camera;\r\n\t};\r\n\t\r\n\t// File:src/cameras/PerspectiveCamera.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author greggman / http://games.greggman.com/\r\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\r\n\t */\r\n\t\r\n\tTHREE.PerspectiveCamera = function ( fov, aspect, near, far ) {\r\n\t\r\n\t\tTHREE.Camera.call( this );\r\n\t\r\n\t\tthis.type = 'PerspectiveCamera';\r\n\t\r\n\t\tthis.zoom = 1;\r\n\t\r\n\t\tthis.fov = fov !== undefined ? fov : 50;\r\n\t\tthis.aspect = aspect !== undefined ? aspect : 1;\r\n\t\tthis.near = near !== undefined ? near : 0.1;\r\n\t\tthis.far = far !== undefined ? far : 2000;\r\n\t\r\n\t\tthis.updateProjectionMatrix();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.PerspectiveCamera.prototype = Object.create( THREE.Camera.prototype );\r\n\tTHREE.PerspectiveCamera.prototype.constructor = THREE.PerspectiveCamera;\r\n\t\r\n\t\r\n\t/**\r\n\t * Uses Focal Length (in mm) to estimate and set FOV\r\n\t * 35mm (fullframe) camera is used if frame size is not specified;\r\n\t * Formula based on http://www.bobatkins.com/photography/technical/field_of_view.html\r\n\t */\r\n\t\r\n\tTHREE.PerspectiveCamera.prototype.setLens = function ( focalLength, frameHeight ) {\r\n\t\r\n\t\tif ( frameHeight === undefined ) frameHeight = 24;\r\n\t\r\n\t\tthis.fov = 2 * THREE.Math.radToDeg( Math.atan( frameHeight / ( focalLength * 2 ) ) );\r\n\t\tthis.updateProjectionMatrix();\r\n\t\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * Sets an offset in a larger frustum. This is useful for multi-window or\r\n\t * multi-monitor/multi-machine setups.\r\n\t *\r\n\t * For example, if you have 3x2 monitors and each monitor is 1920x1080 and\r\n\t * the monitors are in grid like this\r\n\t *\r\n\t *   +---+---+---+\r\n\t *   | A | B | C |\r\n\t *   +---+---+---+\r\n\t *   | D | E | F |\r\n\t *   +---+---+---+\r\n\t *\r\n\t * then for each monitor you would call it like this\r\n\t *\r\n\t *   var w = 1920;\r\n\t *   var h = 1080;\r\n\t *   var fullWidth = w * 3;\r\n\t *   var fullHeight = h * 2;\r\n\t *\r\n\t *   --A--\r\n\t *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );\r\n\t *   --B--\r\n\t *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );\r\n\t *   --C--\r\n\t *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );\r\n\t *   --D--\r\n\t *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );\r\n\t *   --E--\r\n\t *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );\r\n\t *   --F--\r\n\t *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );\r\n\t *\r\n\t *   Note there is no reason monitors have to be the same size or in a grid.\r\n\t */\r\n\t\r\n\tTHREE.PerspectiveCamera.prototype.setViewOffset = function ( fullWidth, fullHeight, x, y, width, height ) {\r\n\t\r\n\t\tthis.fullWidth = fullWidth;\r\n\t\tthis.fullHeight = fullHeight;\r\n\t\tthis.x = x;\r\n\t\tthis.y = y;\r\n\t\tthis.width = width;\r\n\t\tthis.height = height;\r\n\t\r\n\t\tthis.updateProjectionMatrix();\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\tTHREE.PerspectiveCamera.prototype.updateProjectionMatrix = function () {\r\n\t\r\n\t\tvar fov = THREE.Math.radToDeg( 2 * Math.atan( Math.tan( THREE.Math.degToRad( this.fov ) * 0.5 ) / this.zoom ) );\r\n\t\r\n\t\tif ( this.fullWidth ) {\r\n\t\r\n\t\t\tvar aspect = this.fullWidth / this.fullHeight;\r\n\t\t\tvar top = Math.tan( THREE.Math.degToRad( fov * 0.5 ) ) * this.near;\r\n\t\t\tvar bottom = - top;\r\n\t\t\tvar left = aspect * bottom;\r\n\t\t\tvar right = aspect * top;\r\n\t\t\tvar width = Math.abs( right - left );\r\n\t\t\tvar height = Math.abs( top - bottom );\r\n\t\r\n\t\t\tthis.projectionMatrix.makeFrustum(\r\n\t\t\t\tleft + this.x * width / this.fullWidth,\r\n\t\t\t\tleft + ( this.x + this.width ) * width / this.fullWidth,\r\n\t\t\t\ttop - ( this.y + this.height ) * height / this.fullHeight,\r\n\t\t\t\ttop - this.y * height / this.fullHeight,\r\n\t\t\t\tthis.near,\r\n\t\t\t\tthis.far\r\n\t\t\t);\r\n\t\r\n\t\t} else {\r\n\t\r\n\t\t\tthis.projectionMatrix.makePerspective( fov, this.aspect, this.near, this.far );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.PerspectiveCamera.prototype.clone = function () {\r\n\t\r\n\t\tvar camera = new THREE.PerspectiveCamera();\r\n\t\r\n\t\tTHREE.Camera.prototype.clone.call( this, camera );\r\n\t\r\n\t\tcamera.zoom = this.zoom;\r\n\t\r\n\t\tcamera.fov = this.fov;\r\n\t\tcamera.aspect = this.aspect;\r\n\t\tcamera.near = this.near;\r\n\t\tcamera.far = this.far;\r\n\t\r\n\t\tcamera.projectionMatrix.copy( this.projectionMatrix );\r\n\t\r\n\t\treturn camera;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/lights/Light.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.Light = function ( color ) {\r\n\t\r\n\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t\tthis.type = 'Light';\r\n\t\t\r\n\t\tthis.color = new THREE.Color( color );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Light.prototype = Object.create( THREE.Object3D.prototype );\r\n\tTHREE.Light.prototype.constructor = THREE.Light;\r\n\t\r\n\tTHREE.Light.prototype.clone = function ( light ) {\r\n\t\r\n\t\tif ( light === undefined ) light = new THREE.Light();\r\n\t\r\n\t\tTHREE.Object3D.prototype.clone.call( this, light );\r\n\t\r\n\t\tlight.color.copy( this.color );\r\n\t\r\n\t\treturn light;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/lights/AmbientLight.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.AmbientLight = function ( color ) {\r\n\t\r\n\t\tTHREE.Light.call( this, color );\r\n\t\r\n\t\tthis.type = 'AmbientLight';\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.AmbientLight.prototype = Object.create( THREE.Light.prototype );\r\n\tTHREE.AmbientLight.prototype.constructor = THREE.AmbientLight;\r\n\t\r\n\tTHREE.AmbientLight.prototype.clone = function () {\r\n\t\r\n\t\tvar light = new THREE.AmbientLight();\r\n\t\r\n\t\tTHREE.Light.prototype.clone.call( this, light );\r\n\t\r\n\t\treturn light;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/lights/AreaLight.js\r\n\t\r\n\t/**\r\n\t * @author MPanknin / http://www.redplant.de/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.AreaLight = function ( color, intensity ) {\r\n\t\r\n\t\tTHREE.Light.call( this, color );\r\n\t\r\n\t\tthis.type = 'AreaLight';\r\n\t\r\n\t\tthis.normal = new THREE.Vector3( 0, - 1, 0 );\r\n\t\tthis.right = new THREE.Vector3( 1, 0, 0 );\r\n\t\r\n\t\tthis.intensity = ( intensity !== undefined ) ? intensity : 1;\r\n\t\r\n\t\tthis.width = 1.0;\r\n\t\tthis.height = 1.0;\r\n\t\r\n\t\tthis.constantAttenuation = 1.5;\r\n\t\tthis.linearAttenuation = 0.5;\r\n\t\tthis.quadraticAttenuation = 0.1;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.AreaLight.prototype = Object.create( THREE.Light.prototype );\r\n\tTHREE.AreaLight.prototype.constructor = THREE.AreaLight;\r\n\t\r\n\t\r\n\t// File:src/lights/DirectionalLight.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.DirectionalLight = function ( color, intensity ) {\r\n\t\r\n\t\tTHREE.Light.call( this, color );\r\n\t\r\n\t\tthis.type = 'DirectionalLight';\r\n\t\r\n\t\tthis.position.set( 0, 1, 0 );\r\n\t\tthis.target = new THREE.Object3D();\r\n\t\r\n\t\tthis.intensity = ( intensity !== undefined ) ? intensity : 1;\r\n\t\r\n\t\tthis.castShadow = false;\r\n\t\tthis.onlyShadow = false;\r\n\t\r\n\t\t//\r\n\t\r\n\t\tthis.shadowCameraNear = 50;\r\n\t\tthis.shadowCameraFar = 5000;\r\n\t\r\n\t\tthis.shadowCameraLeft = - 500;\r\n\t\tthis.shadowCameraRight = 500;\r\n\t\tthis.shadowCameraTop = 500;\r\n\t\tthis.shadowCameraBottom = - 500;\r\n\t\r\n\t\tthis.shadowCameraVisible = false;\r\n\t\r\n\t\tthis.shadowBias = 0;\r\n\t\tthis.shadowDarkness = 0.5;\r\n\t\r\n\t\tthis.shadowMapWidth = 512;\r\n\t\tthis.shadowMapHeight = 512;\r\n\t\r\n\t\t//\r\n\t\r\n\t\tthis.shadowCascade = false;\r\n\t\r\n\t\tthis.shadowCascadeOffset = new THREE.Vector3( 0, 0, - 1000 );\r\n\t\tthis.shadowCascadeCount = 2;\r\n\t\r\n\t\tthis.shadowCascadeBias = [ 0, 0, 0 ];\r\n\t\tthis.shadowCascadeWidth = [ 512, 512, 512 ];\r\n\t\tthis.shadowCascadeHeight = [ 512, 512, 512 ];\r\n\t\r\n\t\tthis.shadowCascadeNearZ = [ - 1.000, 0.990, 0.998 ];\r\n\t\tthis.shadowCascadeFarZ  = [ 0.990, 0.998, 1.000 ];\r\n\t\r\n\t\tthis.shadowCascadeArray = [];\r\n\t\r\n\t\t//\r\n\t\r\n\t\tthis.shadowMap = null;\r\n\t\tthis.shadowMapSize = null;\r\n\t\tthis.shadowCamera = null;\r\n\t\tthis.shadowMatrix = null;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.DirectionalLight.prototype = Object.create( THREE.Light.prototype );\r\n\tTHREE.DirectionalLight.prototype.constructor = THREE.DirectionalLight;\r\n\t\r\n\tTHREE.DirectionalLight.prototype.clone = function () {\r\n\t\r\n\t\tvar light = new THREE.DirectionalLight();\r\n\t\r\n\t\tTHREE.Light.prototype.clone.call( this, light );\r\n\t\r\n\t\tlight.target = this.target.clone();\r\n\t\r\n\t\tlight.intensity = this.intensity;\r\n\t\r\n\t\tlight.castShadow = this.castShadow;\r\n\t\tlight.onlyShadow = this.onlyShadow;\r\n\t\r\n\t\t//\r\n\t\r\n\t\tlight.shadowCameraNear = this.shadowCameraNear;\r\n\t\tlight.shadowCameraFar = this.shadowCameraFar;\r\n\t\r\n\t\tlight.shadowCameraLeft = this.shadowCameraLeft;\r\n\t\tlight.shadowCameraRight = this.shadowCameraRight;\r\n\t\tlight.shadowCameraTop = this.shadowCameraTop;\r\n\t\tlight.shadowCameraBottom = this.shadowCameraBottom;\r\n\t\r\n\t\tlight.shadowCameraVisible = this.shadowCameraVisible;\r\n\t\r\n\t\tlight.shadowBias = this.shadowBias;\r\n\t\tlight.shadowDarkness = this.shadowDarkness;\r\n\t\r\n\t\tlight.shadowMapWidth = this.shadowMapWidth;\r\n\t\tlight.shadowMapHeight = this.shadowMapHeight;\r\n\t\r\n\t\t//\r\n\t\r\n\t\tlight.shadowCascade = this.shadowCascade;\r\n\t\r\n\t\tlight.shadowCascadeOffset.copy( this.shadowCascadeOffset );\r\n\t\tlight.shadowCascadeCount = this.shadowCascadeCount;\r\n\t\r\n\t\tlight.shadowCascadeBias = this.shadowCascadeBias.slice( 0 );\r\n\t\tlight.shadowCascadeWidth = this.shadowCascadeWidth.slice( 0 );\r\n\t\tlight.shadowCascadeHeight = this.shadowCascadeHeight.slice( 0 );\r\n\t\r\n\t\tlight.shadowCascadeNearZ = this.shadowCascadeNearZ.slice( 0 );\r\n\t\tlight.shadowCascadeFarZ  = this.shadowCascadeFarZ.slice( 0 );\r\n\t\r\n\t\treturn light;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/lights/HemisphereLight.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.HemisphereLight = function ( skyColor, groundColor, intensity ) {\r\n\t\r\n\t\tTHREE.Light.call( this, skyColor );\r\n\t\r\n\t\tthis.type = 'HemisphereLight';\r\n\t\r\n\t\tthis.position.set( 0, 100, 0 );\r\n\t\r\n\t\tthis.groundColor = new THREE.Color( groundColor );\r\n\t\tthis.intensity = ( intensity !== undefined ) ? intensity : 1;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.HemisphereLight.prototype = Object.create( THREE.Light.prototype );\r\n\tTHREE.HemisphereLight.prototype.constructor = THREE.HemisphereLight;\r\n\t\r\n\tTHREE.HemisphereLight.prototype.clone = function () {\r\n\t\r\n\t\tvar light = new THREE.HemisphereLight();\r\n\t\r\n\t\tTHREE.Light.prototype.clone.call( this, light );\r\n\t\r\n\t\tlight.groundColor.copy( this.groundColor );\r\n\t\tlight.intensity = this.intensity;\r\n\t\r\n\t\treturn light;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/lights/PointLight.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.PointLight = function ( color, intensity, distance, decay ) {\r\n\t\r\n\t\tTHREE.Light.call( this, color );\r\n\t\r\n\t\tthis.type = 'PointLight';\r\n\t\r\n\t\tthis.intensity = ( intensity !== undefined ) ? intensity : 1;\r\n\t\tthis.distance = ( distance !== undefined ) ? distance : 0;\r\n\t\tthis.decay = ( decay !== undefined ) ? decay : 1;\t// for physically correct lights, should be 2.\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.PointLight.prototype = Object.create( THREE.Light.prototype );\r\n\tTHREE.PointLight.prototype.constructor = THREE.PointLight;\r\n\t\r\n\tTHREE.PointLight.prototype.clone = function () {\r\n\t\r\n\t\tvar light = new THREE.PointLight();\r\n\t\r\n\t\tTHREE.Light.prototype.clone.call( this, light );\r\n\t\r\n\t\tlight.intensity = this.intensity;\r\n\t\tlight.distance = this.distance;\r\n\t\tlight.decay = this.decay;\r\n\t\r\n\t\treturn light;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/lights/SpotLight.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.SpotLight = function ( color, intensity, distance, angle, exponent, decay ) {\r\n\t\r\n\t\tTHREE.Light.call( this, color );\r\n\t\r\n\t\tthis.type = 'SpotLight';\r\n\t\r\n\t\tthis.position.set( 0, 1, 0 );\r\n\t\tthis.target = new THREE.Object3D();\r\n\t\r\n\t\tthis.intensity = ( intensity !== undefined ) ? intensity : 1;\r\n\t\tthis.distance = ( distance !== undefined ) ? distance : 0;\r\n\t\tthis.angle = ( angle !== undefined ) ? angle : Math.PI / 3;\r\n\t\tthis.exponent = ( exponent !== undefined ) ? exponent : 10;\r\n\t\tthis.decay = ( decay !== undefined ) ? decay : 1;\t// for physically correct lights, should be 2.\r\n\t\r\n\t\tthis.castShadow = false;\r\n\t\tthis.onlyShadow = false;\r\n\t\r\n\t\t//\r\n\t\r\n\t\tthis.shadowCameraNear = 50;\r\n\t\tthis.shadowCameraFar = 5000;\r\n\t\tthis.shadowCameraFov = 50;\r\n\t\r\n\t\tthis.shadowCameraVisible = false;\r\n\t\r\n\t\tthis.shadowBias = 0;\r\n\t\tthis.shadowDarkness = 0.5;\r\n\t\r\n\t\tthis.shadowMapWidth = 512;\r\n\t\tthis.shadowMapHeight = 512;\r\n\t\r\n\t\t//\r\n\t\r\n\t\tthis.shadowMap = null;\r\n\t\tthis.shadowMapSize = null;\r\n\t\tthis.shadowCamera = null;\r\n\t\tthis.shadowMatrix = null;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.SpotLight.prototype = Object.create( THREE.Light.prototype );\r\n\tTHREE.SpotLight.prototype.constructor = THREE.SpotLight;\r\n\t\r\n\tTHREE.SpotLight.prototype.clone = function () {\r\n\t\r\n\t\tvar light = new THREE.SpotLight();\r\n\t\r\n\t\tTHREE.Light.prototype.clone.call( this, light );\r\n\t\r\n\t\tlight.target = this.target.clone();\r\n\t\r\n\t\tlight.intensity = this.intensity;\r\n\t\tlight.distance = this.distance;\r\n\t\tlight.angle = this.angle;\r\n\t\tlight.exponent = this.exponent;\r\n\t\tlight.decay = this.decay;\r\n\t\r\n\t\tlight.castShadow = this.castShadow;\r\n\t\tlight.onlyShadow = this.onlyShadow;\r\n\t\r\n\t\t//\r\n\t\r\n\t\tlight.shadowCameraNear = this.shadowCameraNear;\r\n\t\tlight.shadowCameraFar = this.shadowCameraFar;\r\n\t\tlight.shadowCameraFov = this.shadowCameraFov;\r\n\t\r\n\t\tlight.shadowCameraVisible = this.shadowCameraVisible;\r\n\t\r\n\t\tlight.shadowBias = this.shadowBias;\r\n\t\tlight.shadowDarkness = this.shadowDarkness;\r\n\t\r\n\t\tlight.shadowMapWidth = this.shadowMapWidth;\r\n\t\tlight.shadowMapHeight = this.shadowMapHeight;\r\n\t\r\n\t\treturn light;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/loaders/Cache.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.Cache = {\r\n\t\r\n\t\tfiles: {},\r\n\t\r\n\t\tadd: function ( key, file ) {\r\n\t\r\n\t\t\t// console.log( 'THREE.Cache', 'Adding key:', key );\r\n\t\r\n\t\t\tthis.files[ key ] = file;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tget: function ( key ) {\r\n\t\r\n\t\t\t// console.log( 'THREE.Cache', 'Checking key:', key );\r\n\t\r\n\t\t\treturn this.files[ key ];\r\n\t\r\n\t\t},\r\n\t\r\n\t\tremove: function ( key ) {\r\n\t\r\n\t\t\tdelete this.files[ key ];\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclear: function () {\r\n\t\r\n\t\t\tthis.files = {}\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/loaders/Loader.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.Loader = function ( showStatus ) {\r\n\t\r\n\t\tthis.showStatus = showStatus;\r\n\t\tthis.statusDomElement = showStatus ? THREE.Loader.prototype.addStatusElement() : null;\r\n\t\r\n\t\tthis.imageLoader = new THREE.ImageLoader();\r\n\t\r\n\t\tthis.onLoadStart = function () {};\r\n\t\tthis.onLoadProgress = function () {};\r\n\t\tthis.onLoadComplete = function () {};\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Loader.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Loader,\r\n\t\r\n\t\tcrossOrigin: undefined,\r\n\t\r\n\t\taddStatusElement: function () {\r\n\t\r\n\t\t\tvar e = document.createElement( 'div' );\r\n\t\r\n\t\t\te.style.position = 'absolute';\r\n\t\t\te.style.right = '0px';\r\n\t\t\te.style.top = '0px';\r\n\t\t\te.style.fontSize = '0.8em';\r\n\t\t\te.style.textAlign = 'left';\r\n\t\t\te.style.background = 'rgba(0,0,0,0.25)';\r\n\t\t\te.style.color = '#fff';\r\n\t\t\te.style.width = '120px';\r\n\t\t\te.style.padding = '0.5em 0.5em 0.5em 0.5em';\r\n\t\t\te.style.zIndex = 1000;\r\n\t\r\n\t\t\te.innerHTML = 'Loading ...';\r\n\t\r\n\t\t\treturn e;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tupdateProgress: function ( progress ) {\r\n\t\r\n\t\t\tvar message = 'Loaded ';\r\n\t\r\n\t\t\tif ( progress.total ) {\r\n\t\r\n\t\t\t\tmessage += ( 100 * progress.loaded / progress.total ).toFixed( 0 ) + '%';\r\n\t\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tmessage += ( progress.loaded / 1024 ).toFixed( 2 ) + ' KB';\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.statusDomElement.innerHTML = message;\r\n\t\r\n\t\t},\r\n\t\r\n\t\textractUrlBase: function ( url ) {\r\n\t\r\n\t\t\tvar parts = url.split( '/' );\r\n\t\r\n\t\t\tif ( parts.length === 1 ) return './';\r\n\t\r\n\t\t\tparts.pop();\r\n\t\r\n\t\t\treturn parts.join( '/' ) + '/';\r\n\t\r\n\t\t},\r\n\t\r\n\t\tinitMaterials: function ( materials, texturePath ) {\r\n\t\r\n\t\t\tvar array = [];\r\n\t\r\n\t\t\tfor ( var i = 0; i < materials.length; ++ i ) {\r\n\t\r\n\t\t\t\tarray[ i ] = this.createMaterial( materials[ i ], texturePath );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn array;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tneedsTangents: function ( materials ) {\r\n\t\r\n\t\t\tfor ( var i = 0, il = materials.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tvar m = materials[ i ];\r\n\t\r\n\t\t\t\tif ( m instanceof THREE.ShaderMaterial ) return true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn false;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcreateMaterial: function ( m, texturePath ) {\r\n\t\r\n\t\t\tvar scope = this;\r\n\t\r\n\t\t\tfunction nearest_pow2( n ) {\r\n\t\r\n\t\t\t\tvar l = Math.log( n ) / Math.LN2;\r\n\t\t\t\treturn Math.pow( 2, Math.round(  l ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfunction create_texture( where, name, sourceFile, repeat, offset, wrap, anisotropy ) {\r\n\t\r\n\t\t\t\tvar fullPath = texturePath + sourceFile;\r\n\t\r\n\t\t\t\tvar texture;\r\n\t\r\n\t\t\t\tvar loader = THREE.Loader.Handlers.get( fullPath );\r\n\t\r\n\t\t\t\tif ( loader !== null ) {\r\n\t\r\n\t\t\t\t\ttexture = loader.load( fullPath );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\ttexture = new THREE.Texture();\r\n\t\r\n\t\t\t\t\tloader = scope.imageLoader;\r\n\t\t\t\t\tloader.crossOrigin = scope.crossOrigin;\r\n\t\t\t\t\tloader.load( fullPath, function ( image ) {\r\n\t\r\n\t\t\t\t\t\tif ( THREE.Math.isPowerOfTwo( image.width ) === false ||\r\n\t\t\t\t\t\t\t THREE.Math.isPowerOfTwo( image.height ) === false ) {\r\n\t\r\n\t\t\t\t\t\t\tvar width = nearest_pow2( image.width );\r\n\t\t\t\t\t\t\tvar height = nearest_pow2( image.height );\r\n\t\r\n\t\t\t\t\t\t\tvar canvas = document.createElement( 'canvas' );\r\n\t\t\t\t\t\t\tcanvas.width = width;\r\n\t\t\t\t\t\t\tcanvas.height = height;\r\n\t\r\n\t\t\t\t\t\t\tvar context = canvas.getContext( '2d' );\r\n\t\t\t\t\t\t\tcontext.drawImage( image, 0, 0, width, height );\r\n\t\r\n\t\t\t\t\t\t\ttexture.image = canvas;\r\n\t\r\n\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\ttexture.image = image;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\ttexture.needsUpdate = true;\r\n\t\r\n\t\t\t\t\t} );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\ttexture.sourceFile = sourceFile;\r\n\t\r\n\t\t\t\tif ( repeat ) {\r\n\t\r\n\t\t\t\t\ttexture.repeat.set( repeat[ 0 ], repeat[ 1 ] );\r\n\t\r\n\t\t\t\t\tif ( repeat[ 0 ] !== 1 ) texture.wrapS = THREE.RepeatWrapping;\r\n\t\t\t\t\tif ( repeat[ 1 ] !== 1 ) texture.wrapT = THREE.RepeatWrapping;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( offset ) {\r\n\t\r\n\t\t\t\t\ttexture.offset.set( offset[ 0 ], offset[ 1 ] );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( wrap ) {\r\n\t\r\n\t\t\t\t\tvar wrapMap = {\r\n\t\t\t\t\t\t'repeat': THREE.RepeatWrapping,\r\n\t\t\t\t\t\t'mirror': THREE.MirroredRepeatWrapping\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( wrapMap[ wrap[ 0 ] ] !== undefined ) texture.wrapS = wrapMap[ wrap[ 0 ] ];\r\n\t\t\t\t\tif ( wrapMap[ wrap[ 1 ] ] !== undefined ) texture.wrapT = wrapMap[ wrap[ 1 ] ];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( anisotropy ) {\r\n\t\r\n\t\t\t\t\ttexture.anisotropy = anisotropy;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\twhere[ name ] = texture;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfunction rgb2hex( rgb ) {\r\n\t\r\n\t\t\t\treturn ( rgb[ 0 ] * 255 << 16 ) + ( rgb[ 1 ] * 255 << 8 ) + rgb[ 2 ] * 255;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// defaults\r\n\t\r\n\t\t\tvar mtype = 'MeshLambertMaterial';\r\n\t\t\tvar mpars = { color: 0xeeeeee, opacity: 1.0, map: null, lightMap: null, normalMap: null, bumpMap: null, wireframe: false };\r\n\t\r\n\t\t\t// parameters from model file\r\n\t\r\n\t\t\tif ( m.shading ) {\r\n\t\r\n\t\t\t\tvar shading = m.shading.toLowerCase();\r\n\t\r\n\t\t\t\tif ( shading === 'phong' ) mtype = 'MeshPhongMaterial';\r\n\t\t\t\telse if ( shading === 'basic' ) mtype = 'MeshBasicMaterial';\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( m.blending !== undefined && THREE[ m.blending ] !== undefined ) {\r\n\t\r\n\t\t\t\tmpars.blending = THREE[ m.blending ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( m.transparent !== undefined ) {\r\n\t\r\n\t\t\t\tmpars.transparent = m.transparent;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( m.opacity !== undefined && m.opacity < 1.0 ) {\r\n\t\r\n\t\t\t\tmpars.transparent = true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( m.depthTest !== undefined ) {\r\n\t\r\n\t\t\t\tmpars.depthTest = m.depthTest;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( m.depthWrite !== undefined ) {\r\n\t\r\n\t\t\t\tmpars.depthWrite = m.depthWrite;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( m.visible !== undefined ) {\r\n\t\r\n\t\t\t\tmpars.visible = m.visible;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( m.flipSided !== undefined ) {\r\n\t\r\n\t\t\t\tmpars.side = THREE.BackSide;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( m.doubleSided !== undefined ) {\r\n\t\r\n\t\t\t\tmpars.side = THREE.DoubleSide;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( m.wireframe !== undefined ) {\r\n\t\r\n\t\t\t\tmpars.wireframe = m.wireframe;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( m.vertexColors !== undefined ) {\r\n\t\r\n\t\t\t\tif ( m.vertexColors === 'face' ) {\r\n\t\r\n\t\t\t\t\tmpars.vertexColors = THREE.FaceColors;\r\n\t\r\n\t\t\t\t} else if ( m.vertexColors ) {\r\n\t\r\n\t\t\t\t\tmpars.vertexColors = THREE.VertexColors;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// colors\r\n\t\r\n\t\t\tif ( m.colorDiffuse ) {\r\n\t\r\n\t\t\t\tmpars.color = rgb2hex( m.colorDiffuse );\r\n\t\r\n\t\t\t} else if ( m.DbgColor ) {\r\n\t\r\n\t\t\t\tmpars.color = m.DbgColor;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( m.colorSpecular ) {\r\n\t\r\n\t\t\t\tmpars.specular = rgb2hex( m.colorSpecular );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( m.colorEmissive ) {\r\n\t\r\n\t\t\t\tmpars.emissive = rgb2hex( m.colorEmissive );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// modifiers\r\n\t\r\n\t\t\tif ( m.transparency !== undefined ) {\r\n\t\r\n\t\t\t\tconsole.warn( 'THREE.Loader: transparency has been renamed to opacity' );\r\n\t\t\t\tm.opacity = m.transparency;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( m.opacity !== undefined ) {\r\n\t\r\n\t\t\t\tmpars.opacity = m.opacity;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( m.specularCoef ) {\r\n\t\r\n\t\t\t\tmpars.shininess = m.specularCoef;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// textures\r\n\t\r\n\t\t\tif ( m.mapDiffuse && texturePath ) {\r\n\t\r\n\t\t\t\tcreate_texture( mpars, 'map', m.mapDiffuse, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( m.mapLight && texturePath ) {\r\n\t\r\n\t\t\t\tcreate_texture( mpars, 'lightMap', m.mapLight, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( m.mapBump && texturePath ) {\r\n\t\r\n\t\t\t\tcreate_texture( mpars, 'bumpMap', m.mapBump, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( m.mapNormal && texturePath ) {\r\n\t\r\n\t\t\t\tcreate_texture( mpars, 'normalMap', m.mapNormal, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( m.mapSpecular && texturePath ) {\r\n\t\r\n\t\t\t\tcreate_texture( mpars, 'specularMap', m.mapSpecular, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( m.mapAlpha && texturePath ) {\r\n\t\r\n\t\t\t\tcreate_texture( mpars, 'alphaMap', m.mapAlpha, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t//\r\n\t\r\n\t\t\tif ( m.mapBumpScale ) {\r\n\t\r\n\t\t\t\tmpars.bumpScale = m.mapBumpScale;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( m.mapNormalFactor ) {\r\n\t\r\n\t\t\t\tmpars.normalScale = new THREE.Vector2( m.mapNormalFactor, m.mapNormalFactor );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar material = new THREE[ mtype ]( mpars );\r\n\t\r\n\t\t\tif ( m.DbgName !== undefined ) material.name = m.DbgName;\r\n\t\r\n\t\t\treturn material;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Loader.Handlers = {\r\n\t\r\n\t\thandlers: [],\r\n\t\r\n\t\tadd: function ( regex, loader ) {\r\n\t\r\n\t\t\tthis.handlers.push( regex, loader );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tget: function ( file ) {\r\n\t\r\n\t\t\tfor ( var i = 0, l = this.handlers.length; i < l; i += 2 ) {\r\n\t\r\n\t\t\t\tvar regex = this.handlers[ i ];\r\n\t\t\t\tvar loader  = this.handlers[ i + 1 ];\r\n\t\r\n\t\t\t\tif ( regex.test( file ) ) {\r\n\t\r\n\t\t\t\t\treturn loader;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn null;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/loaders/XHRLoader.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.XHRLoader = function ( manager ) {\r\n\t\r\n\t\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.XHRLoader.prototype = {\r\n\t\r\n\t\tconstructor: THREE.XHRLoader,\r\n\t\r\n\t\tload: function ( url, onLoad, onProgress, onError ) {\r\n\t\r\n\t\t\tvar scope = this;\r\n\t\r\n\t\t\tvar cached = THREE.Cache.get( url );\r\n\t\r\n\t\t\tif ( cached !== undefined ) {\r\n\t\r\n\t\t\t\tif ( onLoad ) onLoad( cached );\r\n\t\t\t\treturn;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar request = new XMLHttpRequest();\r\n\t\t\trequest.open( 'GET', url, true );\r\n\t\r\n\t\t\trequest.addEventListener( 'load', function ( event ) {\r\n\t\r\n\t\t\t\tTHREE.Cache.add( url, this.response );\r\n\t\r\n\t\t\t\tif ( onLoad ) onLoad( this.response );\r\n\t\r\n\t\t\t\tscope.manager.itemEnd( url );\r\n\t\r\n\t\t\t}, false );\r\n\t\r\n\t\t\tif ( onProgress !== undefined ) {\r\n\t\r\n\t\t\t\trequest.addEventListener( 'progress', function ( event ) {\r\n\t\r\n\t\t\t\t\tonProgress( event );\r\n\t\r\n\t\t\t\t}, false );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( onError !== undefined ) {\r\n\t\r\n\t\t\t\trequest.addEventListener( 'error', function ( event ) {\r\n\t\r\n\t\t\t\t\tonError( event );\r\n\t\r\n\t\t\t\t}, false );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( this.crossOrigin !== undefined ) request.crossOrigin = this.crossOrigin;\r\n\t\t\tif ( this.responseType !== undefined ) request.responseType = this.responseType;\r\n\t\r\n\t\t\trequest.send( null );\r\n\t\r\n\t\t\tscope.manager.itemStart( url );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetResponseType: function ( value ) {\r\n\t\r\n\t\t\tthis.responseType = value;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetCrossOrigin: function ( value ) {\r\n\t\r\n\t\t\tthis.crossOrigin = value;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/loaders/ImageLoader.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.ImageLoader = function ( manager ) {\r\n\t\r\n\t\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.ImageLoader.prototype = {\r\n\t\r\n\t\tconstructor: THREE.ImageLoader,\r\n\t\r\n\t\tload: function ( url, onLoad, onProgress, onError ) {\r\n\t\r\n\t\t\tvar scope = this;\r\n\t\r\n\t\t\tvar cached = THREE.Cache.get( url );\r\n\t\r\n\t\t\tif ( cached !== undefined ) {\r\n\t\r\n\t\t\t\tonLoad( cached );\r\n\t\t\t\treturn;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar image = document.createElement( 'img' );\r\n\t\r\n\t\t\timage.addEventListener( 'load', function ( event ) {\r\n\t\r\n\t\t\t\tTHREE.Cache.add( url, this );\r\n\t\r\n\t\t\t\tif ( onLoad ) onLoad( this );\r\n\t\t\t\t\r\n\t\t\t\tscope.manager.itemEnd( url );\r\n\t\r\n\t\t\t}, false );\r\n\t\r\n\t\t\tif ( onProgress !== undefined ) {\r\n\t\r\n\t\t\t\timage.addEventListener( 'progress', function ( event ) {\r\n\t\r\n\t\t\t\t\tonProgress( event );\r\n\t\r\n\t\t\t\t}, false );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( onError !== undefined ) {\r\n\t\r\n\t\t\t\timage.addEventListener( 'error', function ( event ) {\r\n\t\r\n\t\t\t\t\tonError( event );\r\n\t\r\n\t\t\t\t}, false );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;\r\n\t\r\n\t\t\timage.src = url;\r\n\t\r\n\t\t\tscope.manager.itemStart( url );\r\n\t\r\n\t\t\treturn image;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetCrossOrigin: function ( value ) {\r\n\t\r\n\t\t\tthis.crossOrigin = value;\r\n\t\r\n\t\t}\r\n\t\r\n\t}\r\n\t\r\n\t// File:src/loaders/JSONLoader.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.JSONLoader = function ( showStatus ) {\r\n\t\r\n\t\tTHREE.Loader.call( this, showStatus );\r\n\t\r\n\t\tthis.withCredentials = false;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.JSONLoader.prototype = Object.create( THREE.Loader.prototype );\r\n\tTHREE.JSONLoader.prototype.constructor = THREE.JSONLoader;\r\n\t\r\n\tTHREE.JSONLoader.prototype.load = function ( url, callback, texturePath ) {\r\n\t\r\n\t\t// todo: unify load API to for easier SceneLoader use\r\n\t\r\n\t\ttexturePath = texturePath && ( typeof texturePath === 'string' ) ? texturePath : this.extractUrlBase( url );\r\n\t\r\n\t\tthis.onLoadStart();\r\n\t\tthis.loadAjaxJSON( this, url, callback, texturePath );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.JSONLoader.prototype.loadAjaxJSON = function ( context, url, callback, texturePath, callbackProgress ) {\r\n\t\r\n\t\tvar xhr = new XMLHttpRequest();\r\n\t\r\n\t\tvar length = 0;\r\n\t\r\n\t\txhr.onreadystatechange = function () {\r\n\t\r\n\t\t\tif ( xhr.readyState === xhr.DONE ) {\r\n\t\r\n\t\t\t\tif ( xhr.status === 200 || xhr.status === 0 ) {\r\n\t\r\n\t\t\t\t\tif ( xhr.responseText ) {\r\n\t\r\n\t\t\t\t\t\tvar json = JSON.parse( xhr.responseText );\r\n\t\t\t\t\t\tvar metadata = json.metadata;\r\n\t\r\n\t\t\t\t\t\tif ( metadata !== undefined ) {\r\n\t\r\n\t\t\t\t\t\t\tif ( metadata.type === 'object' ) {\r\n\t\r\n\t\t\t\t\t\t\t\tTHREE.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.' );\r\n\t\t\t\t\t\t\t\treturn;\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\tif ( metadata.type === 'scene' ) {\r\n\t\r\n\t\t\t\t\t\t\t\tTHREE.error( 'THREE.JSONLoader: ' + url + ' seems to be a Scene. Use THREE.SceneLoader instead.' );\r\n\t\t\t\t\t\t\t\treturn;\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tvar result = context.parse( json, texturePath );\r\n\t\t\t\t\t\tcallback( result.geometry, result.materials );\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tTHREE.error( 'THREE.JSONLoader: ' + url + ' seems to be unreachable or the file is empty.' );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t// in context of more complex asset initialization\r\n\t\t\t\t\t// do not block on single failed file\r\n\t\t\t\t\t// maybe should go even one more level up\r\n\t\r\n\t\t\t\t\tcontext.onLoadComplete();\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tTHREE.error( 'THREE.JSONLoader: Couldn\\'t load ' + url + ' (' + xhr.status + ')' );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else if ( xhr.readyState === xhr.LOADING ) {\r\n\t\r\n\t\t\t\tif ( callbackProgress ) {\r\n\t\r\n\t\t\t\t\tif ( length === 0 ) {\r\n\t\r\n\t\t\t\t\t\tlength = xhr.getResponseHeader( 'Content-Length' );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tcallbackProgress( { total: length, loaded: xhr.responseText.length } );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else if ( xhr.readyState === xhr.HEADERS_RECEIVED ) {\r\n\t\r\n\t\t\t\tif ( callbackProgress !== undefined ) {\r\n\t\r\n\t\t\t\t\tlength = xhr.getResponseHeader( 'Content-Length' );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\txhr.open( 'GET', url, true );\r\n\t\txhr.withCredentials = this.withCredentials;\r\n\t\txhr.send( null );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.JSONLoader.prototype.parse = function ( json, texturePath ) {\r\n\t\r\n\t\tvar geometry = new THREE.Geometry(),\r\n\t\tscale = ( json.scale !== undefined ) ? 1.0 / json.scale : 1.0;\r\n\t\r\n\t\tparseModel( scale );\r\n\t\r\n\t\tparseSkin();\r\n\t\tparseMorphing( scale );\r\n\t\r\n\t\tgeometry.computeFaceNormals();\r\n\t\tgeometry.computeBoundingSphere();\r\n\t\r\n\t\tfunction parseModel( scale ) {\r\n\t\r\n\t\t\tfunction isBitSet( value, position ) {\r\n\t\r\n\t\t\t\treturn value & ( 1 << position );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar i, j, fi,\r\n\t\r\n\t\t\toffset, zLength,\r\n\t\r\n\t\t\tcolorIndex, normalIndex, uvIndex, materialIndex,\r\n\t\r\n\t\t\ttype,\r\n\t\t\tisQuad,\r\n\t\t\thasMaterial,\r\n\t\t\thasFaceVertexUv,\r\n\t\t\thasFaceNormal, hasFaceVertexNormal,\r\n\t\t\thasFaceColor, hasFaceVertexColor,\r\n\t\r\n\t\t\tvertex, face, faceA, faceB, hex, normal,\r\n\t\r\n\t\t\tuvLayer, uv, u, v,\r\n\t\r\n\t\t\tfaces = json.faces,\r\n\t\t\tvertices = json.vertices,\r\n\t\t\tnormals = json.normals,\r\n\t\t\tcolors = json.colors,\r\n\t\r\n\t\t\tnUvLayers = 0;\r\n\t\r\n\t\t\tif ( json.uvs !== undefined ) {\r\n\t\r\n\t\t\t\t// disregard empty arrays\r\n\t\r\n\t\t\t\tfor ( i = 0; i < json.uvs.length; i ++ ) {\r\n\t\r\n\t\t\t\t\tif ( json.uvs[ i ].length ) nUvLayers ++;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tfor ( i = 0; i < nUvLayers; i ++ ) {\r\n\t\r\n\t\t\t\t\tgeometry.faceVertexUvs[ i ] = [];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\toffset = 0;\r\n\t\t\tzLength = vertices.length;\r\n\t\r\n\t\t\twhile ( offset < zLength ) {\r\n\t\r\n\t\t\t\tvertex = new THREE.Vector3();\r\n\t\r\n\t\t\t\tvertex.x = vertices[ offset ++ ] * scale;\r\n\t\t\t\tvertex.y = vertices[ offset ++ ] * scale;\r\n\t\t\t\tvertex.z = vertices[ offset ++ ] * scale;\r\n\t\r\n\t\t\t\tgeometry.vertices.push( vertex );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\toffset = 0;\r\n\t\t\tzLength = faces.length;\r\n\t\r\n\t\t\twhile ( offset < zLength ) {\r\n\t\r\n\t\t\t\ttype = faces[ offset ++ ];\r\n\t\r\n\t\r\n\t\t\t\tisQuad              = isBitSet( type, 0 );\r\n\t\t\t\thasMaterial         = isBitSet( type, 1 );\r\n\t\t\t\thasFaceVertexUv     = isBitSet( type, 3 );\r\n\t\t\t\thasFaceNormal       = isBitSet( type, 4 );\r\n\t\t\t\thasFaceVertexNormal = isBitSet( type, 5 );\r\n\t\t\t\thasFaceColor\t     = isBitSet( type, 6 );\r\n\t\t\t\thasFaceVertexColor  = isBitSet( type, 7 );\r\n\t\r\n\t\t\t\t// console.log(\"type\", type, \"bits\", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);\r\n\t\r\n\t\t\t\tif ( isQuad ) {\r\n\t\r\n\t\t\t\t\tfaceA = new THREE.Face3();\r\n\t\t\t\t\tfaceA.a = faces[ offset ];\r\n\t\t\t\t\tfaceA.b = faces[ offset + 1 ];\r\n\t\t\t\t\tfaceA.c = faces[ offset + 3 ];\r\n\t\r\n\t\t\t\t\tfaceB = new THREE.Face3();\r\n\t\t\t\t\tfaceB.a = faces[ offset + 1 ];\r\n\t\t\t\t\tfaceB.b = faces[ offset + 2 ];\r\n\t\t\t\t\tfaceB.c = faces[ offset + 3 ];\r\n\t\r\n\t\t\t\t\toffset += 4;\r\n\t\r\n\t\t\t\t\tif ( hasMaterial ) {\r\n\t\r\n\t\t\t\t\t\tmaterialIndex = faces[ offset ++ ];\r\n\t\t\t\t\t\tfaceA.materialIndex = materialIndex;\r\n\t\t\t\t\t\tfaceB.materialIndex = materialIndex;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t// to get face <=> uv index correspondence\r\n\t\r\n\t\t\t\t\tfi = geometry.faces.length;\r\n\t\r\n\t\t\t\t\tif ( hasFaceVertexUv ) {\r\n\t\r\n\t\t\t\t\t\tfor ( i = 0; i < nUvLayers; i ++ ) {\r\n\t\r\n\t\t\t\t\t\t\tuvLayer = json.uvs[ i ];\r\n\t\r\n\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ] = [];\r\n\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi + 1 ] = []\r\n\t\r\n\t\t\t\t\t\t\tfor ( j = 0; j < 4; j ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\tuvIndex = faces[ offset ++ ];\r\n\t\r\n\t\t\t\t\t\t\t\tu = uvLayer[ uvIndex * 2 ];\r\n\t\t\t\t\t\t\t\tv = uvLayer[ uvIndex * 2 + 1 ];\r\n\t\r\n\t\t\t\t\t\t\t\tuv = new THREE.Vector2( u, v );\r\n\t\r\n\t\t\t\t\t\t\t\tif ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );\r\n\t\t\t\t\t\t\t\tif ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( hasFaceNormal ) {\r\n\t\r\n\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\r\n\t\r\n\t\t\t\t\t\tfaceA.normal.set(\r\n\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\t\tnormals[ normalIndex ]\r\n\t\t\t\t\t\t);\r\n\t\r\n\t\t\t\t\t\tfaceB.normal.copy( faceA.normal );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( hasFaceVertexNormal ) {\r\n\t\r\n\t\t\t\t\t\tfor ( i = 0; i < 4; i ++ ) {\r\n\t\r\n\t\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\r\n\t\r\n\t\t\t\t\t\t\tnormal = new THREE.Vector3(\r\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\t\t\tnormals[ normalIndex ]\r\n\t\t\t\t\t\t\t);\r\n\t\r\n\t\r\n\t\t\t\t\t\t\tif ( i !== 2 ) faceA.vertexNormals.push( normal );\r\n\t\t\t\t\t\t\tif ( i !== 0 ) faceB.vertexNormals.push( normal );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\r\n\t\t\t\t\tif ( hasFaceColor ) {\r\n\t\r\n\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\r\n\t\t\t\t\t\thex = colors[ colorIndex ];\r\n\t\r\n\t\t\t\t\t\tfaceA.color.setHex( hex );\r\n\t\t\t\t\t\tfaceB.color.setHex( hex );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\r\n\t\t\t\t\tif ( hasFaceVertexColor ) {\r\n\t\r\n\t\t\t\t\t\tfor ( i = 0; i < 4; i ++ ) {\r\n\t\r\n\t\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\r\n\t\t\t\t\t\t\thex = colors[ colorIndex ];\r\n\t\r\n\t\t\t\t\t\t\tif ( i !== 2 ) faceA.vertexColors.push( new THREE.Color( hex ) );\r\n\t\t\t\t\t\t\tif ( i !== 0 ) faceB.vertexColors.push( new THREE.Color( hex ) );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tgeometry.faces.push( faceA );\r\n\t\t\t\t\tgeometry.faces.push( faceB );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tface = new THREE.Face3();\r\n\t\t\t\t\tface.a = faces[ offset ++ ];\r\n\t\t\t\t\tface.b = faces[ offset ++ ];\r\n\t\t\t\t\tface.c = faces[ offset ++ ];\r\n\t\r\n\t\t\t\t\tif ( hasMaterial ) {\r\n\t\r\n\t\t\t\t\t\tmaterialIndex = faces[ offset ++ ];\r\n\t\t\t\t\t\tface.materialIndex = materialIndex;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t// to get face <=> uv index correspondence\r\n\t\r\n\t\t\t\t\tfi = geometry.faces.length;\r\n\t\r\n\t\t\t\t\tif ( hasFaceVertexUv ) {\r\n\t\r\n\t\t\t\t\t\tfor ( i = 0; i < nUvLayers; i ++ ) {\r\n\t\r\n\t\t\t\t\t\t\tuvLayer = json.uvs[ i ];\r\n\t\r\n\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ] = [];\r\n\t\r\n\t\t\t\t\t\t\tfor ( j = 0; j < 3; j ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\tuvIndex = faces[ offset ++ ];\r\n\t\r\n\t\t\t\t\t\t\t\tu = uvLayer[ uvIndex * 2 ];\r\n\t\t\t\t\t\t\t\tv = uvLayer[ uvIndex * 2 + 1 ];\r\n\t\r\n\t\t\t\t\t\t\t\tuv = new THREE.Vector2( u, v );\r\n\t\r\n\t\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ].push( uv );\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( hasFaceNormal ) {\r\n\t\r\n\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\r\n\t\r\n\t\t\t\t\t\tface.normal.set(\r\n\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\t\tnormals[ normalIndex ]\r\n\t\t\t\t\t\t);\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( hasFaceVertexNormal ) {\r\n\t\r\n\t\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\r\n\t\r\n\t\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\r\n\t\r\n\t\t\t\t\t\t\tnormal = new THREE.Vector3(\r\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\t\t\tnormals[ normalIndex ]\r\n\t\t\t\t\t\t\t);\r\n\t\r\n\t\t\t\t\t\t\tface.vertexNormals.push( normal );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\r\n\t\t\t\t\tif ( hasFaceColor ) {\r\n\t\r\n\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\r\n\t\t\t\t\t\tface.color.setHex( colors[ colorIndex ] );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\r\n\t\t\t\t\tif ( hasFaceVertexColor ) {\r\n\t\r\n\t\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\r\n\t\r\n\t\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\r\n\t\t\t\t\t\t\tface.vertexColors.push( new THREE.Color( colors[ colorIndex ] ) );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tgeometry.faces.push( face );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tfunction parseSkin() {\r\n\t\t\tvar influencesPerVertex = ( json.influencesPerVertex !== undefined ) ? json.influencesPerVertex : 2;\r\n\t\r\n\t\t\tif ( json.skinWeights ) {\r\n\t\r\n\t\t\t\tfor ( var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex ) {\r\n\t\r\n\t\t\t\t\tvar x =                               json.skinWeights[ i     ];\r\n\t\t\t\t\tvar y = ( influencesPerVertex > 1 ) ? json.skinWeights[ i + 1 ] : 0;\r\n\t\t\t\t\tvar z = ( influencesPerVertex > 2 ) ? json.skinWeights[ i + 2 ] : 0;\r\n\t\t\t\t\tvar w = ( influencesPerVertex > 3 ) ? json.skinWeights[ i + 3 ] : 0;\r\n\t\r\n\t\t\t\t\tgeometry.skinWeights.push( new THREE.Vector4( x, y, z, w ) );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( json.skinIndices ) {\r\n\t\r\n\t\t\t\tfor ( var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex ) {\r\n\t\r\n\t\t\t\t\tvar a =                               json.skinIndices[ i     ];\r\n\t\t\t\t\tvar b = ( influencesPerVertex > 1 ) ? json.skinIndices[ i + 1 ] : 0;\r\n\t\t\t\t\tvar c = ( influencesPerVertex > 2 ) ? json.skinIndices[ i + 2 ] : 0;\r\n\t\t\t\t\tvar d = ( influencesPerVertex > 3 ) ? json.skinIndices[ i + 3 ] : 0;\r\n\t\r\n\t\t\t\t\tgeometry.skinIndices.push( new THREE.Vector4( a, b, c, d ) );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tgeometry.bones = json.bones;\r\n\t\r\n\t\t\tif ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {\r\n\t\r\n\t\t\t\tTHREE.warn( 'THREE.JSONLoader: When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +\r\n\t\t\t\t\t\tgeometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\r\n\t\t\t// could change this to json.animations[0] or remove completely\r\n\t\r\n\t\t\tgeometry.animation = json.animation;\r\n\t\t\tgeometry.animations = json.animations;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tfunction parseMorphing( scale ) {\r\n\t\r\n\t\t\tif ( json.morphTargets !== undefined ) {\r\n\t\r\n\t\t\t\tvar i, l, v, vl, dstVertices, srcVertices;\r\n\t\r\n\t\t\t\tfor ( i = 0, l = json.morphTargets.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\tgeometry.morphTargets[ i ] = {};\r\n\t\t\t\t\tgeometry.morphTargets[ i ].name = json.morphTargets[ i ].name;\r\n\t\t\t\t\tgeometry.morphTargets[ i ].vertices = [];\r\n\t\r\n\t\t\t\t\tdstVertices = geometry.morphTargets[ i ].vertices;\r\n\t\t\t\t\tsrcVertices = json.morphTargets [ i ].vertices;\r\n\t\r\n\t\t\t\t\tfor ( v = 0, vl = srcVertices.length; v < vl; v += 3 ) {\r\n\t\r\n\t\t\t\t\t\tvar vertex = new THREE.Vector3();\r\n\t\t\t\t\t\tvertex.x = srcVertices[ v ] * scale;\r\n\t\t\t\t\t\tvertex.y = srcVertices[ v + 1 ] * scale;\r\n\t\t\t\t\t\tvertex.z = srcVertices[ v + 2 ] * scale;\r\n\t\r\n\t\t\t\t\t\tdstVertices.push( vertex );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( json.morphColors !== undefined ) {\r\n\t\r\n\t\t\t\tvar i, l, c, cl, dstColors, srcColors, color;\r\n\t\r\n\t\t\t\tfor ( i = 0, l = json.morphColors.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\tgeometry.morphColors[ i ] = {};\r\n\t\t\t\t\tgeometry.morphColors[ i ].name = json.morphColors[ i ].name;\r\n\t\t\t\t\tgeometry.morphColors[ i ].colors = [];\r\n\t\r\n\t\t\t\t\tdstColors = geometry.morphColors[ i ].colors;\r\n\t\t\t\t\tsrcColors = json.morphColors [ i ].colors;\r\n\t\r\n\t\t\t\t\tfor ( c = 0, cl = srcColors.length; c < cl; c += 3 ) {\r\n\t\r\n\t\t\t\t\t\tcolor = new THREE.Color( 0xffaa00 );\r\n\t\t\t\t\t\tcolor.setRGB( srcColors[ c ], srcColors[ c + 1 ], srcColors[ c + 2 ] );\r\n\t\t\t\t\t\tdstColors.push( color );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tif ( json.materials === undefined || json.materials.length === 0 ) {\r\n\t\r\n\t\t\treturn { geometry: geometry };\r\n\t\r\n\t\t} else {\r\n\t\r\n\t\t\tvar materials = this.initMaterials( json.materials, texturePath );\r\n\t\r\n\t\t\tif ( this.needsTangents( materials ) ) {\r\n\t\r\n\t\t\t\tgeometry.computeTangents();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn { geometry: geometry, materials: materials };\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/loaders/LoadingManager.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.LoadingManager = function ( onLoad, onProgress, onError ) {\r\n\t\r\n\t\tvar scope = this;\r\n\t\r\n\t\tvar loaded = 0, total = 0;\r\n\t\r\n\t\tthis.onLoad = onLoad;\r\n\t\tthis.onProgress = onProgress;\r\n\t\tthis.onError = onError;\r\n\t\r\n\t\tthis.itemStart = function ( url ) {\r\n\t\r\n\t\t\ttotal ++;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.itemEnd = function ( url ) {\r\n\t\r\n\t\t\tloaded ++;\r\n\t\r\n\t\t\tif ( scope.onProgress !== undefined ) {\r\n\t\r\n\t\t\t\tscope.onProgress( url, loaded, total );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( loaded === total && scope.onLoad !== undefined ) {\r\n\t\r\n\t\t\t\tscope.onLoad();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.DefaultLoadingManager = new THREE.LoadingManager();\r\n\t\r\n\t// File:src/loaders/BufferGeometryLoader.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.BufferGeometryLoader = function ( manager ) {\r\n\t\r\n\t\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.BufferGeometryLoader.prototype = {\r\n\t\r\n\t\tconstructor: THREE.BufferGeometryLoader,\r\n\t\r\n\t\tload: function ( url, onLoad, onProgress, onError ) {\r\n\t\r\n\t\t\tvar scope = this;\r\n\t\r\n\t\t\tvar loader = new THREE.XHRLoader( scope.manager );\r\n\t\t\tloader.setCrossOrigin( this.crossOrigin );\r\n\t\t\tloader.load( url, function ( text ) {\r\n\t\r\n\t\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\r\n\t\r\n\t\t\t}, onProgress, onError );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetCrossOrigin: function ( value ) {\r\n\t\r\n\t\t\tthis.crossOrigin = value;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tparse: function ( json ) {\r\n\t\r\n\t\t\tvar geometry = new THREE.BufferGeometry();\r\n\t\r\n\t\t\tvar attributes = json.data.attributes;\r\n\t\r\n\t\t\tfor ( var key in attributes ) {\r\n\t\r\n\t\t\t\tvar attribute = attributes[ key ];\r\n\t\t\t\tvar typedArray = new self[ attribute.type ]( attribute.array );\r\n\t\r\n\t\t\t\tgeometry.addAttribute( key, new THREE.BufferAttribute( typedArray, attribute.itemSize ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar offsets = json.data.offsets;\r\n\t\r\n\t\t\tif ( offsets !== undefined ) {\r\n\t\r\n\t\t\t\tgeometry.offsets = JSON.parse( JSON.stringify( offsets ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar boundingSphere = json.data.boundingSphere;\r\n\t\r\n\t\t\tif ( boundingSphere !== undefined ) {\r\n\t\r\n\t\t\t\tvar center = new THREE.Vector3();\r\n\t\r\n\t\t\t\tif ( boundingSphere.center !== undefined ) {\r\n\t\r\n\t\t\t\t\tcenter.fromArray( boundingSphere.center );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tgeometry.boundingSphere = new THREE.Sphere( center, boundingSphere.radius );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn geometry;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/loaders/MaterialLoader.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.MaterialLoader = function ( manager ) {\r\n\t\r\n\t\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MaterialLoader.prototype = {\r\n\t\r\n\t\tconstructor: THREE.MaterialLoader,\r\n\t\r\n\t\tload: function ( url, onLoad, onProgress, onError ) {\r\n\t\r\n\t\t\tvar scope = this;\r\n\t\r\n\t\t\tvar loader = new THREE.XHRLoader( scope.manager );\r\n\t\t\tloader.setCrossOrigin( this.crossOrigin );\r\n\t\t\tloader.load( url, function ( text ) {\r\n\t\r\n\t\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\r\n\t\r\n\t\t\t}, onProgress, onError );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetCrossOrigin: function ( value ) {\r\n\t\r\n\t\t\tthis.crossOrigin = value;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tparse: function ( json ) {\r\n\t\r\n\t\t\tvar material = new THREE[ json.type ];\r\n\t\r\n\t\t\tif ( json.color !== undefined ) material.color.setHex( json.color );\r\n\t\t\tif ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );\r\n\t\t\tif ( json.specular !== undefined ) material.specular.setHex( json.specular );\r\n\t\t\tif ( json.shininess !== undefined ) material.shininess = json.shininess;\r\n\t\t\tif ( json.uniforms !== undefined ) material.uniforms = json.uniforms;\r\n\t\t\tif ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;\r\n\t\t\tif ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;\r\n\t\t\tif ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;\r\n\t\t\tif ( json.shading !== undefined ) material.shading = json.shading;\r\n\t\t\tif ( json.blending !== undefined ) material.blending = json.blending;\r\n\t\t\tif ( json.side !== undefined ) material.side = json.side;\r\n\t\t\tif ( json.opacity !== undefined ) material.opacity = json.opacity;\r\n\t\t\tif ( json.transparent !== undefined ) material.transparent = json.transparent;\r\n\t\t\tif ( json.wireframe !== undefined ) material.wireframe = json.wireframe;\r\n\t\r\n\t\t\t// for PointCloudMaterial\r\n\t\t\tif ( json.size !== undefined ) material.size = json.size;\r\n\t\t\tif ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;\r\n\t\r\n\t\t\tif ( json.materials !== undefined ) {\r\n\t\r\n\t\t\t\tfor ( var i = 0, l = json.materials.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\tmaterial.materials.push( this.parse( json.materials[ i ] ) );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn material;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/loaders/ObjectLoader.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.ObjectLoader = function ( manager ) {\r\n\t\r\n\t\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\t\tthis.texturePath = '';\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.ObjectLoader.prototype = {\r\n\t\r\n\t\tconstructor: THREE.ObjectLoader,\r\n\t\r\n\t\tload: function ( url, onLoad, onProgress, onError ) {\r\n\t\r\n\t\t\tif ( this.texturePath === '' ) {\r\n\t\r\n\t\t\t\tthis.texturePath = url.substring( 0, url.lastIndexOf( '/' ) + 1 );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar scope = this;\r\n\t\r\n\t\t\tvar loader = new THREE.XHRLoader( scope.manager );\r\n\t\t\tloader.setCrossOrigin( this.crossOrigin );\r\n\t\t\tloader.load( url, function ( text ) {\r\n\t\r\n\t\t\t\tscope.parse( JSON.parse( text ), onLoad );\r\n\t\r\n\t\t\t}, onProgress, onError );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetTexturePath: function ( value ) {\r\n\t\r\n\t\t\tthis.texturePath = value;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetCrossOrigin: function ( value ) {\r\n\t\r\n\t\t\tthis.crossOrigin = value;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tparse: function ( json, onLoad ) {\r\n\t\r\n\t\t\tvar geometries = this.parseGeometries( json.geometries );\r\n\t\r\n\t\t\tvar images = this.parseImages( json.images, function () {\r\n\t\r\n\t\t\t\tif ( onLoad !== undefined ) onLoad( object );\r\n\t\r\n\t\t\t} );\r\n\t\t\tvar textures  = this.parseTextures( json.textures, images );\r\n\t\t\tvar materials = this.parseMaterials( json.materials, textures );\r\n\t\t\tvar object = this.parseObject( json.object, geometries, materials );\r\n\t\r\n\t\t\tif ( json.images === undefined || json.images.length === 0 ) {\r\n\t\r\n\t\t\t\tif ( onLoad !== undefined ) onLoad( object );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn object;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tparseGeometries: function ( json ) {\r\n\t\r\n\t\t\tvar geometries = {};\r\n\t\r\n\t\t\tif ( json !== undefined ) {\r\n\t\r\n\t\t\t\tvar geometryLoader = new THREE.JSONLoader();\r\n\t\t\t\tvar bufferGeometryLoader = new THREE.BufferGeometryLoader();\r\n\t\r\n\t\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\tvar geometry;\r\n\t\t\t\t\tvar data = json[ i ];\r\n\t\r\n\t\t\t\t\tswitch ( data.type ) {\r\n\t\r\n\t\t\t\t\t\tcase 'PlaneGeometry':\r\n\t\t\t\t\t\tcase 'PlaneBufferGeometry':\r\n\t\r\n\t\t\t\t\t\t\tgeometry = new THREE[ data.type ](\r\n\t\t\t\t\t\t\t\tdata.width,\r\n\t\t\t\t\t\t\t\tdata.height,\r\n\t\t\t\t\t\t\t\tdata.widthSegments,\r\n\t\t\t\t\t\t\t\tdata.heightSegments\r\n\t\t\t\t\t\t\t);\r\n\t\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\tcase 'BoxGeometry':\r\n\t\t\t\t\t\tcase 'CubeGeometry': // backwards compatible\r\n\t\r\n\t\t\t\t\t\t\tgeometry = new THREE.BoxGeometry(\r\n\t\t\t\t\t\t\t\tdata.width,\r\n\t\t\t\t\t\t\t\tdata.height,\r\n\t\t\t\t\t\t\t\tdata.depth,\r\n\t\t\t\t\t\t\t\tdata.widthSegments,\r\n\t\t\t\t\t\t\t\tdata.heightSegments,\r\n\t\t\t\t\t\t\t\tdata.depthSegments\r\n\t\t\t\t\t\t\t);\r\n\t\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\tcase 'CircleGeometry':\r\n\t\r\n\t\t\t\t\t\t\tgeometry = new THREE.CircleGeometry(\r\n\t\t\t\t\t\t\t\tdata.radius,\r\n\t\t\t\t\t\t\t\tdata.segments\r\n\t\t\t\t\t\t\t);\r\n\t\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\tcase 'CylinderGeometry':\r\n\t\r\n\t\t\t\t\t\t\tgeometry = new THREE.CylinderGeometry(\r\n\t\t\t\t\t\t\t\tdata.radiusTop,\r\n\t\t\t\t\t\t\t\tdata.radiusBottom,\r\n\t\t\t\t\t\t\t\tdata.height,\r\n\t\t\t\t\t\t\t\tdata.radialSegments,\r\n\t\t\t\t\t\t\t\tdata.heightSegments,\r\n\t\t\t\t\t\t\t\tdata.openEnded\r\n\t\t\t\t\t\t\t);\r\n\t\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\tcase 'SphereGeometry':\r\n\t\r\n\t\t\t\t\t\t\tgeometry = new THREE.SphereGeometry(\r\n\t\t\t\t\t\t\t\tdata.radius,\r\n\t\t\t\t\t\t\t\tdata.widthSegments,\r\n\t\t\t\t\t\t\t\tdata.heightSegments,\r\n\t\t\t\t\t\t\t\tdata.phiStart,\r\n\t\t\t\t\t\t\t\tdata.phiLength,\r\n\t\t\t\t\t\t\t\tdata.thetaStart,\r\n\t\t\t\t\t\t\t\tdata.thetaLength\r\n\t\t\t\t\t\t\t);\r\n\t\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\tcase 'IcosahedronGeometry':\r\n\t\r\n\t\t\t\t\t\t\tgeometry = new THREE.IcosahedronGeometry(\r\n\t\t\t\t\t\t\t\tdata.radius,\r\n\t\t\t\t\t\t\t\tdata.detail\r\n\t\t\t\t\t\t\t);\r\n\t\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\tcase 'TorusGeometry':\r\n\t\r\n\t\t\t\t\t\t\tgeometry = new THREE.TorusGeometry(\r\n\t\t\t\t\t\t\t\tdata.radius,\r\n\t\t\t\t\t\t\t\tdata.tube,\r\n\t\t\t\t\t\t\t\tdata.radialSegments,\r\n\t\t\t\t\t\t\t\tdata.tubularSegments,\r\n\t\t\t\t\t\t\t\tdata.arc\r\n\t\t\t\t\t\t\t);\r\n\t\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\tcase 'TorusKnotGeometry':\r\n\t\r\n\t\t\t\t\t\t\tgeometry = new THREE.TorusKnotGeometry(\r\n\t\t\t\t\t\t\t\tdata.radius,\r\n\t\t\t\t\t\t\t\tdata.tube,\r\n\t\t\t\t\t\t\t\tdata.radialSegments,\r\n\t\t\t\t\t\t\t\tdata.tubularSegments,\r\n\t\t\t\t\t\t\t\tdata.p,\r\n\t\t\t\t\t\t\t\tdata.q,\r\n\t\t\t\t\t\t\t\tdata.heightScale\r\n\t\t\t\t\t\t\t);\r\n\t\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\tcase 'BufferGeometry':\r\n\t\r\n\t\t\t\t\t\t\tgeometry = bufferGeometryLoader.parse( data );\r\n\t\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\tcase 'Geometry':\r\n\t\r\n\t\t\t\t\t\t\tgeometry = geometryLoader.parse( data.data ).geometry;\r\n\t\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tgeometry.uuid = data.uuid;\r\n\t\r\n\t\t\t\t\tif ( data.name !== undefined ) geometry.name = data.name;\r\n\t\r\n\t\t\t\t\tgeometries[ data.uuid ] = geometry;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn geometries;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tparseMaterials: function ( json, textures ) {\r\n\t\r\n\t\t\tvar materials = {};\r\n\t\r\n\t\t\tif ( json !== undefined ) {\r\n\t\r\n\t\t\t\tvar getTexture = function ( name ) {\r\n\t\r\n\t\t\t\t\tif ( textures[ name ] === undefined ) {\r\n\t\r\n\t\t\t\t\t\tTHREE.warn( 'THREE.ObjectLoader: Undefined texture', name );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\treturn textures[ name ];\r\n\t\r\n\t\t\t\t};\r\n\t\r\n\t\t\t\tvar loader = new THREE.MaterialLoader();\r\n\t\r\n\t\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\tvar data = json[ i ];\r\n\t\t\t\t\tvar material = loader.parse( data );\r\n\t\r\n\t\t\t\t\tmaterial.uuid = data.uuid;\r\n\t\r\n\t\t\t\t\tif ( data.name !== undefined ) material.name = data.name;\r\n\t\r\n\t\t\t\t\tif ( data.map !== undefined ) {\r\n\t\r\n\t\t\t\t\t\tmaterial.map = getTexture( data.map );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( data.bumpMap !== undefined ) {\r\n\t\r\n\t\t\t\t\t\tmaterial.bumpMap = getTexture( data.bumpMap );\r\n\t\t\t\t\t\tif ( data.bumpScale ) {\r\n\t\t\t\t\t\t\tmaterial.bumpScale = new THREE.Vector2( data.bumpScale, data.bumpScale );\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( data.alphaMap !== undefined ) {\r\n\t\r\n\t\t\t\t\t\tmaterial.alphaMap = getTexture( data.alphaMap );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( data.envMap !== undefined ) {\r\n\t\r\n\t\t\t\t\t\tmaterial.envMap = getTexture( data.envMap );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( data.normalMap !== undefined ) {\r\n\t\r\n\t\t\t\t\t\tmaterial.normalMap = getTexture( data.normalMap );\r\n\t\t\t\t\t\tif ( data.normalScale ) {\r\n\t\t\t\t\t\t\tmaterial.normalScale = new THREE.Vector2( data.normalScale, data.normalScale );\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( data.lightMap !== undefined ) {\r\n\t\r\n\t\t\t\t\t\tmaterial.lightMap = getTexture( data.lightMap );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( data.specularMap !== undefined ) {\r\n\t\r\n\t\t\t\t\t\tmaterial.specularMap = getTexture( data.specularMap );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tmaterials[ data.uuid ] = material;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn materials;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tparseImages: function ( json, onLoad ) {\r\n\t\r\n\t\t\tvar scope = this;\r\n\t\t\tvar images = {};\r\n\t\r\n\t\t\tif ( json !== undefined && json.length > 0 ) {\r\n\t\r\n\t\t\t\tvar manager = new THREE.LoadingManager( onLoad );\r\n\t\r\n\t\t\t\tvar loader = new THREE.ImageLoader( manager );\r\n\t\t\t\tloader.setCrossOrigin( this.crossOrigin );\r\n\t\r\n\t\t\t\tvar loadImage = function ( url ) {\r\n\t\r\n\t\t\t\t\tscope.manager.itemStart( url );\r\n\t\r\n\t\t\t\t\treturn loader.load( url, function () {\r\n\t\r\n\t\t\t\t\t\tscope.manager.itemEnd( url );\r\n\t\r\n\t\t\t\t\t} );\r\n\t\r\n\t\t\t\t};\r\n\t\r\n\t\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\tvar image = json[ i ];\r\n\t\t\t\t\tvar path = /^(\\/\\/)|([a-z]+:(\\/\\/)?)/i.test( image.url ) ? image.url : scope.texturePath + image.url;\r\n\t\r\n\t\t\t\t\timages[ image.uuid ] = loadImage( path );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn images;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tparseTextures: function ( json, images ) {\r\n\t\r\n\t\t\tvar textures = {};\r\n\t\r\n\t\t\tif ( json !== undefined ) {\r\n\t\r\n\t\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\tvar data = json[ i ];\r\n\t\r\n\t\t\t\t\tif ( data.image === undefined ) {\r\n\t\r\n\t\t\t\t\t\tTHREE.warn( 'THREE.ObjectLoader: No \"image\" speficied for', data.uuid );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( images[ data.image ] === undefined ) {\r\n\t\r\n\t\t\t\t\t\tTHREE.warn( 'THREE.ObjectLoader: Undefined image', data.image );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tvar texture = new THREE.Texture( images[ data.image ] );\r\n\t\t\t\t\ttexture.needsUpdate = true;\r\n\t\r\n\t\t\t\t\ttexture.uuid = data.uuid;\r\n\t\r\n\t\t\t\t\tif ( data.name !== undefined ) texture.name = data.name;\r\n\t\t\t\t\tif ( data.repeat !== undefined ) texture.repeat = new THREE.Vector2( data.repeat[ 0 ], data.repeat[ 1 ] );\r\n\t\t\t\t\tif ( data.minFilter !== undefined ) texture.minFilter = THREE[ data.minFilter ];\r\n\t\t\t\t\tif ( data.magFilter !== undefined ) texture.magFilter = THREE[ data.magFilter ];\r\n\t\t\t\t\tif ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;\r\n\t\t\t\t\tif ( data.wrap instanceof Array ) {\r\n\t\r\n\t\t\t\t\t\ttexture.wrapS = THREE[ data.wrap[ 0 ] ];\r\n\t\t\t\t\t\ttexture.wrapT = THREE[ data.wrap[ 1 ] ];\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\ttextures[ data.uuid ] = texture;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn textures;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tparseObject: function () {\r\n\t\r\n\t\t\tvar matrix = new THREE.Matrix4();\r\n\t\r\n\t\t\treturn function ( data, geometries, materials ) {\r\n\t\r\n\t\t\t\tvar object;\r\n\t\r\n\t\t\t\tvar getGeometry = function ( name ) {\r\n\t\r\n\t\t\t\t\tif ( geometries[ name ] === undefined ) {\r\n\t\r\n\t\t\t\t\t\tTHREE.warn( 'THREE.ObjectLoader: Undefined geometry', name );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\treturn geometries[ name ];\r\n\t\r\n\t\t\t\t};\r\n\t\r\n\t\t\t\tvar getMaterial = function ( name ) {\r\n\t\r\n\t\t\t\t\tif ( materials[ name ] === undefined ) {\r\n\t\r\n\t\t\t\t\t\tTHREE.warn( 'THREE.ObjectLoader: Undefined material', name );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\treturn materials[ name ];\r\n\t\r\n\t\t\t\t};\r\n\t\r\n\t\t\t\tswitch ( data.type ) {\r\n\t\r\n\t\t\t\t\tcase 'Scene':\r\n\t\r\n\t\t\t\t\t\tobject = new THREE.Scene();\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'PerspectiveCamera':\r\n\t\r\n\t\t\t\t\t\tobject = new THREE.PerspectiveCamera( data.fov, data.aspect, data.near, data.far );\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'OrthographicCamera':\r\n\t\r\n\t\t\t\t\t\tobject = new THREE.OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'AmbientLight':\r\n\t\r\n\t\t\t\t\t\tobject = new THREE.AmbientLight( data.color );\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'DirectionalLight':\r\n\t\r\n\t\t\t\t\t\tobject = new THREE.DirectionalLight( data.color, data.intensity );\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'PointLight':\r\n\t\r\n\t\t\t\t\t\tobject = new THREE.PointLight( data.color, data.intensity, data.distance, data.decay );\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'SpotLight':\r\n\t\r\n\t\t\t\t\t\tobject = new THREE.SpotLight( data.color, data.intensity, data.distance, data.angle, data.exponent, data.decay );\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'HemisphereLight':\r\n\t\r\n\t\t\t\t\t\tobject = new THREE.HemisphereLight( data.color, data.groundColor, data.intensity );\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'Mesh':\r\n\t\r\n\t\t\t\t\t\tobject = new THREE.Mesh( getGeometry( data.geometry ), getMaterial( data.material ) );\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'Line':\r\n\t\r\n\t\t\t\t\t\tobject = new THREE.Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'PointCloud':\r\n\t\r\n\t\t\t\t\t\tobject = new THREE.PointCloud( getGeometry( data.geometry ), getMaterial( data.material ) );\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'Sprite':\r\n\t\r\n\t\t\t\t\t\tobject = new THREE.Sprite( getMaterial( data.material ) );\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'Group':\r\n\t\r\n\t\t\t\t\t\tobject = new THREE.Group();\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tdefault:\r\n\t\r\n\t\t\t\t\t\tobject = new THREE.Object3D();\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tobject.uuid = data.uuid;\r\n\t\r\n\t\t\t\tif ( data.name !== undefined ) object.name = data.name;\r\n\t\t\t\tif ( data.matrix !== undefined ) {\r\n\t\r\n\t\t\t\t\tmatrix.fromArray( data.matrix );\r\n\t\t\t\t\tmatrix.decompose( object.position, object.quaternion, object.scale );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tif ( data.position !== undefined ) object.position.fromArray( data.position );\r\n\t\t\t\t\tif ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );\r\n\t\t\t\t\tif ( data.scale !== undefined ) object.scale.fromArray( data.scale );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( data.visible !== undefined ) object.visible = data.visible;\r\n\t\t\t\tif ( data.userData !== undefined ) object.userData = data.userData;\r\n\t\r\n\t\t\t\tif ( data.children !== undefined ) {\r\n\t\r\n\t\t\t\t\tfor ( var child in data.children ) {\r\n\t\r\n\t\t\t\t\t\tobject.add( this.parseObject( data.children[ child ], geometries, materials ) );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn object;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}()\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/loaders/TextureLoader.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.TextureLoader = function ( manager ) {\r\n\t\r\n\t\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.TextureLoader.prototype = {\r\n\t\r\n\t\tconstructor: THREE.TextureLoader,\r\n\t\r\n\t\tload: function ( url, onLoad, onProgress, onError ) {\r\n\t\r\n\t\t\tvar scope = this;\r\n\t\r\n\t\t\tvar loader = new THREE.ImageLoader( scope.manager );\r\n\t\t\tloader.setCrossOrigin( this.crossOrigin );\r\n\t\t\tloader.load( url, function ( image ) {\r\n\t\r\n\t\t\t\tvar texture = new THREE.Texture( image );\r\n\t\t\t\ttexture.needsUpdate = true;\r\n\t\r\n\t\t\t\tif ( onLoad !== undefined ) {\r\n\t\r\n\t\t\t\t\tonLoad( texture );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}, onProgress, onError );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetCrossOrigin: function ( value ) {\r\n\t\r\n\t\t\tthis.crossOrigin = value;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/loaders/BinaryTextureLoader.js\r\n\t\r\n\t/**\r\n\t * @author Nikos M. / https://github.com/foo123/\r\n\t *\r\n\t * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)\r\n\t */\r\n\t\r\n\tTHREE.DataTextureLoader = THREE.BinaryTextureLoader = function () {\r\n\t\r\n\t\t// override in sub classes\r\n\t\tthis._parser = null;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.BinaryTextureLoader.prototype = {\r\n\t\r\n\t\tconstructor: THREE.BinaryTextureLoader,\r\n\t\r\n\t\tload: function ( url, onLoad, onProgress, onError ) {\r\n\t\r\n\t\t\tvar scope = this;\r\n\t\r\n\t\t\tvar texture = new THREE.DataTexture( );\r\n\t\r\n\t\t\tvar loader = new THREE.XHRLoader();\r\n\t\t\tloader.setResponseType( 'arraybuffer' );\r\n\t\r\n\t\t\tloader.load( url, function ( buffer ) {\r\n\t\r\n\t\t\t\tvar texData = scope._parser( buffer );\r\n\t\r\n\t\t\t\tif ( !texData ) return;\r\n\t\r\n\t\t\t\tif ( undefined !== texData.image ) {\r\n\t\r\n\t\t\t\t\ttexture.image = texData.image;\r\n\t\r\n\t\t\t\t} else if ( undefined !== texData.data ) {\r\n\t\r\n\t\t\t\t\ttexture.image.width = texData.width;\r\n\t\t\t\t\ttexture.image.height = texData.height;\r\n\t\t\t\t\ttexture.image.data = texData.data;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\ttexture.wrapS = undefined !== texData.wrapS ? texData.wrapS : THREE.ClampToEdgeWrapping;\r\n\t\t\t\ttexture.wrapT = undefined !== texData.wrapT ? texData.wrapT : THREE.ClampToEdgeWrapping;\r\n\t\r\n\t\t\t\ttexture.magFilter = undefined !== texData.magFilter ? texData.magFilter : THREE.LinearFilter;\r\n\t\t\t\ttexture.minFilter = undefined !== texData.minFilter ? texData.minFilter : THREE.LinearMipMapLinearFilter;\r\n\t\r\n\t\t\t\ttexture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;\r\n\t\r\n\t\t\t\tif ( undefined !== texData.format ) {\r\n\t\r\n\t\t\t\t\ttexture.format = texData.format;\r\n\t\r\n\t\t\t\t}\r\n\t\t\t\tif ( undefined !== texData.type ) {\r\n\t\r\n\t\t\t\t\ttexture.type = texData.type;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( undefined !== texData.mipmaps ) {\r\n\t\r\n\t\t\t\t\ttexture.mipmaps = texData.mipmaps;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( 1 === texData.mipmapCount ) {\r\n\t\r\n\t\t\t\t\ttexture.minFilter = THREE.LinearFilter;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\ttexture.needsUpdate = true;\r\n\t\r\n\t\t\t\tif ( onLoad ) onLoad( texture, texData );\r\n\t\r\n\t\t\t}, onProgress, onError );\r\n\t\r\n\t\r\n\t\t\treturn texture;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/loaders/CompressedTextureLoader.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t *\r\n\t * Abstract Base class to block based textures loader (dds, pvr, ...)\r\n\t */\r\n\t\r\n\tTHREE.CompressedTextureLoader = function () {\r\n\t\r\n\t\t// override in sub classes\r\n\t\tthis._parser = null;\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\tTHREE.CompressedTextureLoader.prototype = {\r\n\t\r\n\t\tconstructor: THREE.CompressedTextureLoader,\r\n\t\r\n\t\tload: function ( url, onLoad, onError ) {\r\n\t\r\n\t\t\tvar scope = this;\r\n\t\r\n\t\t\tvar images = [];\r\n\t\r\n\t\t\tvar texture = new THREE.CompressedTexture();\r\n\t\t\ttexture.image = images;\r\n\t\r\n\t\t\tvar loader = new THREE.XHRLoader();\r\n\t\t\tloader.setResponseType( 'arraybuffer' );\r\n\t\r\n\t\t\tif ( url instanceof Array ) {\r\n\t\r\n\t\t\t\tvar loaded = 0;\r\n\t\r\n\t\t\t\tvar loadTexture = function ( i ) {\r\n\t\r\n\t\t\t\t\tloader.load( url[ i ], function ( buffer ) {\r\n\t\r\n\t\t\t\t\t\tvar texDatas = scope._parser( buffer, true );\r\n\t\r\n\t\t\t\t\t\timages[ i ] = {\r\n\t\t\t\t\t\t\twidth: texDatas.width,\r\n\t\t\t\t\t\t\theight: texDatas.height,\r\n\t\t\t\t\t\t\tformat: texDatas.format,\r\n\t\t\t\t\t\t\tmipmaps: texDatas.mipmaps\r\n\t\t\t\t\t\t};\r\n\t\r\n\t\t\t\t\t\tloaded += 1;\r\n\t\r\n\t\t\t\t\t\tif ( loaded === 6 ) {\r\n\t\r\n\t\t\t\t\t\t\tif (texDatas.mipmapCount == 1)\r\n\t \t\t\t\t\t\t\ttexture.minFilter = THREE.LinearFilter;\r\n\t\r\n\t\t\t\t\t\t\ttexture.format = texDatas.format;\r\n\t\t\t\t\t\t\ttexture.needsUpdate = true;\r\n\t\r\n\t\t\t\t\t\t\tif ( onLoad ) onLoad( texture );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t} );\r\n\t\r\n\t\t\t\t};\r\n\t\r\n\t\t\t\tfor ( var i = 0, il = url.length; i < il; ++ i ) {\r\n\t\r\n\t\t\t\t\tloadTexture( i );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\t// compressed cubemap texture stored in a single DDS file\r\n\t\r\n\t\t\t\tloader.load( url, function ( buffer ) {\r\n\t\r\n\t\t\t\t\tvar texDatas = scope._parser( buffer, true );\r\n\t\r\n\t\t\t\t\tif ( texDatas.isCubemap ) {\r\n\t\r\n\t\t\t\t\t\tvar faces = texDatas.mipmaps.length / texDatas.mipmapCount;\r\n\t\r\n\t\t\t\t\t\tfor ( var f = 0; f < faces; f ++ ) {\r\n\t\r\n\t\t\t\t\t\t\timages[ f ] = { mipmaps : [] };\r\n\t\r\n\t\t\t\t\t\t\tfor ( var i = 0; i < texDatas.mipmapCount; i ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\timages[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );\r\n\t\t\t\t\t\t\t\timages[ f ].format = texDatas.format;\r\n\t\t\t\t\t\t\t\timages[ f ].width = texDatas.width;\r\n\t\t\t\t\t\t\t\timages[ f ].height = texDatas.height;\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\ttexture.image.width = texDatas.width;\r\n\t\t\t\t\t\ttexture.image.height = texDatas.height;\r\n\t\t\t\t\t\ttexture.mipmaps = texDatas.mipmaps;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( texDatas.mipmapCount === 1 ) {\r\n\t\r\n\t\t\t\t\t\ttexture.minFilter = THREE.LinearFilter;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\ttexture.format = texDatas.format;\r\n\t\t\t\t\ttexture.needsUpdate = true;\r\n\t\r\n\t\t\t\t\tif ( onLoad ) onLoad( texture );\r\n\t\r\n\t\t\t\t} );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn texture;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/materials/Material.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.Material = function () {\r\n\t\r\n\t\tObject.defineProperty( this, 'id', { value: THREE.MaterialIdCount ++ } );\r\n\t\r\n\t\tthis.uuid = THREE.Math.generateUUID();\r\n\t\r\n\t\tthis.name = '';\r\n\t\tthis.type = 'Material';\r\n\t\r\n\t\tthis.side = THREE.FrontSide;\r\n\t\r\n\t\tthis.opacity = 1;\r\n\t\tthis.transparent = false;\r\n\t\r\n\t\tthis.blending = THREE.NormalBlending;\r\n\t\r\n\t\tthis.blendSrc = THREE.SrcAlphaFactor;\r\n\t\tthis.blendDst = THREE.OneMinusSrcAlphaFactor;\r\n\t\tthis.blendEquation = THREE.AddEquation;\r\n\t\tthis.blendSrcAlpha = null;\r\n\t\tthis.blendDstAlpha = null;\r\n\t\tthis.blendEquationAlpha = null;\r\n\t\r\n\t\tthis.depthTest = true;\r\n\t\tthis.depthWrite = true;\r\n\t\r\n\t\tthis.colorWrite = true;\r\n\t\r\n\t\tthis.polygonOffset = false;\r\n\t\tthis.polygonOffsetFactor = 0;\r\n\t\tthis.polygonOffsetUnits = 0;\r\n\t\r\n\t\tthis.alphaTest = 0;\r\n\t\r\n\t\tthis.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer\r\n\t\r\n\t\tthis.visible = true;\r\n\t\r\n\t\tthis._needsUpdate = true;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Material.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Material,\r\n\t\r\n\t\tget needsUpdate () {\r\n\t\r\n\t\t\treturn this._needsUpdate;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tset needsUpdate ( value ) {\r\n\t\r\n\t\t\tif ( value === true ) this.update();\r\n\t\r\n\t\t\tthis._needsUpdate = value;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetValues: function ( values ) {\r\n\t\r\n\t\t\tif ( values === undefined ) return;\r\n\t\r\n\t\t\tfor ( var key in values ) {\r\n\t\r\n\t\t\t\tvar newValue = values[ key ];\r\n\t\r\n\t\t\t\tif ( newValue === undefined ) {\r\n\t\r\n\t\t\t\t\tTHREE.warn( \"THREE.Material: '\" + key + \"' parameter is undefined.\" );\r\n\t\t\t\t\tcontinue;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( key in this ) {\r\n\t\r\n\t\t\t\t\tvar currentValue = this[ key ];\r\n\t\r\n\t\t\t\t\tif ( currentValue instanceof THREE.Color ) {\r\n\t\r\n\t\t\t\t\t\tcurrentValue.set( newValue );\r\n\t\r\n\t\t\t\t\t} else if ( currentValue instanceof THREE.Vector3 && newValue instanceof THREE.Vector3 ) {\r\n\t\r\n\t\t\t\t\t\tcurrentValue.copy( newValue );\r\n\t\r\n\t\t\t\t\t} else if ( key == 'overdraw' ) {\r\n\t\r\n\t\t\t\t\t\t// ensure overdraw is backwards-compatable with legacy boolean type\r\n\t\t\t\t\t\tthis[ key ] = Number( newValue );\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tthis[ key ] = newValue;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttoJSON: function () {\r\n\t\r\n\t\t\tvar output = {\r\n\t\t\t\tmetadata: {\r\n\t\t\t\t\tversion: 4.2,\r\n\t\t\t\t\ttype: 'material',\r\n\t\t\t\t\tgenerator: 'MaterialExporter'\r\n\t\t\t\t},\r\n\t\t\t\tuuid: this.uuid,\r\n\t\t\t\ttype: this.type\r\n\t\t\t};\r\n\t\r\n\t\t\tif ( this.name !== \"\" ) output.name = this.name;\r\n\t\r\n\t\t\tif ( this instanceof THREE.MeshBasicMaterial ) {\r\n\t\r\n\t\t\t\toutput.color = this.color.getHex();\r\n\t\t\t\tif ( this.vertexColors !== THREE.NoColors ) output.vertexColors = this.vertexColors;\r\n\t\t\t\tif ( this.blending !== THREE.NormalBlending ) output.blending = this.blending;\r\n\t\t\t\tif ( this.side !== THREE.FrontSide ) output.side = this.side;\r\n\t\r\n\t\t\t} else if ( this instanceof THREE.MeshLambertMaterial ) {\r\n\t\r\n\t\t\t\toutput.color = this.color.getHex();\r\n\t\t\t\toutput.emissive = this.emissive.getHex();\r\n\t\t\t\tif ( this.vertexColors !== THREE.NoColors ) output.vertexColors = this.vertexColors;\r\n\t\t\t\tif ( this.shading !== THREE.SmoothShading ) output.shading = this.shading;\r\n\t\t\t\tif ( this.blending !== THREE.NormalBlending ) output.blending = this.blending;\r\n\t\t\t\tif ( this.side !== THREE.FrontSide ) output.side = this.side;\r\n\t\r\n\t\t\t} else if ( this instanceof THREE.MeshPhongMaterial ) {\r\n\t\r\n\t\t\t\toutput.color = this.color.getHex();\r\n\t\t\t\toutput.emissive = this.emissive.getHex();\r\n\t\t\t\toutput.specular = this.specular.getHex();\r\n\t\t\t\toutput.shininess = this.shininess;\r\n\t\t\t\tif ( this.vertexColors !== THREE.NoColors ) output.vertexColors = this.vertexColors;\r\n\t\t\t\tif ( this.shading !== THREE.SmoothShading ) output.shading = this.shading;\r\n\t\t\t\tif ( this.blending !== THREE.NormalBlending ) output.blending = this.blending;\r\n\t\t\t\tif ( this.side !== THREE.FrontSide ) output.side = this.side;\r\n\t\r\n\t\t\t} else if ( this instanceof THREE.MeshNormalMaterial ) {\r\n\t\r\n\t\t\t\tif ( this.blending !== THREE.NormalBlending ) output.blending = this.blending;\r\n\t\t\t\tif ( this.side !== THREE.FrontSide ) output.side = this.side;\r\n\t\r\n\t\t\t} else if ( this instanceof THREE.MeshDepthMaterial ) {\r\n\t\r\n\t\t\t\tif ( this.blending !== THREE.NormalBlending ) output.blending = this.blending;\r\n\t\t\t\tif ( this.side !== THREE.FrontSide ) output.side = this.side;\r\n\t\r\n\t\t\t} else if ( this instanceof THREE.PointCloudMaterial ) {\r\n\t\r\n\t\t\t\toutput.size  = this.size;\r\n\t\t\t\toutput.sizeAttenuation = this.sizeAttenuation;\r\n\t\t\t\toutput.color = this.color.getHex();\r\n\t\r\n\t\t\t\tif ( this.vertexColors !== THREE.NoColors ) output.vertexColors = this.vertexColors;\r\n\t\t\t\tif ( this.blending !== THREE.NormalBlending ) output.blending = this.blending;\r\n\t\r\n\t\t\t} else if ( this instanceof THREE.ShaderMaterial ) {\r\n\t\r\n\t\t\t\toutput.uniforms = this.uniforms;\r\n\t\t\t\toutput.vertexShader = this.vertexShader;\r\n\t\t\t\toutput.fragmentShader = this.fragmentShader;\r\n\t\r\n\t\t\t} else if ( this instanceof THREE.SpriteMaterial ) {\r\n\t\r\n\t\t\t\toutput.color = this.color.getHex();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( this.opacity < 1 ) output.opacity = this.opacity;\r\n\t\t\tif ( this.transparent !== false ) output.transparent = this.transparent;\r\n\t\t\tif ( this.wireframe !== false ) output.wireframe = this.wireframe;\r\n\t\r\n\t\t\treturn output;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function ( material ) {\r\n\t\r\n\t\t\tif ( material === undefined ) material = new THREE.Material();\r\n\t\r\n\t\t\tmaterial.name = this.name;\r\n\t\r\n\t\t\tmaterial.side = this.side;\r\n\t\r\n\t\t\tmaterial.opacity = this.opacity;\r\n\t\t\tmaterial.transparent = this.transparent;\r\n\t\r\n\t\t\tmaterial.blending = this.blending;\r\n\t\r\n\t\t\tmaterial.blendSrc = this.blendSrc;\r\n\t\t\tmaterial.blendDst = this.blendDst;\r\n\t\t\tmaterial.blendEquation = this.blendEquation;\r\n\t\t\tmaterial.blendSrcAlpha = this.blendSrcAlpha;\r\n\t\t\tmaterial.blendDstAlpha = this.blendDstAlpha;\r\n\t\t\tmaterial.blendEquationAlpha = this.blendEquationAlpha;\r\n\t\r\n\t\t\tmaterial.depthTest = this.depthTest;\r\n\t\t\tmaterial.depthWrite = this.depthWrite;\r\n\t\r\n\t\t\tmaterial.polygonOffset = this.polygonOffset;\r\n\t\t\tmaterial.polygonOffsetFactor = this.polygonOffsetFactor;\r\n\t\t\tmaterial.polygonOffsetUnits = this.polygonOffsetUnits;\r\n\t\r\n\t\t\tmaterial.alphaTest = this.alphaTest;\r\n\t\r\n\t\t\tmaterial.overdraw = this.overdraw;\r\n\t\r\n\t\t\tmaterial.visible = this.visible;\r\n\t\r\n\t\t\treturn material;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tupdate: function () {\r\n\t\r\n\t\t\tthis.dispatchEvent( { type: 'update' } );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdispose: function () {\r\n\t\r\n\t\t\tthis.dispatchEvent( { type: 'dispose' } );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.EventDispatcher.prototype.apply( THREE.Material.prototype );\r\n\t\r\n\tTHREE.MaterialIdCount = 0;\r\n\t\r\n\t// File:src/materials/LineBasicMaterial.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t *\r\n\t * parameters = {\r\n\t *  color: <hex>,\r\n\t *  opacity: <float>,\r\n\t *\r\n\t *  blending: THREE.NormalBlending,\r\n\t *  depthTest: <bool>,\r\n\t *  depthWrite: <bool>,\r\n\t *\r\n\t *  linewidth: <float>,\r\n\t *  linecap: \"round\",\r\n\t *  linejoin: \"round\",\r\n\t *\r\n\t *  vertexColors: <bool>\r\n\t *\r\n\t *  fog: <bool>\r\n\t * }\r\n\t */\r\n\t\r\n\tTHREE.LineBasicMaterial = function ( parameters ) {\r\n\t\r\n\t\tTHREE.Material.call( this );\r\n\t\r\n\t\tthis.type = 'LineBasicMaterial';\r\n\t\r\n\t\tthis.color = new THREE.Color( 0xffffff );\r\n\t\r\n\t\tthis.linewidth = 1;\r\n\t\tthis.linecap = 'round';\r\n\t\tthis.linejoin = 'round';\r\n\t\r\n\t\tthis.vertexColors = THREE.NoColors;\r\n\t\r\n\t\tthis.fog = true;\r\n\t\r\n\t\tthis.setValues( parameters );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.LineBasicMaterial.prototype = Object.create( THREE.Material.prototype );\r\n\tTHREE.LineBasicMaterial.prototype.constructor = THREE.LineBasicMaterial;\r\n\t\r\n\tTHREE.LineBasicMaterial.prototype.clone = function () {\r\n\t\r\n\t\tvar material = new THREE.LineBasicMaterial();\r\n\t\r\n\t\tTHREE.Material.prototype.clone.call( this, material );\r\n\t\r\n\t\tmaterial.color.copy( this.color );\r\n\t\r\n\t\tmaterial.linewidth = this.linewidth;\r\n\t\tmaterial.linecap = this.linecap;\r\n\t\tmaterial.linejoin = this.linejoin;\r\n\t\r\n\t\tmaterial.vertexColors = this.vertexColors;\r\n\t\r\n\t\tmaterial.fog = this.fog;\r\n\t\r\n\t\treturn material;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/materials/LineDashedMaterial.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t *\r\n\t * parameters = {\r\n\t *  color: <hex>,\r\n\t *  opacity: <float>,\r\n\t *\r\n\t *  blending: THREE.NormalBlending,\r\n\t *  depthTest: <bool>,\r\n\t *  depthWrite: <bool>,\r\n\t *\r\n\t *  linewidth: <float>,\r\n\t *\r\n\t *  scale: <float>,\r\n\t *  dashSize: <float>,\r\n\t *  gapSize: <float>,\r\n\t *\r\n\t *  vertexColors: <bool>\r\n\t *\r\n\t *  fog: <bool>\r\n\t * }\r\n\t */\r\n\t\r\n\tTHREE.LineDashedMaterial = function ( parameters ) {\r\n\t\r\n\t\tTHREE.Material.call( this );\r\n\t\r\n\t\tthis.type = 'LineDashedMaterial';\r\n\t\r\n\t\tthis.color = new THREE.Color( 0xffffff );\r\n\t\r\n\t\tthis.linewidth = 1;\r\n\t\r\n\t\tthis.scale = 1;\r\n\t\tthis.dashSize = 3;\r\n\t\tthis.gapSize = 1;\r\n\t\r\n\t\tthis.vertexColors = false;\r\n\t\r\n\t\tthis.fog = true;\r\n\t\r\n\t\tthis.setValues( parameters );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.LineDashedMaterial.prototype = Object.create( THREE.Material.prototype );\r\n\tTHREE.LineDashedMaterial.prototype.constructor = THREE.LineDashedMaterial;\r\n\t\r\n\tTHREE.LineDashedMaterial.prototype.clone = function () {\r\n\t\r\n\t\tvar material = new THREE.LineDashedMaterial();\r\n\t\r\n\t\tTHREE.Material.prototype.clone.call( this, material );\r\n\t\r\n\t\tmaterial.color.copy( this.color );\r\n\t\r\n\t\tmaterial.linewidth = this.linewidth;\r\n\t\r\n\t\tmaterial.scale = this.scale;\r\n\t\tmaterial.dashSize = this.dashSize;\r\n\t\tmaterial.gapSize = this.gapSize;\r\n\t\r\n\t\tmaterial.vertexColors = this.vertexColors;\r\n\t\r\n\t\tmaterial.fog = this.fog;\r\n\t\r\n\t\treturn material;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/materials/MeshBasicMaterial.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t *\r\n\t * parameters = {\r\n\t *  color: <hex>,\r\n\t *  opacity: <float>,\r\n\t *  map: new THREE.Texture( <Image> ),\r\n\t *\r\n\t *  lightMap: new THREE.Texture( <Image> ),\r\n\t *\r\n\t *  specularMap: new THREE.Texture( <Image> ),\r\n\t *\r\n\t *  alphaMap: new THREE.Texture( <Image> ),\r\n\t *\r\n\t *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\r\n\t *  combine: THREE.Multiply,\r\n\t *  reflectivity: <float>,\r\n\t *  refractionRatio: <float>,\r\n\t *\r\n\t *  shading: THREE.SmoothShading,\r\n\t *  blending: THREE.NormalBlending,\r\n\t *  depthTest: <bool>,\r\n\t *  depthWrite: <bool>,\r\n\t *\r\n\t *  wireframe: <boolean>,\r\n\t *  wireframeLinewidth: <float>,\r\n\t *\r\n\t *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,\r\n\t *\r\n\t *  skinning: <bool>,\r\n\t *  morphTargets: <bool>,\r\n\t *\r\n\t *  fog: <bool>\r\n\t * }\r\n\t */\r\n\t\r\n\tTHREE.MeshBasicMaterial = function ( parameters ) {\r\n\t\r\n\t\tTHREE.Material.call( this );\r\n\t\r\n\t\tthis.type = 'MeshBasicMaterial';\r\n\t\r\n\t\tthis.color = new THREE.Color( 0xffffff ); // emissive\r\n\t\r\n\t\tthis.map = null;\r\n\t\r\n\t\tthis.lightMap = null;\r\n\t\r\n\t\tthis.specularMap = null;\r\n\t\r\n\t\tthis.alphaMap = null;\r\n\t\r\n\t\tthis.envMap = null;\r\n\t\tthis.combine = THREE.MultiplyOperation;\r\n\t\tthis.reflectivity = 1;\r\n\t\tthis.refractionRatio = 0.98;\r\n\t\r\n\t\tthis.fog = true;\r\n\t\r\n\t\tthis.shading = THREE.SmoothShading;\r\n\t\r\n\t\tthis.wireframe = false;\r\n\t\tthis.wireframeLinewidth = 1;\r\n\t\tthis.wireframeLinecap = 'round';\r\n\t\tthis.wireframeLinejoin = 'round';\r\n\t\r\n\t\tthis.vertexColors = THREE.NoColors;\r\n\t\r\n\t\tthis.skinning = false;\r\n\t\tthis.morphTargets = false;\r\n\t\r\n\t\tthis.setValues( parameters );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MeshBasicMaterial.prototype = Object.create( THREE.Material.prototype );\r\n\tTHREE.MeshBasicMaterial.prototype.constructor = THREE.MeshBasicMaterial;\r\n\t\r\n\tTHREE.MeshBasicMaterial.prototype.clone = function () {\r\n\t\r\n\t\tvar material = new THREE.MeshBasicMaterial();\r\n\t\r\n\t\tTHREE.Material.prototype.clone.call( this, material );\r\n\t\r\n\t\tmaterial.color.copy( this.color );\r\n\t\r\n\t\tmaterial.map = this.map;\r\n\t\r\n\t\tmaterial.lightMap = this.lightMap;\r\n\t\r\n\t\tmaterial.specularMap = this.specularMap;\r\n\t\r\n\t\tmaterial.alphaMap = this.alphaMap;\r\n\t\r\n\t\tmaterial.envMap = this.envMap;\r\n\t\tmaterial.combine = this.combine;\r\n\t\tmaterial.reflectivity = this.reflectivity;\r\n\t\tmaterial.refractionRatio = this.refractionRatio;\r\n\t\r\n\t\tmaterial.fog = this.fog;\r\n\t\r\n\t\tmaterial.shading = this.shading;\r\n\t\r\n\t\tmaterial.wireframe = this.wireframe;\r\n\t\tmaterial.wireframeLinewidth = this.wireframeLinewidth;\r\n\t\tmaterial.wireframeLinecap = this.wireframeLinecap;\r\n\t\tmaterial.wireframeLinejoin = this.wireframeLinejoin;\r\n\t\r\n\t\tmaterial.vertexColors = this.vertexColors;\r\n\t\r\n\t\tmaterial.skinning = this.skinning;\r\n\t\tmaterial.morphTargets = this.morphTargets;\r\n\t\r\n\t\treturn material;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/materials/MeshLambertMaterial.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t *\r\n\t * parameters = {\r\n\t *  color: <hex>,\r\n\t *  emissive: <hex>,\r\n\t *  opacity: <float>,\r\n\t *\r\n\t *  map: new THREE.Texture( <Image> ),\r\n\t *\r\n\t *  lightMap: new THREE.Texture( <Image> ),\r\n\t *\r\n\t *  specularMap: new THREE.Texture( <Image> ),\r\n\t *\r\n\t *  alphaMap: new THREE.Texture( <Image> ),\r\n\t *\r\n\t *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\r\n\t *  combine: THREE.Multiply,\r\n\t *  reflectivity: <float>,\r\n\t *  refractionRatio: <float>,\r\n\t *\r\n\t *  shading: THREE.SmoothShading,\r\n\t *  blending: THREE.NormalBlending,\r\n\t *  depthTest: <bool>,\r\n\t *  depthWrite: <bool>,\r\n\t *\r\n\t *  wireframe: <boolean>,\r\n\t *  wireframeLinewidth: <float>,\r\n\t *\r\n\t *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,\r\n\t *\r\n\t *  skinning: <bool>,\r\n\t *  morphTargets: <bool>,\r\n\t *  morphNormals: <bool>,\r\n\t *\r\n\t *\tfog: <bool>\r\n\t * }\r\n\t */\r\n\t\r\n\tTHREE.MeshLambertMaterial = function ( parameters ) {\r\n\t\r\n\t\tTHREE.Material.call( this );\r\n\t\r\n\t\tthis.type = 'MeshLambertMaterial';\r\n\t\r\n\t\tthis.color = new THREE.Color( 0xffffff ); // diffuse\r\n\t\tthis.emissive = new THREE.Color( 0x000000 );\r\n\t\r\n\t\tthis.wrapAround = false;\r\n\t\tthis.wrapRGB = new THREE.Vector3( 1, 1, 1 );\r\n\t\r\n\t\tthis.map = null;\r\n\t\r\n\t\tthis.lightMap = null;\r\n\t\r\n\t\tthis.specularMap = null;\r\n\t\r\n\t\tthis.alphaMap = null;\r\n\t\r\n\t\tthis.envMap = null;\r\n\t\tthis.combine = THREE.MultiplyOperation;\r\n\t\tthis.reflectivity = 1;\r\n\t\tthis.refractionRatio = 0.98;\r\n\t\r\n\t\tthis.fog = true;\r\n\t\r\n\t\tthis.shading = THREE.SmoothShading;\r\n\t\r\n\t\tthis.wireframe = false;\r\n\t\tthis.wireframeLinewidth = 1;\r\n\t\tthis.wireframeLinecap = 'round';\r\n\t\tthis.wireframeLinejoin = 'round';\r\n\t\r\n\t\tthis.vertexColors = THREE.NoColors;\r\n\t\r\n\t\tthis.skinning = false;\r\n\t\tthis.morphTargets = false;\r\n\t\tthis.morphNormals = false;\r\n\t\r\n\t\tthis.setValues( parameters );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MeshLambertMaterial.prototype = Object.create( THREE.Material.prototype );\r\n\tTHREE.MeshLambertMaterial.prototype.constructor = THREE.MeshLambertMaterial;\r\n\t\r\n\tTHREE.MeshLambertMaterial.prototype.clone = function () {\r\n\t\r\n\t\tvar material = new THREE.MeshLambertMaterial();\r\n\t\r\n\t\tTHREE.Material.prototype.clone.call( this, material );\r\n\t\r\n\t\tmaterial.color.copy( this.color );\r\n\t\tmaterial.emissive.copy( this.emissive );\r\n\t\r\n\t\tmaterial.wrapAround = this.wrapAround;\r\n\t\tmaterial.wrapRGB.copy( this.wrapRGB );\r\n\t\r\n\t\tmaterial.map = this.map;\r\n\t\r\n\t\tmaterial.lightMap = this.lightMap;\r\n\t\r\n\t\tmaterial.specularMap = this.specularMap;\r\n\t\r\n\t\tmaterial.alphaMap = this.alphaMap;\r\n\t\r\n\t\tmaterial.envMap = this.envMap;\r\n\t\tmaterial.combine = this.combine;\r\n\t\tmaterial.reflectivity = this.reflectivity;\r\n\t\tmaterial.refractionRatio = this.refractionRatio;\r\n\t\r\n\t\tmaterial.fog = this.fog;\r\n\t\r\n\t\tmaterial.shading = this.shading;\r\n\t\r\n\t\tmaterial.wireframe = this.wireframe;\r\n\t\tmaterial.wireframeLinewidth = this.wireframeLinewidth;\r\n\t\tmaterial.wireframeLinecap = this.wireframeLinecap;\r\n\t\tmaterial.wireframeLinejoin = this.wireframeLinejoin;\r\n\t\r\n\t\tmaterial.vertexColors = this.vertexColors;\r\n\t\r\n\t\tmaterial.skinning = this.skinning;\r\n\t\tmaterial.morphTargets = this.morphTargets;\r\n\t\tmaterial.morphNormals = this.morphNormals;\r\n\t\r\n\t\treturn material;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/materials/MeshPhongMaterial.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t *\r\n\t * parameters = {\r\n\t *  color: <hex>,\r\n\t *  emissive: <hex>,\r\n\t *  specular: <hex>,\r\n\t *  shininess: <float>,\r\n\t *  opacity: <float>,\r\n\t *\r\n\t *  map: new THREE.Texture( <Image> ),\r\n\t *\r\n\t *  lightMap: new THREE.Texture( <Image> ),\r\n\t *\r\n\t *  bumpMap: new THREE.Texture( <Image> ),\r\n\t *  bumpScale: <float>,\r\n\t *\r\n\t *  normalMap: new THREE.Texture( <Image> ),\r\n\t *  normalScale: <Vector2>,\r\n\t *\r\n\t *  specularMap: new THREE.Texture( <Image> ),\r\n\t *\r\n\t *  alphaMap: new THREE.Texture( <Image> ),\r\n\t *\r\n\t *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\r\n\t *  combine: THREE.Multiply,\r\n\t *  reflectivity: <float>,\r\n\t *  refractionRatio: <float>,\r\n\t *\r\n\t *  shading: THREE.SmoothShading,\r\n\t *  blending: THREE.NormalBlending,\r\n\t *  depthTest: <bool>,\r\n\t *  depthWrite: <bool>,\r\n\t *\r\n\t *  wireframe: <boolean>,\r\n\t *  wireframeLinewidth: <float>,\r\n\t *\r\n\t *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,\r\n\t *\r\n\t *  skinning: <bool>,\r\n\t *  morphTargets: <bool>,\r\n\t *  morphNormals: <bool>,\r\n\t *\r\n\t *\tfog: <bool>\r\n\t * }\r\n\t */\r\n\t\r\n\tTHREE.MeshPhongMaterial = function ( parameters ) {\r\n\t\r\n\t\tTHREE.Material.call( this );\r\n\t\r\n\t\tthis.type = 'MeshPhongMaterial';\r\n\t\r\n\t\tthis.color = new THREE.Color( 0xffffff ); // diffuse\r\n\t\tthis.emissive = new THREE.Color( 0x000000 );\r\n\t\tthis.specular = new THREE.Color( 0x111111 );\r\n\t\tthis.shininess = 30;\r\n\t\r\n\t\tthis.metal = false;\r\n\t\r\n\t\tthis.wrapAround = false;\r\n\t\tthis.wrapRGB = new THREE.Vector3( 1, 1, 1 );\r\n\t\r\n\t\tthis.map = null;\r\n\t\r\n\t\tthis.lightMap = null;\r\n\t\r\n\t\tthis.bumpMap = null;\r\n\t\tthis.bumpScale = 1;\r\n\t\r\n\t\tthis.normalMap = null;\r\n\t\tthis.normalScale = new THREE.Vector2( 1, 1 );\r\n\t\r\n\t\tthis.specularMap = null;\r\n\t\r\n\t\tthis.alphaMap = null;\r\n\t\r\n\t\tthis.envMap = null;\r\n\t\tthis.combine = THREE.MultiplyOperation;\r\n\t\tthis.reflectivity = 1;\r\n\t\tthis.refractionRatio = 0.98;\r\n\t\r\n\t\tthis.fog = true;\r\n\t\r\n\t\tthis.shading = THREE.SmoothShading;\r\n\t\r\n\t\tthis.wireframe = false;\r\n\t\tthis.wireframeLinewidth = 1;\r\n\t\tthis.wireframeLinecap = 'round';\r\n\t\tthis.wireframeLinejoin = 'round';\r\n\t\r\n\t\tthis.vertexColors = THREE.NoColors;\r\n\t\r\n\t\tthis.skinning = false;\r\n\t\tthis.morphTargets = false;\r\n\t\tthis.morphNormals = false;\r\n\t\r\n\t\tthis.setValues( parameters );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MeshPhongMaterial.prototype = Object.create( THREE.Material.prototype );\r\n\tTHREE.MeshPhongMaterial.prototype.constructor = THREE.MeshPhongMaterial;\r\n\t\r\n\tTHREE.MeshPhongMaterial.prototype.clone = function () {\r\n\t\r\n\t\tvar material = new THREE.MeshPhongMaterial();\r\n\t\r\n\t\tTHREE.Material.prototype.clone.call( this, material );\r\n\t\r\n\t\tmaterial.color.copy( this.color );\r\n\t\tmaterial.emissive.copy( this.emissive );\r\n\t\tmaterial.specular.copy( this.specular );\r\n\t\tmaterial.shininess = this.shininess;\r\n\t\r\n\t\tmaterial.metal = this.metal;\r\n\t\r\n\t\tmaterial.wrapAround = this.wrapAround;\r\n\t\tmaterial.wrapRGB.copy( this.wrapRGB );\r\n\t\r\n\t\tmaterial.map = this.map;\r\n\t\r\n\t\tmaterial.lightMap = this.lightMap;\r\n\t\r\n\t\tmaterial.bumpMap = this.bumpMap;\r\n\t\tmaterial.bumpScale = this.bumpScale;\r\n\t\r\n\t\tmaterial.normalMap = this.normalMap;\r\n\t\tmaterial.normalScale.copy( this.normalScale );\r\n\t\r\n\t\tmaterial.specularMap = this.specularMap;\r\n\t\r\n\t\tmaterial.alphaMap = this.alphaMap;\r\n\t\r\n\t\tmaterial.envMap = this.envMap;\r\n\t\tmaterial.combine = this.combine;\r\n\t\tmaterial.reflectivity = this.reflectivity;\r\n\t\tmaterial.refractionRatio = this.refractionRatio;\r\n\t\r\n\t\tmaterial.fog = this.fog;\r\n\t\r\n\t\tmaterial.shading = this.shading;\r\n\t\r\n\t\tmaterial.wireframe = this.wireframe;\r\n\t\tmaterial.wireframeLinewidth = this.wireframeLinewidth;\r\n\t\tmaterial.wireframeLinecap = this.wireframeLinecap;\r\n\t\tmaterial.wireframeLinejoin = this.wireframeLinejoin;\r\n\t\r\n\t\tmaterial.vertexColors = this.vertexColors;\r\n\t\r\n\t\tmaterial.skinning = this.skinning;\r\n\t\tmaterial.morphTargets = this.morphTargets;\r\n\t\tmaterial.morphNormals = this.morphNormals;\r\n\t\r\n\t\treturn material;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/materials/MeshDepthMaterial.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t *\r\n\t * parameters = {\r\n\t *  opacity: <float>,\r\n\t *\r\n\t *  blending: THREE.NormalBlending,\r\n\t *  depthTest: <bool>,\r\n\t *  depthWrite: <bool>,\r\n\t *\r\n\t *  wireframe: <boolean>,\r\n\t *  wireframeLinewidth: <float>\r\n\t * }\r\n\t */\r\n\t\r\n\tTHREE.MeshDepthMaterial = function ( parameters ) {\r\n\t\r\n\t\tTHREE.Material.call( this );\r\n\t\r\n\t\tthis.type = 'MeshDepthMaterial';\r\n\t\r\n\t\tthis.morphTargets = false;\r\n\t\tthis.wireframe = false;\r\n\t\tthis.wireframeLinewidth = 1;\r\n\t\r\n\t\tthis.setValues( parameters );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MeshDepthMaterial.prototype = Object.create( THREE.Material.prototype );\r\n\tTHREE.MeshDepthMaterial.prototype.constructor = THREE.MeshDepthMaterial;\r\n\t\r\n\tTHREE.MeshDepthMaterial.prototype.clone = function () {\r\n\t\r\n\t\tvar material = new THREE.MeshDepthMaterial();\r\n\t\r\n\t\tTHREE.Material.prototype.clone.call( this, material );\r\n\t\r\n\t\tmaterial.wireframe = this.wireframe;\r\n\t\tmaterial.wireframeLinewidth = this.wireframeLinewidth;\r\n\t\r\n\t\treturn material;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/materials/MeshNormalMaterial.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t *\r\n\t * parameters = {\r\n\t *  opacity: <float>,\r\n\t *\r\n\t *  shading: THREE.FlatShading,\r\n\t *  blending: THREE.NormalBlending,\r\n\t *  depthTest: <bool>,\r\n\t *  depthWrite: <bool>,\r\n\t *\r\n\t *  wireframe: <boolean>,\r\n\t *  wireframeLinewidth: <float>\r\n\t * }\r\n\t */\r\n\t\r\n\tTHREE.MeshNormalMaterial = function ( parameters ) {\r\n\t\r\n\t\tTHREE.Material.call( this, parameters );\r\n\t\r\n\t\tthis.type = 'MeshNormalMaterial';\r\n\t\r\n\t\tthis.wireframe = false;\r\n\t\tthis.wireframeLinewidth = 1;\r\n\t\r\n\t\tthis.morphTargets = false;\r\n\t\r\n\t\tthis.setValues( parameters );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MeshNormalMaterial.prototype = Object.create( THREE.Material.prototype );\r\n\tTHREE.MeshNormalMaterial.prototype.constructor = THREE.MeshNormalMaterial;\r\n\t\r\n\tTHREE.MeshNormalMaterial.prototype.clone = function () {\r\n\t\r\n\t\tvar material = new THREE.MeshNormalMaterial();\r\n\t\r\n\t\tTHREE.Material.prototype.clone.call( this, material );\r\n\t\r\n\t\tmaterial.wireframe = this.wireframe;\r\n\t\tmaterial.wireframeLinewidth = this.wireframeLinewidth;\r\n\t\r\n\t\treturn material;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/materials/MeshFaceMaterial.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.MeshFaceMaterial = function ( materials ) {\r\n\t\r\n\t\tthis.uuid = THREE.Math.generateUUID();\r\n\t\r\n\t\tthis.type = 'MeshFaceMaterial';\r\n\t\t\r\n\t\tthis.materials = materials instanceof Array ? materials : [];\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MeshFaceMaterial.prototype = {\r\n\t\r\n\t\tconstructor: THREE.MeshFaceMaterial,\r\n\t\r\n\t\ttoJSON: function () {\r\n\t\r\n\t\t\tvar output = {\r\n\t\t\t\tmetadata: {\r\n\t\t\t\t\tversion: 4.2,\r\n\t\t\t\t\ttype: 'material',\r\n\t\t\t\t\tgenerator: 'MaterialExporter'\r\n\t\t\t\t},\r\n\t\t\t\tuuid: this.uuid,\r\n\t\t\t\ttype: this.type,\r\n\t\t\t\tmaterials: []\r\n\t\t\t};\r\n\t\r\n\t\t\tfor ( var i = 0, l = this.materials.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\toutput.materials.push( this.materials[ i ].toJSON() );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn output;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\tvar material = new THREE.MeshFaceMaterial();\r\n\t\r\n\t\t\tfor ( var i = 0; i < this.materials.length; i ++ ) {\r\n\t\r\n\t\t\t\tmaterial.materials.push( this.materials[ i ].clone() );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn material;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/materials/PointCloudMaterial.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t *\r\n\t * parameters = {\r\n\t *  color: <hex>,\r\n\t *  opacity: <float>,\r\n\t *  map: new THREE.Texture( <Image> ),\r\n\t *\r\n\t *  size: <float>,\r\n\t *  sizeAttenuation: <bool>,\r\n\t *\r\n\t *  blending: THREE.NormalBlending,\r\n\t *  depthTest: <bool>,\r\n\t *  depthWrite: <bool>,\r\n\t *\r\n\t *  vertexColors: <bool>,\r\n\t *\r\n\t *  fog: <bool>\r\n\t * }\r\n\t */\r\n\t\r\n\tTHREE.PointCloudMaterial = function ( parameters ) {\r\n\t\r\n\t\tTHREE.Material.call( this );\r\n\t\r\n\t\tthis.type = 'PointCloudMaterial';\r\n\t\r\n\t\tthis.color = new THREE.Color( 0xffffff );\r\n\t\r\n\t\tthis.map = null;\r\n\t\r\n\t\tthis.size = 1;\r\n\t\tthis.sizeAttenuation = true;\r\n\t\r\n\t\tthis.vertexColors = THREE.NoColors;\r\n\t\r\n\t\tthis.fog = true;\r\n\t\r\n\t\tthis.setValues( parameters );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.PointCloudMaterial.prototype = Object.create( THREE.Material.prototype );\r\n\tTHREE.PointCloudMaterial.prototype.constructor = THREE.PointCloudMaterial;\r\n\t\r\n\tTHREE.PointCloudMaterial.prototype.clone = function () {\r\n\t\r\n\t\tvar material = new THREE.PointCloudMaterial();\r\n\t\r\n\t\tTHREE.Material.prototype.clone.call( this, material );\r\n\t\r\n\t\tmaterial.color.copy( this.color );\r\n\t\r\n\t\tmaterial.map = this.map;\r\n\t\r\n\t\tmaterial.size = this.size;\r\n\t\tmaterial.sizeAttenuation = this.sizeAttenuation;\r\n\t\r\n\t\tmaterial.vertexColors = this.vertexColors;\r\n\t\r\n\t\tmaterial.fog = this.fog;\r\n\t\r\n\t\treturn material;\r\n\t\r\n\t};\r\n\t\r\n\t// backwards compatibility\r\n\t\r\n\tTHREE.ParticleBasicMaterial = function ( parameters ) {\r\n\t\r\n\t\tTHREE.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointCloudMaterial.' );\r\n\t\treturn new THREE.PointCloudMaterial( parameters );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.ParticleSystemMaterial = function ( parameters ) {\r\n\t\r\n\t\tTHREE.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointCloudMaterial.' );\r\n\t\treturn new THREE.PointCloudMaterial( parameters );\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/materials/ShaderMaterial.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t *\r\n\t * parameters = {\r\n\t *  defines: { \"label\" : \"value\" },\r\n\t *  uniforms: { \"parameter1\": { type: \"f\", value: 1.0 }, \"parameter2\": { type: \"i\" value2: 2 } },\r\n\t *\r\n\t *  fragmentShader: <string>,\r\n\t *  vertexShader: <string>,\r\n\t *\r\n\t *  shading: THREE.SmoothShading,\r\n\t *  blending: THREE.NormalBlending,\r\n\t *  depthTest: <bool>,\r\n\t *  depthWrite: <bool>,\r\n\t *\r\n\t *  wireframe: <boolean>,\r\n\t *  wireframeLinewidth: <float>,\r\n\t *\r\n\t *  lights: <bool>,\r\n\t *\r\n\t *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,\r\n\t *\r\n\t *  skinning: <bool>,\r\n\t *  morphTargets: <bool>,\r\n\t *  morphNormals: <bool>,\r\n\t *\r\n\t *\tfog: <bool>\r\n\t * }\r\n\t */\r\n\t\r\n\tTHREE.ShaderMaterial = function ( parameters ) {\r\n\t\r\n\t\tTHREE.Material.call( this );\r\n\t\r\n\t\tthis.type = 'ShaderMaterial';\r\n\t\r\n\t\tthis.defines = {};\r\n\t\tthis.uniforms = {};\r\n\t\tthis.attributes = null;\r\n\t\r\n\t\tthis.vertexShader = 'void main() {\\n\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}';\r\n\t\tthis.fragmentShader = 'void main() {\\n\\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\\n}';\r\n\t\r\n\t\tthis.shading = THREE.SmoothShading;\r\n\t\r\n\t\tthis.linewidth = 1;\r\n\t\r\n\t\tthis.wireframe = false;\r\n\t\tthis.wireframeLinewidth = 1;\r\n\t\r\n\t\tthis.fog = false; // set to use scene fog\r\n\t\r\n\t\tthis.lights = false; // set to use scene lights\r\n\t\r\n\t\tthis.vertexColors = THREE.NoColors; // set to use \"color\" attribute stream\r\n\t\r\n\t\tthis.skinning = false; // set to use skinning attribute streams\r\n\t\r\n\t\tthis.morphTargets = false; // set to use morph targets\r\n\t\tthis.morphNormals = false; // set to use morph normals\r\n\t\r\n\t\t// When rendered geometry doesn't include these attributes but the material does,\r\n\t\t// use these default values in WebGL. This avoids errors when buffer data is missing.\r\n\t\tthis.defaultAttributeValues = {\r\n\t\t\t'color': [ 1, 1, 1 ],\r\n\t\t\t'uv': [ 0, 0 ],\r\n\t\t\t'uv2': [ 0, 0 ]\r\n\t\t};\r\n\t\r\n\t\tthis.index0AttributeName = undefined;\r\n\t\r\n\t\tthis.setValues( parameters );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.ShaderMaterial.prototype = Object.create( THREE.Material.prototype );\r\n\tTHREE.ShaderMaterial.prototype.constructor = THREE.ShaderMaterial;\r\n\t\r\n\tTHREE.ShaderMaterial.prototype.clone = function () {\r\n\t\r\n\t\tvar material = new THREE.ShaderMaterial();\r\n\t\r\n\t\tTHREE.Material.prototype.clone.call( this, material );\r\n\t\r\n\t\tmaterial.fragmentShader = this.fragmentShader;\r\n\t\tmaterial.vertexShader = this.vertexShader;\r\n\t\r\n\t\tmaterial.uniforms = THREE.UniformsUtils.clone( this.uniforms );\r\n\t\r\n\t\tmaterial.attributes = this.attributes;\r\n\t\tmaterial.defines = this.defines;\r\n\t\r\n\t\tmaterial.shading = this.shading;\r\n\t\r\n\t\tmaterial.wireframe = this.wireframe;\r\n\t\tmaterial.wireframeLinewidth = this.wireframeLinewidth;\r\n\t\r\n\t\tmaterial.fog = this.fog;\r\n\t\r\n\t\tmaterial.lights = this.lights;\r\n\t\r\n\t\tmaterial.vertexColors = this.vertexColors;\r\n\t\r\n\t\tmaterial.skinning = this.skinning;\r\n\t\r\n\t\tmaterial.morphTargets = this.morphTargets;\r\n\t\tmaterial.morphNormals = this.morphNormals;\r\n\t\r\n\t\treturn material;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/materials/RawShaderMaterial.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.RawShaderMaterial = function ( parameters ) {\r\n\t\r\n\t\tTHREE.ShaderMaterial.call( this, parameters );\r\n\t\r\n\t\tthis.type = 'RawShaderMaterial';\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.RawShaderMaterial.prototype = Object.create( THREE.ShaderMaterial.prototype );\r\n\tTHREE.RawShaderMaterial.prototype.constructor = THREE.RawShaderMaterial;\r\n\t\r\n\tTHREE.RawShaderMaterial.prototype.clone = function () {\r\n\t\r\n\t\tvar material = new THREE.RawShaderMaterial();\r\n\t\r\n\t\tTHREE.ShaderMaterial.prototype.clone.call( this, material );\r\n\t\r\n\t\treturn material;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/materials/SpriteMaterial.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t *\r\n\t * parameters = {\r\n\t *  color: <hex>,\r\n\t *  opacity: <float>,\r\n\t *  map: new THREE.Texture( <Image> ),\r\n\t *\r\n\t *  blending: THREE.NormalBlending,\r\n\t *  depthTest: <bool>,\r\n\t *  depthWrite: <bool>,\r\n\t *\r\n\t *\tuvOffset: new THREE.Vector2(),\r\n\t *\tuvScale: new THREE.Vector2(),\r\n\t *\r\n\t *  fog: <bool>\r\n\t * }\r\n\t */\r\n\t\r\n\tTHREE.SpriteMaterial = function ( parameters ) {\r\n\t\r\n\t\tTHREE.Material.call( this );\r\n\t\r\n\t\tthis.type = 'SpriteMaterial';\r\n\t\r\n\t\tthis.color = new THREE.Color( 0xffffff );\r\n\t\tthis.map = null;\r\n\t\r\n\t\tthis.rotation = 0;\r\n\t\r\n\t\tthis.fog = false;\r\n\t\r\n\t\t// set parameters\r\n\t\r\n\t\tthis.setValues( parameters );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.SpriteMaterial.prototype = Object.create( THREE.Material.prototype );\r\n\tTHREE.SpriteMaterial.prototype.constructor = THREE.SpriteMaterial;\r\n\t\r\n\tTHREE.SpriteMaterial.prototype.clone = function () {\r\n\t\r\n\t\tvar material = new THREE.SpriteMaterial();\r\n\t\r\n\t\tTHREE.Material.prototype.clone.call( this, material );\r\n\t\r\n\t\tmaterial.color.copy( this.color );\r\n\t\tmaterial.map = this.map;\r\n\t\r\n\t\tmaterial.rotation = this.rotation;\r\n\t\r\n\t\tmaterial.fog = this.fog;\r\n\t\r\n\t\treturn material;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/textures/Texture.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author szimek / https://github.com/szimek/\r\n\t */\r\n\t\r\n\tTHREE.Texture = function ( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\r\n\t\r\n\t\tObject.defineProperty( this, 'id', { value: THREE.TextureIdCount ++ } );\r\n\t\r\n\t\tthis.uuid = THREE.Math.generateUUID();\r\n\t\r\n\t\tthis.name = '';\r\n\t\tthis.sourceFile = '';\r\n\t\r\n\t\tthis.image = image !== undefined ? image : THREE.Texture.DEFAULT_IMAGE;\r\n\t\tthis.mipmaps = [];\r\n\t\r\n\t\tthis.mapping = mapping !== undefined ? mapping : THREE.Texture.DEFAULT_MAPPING;\r\n\t\r\n\t\tthis.wrapS = wrapS !== undefined ? wrapS : THREE.ClampToEdgeWrapping;\r\n\t\tthis.wrapT = wrapT !== undefined ? wrapT : THREE.ClampToEdgeWrapping;\r\n\t\r\n\t\tthis.magFilter = magFilter !== undefined ? magFilter : THREE.LinearFilter;\r\n\t\tthis.minFilter = minFilter !== undefined ? minFilter : THREE.LinearMipMapLinearFilter;\r\n\t\r\n\t\tthis.anisotropy = anisotropy !== undefined ? anisotropy : 1;\r\n\t\r\n\t\tthis.format = format !== undefined ? format : THREE.RGBAFormat;\r\n\t\tthis.type = type !== undefined ? type : THREE.UnsignedByteType;\r\n\t\r\n\t\tthis.offset = new THREE.Vector2( 0, 0 );\r\n\t\tthis.repeat = new THREE.Vector2( 1, 1 );\r\n\t\r\n\t\tthis.generateMipmaps = true;\r\n\t\tthis.premultiplyAlpha = false;\r\n\t\tthis.flipY = true;\r\n\t\tthis.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)\r\n\t\r\n\t\tthis._needsUpdate = false;\r\n\t\tthis.onUpdate = null;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Texture.DEFAULT_IMAGE = undefined;\r\n\tTHREE.Texture.DEFAULT_MAPPING = THREE.UVMapping;\r\n\t\r\n\tTHREE.Texture.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Texture,\r\n\t\r\n\t\tget needsUpdate () {\r\n\t\r\n\t\t\treturn this._needsUpdate;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tset needsUpdate ( value ) {\r\n\t\r\n\t\t\tif ( value === true ) this.update();\r\n\t\r\n\t\t\tthis._needsUpdate = value;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function ( texture ) {\r\n\t\r\n\t\t\tif ( texture === undefined ) texture = new THREE.Texture();\r\n\t\r\n\t\t\ttexture.image = this.image;\r\n\t\t\ttexture.mipmaps = this.mipmaps.slice( 0 );\r\n\t\r\n\t\t\ttexture.mapping = this.mapping;\r\n\t\r\n\t\t\ttexture.wrapS = this.wrapS;\r\n\t\t\ttexture.wrapT = this.wrapT;\r\n\t\r\n\t\t\ttexture.magFilter = this.magFilter;\r\n\t\t\ttexture.minFilter = this.minFilter;\r\n\t\r\n\t\t\ttexture.anisotropy = this.anisotropy;\r\n\t\r\n\t\t\ttexture.format = this.format;\r\n\t\t\ttexture.type = this.type;\r\n\t\r\n\t\t\ttexture.offset.copy( this.offset );\r\n\t\t\ttexture.repeat.copy( this.repeat );\r\n\t\r\n\t\t\ttexture.generateMipmaps = this.generateMipmaps;\r\n\t\t\ttexture.premultiplyAlpha = this.premultiplyAlpha;\r\n\t\t\ttexture.flipY = this.flipY;\r\n\t\t\ttexture.unpackAlignment = this.unpackAlignment;\r\n\t\r\n\t\t\treturn texture;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tupdate: function () {\r\n\t\r\n\t\t\tthis.dispatchEvent( { type: 'update' } );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdispose: function () {\r\n\t\r\n\t\t\tthis.dispatchEvent( { type: 'dispose' } );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.EventDispatcher.prototype.apply( THREE.Texture.prototype );\r\n\t\r\n\tTHREE.TextureIdCount = 0;\r\n\t\r\n\t// File:src/textures/CubeTexture.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.CubeTexture = function ( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\r\n\t\r\n\t\tmapping = mapping !== undefined ? mapping : THREE.CubeReflectionMapping;\r\n\t\t\r\n\t\tTHREE.Texture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\r\n\t\r\n\t\tthis.images = images;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.CubeTexture.prototype = Object.create( THREE.Texture.prototype );\r\n\tTHREE.CubeTexture.prototype.constructor = THREE.CubeTexture;\r\n\t\r\n\tTHREE.CubeTexture.clone = function ( texture ) {\r\n\t\r\n\t\tif ( texture === undefined ) texture = new THREE.CubeTexture();\r\n\t\r\n\t\tTHREE.Texture.prototype.clone.call( this, texture );\r\n\t\r\n\t\ttexture.images = this.images;\r\n\t\r\n\t\treturn texture;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/textures/CompressedTexture.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.CompressedTexture = function ( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {\r\n\t\r\n\t\tTHREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\r\n\t\r\n\t\tthis.image = { width: width, height: height };\r\n\t\tthis.mipmaps = mipmaps;\r\n\t\r\n\t\t// no flipping for cube textures\r\n\t\t// (also flipping doesn't work for compressed textures )\r\n\t\r\n\t\tthis.flipY = false;\r\n\t\r\n\t\t// can't generate mipmaps for compressed textures\r\n\t\t// mips must be embedded in DDS files\r\n\t\r\n\t\tthis.generateMipmaps = false;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.CompressedTexture.prototype = Object.create( THREE.Texture.prototype );\r\n\tTHREE.CompressedTexture.prototype.constructor = THREE.CompressedTexture;\r\n\t\r\n\tTHREE.CompressedTexture.prototype.clone = function () {\r\n\t\r\n\t\tvar texture = new THREE.CompressedTexture();\r\n\t\r\n\t\tTHREE.Texture.prototype.clone.call( this, texture );\r\n\t\r\n\t\treturn texture;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/textures/DataTexture.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.DataTexture = function ( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {\r\n\t\r\n\t\tTHREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\r\n\t\r\n\t\tthis.image = { data: data, width: width, height: height };\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.DataTexture.prototype = Object.create( THREE.Texture.prototype );\r\n\tTHREE.DataTexture.prototype.constructor = THREE.DataTexture;\r\n\t\r\n\tTHREE.DataTexture.prototype.clone = function () {\r\n\t\r\n\t\tvar texture = new THREE.DataTexture();\r\n\t\r\n\t\tTHREE.Texture.prototype.clone.call( this, texture );\r\n\t\r\n\t\treturn texture;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/textures/VideoTexture.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.VideoTexture = function ( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\r\n\t\r\n\t\tTHREE.Texture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\r\n\t\r\n\t\tthis.generateMipmaps = false;\r\n\t\r\n\t\tvar scope = this;\r\n\t\r\n\t\tvar update = function () {\r\n\t\r\n\t\t\trequestAnimationFrame( update );\r\n\t\r\n\t\t\tif ( video.readyState === video.HAVE_ENOUGH_DATA ) {\r\n\t\r\n\t\t\t\tscope.needsUpdate = true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tupdate();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.VideoTexture.prototype = Object.create( THREE.Texture.prototype );\r\n\tTHREE.VideoTexture.prototype.constructor = THREE.VideoTexture;\r\n\t\r\n\t// File:src/objects/Group.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.Group = function () {\r\n\t\r\n\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t\tthis.type = 'Group';\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Group.prototype = Object.create( THREE.Object3D.prototype );\r\n\tTHREE.Group.prototype.constructor = THREE.Group;\r\n\t\r\n\t// File:src/objects/PointCloud.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.PointCloud = function ( geometry, material ) {\r\n\t\r\n\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t\tthis.type = 'PointCloud';\r\n\t\r\n\t\tthis.geometry = geometry !== undefined ? geometry : new THREE.Geometry();\r\n\t\tthis.material = material !== undefined ? material : new THREE.PointCloudMaterial( { color: Math.random() * 0xffffff } );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.PointCloud.prototype = Object.create( THREE.Object3D.prototype );\r\n\tTHREE.PointCloud.prototype.constructor = THREE.PointCloud;\r\n\t\r\n\tTHREE.PointCloud.prototype.raycast = ( function () {\r\n\t\r\n\t\tvar inverseMatrix = new THREE.Matrix4();\r\n\t\tvar ray = new THREE.Ray();\r\n\t\r\n\t\treturn function ( raycaster, intersects ) {\r\n\t\r\n\t\t\tvar object = this;\r\n\t\t\tvar geometry = object.geometry;\r\n\t\t\tvar threshold = raycaster.params.PointCloud.threshold;\r\n\t\r\n\t\t\tinverseMatrix.getInverse( this.matrixWorld );\r\n\t\t\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\r\n\t\r\n\t\t\tif ( geometry.boundingBox !== null ) {\r\n\t\r\n\t\t\t\tif ( ray.isIntersectionBox( geometry.boundingBox ) === false ) {\r\n\t\r\n\t\t\t\t\treturn;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );\r\n\t\t\tvar position = new THREE.Vector3();\r\n\t\r\n\t\t\tvar testPoint = function ( point, index ) {\r\n\t\r\n\t\t\t\tvar rayPointDistance = ray.distanceToPoint( point );\r\n\t\r\n\t\t\t\tif ( rayPointDistance < localThreshold ) {\r\n\t\r\n\t\t\t\t\tvar intersectPoint = ray.closestPointToPoint( point );\r\n\t\t\t\t\tintersectPoint.applyMatrix4( object.matrixWorld );\r\n\t\r\n\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( intersectPoint );\r\n\t\r\n\t\t\t\t\tintersects.push( {\r\n\t\r\n\t\t\t\t\t\tdistance: distance,\r\n\t\t\t\t\t\tdistanceToRay: rayPointDistance,\r\n\t\t\t\t\t\tpoint: intersectPoint.clone(),\r\n\t\t\t\t\t\tindex: index,\r\n\t\t\t\t\t\tface: null,\r\n\t\t\t\t\t\tobject: object\r\n\t\r\n\t\t\t\t\t} );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\r\n\t\r\n\t\t\t\tvar attributes = geometry.attributes;\r\n\t\t\t\tvar positions = attributes.position.array;\r\n\t\r\n\t\t\t\tif ( attributes.index !== undefined ) {\r\n\t\r\n\t\t\t\t\tvar indices = attributes.index.array;\r\n\t\t\t\t\tvar offsets = geometry.offsets;\r\n\t\r\n\t\t\t\t\tif ( offsets.length === 0 ) {\r\n\t\r\n\t\t\t\t\t\tvar offset = {\r\n\t\t\t\t\t\t\tstart: 0,\r\n\t\t\t\t\t\t\tcount: indices.length,\r\n\t\t\t\t\t\t\tindex: 0\r\n\t\t\t\t\t\t};\r\n\t\r\n\t\t\t\t\t\toffsets = [ offset ];\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tfor ( var oi = 0, ol = offsets.length; oi < ol; ++ oi ) {\r\n\t\r\n\t\t\t\t\t\tvar start = offsets[ oi ].start;\r\n\t\t\t\t\t\tvar count = offsets[ oi ].count;\r\n\t\t\t\t\t\tvar index = offsets[ oi ].index;\r\n\t\r\n\t\t\t\t\t\tfor ( var i = start, il = start + count; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\t\t\tvar a = index + indices[ i ];\r\n\t\r\n\t\t\t\t\t\t\tposition.fromArray( positions, a * 3 );\r\n\t\r\n\t\t\t\t\t\t\ttestPoint( position, a );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tvar pointCount = positions.length / 3;\r\n\t\r\n\t\t\t\t\tfor ( var i = 0; i < pointCount; i ++ ) {\r\n\t\r\n\t\t\t\t\t\tposition.set(\r\n\t\t\t\t\t\t\tpositions[ 3 * i ],\r\n\t\t\t\t\t\t\tpositions[ 3 * i + 1 ],\r\n\t\t\t\t\t\t\tpositions[ 3 * i + 2 ]\r\n\t\t\t\t\t\t);\r\n\t\r\n\t\t\t\t\t\ttestPoint( position, i );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tvar vertices = this.geometry.vertices;\r\n\t\r\n\t\t\t\tfor ( var i = 0; i < vertices.length; i ++ ) {\r\n\t\r\n\t\t\t\t\ttestPoint( vertices[ i ], i );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t}() );\r\n\t\r\n\tTHREE.PointCloud.prototype.clone = function ( object ) {\r\n\t\r\n\t\tif ( object === undefined ) object = new THREE.PointCloud( this.geometry, this.material );\r\n\t\r\n\t\tTHREE.Object3D.prototype.clone.call( this, object );\r\n\t\r\n\t\treturn object;\r\n\t\r\n\t};\r\n\t\r\n\t// Backwards compatibility\r\n\t\r\n\tTHREE.ParticleSystem = function ( geometry, material ) {\r\n\t\r\n\t\tTHREE.warn( 'THREE.ParticleSystem has been renamed to THREE.PointCloud.' );\r\n\t\treturn new THREE.PointCloud( geometry, material );\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/objects/Line.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.Line = function ( geometry, material, mode ) {\r\n\t\r\n\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t\tthis.type = 'Line';\r\n\t\r\n\t\tthis.geometry = geometry !== undefined ? geometry : new THREE.Geometry();\r\n\t\tthis.material = material !== undefined ? material : new THREE.LineBasicMaterial( { color: Math.random() * 0xffffff } );\r\n\t\r\n\t\tthis.mode = mode !== undefined ? mode : THREE.LineStrip;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.LineStrip = 0;\r\n\tTHREE.LinePieces = 1;\r\n\t\r\n\tTHREE.Line.prototype = Object.create( THREE.Object3D.prototype );\r\n\tTHREE.Line.prototype.constructor = THREE.Line;\r\n\t\r\n\tTHREE.Line.prototype.raycast = ( function () {\r\n\t\r\n\t\tvar inverseMatrix = new THREE.Matrix4();\r\n\t\tvar ray = new THREE.Ray();\r\n\t\tvar sphere = new THREE.Sphere();\r\n\t\r\n\t\treturn function ( raycaster, intersects ) {\r\n\t\r\n\t\t\tvar precision = raycaster.linePrecision;\r\n\t\t\tvar precisionSq = precision * precision;\r\n\t\r\n\t\t\tvar geometry = this.geometry;\r\n\t\r\n\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\r\n\t\r\n\t\t\t// Checking boundingSphere distance to ray\r\n\t\r\n\t\t\tsphere.copy( geometry.boundingSphere );\r\n\t\t\tsphere.applyMatrix4( this.matrixWorld );\r\n\t\r\n\t\t\tif ( raycaster.ray.isIntersectionSphere( sphere ) === false ) {\r\n\t\r\n\t\t\t\treturn;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tinverseMatrix.getInverse( this.matrixWorld );\r\n\t\t\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\r\n\t\r\n\t\t\tvar vStart = new THREE.Vector3();\r\n\t\t\tvar vEnd = new THREE.Vector3();\r\n\t\t\tvar interSegment = new THREE.Vector3();\r\n\t\t\tvar interRay = new THREE.Vector3();\r\n\t\t\tvar step = this.mode === THREE.LineStrip ? 1 : 2;\r\n\t\r\n\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\r\n\t\r\n\t\t\t\tvar attributes = geometry.attributes;\r\n\t\r\n\t\t\t\tif ( attributes.index !== undefined ) {\r\n\t\r\n\t\t\t\t\tvar indices = attributes.index.array;\r\n\t\t\t\t\tvar positions = attributes.position.array;\r\n\t\t\t\t\tvar offsets = geometry.offsets;\r\n\t\r\n\t\t\t\t\tif ( offsets.length === 0 ) {\r\n\t\r\n\t\t\t\t\t\toffsets = [ { start: 0, count: indices.length, index: 0 } ];\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tfor ( var oi = 0; oi < offsets.length; oi ++) {\r\n\t\r\n\t\t\t\t\t\tvar start = offsets[ oi ].start;\r\n\t\t\t\t\t\tvar count = offsets[ oi ].count;\r\n\t\t\t\t\t\tvar index = offsets[ oi ].index;\r\n\t\r\n\t\t\t\t\t\tfor ( var i = start; i < start + count - 1; i += step ) {\r\n\t\r\n\t\t\t\t\t\t\tvar a = index + indices[ i ];\r\n\t\t\t\t\t\t\tvar b = index + indices[ i + 1 ];\r\n\t\r\n\t\t\t\t\t\t\tvStart.fromArray( positions, a * 3 );\r\n\t\t\t\t\t\t\tvEnd.fromArray( positions, b * 3 );\r\n\t\r\n\t\t\t\t\t\t\tvar distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );\r\n\t\r\n\t\t\t\t\t\t\tif ( distSq > precisionSq ) continue;\r\n\t\r\n\t\t\t\t\t\t\tvar distance = ray.origin.distanceTo( interRay );\r\n\t\r\n\t\t\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\r\n\t\r\n\t\t\t\t\t\t\tintersects.push( {\r\n\t\r\n\t\t\t\t\t\t\t\tdistance: distance,\r\n\t\t\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\r\n\t\t\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\r\n\t\t\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\r\n\t\t\t\t\t\t\t\tindex: i,\r\n\t\t\t\t\t\t\t\toffsetIndex: oi,\r\n\t\t\t\t\t\t\t\tface: null,\r\n\t\t\t\t\t\t\t\tfaceIndex: null,\r\n\t\t\t\t\t\t\t\tobject: this\r\n\t\r\n\t\t\t\t\t\t\t} );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tvar positions = attributes.position.array;\r\n\t\r\n\t\t\t\t\tfor ( var i = 0; i < positions.length / 3 - 1; i += step ) {\r\n\t\r\n\t\t\t\t\t\tvStart.fromArray( positions, 3 * i );\r\n\t\t\t\t\t\tvEnd.fromArray( positions, 3 * i + 3 );\r\n\t\r\n\t\t\t\t\t\tvar distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );\r\n\t\r\n\t\t\t\t\t\tif ( distSq > precisionSq ) continue;\r\n\t\r\n\t\t\t\t\t\tvar distance = ray.origin.distanceTo( interRay );\r\n\t\r\n\t\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\r\n\t\r\n\t\t\t\t\t\tintersects.push( {\r\n\t\r\n\t\t\t\t\t\t\tdistance: distance,\r\n\t\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\r\n\t\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\r\n\t\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\r\n\t\t\t\t\t\t\tindex: i,\r\n\t\t\t\t\t\t\tface: null,\r\n\t\t\t\t\t\t\tfaceIndex: null,\r\n\t\t\t\t\t\t\tobject: this\r\n\t\r\n\t\t\t\t\t\t} );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else if ( geometry instanceof THREE.Geometry ) {\r\n\t\r\n\t\t\t\tvar vertices = geometry.vertices;\r\n\t\t\t\tvar nbVertices = vertices.length;\r\n\t\r\n\t\t\t\tfor ( var i = 0; i < nbVertices - 1; i += step ) {\r\n\t\r\n\t\t\t\t\tvar distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );\r\n\t\r\n\t\t\t\t\tif ( distSq > precisionSq ) continue;\r\n\t\r\n\t\t\t\t\tvar distance = ray.origin.distanceTo( interRay );\r\n\t\r\n\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\r\n\t\r\n\t\t\t\t\tintersects.push( {\r\n\t\r\n\t\t\t\t\t\tdistance: distance,\r\n\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\r\n\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\r\n\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\r\n\t\t\t\t\t\tindex: i,\r\n\t\t\t\t\t\tface: null,\r\n\t\t\t\t\t\tfaceIndex: null,\r\n\t\t\t\t\t\tobject: this\r\n\t\r\n\t\t\t\t\t} );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t}() );\r\n\t\r\n\tTHREE.Line.prototype.clone = function ( object ) {\r\n\t\r\n\t\tif ( object === undefined ) object = new THREE.Line( this.geometry, this.material, this.mode );\r\n\t\r\n\t\tTHREE.Object3D.prototype.clone.call( this, object );\r\n\t\r\n\t\treturn object;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/objects/Mesh.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author mikael emtinger / http://gomo.se/\r\n\t * @author jonobr1 / http://jonobr1.com/\r\n\t */\r\n\t\r\n\tTHREE.Mesh = function ( geometry, material ) {\r\n\t\r\n\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t\tthis.type = 'Mesh';\r\n\t\t\r\n\t\tthis.geometry = geometry !== undefined ? geometry : new THREE.Geometry();\r\n\t\tthis.material = material !== undefined ? material : new THREE.MeshBasicMaterial( { color: Math.random() * 0xffffff } );\r\n\t\r\n\t\tthis.updateMorphTargets();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Mesh.prototype = Object.create( THREE.Object3D.prototype );\r\n\tTHREE.Mesh.prototype.constructor = THREE.Mesh;\r\n\t\r\n\tTHREE.Mesh.prototype.updateMorphTargets = function () {\r\n\t\r\n\t\tif ( this.geometry.morphTargets !== undefined && this.geometry.morphTargets.length > 0 ) {\r\n\t\r\n\t\t\tthis.morphTargetBase = - 1;\r\n\t\t\tthis.morphTargetForcedOrder = [];\r\n\t\t\tthis.morphTargetInfluences = [];\r\n\t\t\tthis.morphTargetDictionary = {};\r\n\t\r\n\t\t\tfor ( var m = 0, ml = this.geometry.morphTargets.length; m < ml; m ++ ) {\r\n\t\r\n\t\t\t\tthis.morphTargetInfluences.push( 0 );\r\n\t\t\t\tthis.morphTargetDictionary[ this.geometry.morphTargets[ m ].name ] = m;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Mesh.prototype.getMorphTargetIndexByName = function ( name ) {\r\n\t\r\n\t\tif ( this.morphTargetDictionary[ name ] !== undefined ) {\r\n\t\r\n\t\t\treturn this.morphTargetDictionary[ name ];\r\n\t\r\n\t\t}\r\n\t\r\n\t\tTHREE.warn( 'THREE.Mesh.getMorphTargetIndexByName: morph target ' + name + ' does not exist. Returning 0.' );\r\n\t\r\n\t\treturn 0;\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\tTHREE.Mesh.prototype.raycast = ( function () {\r\n\t\r\n\t\tvar inverseMatrix = new THREE.Matrix4();\r\n\t\tvar ray = new THREE.Ray();\r\n\t\tvar sphere = new THREE.Sphere();\r\n\t\r\n\t\tvar vA = new THREE.Vector3();\r\n\t\tvar vB = new THREE.Vector3();\r\n\t\tvar vC = new THREE.Vector3();\r\n\t\r\n\t\treturn function ( raycaster, intersects ) {\r\n\t\r\n\t\t\tvar geometry = this.geometry;\r\n\t\r\n\t\t\t// Checking boundingSphere distance to ray\r\n\t\r\n\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\r\n\t\r\n\t\t\tsphere.copy( geometry.boundingSphere );\r\n\t\t\tsphere.applyMatrix4( this.matrixWorld );\r\n\t\r\n\t\t\tif ( raycaster.ray.isIntersectionSphere( sphere ) === false ) {\r\n\t\r\n\t\t\t\treturn;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// Check boundingBox before continuing\r\n\t\r\n\t\t\tinverseMatrix.getInverse( this.matrixWorld );\r\n\t\t\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\r\n\t\r\n\t\t\tif ( geometry.boundingBox !== null ) {\r\n\t\r\n\t\t\t\tif ( ray.isIntersectionBox( geometry.boundingBox ) === false ) {\r\n\t\r\n\t\t\t\t\treturn;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\r\n\t\r\n\t\t\t\tvar material = this.material;\r\n\t\r\n\t\t\t\tif ( material === undefined ) return;\r\n\t\r\n\t\t\t\tvar attributes = geometry.attributes;\r\n\t\r\n\t\t\t\tvar a, b, c;\r\n\t\t\t\tvar precision = raycaster.precision;\r\n\t\r\n\t\t\t\tif ( attributes.index !== undefined ) {\r\n\t\r\n\t\t\t\t\tvar indices = attributes.index.array;\r\n\t\t\t\t\tvar positions = attributes.position.array;\r\n\t\t\t\t\tvar offsets = geometry.offsets;\r\n\t\r\n\t\t\t\t\tif ( offsets.length === 0 ) {\r\n\t\r\n\t\t\t\t\t\toffsets = [ { start: 0, count: indices.length, index: 0 } ];\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tfor ( var oi = 0, ol = offsets.length; oi < ol; ++ oi ) {\r\n\t\r\n\t\t\t\t\t\tvar start = offsets[ oi ].start;\r\n\t\t\t\t\t\tvar count = offsets[ oi ].count;\r\n\t\t\t\t\t\tvar index = offsets[ oi ].index;\r\n\t\r\n\t\t\t\t\t\tfor ( var i = start, il = start + count; i < il; i += 3 ) {\r\n\t\r\n\t\t\t\t\t\t\ta = index + indices[ i ];\r\n\t\t\t\t\t\t\tb = index + indices[ i + 1 ];\r\n\t\t\t\t\t\t\tc = index + indices[ i + 2 ];\r\n\t\r\n\t\t\t\t\t\t\tvA.fromArray( positions, a * 3 );\r\n\t\t\t\t\t\t\tvB.fromArray( positions, b * 3 );\r\n\t\t\t\t\t\t\tvC.fromArray( positions, c * 3 );\r\n\t\r\n\t\t\t\t\t\t\tif ( material.side === THREE.BackSide ) {\r\n\t\r\n\t\t\t\t\t\t\t\tvar intersectionPoint = ray.intersectTriangle( vC, vB, vA, true );\r\n\t\r\n\t\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\t\tvar intersectionPoint = ray.intersectTriangle( vA, vB, vC, material.side !== THREE.DoubleSide );\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\tif ( intersectionPoint === null ) continue;\r\n\t\r\n\t\t\t\t\t\t\tintersectionPoint.applyMatrix4( this.matrixWorld );\r\n\t\r\n\t\t\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( intersectionPoint );\r\n\t\r\n\t\t\t\t\t\t\tif ( distance < precision || distance < raycaster.near || distance > raycaster.far ) continue;\r\n\t\r\n\t\t\t\t\t\t\tintersects.push( {\r\n\t\r\n\t\t\t\t\t\t\t\tdistance: distance,\r\n\t\t\t\t\t\t\t\tpoint: intersectionPoint,\r\n\t\t\t\t\t\t\t\tface: new THREE.Face3( a, b, c, THREE.Triangle.normal( vA, vB, vC ) ),\r\n\t\t\t\t\t\t\t\tfaceIndex: null,\r\n\t\t\t\t\t\t\t\tobject: this\r\n\t\r\n\t\t\t\t\t\t\t} );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tvar positions = attributes.position.array;\r\n\t\r\n\t\t\t\t\tfor ( var i = 0, j = 0, il = positions.length; i < il; i += 3, j += 9 ) {\r\n\t\r\n\t\t\t\t\t\ta = i;\r\n\t\t\t\t\t\tb = i + 1;\r\n\t\t\t\t\t\tc = i + 2;\r\n\t\r\n\t\t\t\t\t\tvA.fromArray( positions, j );\r\n\t\t\t\t\t\tvB.fromArray( positions, j + 3 );\r\n\t\t\t\t\t\tvC.fromArray( positions, j + 6 );\r\n\t\r\n\t\t\t\t\t\tif ( material.side === THREE.BackSide ) {\r\n\t\r\n\t\t\t\t\t\t\tvar intersectionPoint = ray.intersectTriangle( vC, vB, vA, true );\r\n\t\r\n\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\tvar intersectionPoint = ray.intersectTriangle( vA, vB, vC, material.side !== THREE.DoubleSide );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tif ( intersectionPoint === null ) continue;\r\n\t\r\n\t\t\t\t\t\tintersectionPoint.applyMatrix4( this.matrixWorld );\r\n\t\r\n\t\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( intersectionPoint );\r\n\t\r\n\t\t\t\t\t\tif ( distance < precision || distance < raycaster.near || distance > raycaster.far ) continue;\r\n\t\r\n\t\t\t\t\t\tintersects.push( {\r\n\t\r\n\t\t\t\t\t\t\tdistance: distance,\r\n\t\t\t\t\t\t\tpoint: intersectionPoint,\r\n\t\t\t\t\t\t\tface: new THREE.Face3( a, b, c, THREE.Triangle.normal( vA, vB, vC ) ),\r\n\t\t\t\t\t\t\tfaceIndex: null,\r\n\t\t\t\t\t\t\tobject: this\r\n\t\r\n\t\t\t\t\t\t} );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else if ( geometry instanceof THREE.Geometry ) {\r\n\t\r\n\t\t\t\tvar isFaceMaterial = this.material instanceof THREE.MeshFaceMaterial;\r\n\t\t\t\tvar objectMaterials = isFaceMaterial === true ? this.material.materials : null;\r\n\t\r\n\t\t\t\tvar a, b, c;\r\n\t\t\t\tvar precision = raycaster.precision;\r\n\t\r\n\t\t\t\tvar vertices = geometry.vertices;\r\n\t\r\n\t\t\t\tfor ( var f = 0, fl = geometry.faces.length; f < fl; f ++ ) {\r\n\t\r\n\t\t\t\t\tvar face = geometry.faces[ f ];\r\n\t\r\n\t\t\t\t\tvar material = isFaceMaterial === true ? objectMaterials[ face.materialIndex ] : this.material;\r\n\t\r\n\t\t\t\t\tif ( material === undefined ) continue;\r\n\t\r\n\t\t\t\t\ta = vertices[ face.a ];\r\n\t\t\t\t\tb = vertices[ face.b ];\r\n\t\t\t\t\tc = vertices[ face.c ];\r\n\t\r\n\t\t\t\t\tif ( material.morphTargets === true ) {\r\n\t\r\n\t\t\t\t\t\tvar morphTargets = geometry.morphTargets;\r\n\t\t\t\t\t\tvar morphInfluences = this.morphTargetInfluences;\r\n\t\r\n\t\t\t\t\t\tvA.set( 0, 0, 0 );\r\n\t\t\t\t\t\tvB.set( 0, 0, 0 );\r\n\t\t\t\t\t\tvC.set( 0, 0, 0 );\r\n\t\r\n\t\t\t\t\t\tfor ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {\r\n\t\r\n\t\t\t\t\t\t\tvar influence = morphInfluences[ t ];\r\n\t\r\n\t\t\t\t\t\t\tif ( influence === 0 ) continue;\r\n\t\r\n\t\t\t\t\t\t\tvar targets = morphTargets[ t ].vertices;\r\n\t\r\n\t\t\t\t\t\t\tvA.x += ( targets[ face.a ].x - a.x ) * influence;\r\n\t\t\t\t\t\t\tvA.y += ( targets[ face.a ].y - a.y ) * influence;\r\n\t\t\t\t\t\t\tvA.z += ( targets[ face.a ].z - a.z ) * influence;\r\n\t\r\n\t\t\t\t\t\t\tvB.x += ( targets[ face.b ].x - b.x ) * influence;\r\n\t\t\t\t\t\t\tvB.y += ( targets[ face.b ].y - b.y ) * influence;\r\n\t\t\t\t\t\t\tvB.z += ( targets[ face.b ].z - b.z ) * influence;\r\n\t\r\n\t\t\t\t\t\t\tvC.x += ( targets[ face.c ].x - c.x ) * influence;\r\n\t\t\t\t\t\t\tvC.y += ( targets[ face.c ].y - c.y ) * influence;\r\n\t\t\t\t\t\t\tvC.z += ( targets[ face.c ].z - c.z ) * influence;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tvA.add( a );\r\n\t\t\t\t\t\tvB.add( b );\r\n\t\t\t\t\t\tvC.add( c );\r\n\t\r\n\t\t\t\t\t\ta = vA;\r\n\t\t\t\t\t\tb = vB;\r\n\t\t\t\t\t\tc = vC;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( material.side === THREE.BackSide ) {\r\n\t\r\n\t\t\t\t\t\tvar intersectionPoint = ray.intersectTriangle( c, b, a, true );\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tvar intersectionPoint = ray.intersectTriangle( a, b, c, material.side !== THREE.DoubleSide );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( intersectionPoint === null ) continue;\r\n\t\r\n\t\t\t\t\tintersectionPoint.applyMatrix4( this.matrixWorld );\r\n\t\r\n\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( intersectionPoint );\r\n\t\r\n\t\t\t\t\tif ( distance < precision || distance < raycaster.near || distance > raycaster.far ) continue;\r\n\t\r\n\t\t\t\t\tintersects.push( {\r\n\t\r\n\t\t\t\t\t\tdistance: distance,\r\n\t\t\t\t\t\tpoint: intersectionPoint,\r\n\t\t\t\t\t\tface: face,\r\n\t\t\t\t\t\tfaceIndex: f,\r\n\t\t\t\t\t\tobject: this\r\n\t\r\n\t\t\t\t\t} );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t}() );\r\n\t\r\n\tTHREE.Mesh.prototype.clone = function ( object, recursive ) {\r\n\t\r\n\t\tif ( object === undefined ) object = new THREE.Mesh( this.geometry, this.material );\r\n\t\r\n\t\tTHREE.Object3D.prototype.clone.call( this, object, recursive );\r\n\t\r\n\t\treturn object;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/objects/Bone.js\r\n\t\r\n\t/**\r\n\t * @author mikael emtinger / http://gomo.se/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author ikerr / http://verold.com\r\n\t */\r\n\t\r\n\tTHREE.Bone = function ( skin ) {\r\n\t\r\n\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t\tthis.type = 'Bone';\r\n\t\r\n\t\tthis.skin = skin;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Bone.prototype = Object.create( THREE.Object3D.prototype );\r\n\tTHREE.Bone.prototype.constructor = THREE.Bone;\r\n\t\r\n\t// File:src/objects/Skeleton.js\r\n\t\r\n\t/**\r\n\t * @author mikael emtinger / http://gomo.se/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author michael guerrero / http://realitymeltdown.com\r\n\t * @author ikerr / http://verold.com\r\n\t */\r\n\t\r\n\tTHREE.Skeleton = function ( bones, boneInverses, useVertexTexture ) {\r\n\t\r\n\t\tthis.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;\r\n\t\r\n\t\tthis.identityMatrix = new THREE.Matrix4();\r\n\t\r\n\t\t// copy the bone array\r\n\t\r\n\t\tbones = bones || [];\r\n\t\r\n\t\tthis.bones = bones.slice( 0 );\r\n\t\r\n\t\t// create a bone texture or an array of floats\r\n\t\r\n\t\tif ( this.useVertexTexture ) {\r\n\t\r\n\t\t\t// layout (1 matrix = 4 pixels)\r\n\t\t\t//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)\r\n\t\t\t//  with  8x8  pixel texture max   16 bones  (8 * 8  / 4)\r\n\t\t\t//       16x16 pixel texture max   64 bones (16 * 16 / 4)\r\n\t\t\t//       32x32 pixel texture max  256 bones (32 * 32 / 4)\r\n\t\t\t//       64x64 pixel texture max 1024 bones (64 * 64 / 4)\r\n\t\r\n\t\t\tvar size;\r\n\t\r\n\t\t\tif ( this.bones.length > 256 )\r\n\t\t\t\tsize = 64;\r\n\t\t\telse if ( this.bones.length > 64 )\r\n\t\t\t\tsize = 32;\r\n\t\t\telse if ( this.bones.length > 16 )\r\n\t\t\t\tsize = 16;\r\n\t\t\telse\r\n\t\t\t\tsize = 8;\r\n\t\r\n\t\t\tthis.boneTextureWidth = size;\r\n\t\t\tthis.boneTextureHeight = size;\r\n\t\r\n\t\t\tthis.boneMatrices = new Float32Array( this.boneTextureWidth * this.boneTextureHeight * 4 ); // 4 floats per RGBA pixel\r\n\t\t\tthis.boneTexture = new THREE.DataTexture( this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType );\r\n\t\t\tthis.boneTexture.minFilter = THREE.NearestFilter;\r\n\t\t\tthis.boneTexture.magFilter = THREE.NearestFilter;\r\n\t\t\tthis.boneTexture.generateMipmaps = false;\r\n\t\t\tthis.boneTexture.flipY = false;\r\n\t\r\n\t\t} else {\r\n\t\r\n\t\t\tthis.boneMatrices = new Float32Array( 16 * this.bones.length );\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// use the supplied bone inverses or calculate the inverses\r\n\t\r\n\t\tif ( boneInverses === undefined ) {\r\n\t\r\n\t\t\tthis.calculateInverses();\r\n\t\r\n\t\t} else {\r\n\t\r\n\t\t\tif ( this.bones.length === boneInverses.length ) {\r\n\t\r\n\t\t\t\tthis.boneInverses = boneInverses.slice( 0 );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tTHREE.warn( 'THREE.Skeleton bonInverses is the wrong length.' );\r\n\t\r\n\t\t\t\tthis.boneInverses = [];\r\n\t\r\n\t\t\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\r\n\t\r\n\t\t\t\t\tthis.boneInverses.push( new THREE.Matrix4() );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Skeleton.prototype.calculateInverses = function () {\r\n\t\r\n\t\tthis.boneInverses = [];\r\n\t\r\n\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\r\n\t\r\n\t\t\tvar inverse = new THREE.Matrix4();\r\n\t\r\n\t\t\tif ( this.bones[ b ] ) {\r\n\t\r\n\t\t\t\tinverse.getInverse( this.bones[ b ].matrixWorld );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.boneInverses.push( inverse );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Skeleton.prototype.pose = function () {\r\n\t\r\n\t\tvar bone;\r\n\t\r\n\t\t// recover the bind-time world matrices\r\n\t\r\n\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\r\n\t\r\n\t\t\tbone = this.bones[ b ];\r\n\t\r\n\t\t\tif ( bone ) {\r\n\t\r\n\t\t\t\tbone.matrixWorld.getInverse( this.boneInverses[ b ] );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// compute the local matrices, positions, rotations and scales\r\n\t\r\n\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\r\n\t\r\n\t\t\tbone = this.bones[ b ];\r\n\t\r\n\t\t\tif ( bone ) {\r\n\t\r\n\t\t\t\tif ( bone.parent ) {\r\n\t\r\n\t\t\t\t\tbone.matrix.getInverse( bone.parent.matrixWorld );\r\n\t\t\t\t\tbone.matrix.multiply( bone.matrixWorld );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tbone.matrix.copy( bone.matrixWorld );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tbone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Skeleton.prototype.update = ( function () {\r\n\t\r\n\t\tvar offsetMatrix = new THREE.Matrix4();\r\n\t\t\r\n\t\treturn function () {\r\n\t\r\n\t\t\t// flatten bone matrices to array\r\n\t\r\n\t\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\r\n\t\r\n\t\t\t\t// compute the offset between the current and the original transform\r\n\t\r\n\t\t\t\tvar matrix = this.bones[ b ] ? this.bones[ b ].matrixWorld : this.identityMatrix;\r\n\t\r\n\t\t\t\toffsetMatrix.multiplyMatrices( matrix, this.boneInverses[ b ] );\r\n\t\t\t\toffsetMatrix.flattenToArrayOffset( this.boneMatrices, b * 16 );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( this.useVertexTexture ) {\r\n\t\r\n\t\t\t\tthis.boneTexture.needsUpdate = true;\r\n\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t};\r\n\t\r\n\t} )();\r\n\t\r\n\t\r\n\t// File:src/objects/SkinnedMesh.js\r\n\t\r\n\t/**\r\n\t * @author mikael emtinger / http://gomo.se/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author ikerr / http://verold.com\r\n\t */\r\n\t\r\n\tTHREE.SkinnedMesh = function ( geometry, material, useVertexTexture ) {\r\n\t\r\n\t\tTHREE.Mesh.call( this, geometry, material );\r\n\t\r\n\t\tthis.type = 'SkinnedMesh';\r\n\t\r\n\t\tthis.bindMode = \"attached\";\r\n\t\tthis.bindMatrix = new THREE.Matrix4();\r\n\t\tthis.bindMatrixInverse = new THREE.Matrix4();\r\n\t\r\n\t\t// init bones\r\n\t\r\n\t\t// TODO: remove bone creation as there is no reason (other than\r\n\t\t// convenience) for THREE.SkinnedMesh to do this.\r\n\t\r\n\t\tvar bones = [];\r\n\t\r\n\t\tif ( this.geometry && this.geometry.bones !== undefined ) {\r\n\t\r\n\t\t\tvar bone, gbone, p, q, s;\r\n\t\r\n\t\t\tfor ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {\r\n\t\r\n\t\t\t\tgbone = this.geometry.bones[ b ];\r\n\t\r\n\t\t\t\tp = gbone.pos;\r\n\t\t\t\tq = gbone.rotq;\r\n\t\t\t\ts = gbone.scl;\r\n\t\r\n\t\t\t\tbone = new THREE.Bone( this );\r\n\t\t\t\tbones.push( bone );\r\n\t\r\n\t\t\t\tbone.name = gbone.name;\r\n\t\t\t\tbone.position.set( p[ 0 ], p[ 1 ], p[ 2 ] );\r\n\t\t\t\tbone.quaternion.set( q[ 0 ], q[ 1 ], q[ 2 ], q[ 3 ] );\r\n\t\r\n\t\t\t\tif ( s !== undefined ) {\r\n\t\r\n\t\t\t\t\tbone.scale.set( s[ 0 ], s[ 1 ], s[ 2 ] );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tbone.scale.set( 1, 1, 1 );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfor ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {\r\n\t\r\n\t\t\t\tgbone = this.geometry.bones[ b ];\r\n\t\r\n\t\t\t\tif ( gbone.parent !== - 1 ) {\r\n\t\r\n\t\t\t\t\tbones[ gbone.parent ].add( bones[ b ] );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tthis.add( bones[ b ] );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.normalizeSkinWeights();\r\n\t\r\n\t\tthis.updateMatrixWorld( true );\r\n\t\tthis.bind( new THREE.Skeleton( bones, undefined, useVertexTexture ) );\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\tTHREE.SkinnedMesh.prototype = Object.create( THREE.Mesh.prototype );\r\n\tTHREE.SkinnedMesh.prototype.constructor = THREE.SkinnedMesh;\r\n\t\r\n\tTHREE.SkinnedMesh.prototype.bind = function( skeleton, bindMatrix ) {\r\n\t\r\n\t\tthis.skeleton = skeleton;\r\n\t\r\n\t\tif ( bindMatrix === undefined ) {\r\n\t\r\n\t\t\tthis.updateMatrixWorld( true );\r\n\t\r\n\t\t\tbindMatrix = this.matrixWorld;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.bindMatrix.copy( bindMatrix );\r\n\t\tthis.bindMatrixInverse.getInverse( bindMatrix );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.SkinnedMesh.prototype.pose = function () {\r\n\t\r\n\t\tthis.skeleton.pose();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.SkinnedMesh.prototype.normalizeSkinWeights = function () {\r\n\t\r\n\t\tif ( this.geometry instanceof THREE.Geometry ) {\r\n\t\r\n\t\t\tfor ( var i = 0; i < this.geometry.skinIndices.length; i ++ ) {\r\n\t\r\n\t\t\t\tvar sw = this.geometry.skinWeights[ i ];\r\n\t\r\n\t\t\t\tvar scale = 1.0 / sw.lengthManhattan();\r\n\t\r\n\t\t\t\tif ( scale !== Infinity ) {\r\n\t\r\n\t\t\t\t\tsw.multiplyScalar( scale );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tsw.set( 1 ); // this will be normalized by the shader anyway\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t} else {\r\n\t\r\n\t\t\t// skinning weights assumed to be normalized for THREE.BufferGeometry\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.SkinnedMesh.prototype.updateMatrixWorld = function( force ) {\r\n\t\r\n\t\tTHREE.Mesh.prototype.updateMatrixWorld.call( this, true );\r\n\t\r\n\t\tif ( this.bindMode === \"attached\" ) {\r\n\t\r\n\t\t\tthis.bindMatrixInverse.getInverse( this.matrixWorld );\r\n\t\r\n\t\t} else if ( this.bindMode === \"detached\" ) {\r\n\t\r\n\t\t\tthis.bindMatrixInverse.getInverse( this.bindMatrix );\r\n\t\r\n\t\t} else {\r\n\t\r\n\t\t\tTHREE.warn( 'THREE.SkinnedMesh unreckognized bindMode: ' + this.bindMode );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.SkinnedMesh.prototype.clone = function( object ) {\r\n\t\r\n\t\tif ( object === undefined ) {\r\n\t\r\n\t\t\tobject = new THREE.SkinnedMesh( this.geometry, this.material, this.useVertexTexture );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tTHREE.Mesh.prototype.clone.call( this, object );\r\n\t\r\n\t\treturn object;\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\t// File:src/objects/MorphAnimMesh.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.MorphAnimMesh = function ( geometry, material ) {\r\n\t\r\n\t\tTHREE.Mesh.call( this, geometry, material );\r\n\t\r\n\t\tthis.type = 'MorphAnimMesh';\r\n\t\r\n\t\t// API\r\n\t\r\n\t\tthis.duration = 1000; // milliseconds\r\n\t\tthis.mirroredLoop = false;\r\n\t\tthis.time = 0;\r\n\t\r\n\t\t// internals\r\n\t\r\n\t\tthis.lastKeyframe = 0;\r\n\t\tthis.currentKeyframe = 0;\r\n\t\r\n\t\tthis.direction = 1;\r\n\t\tthis.directionBackwards = false;\r\n\t\r\n\t\tthis.setFrameRange( 0, this.geometry.morphTargets.length - 1 );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MorphAnimMesh.prototype = Object.create( THREE.Mesh.prototype );\r\n\tTHREE.MorphAnimMesh.prototype.constructor = THREE.MorphAnimMesh;\r\n\t\r\n\tTHREE.MorphAnimMesh.prototype.setFrameRange = function ( start, end ) {\r\n\t\r\n\t\tthis.startKeyframe = start;\r\n\t\tthis.endKeyframe = end;\r\n\t\r\n\t\tthis.length = this.endKeyframe - this.startKeyframe + 1;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MorphAnimMesh.prototype.setDirectionForward = function () {\r\n\t\r\n\t\tthis.direction = 1;\r\n\t\tthis.directionBackwards = false;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MorphAnimMesh.prototype.setDirectionBackward = function () {\r\n\t\r\n\t\tthis.direction = - 1;\r\n\t\tthis.directionBackwards = true;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MorphAnimMesh.prototype.parseAnimations = function () {\r\n\t\r\n\t\tvar geometry = this.geometry;\r\n\t\r\n\t\tif ( ! geometry.animations ) geometry.animations = {};\r\n\t\r\n\t\tvar firstAnimation, animations = geometry.animations;\r\n\t\r\n\t\tvar pattern = /([a-z]+)_?(\\d+)/;\r\n\t\r\n\t\tfor ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {\r\n\t\r\n\t\t\tvar morph = geometry.morphTargets[ i ];\r\n\t\t\tvar parts = morph.name.match( pattern );\r\n\t\r\n\t\t\tif ( parts && parts.length > 1 ) {\r\n\t\r\n\t\t\t\tvar label = parts[ 1 ];\r\n\t\r\n\t\t\t\tif ( ! animations[ label ] ) animations[ label ] = { start: Infinity, end: - Infinity };\r\n\t\r\n\t\t\t\tvar animation = animations[ label ];\r\n\t\r\n\t\t\t\tif ( i < animation.start ) animation.start = i;\r\n\t\t\t\tif ( i > animation.end ) animation.end = i;\r\n\t\r\n\t\t\t\tif ( ! firstAnimation ) firstAnimation = label;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tgeometry.firstAnimation = firstAnimation;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MorphAnimMesh.prototype.setAnimationLabel = function ( label, start, end ) {\r\n\t\r\n\t\tif ( ! this.geometry.animations ) this.geometry.animations = {};\r\n\t\r\n\t\tthis.geometry.animations[ label ] = { start: start, end: end };\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MorphAnimMesh.prototype.playAnimation = function ( label, fps ) {\r\n\t\r\n\t\tvar animation = this.geometry.animations[ label ];\r\n\t\r\n\t\tif ( animation ) {\r\n\t\r\n\t\t\tthis.setFrameRange( animation.start, animation.end );\r\n\t\t\tthis.duration = 1000 * ( ( animation.end - animation.start ) / fps );\r\n\t\t\tthis.time = 0;\r\n\t\r\n\t\t} else {\r\n\t\r\n\t\t\tTHREE.warn( 'THREE.MorphAnimMesh: animation[' + label + '] undefined in .playAnimation()' );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MorphAnimMesh.prototype.updateAnimation = function ( delta ) {\r\n\t\r\n\t\tvar frameTime = this.duration / this.length;\r\n\t\r\n\t\tthis.time += this.direction * delta;\r\n\t\r\n\t\tif ( this.mirroredLoop ) {\r\n\t\r\n\t\t\tif ( this.time > this.duration || this.time < 0 ) {\r\n\t\r\n\t\t\t\tthis.direction *= - 1;\r\n\t\r\n\t\t\t\tif ( this.time > this.duration ) {\r\n\t\r\n\t\t\t\t\tthis.time = this.duration;\r\n\t\t\t\t\tthis.directionBackwards = true;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( this.time < 0 ) {\r\n\t\r\n\t\t\t\t\tthis.time = 0;\r\n\t\t\t\t\tthis.directionBackwards = false;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t} else {\r\n\t\r\n\t\t\tthis.time = this.time % this.duration;\r\n\t\r\n\t\t\tif ( this.time < 0 ) this.time += this.duration;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar keyframe = this.startKeyframe + THREE.Math.clamp( Math.floor( this.time / frameTime ), 0, this.length - 1 );\r\n\t\r\n\t\tif ( keyframe !== this.currentKeyframe ) {\r\n\t\r\n\t\t\tthis.morphTargetInfluences[ this.lastKeyframe ] = 0;\r\n\t\t\tthis.morphTargetInfluences[ this.currentKeyframe ] = 1;\r\n\t\r\n\t\t\tthis.morphTargetInfluences[ keyframe ] = 0;\r\n\t\r\n\t\t\tthis.lastKeyframe = this.currentKeyframe;\r\n\t\t\tthis.currentKeyframe = keyframe;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar mix = ( this.time % frameTime ) / frameTime;\r\n\t\r\n\t\tif ( this.directionBackwards ) {\r\n\t\r\n\t\t\tmix = 1 - mix;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.morphTargetInfluences[ this.currentKeyframe ] = mix;\r\n\t\tthis.morphTargetInfluences[ this.lastKeyframe ] = 1 - mix;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MorphAnimMesh.prototype.interpolateTargets = function ( a, b, t ) {\r\n\t\r\n\t\tvar influences = this.morphTargetInfluences;\r\n\t\r\n\t\tfor ( var i = 0, l = influences.length; i < l; i ++ ) {\r\n\t\r\n\t\t\tinfluences[ i ] = 0;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tif ( a > -1 ) influences[ a ] = 1 - t;\r\n\t\tif ( b > -1 ) influences[ b ] = t;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MorphAnimMesh.prototype.clone = function ( object ) {\r\n\t\r\n\t\tif ( object === undefined ) object = new THREE.MorphAnimMesh( this.geometry, this.material );\r\n\t\r\n\t\tobject.duration = this.duration;\r\n\t\tobject.mirroredLoop = this.mirroredLoop;\r\n\t\tobject.time = this.time;\r\n\t\r\n\t\tobject.lastKeyframe = this.lastKeyframe;\r\n\t\tobject.currentKeyframe = this.currentKeyframe;\r\n\t\r\n\t\tobject.direction = this.direction;\r\n\t\tobject.directionBackwards = this.directionBackwards;\r\n\t\r\n\t\tTHREE.Mesh.prototype.clone.call( this, object );\r\n\t\r\n\t\treturn object;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/objects/LOD.js\r\n\t\r\n\t/**\r\n\t * @author mikael emtinger / http://gomo.se/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.LOD = function () {\r\n\t\r\n\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t\tthis.objects = [];\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\tTHREE.LOD.prototype = Object.create( THREE.Object3D.prototype );\r\n\tTHREE.LOD.prototype.constructor = THREE.LOD;\r\n\t\r\n\tTHREE.LOD.prototype.addLevel = function ( object, distance ) {\r\n\t\r\n\t\tif ( distance === undefined ) distance = 0;\r\n\t\r\n\t\tdistance = Math.abs( distance );\r\n\t\r\n\t\tfor ( var l = 0; l < this.objects.length; l ++ ) {\r\n\t\r\n\t\t\tif ( distance < this.objects[ l ].distance ) {\r\n\t\r\n\t\t\t\tbreak;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.objects.splice( l, 0, { distance: distance, object: object } );\r\n\t\tthis.add( object );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.LOD.prototype.getObjectForDistance = function ( distance ) {\r\n\t\r\n\t\tfor ( var i = 1, l = this.objects.length; i < l; i ++ ) {\r\n\t\r\n\t\t\tif ( distance < this.objects[ i ].distance ) {\r\n\t\r\n\t\t\t\tbreak;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\treturn this.objects[ i - 1 ].object;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.LOD.prototype.raycast = ( function () {\r\n\t\r\n\t\tvar matrixPosition = new THREE.Vector3();\r\n\t\r\n\t\treturn function ( raycaster, intersects ) {\r\n\t\r\n\t\t\tmatrixPosition.setFromMatrixPosition( this.matrixWorld );\r\n\t\r\n\t\t\tvar distance = raycaster.ray.origin.distanceTo( matrixPosition );\r\n\t\r\n\t\t\tthis.getObjectForDistance( distance ).raycast( raycaster, intersects );\r\n\t\r\n\t\t};\r\n\t\r\n\t}() );\r\n\t\r\n\tTHREE.LOD.prototype.update = function () {\r\n\t\r\n\t\tvar v1 = new THREE.Vector3();\r\n\t\tvar v2 = new THREE.Vector3();\r\n\t\r\n\t\treturn function ( camera ) {\r\n\t\r\n\t\t\tif ( this.objects.length > 1 ) {\r\n\t\r\n\t\t\t\tv1.setFromMatrixPosition( camera.matrixWorld );\r\n\t\t\t\tv2.setFromMatrixPosition( this.matrixWorld );\r\n\t\r\n\t\t\t\tvar distance = v1.distanceTo( v2 );\r\n\t\r\n\t\t\t\tthis.objects[ 0 ].object.visible = true;\r\n\t\r\n\t\t\t\tfor ( var i = 1, l = this.objects.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\tif ( distance >= this.objects[ i ].distance ) {\r\n\t\r\n\t\t\t\t\t\tthis.objects[ i - 1 ].object.visible = false;\r\n\t\t\t\t\t\tthis.objects[ i     ].object.visible = true;\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tfor ( ; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\tthis.objects[ i ].object.visible = false;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t}();\r\n\t\r\n\tTHREE.LOD.prototype.clone = function ( object ) {\r\n\t\r\n\t\tif ( object === undefined ) object = new THREE.LOD();\r\n\t\r\n\t\tTHREE.Object3D.prototype.clone.call( this, object );\r\n\t\r\n\t\tfor ( var i = 0, l = this.objects.length; i < l; i ++ ) {\r\n\t\t\tvar x = this.objects[ i ].object.clone();\r\n\t\t\tx.visible = i === 0;\r\n\t\t\tobject.addLevel( x, this.objects[ i ].distance );\r\n\t\t}\r\n\t\r\n\t\treturn object;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/objects/Sprite.js\r\n\t\r\n\t/**\r\n\t * @author mikael emtinger / http://gomo.se/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.Sprite = ( function () {\r\n\t\r\n\t\tvar indices = new Uint16Array( [ 0, 1, 2,  0, 2, 3 ] );\r\n\t\tvar vertices = new Float32Array( [ - 0.5, - 0.5, 0,   0.5, - 0.5, 0,   0.5, 0.5, 0,   - 0.5, 0.5, 0 ] );\r\n\t\tvar uvs = new Float32Array( [ 0, 0,   1, 0,   1, 1,   0, 1 ] );\r\n\t\r\n\t\tvar geometry = new THREE.BufferGeometry();\r\n\t\tgeometry.addAttribute( 'index', new THREE.BufferAttribute( indices, 1 ) );\r\n\t\tgeometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\r\n\t\tgeometry.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );\r\n\t\r\n\t\treturn function ( material ) {\r\n\t\r\n\t\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t\t\tthis.type = 'Sprite';\r\n\t\r\n\t\t\tthis.geometry = geometry;\r\n\t\t\tthis.material = ( material !== undefined ) ? material : new THREE.SpriteMaterial();\r\n\t\r\n\t\t};\r\n\t\r\n\t} )();\r\n\t\r\n\tTHREE.Sprite.prototype = Object.create( THREE.Object3D.prototype );\r\n\tTHREE.Sprite.prototype.constructor = THREE.Sprite;\r\n\t\r\n\tTHREE.Sprite.prototype.raycast = ( function () {\r\n\t\r\n\t\tvar matrixPosition = new THREE.Vector3();\r\n\t\r\n\t\treturn function ( raycaster, intersects ) {\r\n\t\r\n\t\t\tmatrixPosition.setFromMatrixPosition( this.matrixWorld );\r\n\t\r\n\t\t\tvar distance = raycaster.ray.distanceToPoint( matrixPosition );\r\n\t\r\n\t\t\tif ( distance > this.scale.x ) {\r\n\t\r\n\t\t\t\treturn;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tintersects.push( {\r\n\t\r\n\t\t\t\tdistance: distance,\r\n\t\t\t\tpoint: this.position,\r\n\t\t\t\tface: null,\r\n\t\t\t\tobject: this\r\n\t\r\n\t\t\t} );\r\n\t\r\n\t\t};\r\n\t\r\n\t}() );\r\n\t\r\n\tTHREE.Sprite.prototype.clone = function ( object ) {\r\n\t\r\n\t\tif ( object === undefined ) object = new THREE.Sprite( this.material );\r\n\t\r\n\t\tTHREE.Object3D.prototype.clone.call( this, object );\r\n\t\r\n\t\treturn object;\r\n\t\r\n\t};\r\n\t\r\n\t// Backwards compatibility\r\n\t\r\n\tTHREE.Particle = THREE.Sprite;\r\n\t\r\n\t// File:src/objects/LensFlare.js\r\n\t\r\n\t/**\r\n\t * @author mikael emtinger / http://gomo.se/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.LensFlare = function ( texture, size, distance, blending, color ) {\r\n\t\r\n\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t\tthis.lensFlares = [];\r\n\t\r\n\t\tthis.positionScreen = new THREE.Vector3();\r\n\t\tthis.customUpdateCallback = undefined;\r\n\t\r\n\t\tif ( texture !== undefined ) {\r\n\t\r\n\t\t\tthis.add( texture, size, distance, blending, color );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.LensFlare.prototype = Object.create( THREE.Object3D.prototype );\r\n\tTHREE.LensFlare.prototype.constructor = THREE.LensFlare;\r\n\t\r\n\t\r\n\t/*\r\n\t * Add: adds another flare\r\n\t */\r\n\t\r\n\tTHREE.LensFlare.prototype.add = function ( texture, size, distance, blending, color, opacity ) {\r\n\t\r\n\t\tif ( size === undefined ) size = - 1;\r\n\t\tif ( distance === undefined ) distance = 0;\r\n\t\tif ( opacity === undefined ) opacity = 1;\r\n\t\tif ( color === undefined ) color = new THREE.Color( 0xffffff );\r\n\t\tif ( blending === undefined ) blending = THREE.NormalBlending;\r\n\t\r\n\t\tdistance = Math.min( distance, Math.max( 0, distance ) );\r\n\t\r\n\t\tthis.lensFlares.push( {\r\n\t\t\ttexture: texture, \t\t\t// THREE.Texture\r\n\t\t\tsize: size, \t\t\t\t// size in pixels (-1 = use texture.width)\r\n\t\t\tdistance: distance, \t\t// distance (0-1) from light source (0=at light source)\r\n\t\t\tx: 0, y: 0, z: 0,\t\t\t// screen position (-1 => 1) z = 0 is ontop z = 1 is back\r\n\t\t\tscale: 1, \t\t\t\t\t// scale\r\n\t\t\trotation: 1, \t\t\t\t// rotation\r\n\t\t\topacity: opacity,\t\t\t// opacity\r\n\t\t\tcolor: color,\t\t\t\t// color\r\n\t\t\tblending: blending\t\t\t// blending\r\n\t\t} );\r\n\t\r\n\t};\r\n\t\r\n\t/*\r\n\t * Update lens flares update positions on all flares based on the screen position\r\n\t * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.\r\n\t */\r\n\t\r\n\tTHREE.LensFlare.prototype.updateLensFlares = function () {\r\n\t\r\n\t\tvar f, fl = this.lensFlares.length;\r\n\t\tvar flare;\r\n\t\tvar vecX = - this.positionScreen.x * 2;\r\n\t\tvar vecY = - this.positionScreen.y * 2;\r\n\t\r\n\t\tfor ( f = 0; f < fl; f ++ ) {\r\n\t\r\n\t\t\tflare = this.lensFlares[ f ];\r\n\t\r\n\t\t\tflare.x = this.positionScreen.x + vecX * flare.distance;\r\n\t\t\tflare.y = this.positionScreen.y + vecY * flare.distance;\r\n\t\r\n\t\t\tflare.wantedRotation = flare.x * Math.PI * 0.25;\r\n\t\t\tflare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\t// File:src/scenes/Scene.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.Scene = function () {\r\n\t\r\n\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t\tthis.type = 'Scene';\r\n\t\r\n\t\tthis.fog = null;\r\n\t\tthis.overrideMaterial = null;\r\n\t\r\n\t\tthis.autoUpdate = true; // checked by the renderer\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Scene.prototype = Object.create( THREE.Object3D.prototype );\r\n\tTHREE.Scene.prototype.constructor = THREE.Scene;\r\n\t\r\n\tTHREE.Scene.prototype.clone = function ( object ) {\r\n\t\r\n\t\tif ( object === undefined ) object = new THREE.Scene();\r\n\t\r\n\t\tTHREE.Object3D.prototype.clone.call( this, object );\r\n\t\r\n\t\tif ( this.fog !== null ) object.fog = this.fog.clone();\r\n\t\tif ( this.overrideMaterial !== null ) object.overrideMaterial = this.overrideMaterial.clone();\r\n\t\r\n\t\tobject.autoUpdate = this.autoUpdate;\r\n\t\tobject.matrixAutoUpdate = this.matrixAutoUpdate;\r\n\t\r\n\t\treturn object;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/scenes/Fog.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.Fog = function ( color, near, far ) {\r\n\t\r\n\t\tthis.name = '';\r\n\t\r\n\t\tthis.color = new THREE.Color( color );\r\n\t\r\n\t\tthis.near = ( near !== undefined ) ? near : 1;\r\n\t\tthis.far = ( far !== undefined ) ? far : 1000;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Fog.prototype.clone = function () {\r\n\t\r\n\t\treturn new THREE.Fog( this.color.getHex(), this.near, this.far );\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/scenes/FogExp2.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.FogExp2 = function ( color, density ) {\r\n\t\r\n\t\tthis.name = '';\r\n\t\r\n\t\tthis.color = new THREE.Color( color );\r\n\t\tthis.density = ( density !== undefined ) ? density : 0.00025;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.FogExp2.prototype.clone = function () {\r\n\t\r\n\t\treturn new THREE.FogExp2( this.color.getHex(), this.density );\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk.js\r\n\t\r\n\tTHREE.ShaderChunk = {};\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/common.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'common'] = \"#define PI 3.14159\\n#define PI2 6.28318\\n#define RECIPROCAL_PI2 0.15915494\\n#define LOG2 1.442695\\n#define EPSILON 1e-6\\n\\nfloat square( in float a ) { return a*a; }\\nvec2  square( in vec2 a )  { return vec2( a.x*a.x, a.y*a.y ); }\\nvec3  square( in vec3 a )  { return vec3( a.x*a.x, a.y*a.y, a.z*a.z ); }\\nvec4  square( in vec4 a )  { return vec4( a.x*a.x, a.y*a.y, a.z*a.z, a.w*a.w ); }\\nfloat saturate( in float a ) { return clamp( a, 0.0, 1.0 ); }\\nvec2  saturate( in vec2 a )  { return clamp( a, 0.0, 1.0 ); }\\nvec3  saturate( in vec3 a )  { return clamp( a, 0.0, 1.0 ); }\\nvec4  saturate( in vec4 a )  { return clamp( a, 0.0, 1.0 ); }\\nfloat average( in float a ) { return a; }\\nfloat average( in vec2 a )  { return ( a.x + a.y) * 0.5; }\\nfloat average( in vec3 a )  { return ( a.x + a.y + a.z) / 3.0; }\\nfloat average( in vec4 a )  { return ( a.x + a.y + a.z + a.w) * 0.25; }\\nfloat whiteCompliment( in float a ) { return saturate( 1.0 - a ); }\\nvec2  whiteCompliment( in vec2 a )  { return saturate( vec2(1.0) - a ); }\\nvec3  whiteCompliment( in vec3 a )  { return saturate( vec3(1.0) - a ); }\\nvec4  whiteCompliment( in vec4 a )  { return saturate( vec4(1.0) - a ); }\\nvec3 transformDirection( in vec3 normal, in mat4 matrix ) {\\n\treturn normalize( ( matrix * vec4( normal, 0.0 ) ).xyz );\\n}\\n// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations\\nvec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {\\n\treturn normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );\\n}\\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal) {\\n\tfloat distance = dot( planeNormal, point-pointOnPlane );\\n\treturn point - distance * planeNormal;\\n}\\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\\n}\\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\treturn pointOnLine + lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) );\\n}\\nfloat calcLightAttenuation( float lightDistance, float cutoffDistance, float decayExponent ) {\\n\tif ( decayExponent > 0.0 ) {\\n\t  return pow( saturate( 1.0 - lightDistance / cutoffDistance ), decayExponent );\\n\t}\\n\treturn 1.0;\\n}\\n\\nvec3 inputToLinear( in vec3 a ) {\\n#ifdef GAMMA_INPUT\\n\treturn pow( a, vec3( float( GAMMA_FACTOR ) ) );\\n#else\\n\treturn a;\\n#endif\\n}\\nvec3 linearToOutput( in vec3 a ) {\\n#ifdef GAMMA_OUTPUT\\n\treturn pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );\\n#else\\n\treturn a;\\n#endif\\n}\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/alphatest_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'alphatest_fragment'] = \"#ifdef ALPHATEST\\n\\n\tif ( diffuseColor.a < ALPHATEST ) discard;\\n\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/lights_lambert_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'lights_lambert_vertex'] = \"vLightFront = vec3( 0.0 );\\n\\n#ifdef DOUBLE_SIDED\\n\\n\tvLightBack = vec3( 0.0 );\\n\\n#endif\\n\\ntransformedNormal = normalize( transformedNormal );\\n\\n#if MAX_DIR_LIGHTS > 0\\n\\nfor( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\\n\\n\tvec3 dirVector = transformDirection( directionalLightDirection[ i ], viewMatrix );\\n\\n\tfloat dotProduct = dot( transformedNormal, dirVector );\\n\tvec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );\\n\\n\t#ifdef DOUBLE_SIDED\\n\\n\t\tvec3 directionalLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\\n\\n\t\t#ifdef WRAP_AROUND\\n\\n\t\t\tvec3 directionalLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\\n\\n\t\t#endif\\n\\n\t#endif\\n\\n\t#ifdef WRAP_AROUND\\n\\n\t\tvec3 directionalLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\\n\t\tdirectionalLightWeighting = mix( directionalLightWeighting, directionalLightWeightingHalf, wrapRGB );\\n\\n\t\t#ifdef DOUBLE_SIDED\\n\\n\t\t\tdirectionalLightWeightingBack = mix( directionalLightWeightingBack, directionalLightWeightingHalfBack, wrapRGB );\\n\\n\t\t#endif\\n\\n\t#endif\\n\\n\tvLightFront += directionalLightColor[ i ] * directionalLightWeighting;\\n\\n\t#ifdef DOUBLE_SIDED\\n\\n\t\tvLightBack += directionalLightColor[ i ] * directionalLightWeightingBack;\\n\\n\t#endif\\n\\n}\\n\\n#endif\\n\\n#if MAX_POINT_LIGHTS > 0\\n\\n\tfor( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\\n\\n\t\tvec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\\n\t\tvec3 lVector = lPosition.xyz - mvPosition.xyz;\\n\\n\t\tfloat attenuation = calcLightAttenuation( length( lVector ), pointLightDistance[ i ], pointLightDecay[ i ] );\\n\\n\t\tlVector = normalize( lVector );\\n\t\tfloat dotProduct = dot( transformedNormal, lVector );\\n\\n\t\tvec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );\\n\\n\t\t#ifdef DOUBLE_SIDED\\n\\n\t\t\tvec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\\n\\n\t\t\t#ifdef WRAP_AROUND\\n\\n\t\t\t\tvec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\\n\\n\t\t\t#endif\\n\\n\t\t#endif\\n\\n\t\t#ifdef WRAP_AROUND\\n\\n\t\t\tvec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\\n\t\t\tpointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );\\n\\n\t\t\t#ifdef DOUBLE_SIDED\\n\\n\t\t\t\tpointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );\\n\\n\t\t\t#endif\\n\\n\t\t#endif\\n\\n\t\tvLightFront += pointLightColor[ i ] * pointLightWeighting * attenuation;\\n\\n\t\t#ifdef DOUBLE_SIDED\\n\\n\t\t\tvLightBack += pointLightColor[ i ] * pointLightWeightingBack * attenuation;\\n\\n\t\t#endif\\n\\n\t}\\n\\n#endif\\n\\n#if MAX_SPOT_LIGHTS > 0\\n\\n\tfor( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\\n\\n\t\tvec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\\n\t\tvec3 lVector = lPosition.xyz - mvPosition.xyz;\\n\\n\t\tfloat spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - worldPosition.xyz ) );\\n\\n\t\tif ( spotEffect > spotLightAngleCos[ i ] ) {\\n\\n\t\t\tspotEffect = max( pow( max( spotEffect, 0.0 ), spotLightExponent[ i ] ), 0.0 );\\n\\n\t\t\tfloat attenuation = calcLightAttenuation( length( lVector ), spotLightDistance[ i ], spotLightDecay[ i ] );\\n\\n\t\t\tlVector = normalize( lVector );\\n\\n\t\t\tfloat dotProduct = dot( transformedNormal, lVector );\\n\t\t\tvec3 spotLightWeighting = vec3( max( dotProduct, 0.0 ) );\\n\\n\t\t\t#ifdef DOUBLE_SIDED\\n\\n\t\t\t\tvec3 spotLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\\n\\n\t\t\t\t#ifdef WRAP_AROUND\\n\\n\t\t\t\t\tvec3 spotLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\\n\\n\t\t\t\t#endif\\n\\n\t\t\t#endif\\n\\n\t\t\t#ifdef WRAP_AROUND\\n\\n\t\t\t\tvec3 spotLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\\n\t\t\t\tspotLightWeighting = mix( spotLightWeighting, spotLightWeightingHalf, wrapRGB );\\n\\n\t\t\t\t#ifdef DOUBLE_SIDED\\n\\n\t\t\t\t\tspotLightWeightingBack = mix( spotLightWeightingBack, spotLightWeightingHalfBack, wrapRGB );\\n\\n\t\t\t\t#endif\\n\\n\t\t\t#endif\\n\\n\t\t\tvLightFront += spotLightColor[ i ] * spotLightWeighting * attenuation * spotEffect;\\n\\n\t\t\t#ifdef DOUBLE_SIDED\\n\\n\t\t\t\tvLightBack += spotLightColor[ i ] * spotLightWeightingBack * attenuation * spotEffect;\\n\\n\t\t\t#endif\\n\\n\t\t}\\n\\n\t}\\n\\n#endif\\n\\n#if MAX_HEMI_LIGHTS > 0\\n\\n\tfor( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\\n\\n\t\tvec3 lVector = transformDirection( hemisphereLightDirection[ i ], viewMatrix );\\n\\n\t\tfloat dotProduct = dot( transformedNormal, lVector );\\n\\n\t\tfloat hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\\n\t\tfloat hemiDiffuseWeightBack = -0.5 * dotProduct + 0.5;\\n\\n\t\tvLightFront += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\\n\\n\t\t#ifdef DOUBLE_SIDED\\n\\n\t\t\tvLightBack += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeightBack );\\n\\n\t\t#endif\\n\\n\t}\\n\\n#endif\\n\\nvLightFront += ambientLightColor;\\n\\n#ifdef DOUBLE_SIDED\\n\\n\tvLightBack += ambientLightColor;\\n\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/map_particle_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'map_particle_pars_fragment'] = \"#ifdef USE_MAP\\n\\n\tuniform vec4 offsetRepeat;\\n\tuniform sampler2D map;\\n\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/default_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'default_vertex'] = \"#ifdef USE_SKINNING\\n\\n\tvec4 mvPosition = modelViewMatrix * skinned;\\n\\n#elif defined( USE_MORPHTARGETS )\\n\\n\tvec4 mvPosition = modelViewMatrix * vec4( morphed, 1.0 );\\n\\n#else\\n\\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\\n\\n#endif\\n\\ngl_Position = projectionMatrix * mvPosition;\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/map_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'map_pars_fragment'] = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\\n\\n\tvarying vec2 vUv;\\n\\n#endif\\n\\n#ifdef USE_MAP\\n\\n\tuniform sampler2D map;\\n\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/skinnormal_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'skinnormal_vertex'] = \"#ifdef USE_SKINNING\\n\\n\tmat4 skinMatrix = mat4( 0.0 );\\n\tskinMatrix += skinWeight.x * boneMatX;\\n\tskinMatrix += skinWeight.y * boneMatY;\\n\tskinMatrix += skinWeight.z * boneMatZ;\\n\tskinMatrix += skinWeight.w * boneMatW;\\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\\n\\n\t#ifdef USE_MORPHNORMALS\\n\\n\tvec4 skinnedNormal = skinMatrix * vec4( morphedNormal, 0.0 );\\n\\n\t#else\\n\\n\tvec4 skinnedNormal = skinMatrix * vec4( normal, 0.0 );\\n\\n\t#endif\\n\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'logdepthbuf_pars_vertex'] = \"#ifdef USE_LOGDEPTHBUF\\n\\n\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\n\t\tvarying float vFragDepth;\\n\\n\t#endif\\n\\n\tuniform float logDepthBufFC;\\n\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/lightmap_pars_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'lightmap_pars_vertex'] = \"#ifdef USE_LIGHTMAP\\n\\n\tvarying vec2 vUv2;\\n\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/lights_phong_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'lights_phong_fragment'] = \"#ifndef FLAT_SHADED\\n\\n\tvec3 normal = normalize( vNormal );\\n\\n\t#ifdef DOUBLE_SIDED\\n\\n\t\tnormal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\\n\\n\t#endif\\n\\n#else\\n\\n\tvec3 fdx = dFdx( vViewPosition );\\n\tvec3 fdy = dFdy( vViewPosition );\\n\tvec3 normal = normalize( cross( fdx, fdy ) );\\n\\n#endif\\n\\nvec3 viewPosition = normalize( vViewPosition );\\n\\n#ifdef USE_NORMALMAP\\n\\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\\n\\n#elif defined( USE_BUMPMAP )\\n\\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\\n\\n#endif\\n\\nvec3 totalDiffuseLight = vec3( 0.0 );\\nvec3 totalSpecularLight = vec3( 0.0 );\\n\\n#if MAX_POINT_LIGHTS > 0\\n\\n\tfor ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\\n\\n\t\tvec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\\n\t\tvec3 lVector = lPosition.xyz + vViewPosition.xyz;\\n\\n\t\tfloat attenuation = calcLightAttenuation( length( lVector ), pointLightDistance[ i ], pointLightDecay[ i ] );\\n\\n\t\tlVector = normalize( lVector );\\n\\n\t\t// diffuse\\n\\n\t\tfloat dotProduct = dot( normal, lVector );\\n\\n\t\t#ifdef WRAP_AROUND\\n\\n\t\t\tfloat pointDiffuseWeightFull = max( dotProduct, 0.0 );\\n\t\t\tfloat pointDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\\n\\n\t\t\tvec3 pointDiffuseWeight = mix( vec3( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );\\n\\n\t\t#else\\n\\n\t\t\tfloat pointDiffuseWeight = max( dotProduct, 0.0 );\\n\\n\t\t#endif\\n\\n\t\ttotalDiffuseLight += pointLightColor[ i ] * pointDiffuseWeight * attenuation;\\n\\n\t\t\t\t// specular\\n\\n\t\tvec3 pointHalfVector = normalize( lVector + viewPosition );\\n\t\tfloat pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\\n\t\tfloat pointSpecularWeight = specularStrength * max( pow( pointDotNormalHalf, shininess ), 0.0 );\\n\\n\t\tfloat specularNormalization = ( shininess + 2.0 ) / 8.0;\\n\\n\t\tvec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, pointHalfVector ), 0.0 ), 5.0 );\\n\t\ttotalSpecularLight += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * attenuation * specularNormalization;\\n\\n\t}\\n\\n#endif\\n\\n#if MAX_SPOT_LIGHTS > 0\\n\\n\tfor ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\\n\\n\t\tvec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\\n\t\tvec3 lVector = lPosition.xyz + vViewPosition.xyz;\\n\\n\t\tfloat attenuation = calcLightAttenuation( length( lVector ), spotLightDistance[ i ], spotLightDecay[ i ] );\\n\\n\t\tlVector = normalize( lVector );\\n\\n\t\tfloat spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );\\n\\n\t\tif ( spotEffect > spotLightAngleCos[ i ] ) {\\n\\n\t\t\tspotEffect = max( pow( max( spotEffect, 0.0 ), spotLightExponent[ i ] ), 0.0 );\\n\\n\t\t\t// diffuse\\n\\n\t\t\tfloat dotProduct = dot( normal, lVector );\\n\\n\t\t\t#ifdef WRAP_AROUND\\n\\n\t\t\t\tfloat spotDiffuseWeightFull = max( dotProduct, 0.0 );\\n\t\t\t\tfloat spotDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\\n\\n\t\t\t\tvec3 spotDiffuseWeight = mix( vec3( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );\\n\\n\t\t\t#else\\n\\n\t\t\t\tfloat spotDiffuseWeight = max( dotProduct, 0.0 );\\n\\n\t\t\t#endif\\n\\n\t\t\ttotalDiffuseLight += spotLightColor[ i ] * spotDiffuseWeight * attenuation * spotEffect;\\n\\n\t\t\t// specular\\n\\n\t\t\tvec3 spotHalfVector = normalize( lVector + viewPosition );\\n\t\t\tfloat spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );\\n\t\t\tfloat spotSpecularWeight = specularStrength * max( pow( spotDotNormalHalf, shininess ), 0.0 );\\n\\n\t\t\tfloat specularNormalization = ( shininess + 2.0 ) / 8.0;\\n\\n\t\t\tvec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, spotHalfVector ), 0.0 ), 5.0 );\\n\t\t\ttotalSpecularLight += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * attenuation * specularNormalization * spotEffect;\\n\\n\t\t}\\n\\n\t}\\n\\n#endif\\n\\n#if MAX_DIR_LIGHTS > 0\\n\\n\tfor( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\\n\\n\t\tvec3 dirVector = transformDirection( directionalLightDirection[ i ], viewMatrix );\\n\\n\t\t// diffuse\\n\\n\t\tfloat dotProduct = dot( normal, dirVector );\\n\\n\t\t#ifdef WRAP_AROUND\\n\\n\t\t\tfloat dirDiffuseWeightFull = max( dotProduct, 0.0 );\\n\t\t\tfloat dirDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\\n\\n\t\t\tvec3 dirDiffuseWeight = mix( vec3( dirDiffuseWeightFull ), vec3( dirDiffuseWeightHalf ), wrapRGB );\\n\\n\t\t#else\\n\\n\t\t\tfloat dirDiffuseWeight = max( dotProduct, 0.0 );\\n\\n\t\t#endif\\n\\n\t\ttotalDiffuseLight += directionalLightColor[ i ] * dirDiffuseWeight;\\n\\n\t\t// specular\\n\\n\t\tvec3 dirHalfVector = normalize( dirVector + viewPosition );\\n\t\tfloat dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\\n\t\tfloat dirSpecularWeight = specularStrength * max( pow( dirDotNormalHalf, shininess ), 0.0 );\\n\\n\t\t/*\\n\t\t// fresnel term from skin shader\\n\t\tconst float F0 = 0.128;\\n\\n\t\tfloat base = 1.0 - dot( viewPosition, dirHalfVector );\\n\t\tfloat exponential = pow( base, 5.0 );\\n\\n\t\tfloat fresnel = exponential + F0 * ( 1.0 - exponential );\\n\t\t*/\\n\\n\t\t/*\\n\t\t// fresnel term from fresnel shader\\n\t\tconst float mFresnelBias = 0.08;\\n\t\tconst float mFresnelScale = 0.3;\\n\t\tconst float mFresnelPower = 5.0;\\n\\n\t\tfloat fresnel = mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( -viewPosition ), normal ), mFresnelPower );\\n\t\t*/\\n\\n\t\tfloat specularNormalization = ( shininess + 2.0 ) / 8.0;\\n\\n\t\t// \t\tdirSpecular += specular * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization * fresnel;\\n\\n\t\tvec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( dirVector, dirHalfVector ), 0.0 ), 5.0 );\\n\t\ttotalSpecularLight += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\\n\\n\\n\t}\\n\\n#endif\\n\\n#if MAX_HEMI_LIGHTS > 0\\n\\n\tfor( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\\n\\n\t\tvec3 lVector = transformDirection( hemisphereLightDirection[ i ], viewMatrix );\\n\\n\t\t// diffuse\\n\\n\t\tfloat dotProduct = dot( normal, lVector );\\n\t\tfloat hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\\n\\n\t\tvec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\\n\\n\t\ttotalDiffuseLight += hemiColor;\\n\\n\t\t// specular (sky light)\\n\\n\t\tvec3 hemiHalfVectorSky = normalize( lVector + viewPosition );\\n\t\tfloat hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;\\n\t\tfloat hemiSpecularWeightSky = specularStrength * max( pow( max( hemiDotNormalHalfSky, 0.0 ), shininess ), 0.0 );\\n\\n\t\t// specular (ground light)\\n\\n\t\tvec3 lVectorGround = -lVector;\\n\\n\t\tvec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );\\n\t\tfloat hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;\\n\t\tfloat hemiSpecularWeightGround = specularStrength * max( pow( max( hemiDotNormalHalfGround, 0.0 ), shininess ), 0.0 );\\n\\n\t\tfloat dotProductGround = dot( normal, lVectorGround );\\n\\n\t\tfloat specularNormalization = ( shininess + 2.0 ) / 8.0;\\n\\n\t\tvec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, hemiHalfVectorSky ), 0.0 ), 5.0 );\\n\t\tvec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 0.0 ), 5.0 );\\n\t\ttotalSpecularLight += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );\\n\\n\t}\\n\\n#endif\\n\\n#ifdef METAL\\n\\n\toutgoingLight += diffuseColor.rgb * ( totalDiffuseLight + ambientLightColor ) * specular + totalSpecularLight + emissive;\\n\\n#else\\n\\n\toutgoingLight += diffuseColor.rgb * ( totalDiffuseLight + ambientLightColor ) + totalSpecularLight + emissive;\\n\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/fog_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'fog_pars_fragment'] = \"#ifdef USE_FOG\\n\\n\tuniform vec3 fogColor;\\n\\n\t#ifdef FOG_EXP2\\n\\n\t\tuniform float fogDensity;\\n\\n\t#else\\n\\n\t\tuniform float fogNear;\\n\t\tuniform float fogFar;\\n\t#endif\\n\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/morphnormal_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'morphnormal_vertex'] = \"#ifdef USE_MORPHNORMALS\\n\\n\tvec3 morphedNormal = vec3( 0.0 );\\n\\n\tmorphedNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\\n\tmorphedNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\\n\tmorphedNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\\n\tmorphedNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\\n\\n\tmorphedNormal += normal;\\n\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/envmap_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'envmap_pars_fragment'] = \"#ifdef USE_ENVMAP\\n\\n\tuniform float reflectivity;\\n\t#ifdef ENVMAP_TYPE_CUBE\\n\t\tuniform samplerCube envMap;\\n\t#else\\n\t\tuniform sampler2D envMap;\\n\t#endif\\n\tuniform float flipEnvMap;\\n\\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\\n\t\tuniform float refractionRatio;\\n\\n\t#else\\n\\n\t\tvarying vec3 vReflect;\\n\\n\t#endif\\n\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/logdepthbuf_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'logdepthbuf_fragment'] = \"#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\\n\\n\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\\n\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/normalmap_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'normalmap_pars_fragment'] = \"#ifdef USE_NORMALMAP\\n\\n\tuniform sampler2D normalMap;\\n\tuniform vec2 normalScale;\\n\\n\t// Per-Pixel Tangent Space Normal Mapping\\n\t// http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\\n\\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\\n\\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\\n\t\tvec2 st0 = dFdx( vUv.st );\\n\t\tvec2 st1 = dFdy( vUv.st );\\n\\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\\n\t\tvec3 N = normalize( surf_norm );\\n\\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\\n\t\tmapN.xy = normalScale * mapN.xy;\\n\t\tmat3 tsn = mat3( S, T, N );\\n\t\treturn normalize( tsn * mapN );\\n\\n\t}\\n\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/lights_phong_pars_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'lights_phong_pars_vertex'] = \"#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\\n\\n\tvarying vec3 vWorldPosition;\\n\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/lightmap_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'lightmap_pars_fragment'] = \"#ifdef USE_LIGHTMAP\\n\\n\tvarying vec2 vUv2;\\n\tuniform sampler2D lightMap;\\n\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/shadowmap_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'shadowmap_vertex'] = \"#ifdef USE_SHADOWMAP\\n\\n\tfor( int i = 0; i < MAX_SHADOWS; i ++ ) {\\n\\n\t\tvShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\\n\\n\t}\\n\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/lights_phong_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'lights_phong_vertex'] = \"#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\\n\\n\tvWorldPosition = worldPosition.xyz;\\n\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/map_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'map_fragment'] = \"#ifdef USE_MAP\\n\\n\tvec4 texelColor = texture2D( map, vUv );\\n\\n\ttexelColor.xyz = inputToLinear( texelColor.xyz );\\n\\n\tdiffuseColor *= texelColor;\\n\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/lightmap_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'lightmap_vertex'] = \"#ifdef USE_LIGHTMAP\\n\\n\tvUv2 = uv2;\\n\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/map_particle_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'map_particle_fragment'] = \"#ifdef USE_MAP\\n\\n\tdiffuseColor *= texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\\n\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/color_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'color_pars_fragment'] = \"#ifdef USE_COLOR\\n\\n\tvarying vec3 vColor;\\n\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/color_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'color_vertex'] = \"#ifdef USE_COLOR\\n\\n\tvColor.xyz = inputToLinear( color.xyz );\\n\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/skinning_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'skinning_vertex'] = \"#ifdef USE_SKINNING\\n\\n\t#ifdef USE_MORPHTARGETS\\n\\n\tvec4 skinVertex = bindMatrix * vec4( morphed, 1.0 );\\n\\n\t#else\\n\\n\tvec4 skinVertex = bindMatrix * vec4( position, 1.0 );\\n\\n\t#endif\\n\\n\tvec4 skinned = vec4( 0.0 );\\n\tskinned += boneMatX * skinVertex * skinWeight.x;\\n\tskinned += boneMatY * skinVertex * skinWeight.y;\\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\\n\tskinned += boneMatW * skinVertex * skinWeight.w;\\n\tskinned  = bindMatrixInverse * skinned;\\n\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/envmap_pars_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'envmap_pars_vertex'] = \"#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\\n\\n\tvarying vec3 vReflect;\\n\\n\tuniform float refractionRatio;\\n\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/linear_to_gamma_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'linear_to_gamma_fragment'] = \"\\n\toutgoingLight = linearToOutput( outgoingLight );\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/color_pars_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'color_pars_vertex'] = \"#ifdef USE_COLOR\\n\\n\tvarying vec3 vColor;\\n\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/lights_lambert_pars_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'lights_lambert_pars_vertex'] = \"uniform vec3 ambientLightColor;\\n\\n#if MAX_DIR_LIGHTS > 0\\n\\n\tuniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\\n\tuniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\\n\\n#endif\\n\\n#if MAX_HEMI_LIGHTS > 0\\n\\n\tuniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\\n\tuniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\\n\tuniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\\n\\n#endif\\n\\n#if MAX_POINT_LIGHTS > 0\\n\\n\tuniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\\n\tuniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\\n\tuniform float pointLightDistance[ MAX_POINT_LIGHTS ];\\n\tuniform float pointLightDecay[ MAX_POINT_LIGHTS ];\\n\\n#endif\\n\\n#if MAX_SPOT_LIGHTS > 0\\n\\n\tuniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\\n\tuniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\\n\tuniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\\n\tuniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\\n\tuniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\\n\tuniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\\n\tuniform float spotLightDecay[ MAX_SPOT_LIGHTS ];\\n\\n#endif\\n\\n#ifdef WRAP_AROUND\\n\\n\tuniform vec3 wrapRGB;\\n\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/map_pars_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'map_pars_vertex'] = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\\n\\n\tvarying vec2 vUv;\\n\tuniform vec4 offsetRepeat;\\n\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/envmap_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'envmap_fragment'] = \"#ifdef USE_ENVMAP\\n\\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\\n\\n\t\t// Transforming Normal Vectors with the Inverse Transformation\\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\\n\\n\t\t#ifdef ENVMAP_MODE_REFLECTION\\n\\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\\n\\n\t\t#else\\n\\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\\n\\n\t\t#endif\\n\\n\t#else\\n\\n\t\tvec3 reflectVec = vReflect;\\n\\n\t#endif\\n\\n\t#ifdef DOUBLE_SIDED\\n\t\tfloat flipNormal = ( -1.0 + 2.0 * float( gl_FrontFacing ) );\\n\t#else\\n\t\tfloat flipNormal = 1.0;\\n\t#endif\\n\\n\t#ifdef ENVMAP_TYPE_CUBE\\n\t\tvec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\\n\\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\\n\t\tvec2 sampleUV;\\n\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\\n\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\\n\\n\t#elif defined( ENVMAP_TYPE_SPHERE )\\n\t\tvec3 reflectView = flipNormal * normalize((viewMatrix * vec4( reflectVec, 0.0 )).xyz + vec3(0.0,0.0,1.0));\\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\\n\t#endif\\n\\n\tenvColor.xyz = inputToLinear( envColor.xyz );\\n\\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\\n\\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\\n\\n\t#elif defined( ENVMAP_BLENDING_MIX )\\n\\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\\n\\n\t#elif defined( ENVMAP_BLENDING_ADD )\\n\\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\\n\\n\t#endif\\n\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/specularmap_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'specularmap_pars_fragment'] = \"#ifdef USE_SPECULARMAP\\n\\n\tuniform sampler2D specularMap;\\n\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/logdepthbuf_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'logdepthbuf_vertex'] = \"#ifdef USE_LOGDEPTHBUF\\n\\n\tgl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\\n\\n\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\n\t\tvFragDepth = 1.0 + gl_Position.w;\\n\\n#else\\n\\n\t\tgl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\\n\\n\t#endif\\n\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/morphtarget_pars_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'morphtarget_pars_vertex'] = \"#ifdef USE_MORPHTARGETS\\n\\n\t#ifndef USE_MORPHNORMALS\\n\\n\tuniform float morphTargetInfluences[ 8 ];\\n\\n\t#else\\n\\n\tuniform float morphTargetInfluences[ 4 ];\\n\\n\t#endif\\n\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/specularmap_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'specularmap_fragment'] = \"float specularStrength;\\n\\n#ifdef USE_SPECULARMAP\\n\\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\\n\tspecularStrength = texelSpecular.r;\\n\\n#else\\n\\n\tspecularStrength = 1.0;\\n\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/fog_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'fog_fragment'] = \"#ifdef USE_FOG\\n\\n\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\n\t\tfloat depth = gl_FragDepthEXT / gl_FragCoord.w;\\n\\n\t#else\\n\\n\t\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\\n\\n\t#endif\\n\\n\t#ifdef FOG_EXP2\\n\\n\t\tfloat fogFactor = exp2( - square( fogDensity ) * square( depth ) * LOG2 );\\n\t\tfogFactor = whiteCompliment( fogFactor );\\n\\n\t#else\\n\\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, depth );\\n\\n\t#endif\\n\t\\n\toutgoingLight = mix( outgoingLight, fogColor, fogFactor );\\n\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/bumpmap_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'bumpmap_pars_fragment'] = \"#ifdef USE_BUMPMAP\\n\\n\tuniform sampler2D bumpMap;\\n\tuniform float bumpScale;\\n\\n\t// Derivative maps - bump mapping unparametrized surfaces by Morten Mikkelsen\\n\t// http://mmikkelsen3d.blogspot.sk/2011/07/derivative-maps.html\\n\\n\t// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\\n\\n\tvec2 dHdxy_fwd() {\\n\\n\t\tvec2 dSTdx = dFdx( vUv );\\n\t\tvec2 dSTdy = dFdy( vUv );\\n\\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\\n\\n\t\treturn vec2( dBx, dBy );\\n\\n\t}\\n\\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\\n\\n\t\tvec3 vSigmaX = dFdx( surf_pos );\\n\t\tvec3 vSigmaY = dFdy( surf_pos );\\n\t\tvec3 vN = surf_norm;\t\t// normalized\\n\\n\t\tvec3 R1 = cross( vSigmaY, vN );\\n\t\tvec3 R2 = cross( vN, vSigmaX );\\n\\n\t\tfloat fDet = dot( vSigmaX, R1 );\\n\\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\\n\\n\t}\\n\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/defaultnormal_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'defaultnormal_vertex'] = \"#ifdef USE_SKINNING\\n\\n\tvec3 objectNormal = skinnedNormal.xyz;\\n\\n#elif defined( USE_MORPHNORMALS )\\n\\n\tvec3 objectNormal = morphedNormal;\\n\\n#else\\n\\n\tvec3 objectNormal = normal;\\n\\n#endif\\n\\n#ifdef FLIP_SIDED\\n\\n\tobjectNormal = -objectNormal;\\n\\n#endif\\n\\nvec3 transformedNormal = normalMatrix * objectNormal;\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/lights_phong_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'lights_phong_pars_fragment'] = \"uniform vec3 ambientLightColor;\\n\\n#if MAX_DIR_LIGHTS > 0\\n\\n\tuniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\\n\tuniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\\n\\n#endif\\n\\n#if MAX_HEMI_LIGHTS > 0\\n\\n\tuniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\\n\tuniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\\n\tuniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\\n\\n#endif\\n\\n#if MAX_POINT_LIGHTS > 0\\n\\n\tuniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\\n\\n\tuniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\\n\tuniform float pointLightDistance[ MAX_POINT_LIGHTS ];\\n\tuniform float pointLightDecay[ MAX_POINT_LIGHTS ];\\n\\n#endif\\n\\n#if MAX_SPOT_LIGHTS > 0\\n\\n\tuniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\\n\tuniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\\n\tuniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\\n\tuniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\\n\tuniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\\n\tuniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\\n\tuniform float spotLightDecay[ MAX_SPOT_LIGHTS ];\\n\\n#endif\\n\\n#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\\n\\n\tvarying vec3 vWorldPosition;\\n\\n#endif\\n\\n#ifdef WRAP_AROUND\\n\\n\tuniform vec3 wrapRGB;\\n\\n#endif\\n\\nvarying vec3 vViewPosition;\\n\\n#ifndef FLAT_SHADED\\n\\n\tvarying vec3 vNormal;\\n\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/skinbase_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'skinbase_vertex'] = \"#ifdef USE_SKINNING\\n\\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\\n\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/map_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'map_vertex'] = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\\n\\n\tvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\\n\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/lightmap_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'lightmap_fragment'] = \"#ifdef USE_LIGHTMAP\\n\\n\toutgoingLight *= diffuseColor.xyz * texture2D( lightMap, vUv2 ).xyz;\\n\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'shadowmap_pars_vertex'] = \"#ifdef USE_SHADOWMAP\\n\\n\tvarying vec4 vShadowCoord[ MAX_SHADOWS ];\\n\tuniform mat4 shadowMatrix[ MAX_SHADOWS ];\\n\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/color_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'color_fragment'] = \"#ifdef USE_COLOR\\n\\n\tdiffuseColor.rgb *= vColor;\\n\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/morphtarget_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'morphtarget_vertex'] = \"#ifdef USE_MORPHTARGETS\\n\\n\tvec3 morphed = vec3( 0.0 );\\n\tmorphed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\\n\tmorphed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\\n\tmorphed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\\n\tmorphed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\\n\\n\t#ifndef USE_MORPHNORMALS\\n\\n\tmorphed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\\n\tmorphed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\\n\tmorphed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\\n\tmorphed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\\n\\n\t#endif\\n\\n\tmorphed += position;\\n\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/envmap_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'envmap_vertex'] = \"#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\\n\\n\tvec3 worldNormal = transformDirection( objectNormal, modelMatrix );\\n\\n\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\\n\\n\t#ifdef ENVMAP_MODE_REFLECTION\\n\\n\t\tvReflect = reflect( cameraToVertex, worldNormal );\\n\\n\t#else\\n\\n\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\\n\\n\t#endif\\n\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/shadowmap_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'shadowmap_fragment'] = \"#ifdef USE_SHADOWMAP\\n\\n\t#ifdef SHADOWMAP_DEBUG\\n\\n\t\tvec3 frustumColors[3];\\n\t\tfrustumColors[0] = vec3( 1.0, 0.5, 0.0 );\\n\t\tfrustumColors[1] = vec3( 0.0, 1.0, 0.8 );\\n\t\tfrustumColors[2] = vec3( 0.0, 0.5, 1.0 );\\n\\n\t#endif\\n\\n\t#ifdef SHADOWMAP_CASCADE\\n\\n\t\tint inFrustumCount = 0;\\n\\n\t#endif\\n\\n\tfloat fDepth;\\n\tvec3 shadowColor = vec3( 1.0 );\\n\\n\tfor( int i = 0; i < MAX_SHADOWS; i ++ ) {\\n\\n\t\tvec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;\\n\\n\t\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\\n\t\t\t\t// if ( all( something, something ) ) using this instead\\n\\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\\n\t\tbool inFrustum = all( inFrustumVec );\\n\\n\t\t\t\t// don't shadow pixels outside of light frustum\\n\t\t\t\t// use just first frustum (for cascades)\\n\t\t\t\t// don't shadow pixels behind far plane of light frustum\\n\\n\t\t#ifdef SHADOWMAP_CASCADE\\n\\n\t\t\tinFrustumCount += int( inFrustum );\\n\t\t\tbvec3 frustumTestVec = bvec3( inFrustum, inFrustumCount == 1, shadowCoord.z <= 1.0 );\\n\\n\t\t#else\\n\\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\\n\\n\t\t#endif\\n\\n\t\tbool frustumTest = all( frustumTestVec );\\n\\n\t\tif ( frustumTest ) {\\n\\n\t\t\tshadowCoord.z += shadowBias[ i ];\\n\\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\\n\\n\t\t\t\t\t\t// Percentage-close filtering\\n\t\t\t\t\t\t// (9 pixel kernel)\\n\t\t\t\t\t\t// http://fabiensanglard.net/shadowmappingPCF/\\n\\n\t\t\t\tfloat shadow = 0.0;\\n\\n\t\t/*\\n\t\t\t\t\t\t// nested loops breaks shader compiler / validator on some ATI cards when using OpenGL\\n\t\t\t\t\t\t// must enroll loop manually\\n\\n\t\t\t\tfor ( float y = -1.25; y <= 1.25; y += 1.25 )\\n\t\t\t\t\tfor ( float x = -1.25; x <= 1.25; x += 1.25 ) {\\n\\n\t\t\t\t\t\tvec4 rgbaDepth = texture2D( shadowMap[ i ], vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy );\\n\\n\t\t\t\t\t\t\t\t// doesn't seem to produce any noticeable visual difference compared to simple texture2D lookup\\n\t\t\t\t\t\t\t\t//vec4 rgbaDepth = texture2DProj( shadowMap[ i ], vec4( vShadowCoord[ i ].w * ( vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy ), 0.05, vShadowCoord[ i ].w ) );\\n\\n\t\t\t\t\t\tfloat fDepth = unpackDepth( rgbaDepth );\\n\\n\t\t\t\t\t\tif ( fDepth < shadowCoord.z )\\n\t\t\t\t\t\t\tshadow += 1.0;\\n\\n\t\t\t\t}\\n\\n\t\t\t\tshadow /= 9.0;\\n\\n\t\t*/\\n\\n\t\t\t\tconst float shadowDelta = 1.0 / 9.0;\\n\\n\t\t\t\tfloat xPixelOffset = 1.0 / shadowMapSize[ i ].x;\\n\t\t\t\tfloat yPixelOffset = 1.0 / shadowMapSize[ i ].y;\\n\\n\t\t\t\tfloat dx0 = -1.25 * xPixelOffset;\\n\t\t\t\tfloat dy0 = -1.25 * yPixelOffset;\\n\t\t\t\tfloat dx1 = 1.25 * xPixelOffset;\\n\t\t\t\tfloat dy1 = 1.25 * yPixelOffset;\\n\\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\n\\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\n\\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\n\\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\n\\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\n\\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\n\\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\n\\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\n\\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\n\\n\t\t\t\tshadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\\n\\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\\n\\n\t\t\t\t\t\t// Percentage-close filtering\\n\t\t\t\t\t\t// (9 pixel kernel)\\n\t\t\t\t\t\t// http://fabiensanglard.net/shadowmappingPCF/\\n\\n\t\t\t\tfloat shadow = 0.0;\\n\\n\t\t\t\tfloat xPixelOffset = 1.0 / shadowMapSize[ i ].x;\\n\t\t\t\tfloat yPixelOffset = 1.0 / shadowMapSize[ i ].y;\\n\\n\t\t\t\tfloat dx0 = -1.0 * xPixelOffset;\\n\t\t\t\tfloat dy0 = -1.0 * yPixelOffset;\\n\t\t\t\tfloat dx1 = 1.0 * xPixelOffset;\\n\t\t\t\tfloat dy1 = 1.0 * yPixelOffset;\\n\\n\t\t\t\tmat3 shadowKernel;\\n\t\t\t\tmat3 depthKernel;\\n\\n\t\t\t\tdepthKernel[0][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\\n\t\t\t\tdepthKernel[0][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\\n\t\t\t\tdepthKernel[0][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\\n\t\t\t\tdepthKernel[1][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\\n\t\t\t\tdepthKernel[1][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\\n\t\t\t\tdepthKernel[1][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\\n\t\t\t\tdepthKernel[2][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\\n\t\t\t\tdepthKernel[2][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\\n\t\t\t\tdepthKernel[2][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\\n\\n\t\t\t\tvec3 shadowZ = vec3( shadowCoord.z );\\n\t\t\t\tshadowKernel[0] = vec3(lessThan(depthKernel[0], shadowZ ));\\n\t\t\t\tshadowKernel[0] *= vec3(0.25);\\n\\n\t\t\t\tshadowKernel[1] = vec3(lessThan(depthKernel[1], shadowZ ));\\n\t\t\t\tshadowKernel[1] *= vec3(0.25);\\n\\n\t\t\t\tshadowKernel[2] = vec3(lessThan(depthKernel[2], shadowZ ));\\n\t\t\t\tshadowKernel[2] *= vec3(0.25);\\n\\n\t\t\t\tvec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[i].xy );\\n\\n\t\t\t\tshadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );\\n\t\t\t\tshadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );\\n\\n\t\t\t\tvec4 shadowValues;\\n\t\t\t\tshadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );\\n\t\t\t\tshadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );\\n\t\t\t\tshadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );\\n\t\t\t\tshadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );\\n\\n\t\t\t\tshadow = dot( shadowValues, vec4( 1.0 ) );\\n\\n\t\t\t\tshadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\\n\\n\t\t\t#else\\n\\n\t\t\t\tvec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );\\n\t\t\t\tfloat fDepth = unpackDepth( rgbaDepth );\\n\\n\t\t\t\tif ( fDepth < shadowCoord.z )\\n\\n\t\t// spot with multiple shadows is darker\\n\\n\t\t\t\t\tshadowColor = shadowColor * vec3( 1.0 - shadowDarkness[ i ] );\\n\\n\t\t// spot with multiple shadows has the same color as single shadow spot\\n\\n\t\t// \t\t\t\t\tshadowColor = min( shadowColor, vec3( shadowDarkness[ i ] ) );\\n\\n\t\t\t#endif\\n\\n\t\t}\\n\\n\\n\t\t#ifdef SHADOWMAP_DEBUG\\n\\n\t\t\t#ifdef SHADOWMAP_CASCADE\\n\\n\t\t\t\tif ( inFrustum && inFrustumCount == 1 ) outgoingLight *= frustumColors[ i ];\\n\\n\t\t\t#else\\n\\n\t\t\t\tif ( inFrustum ) outgoingLight *= frustumColors[ i ];\\n\\n\t\t\t#endif\\n\\n\t\t#endif\\n\\n\t}\\n\\n\t// NOTE: I am unsure if this is correct in linear space.  -bhouston, Dec 29, 2014\\n\tshadowColor = inputToLinear( shadowColor );\\n\\n\toutgoingLight = outgoingLight * shadowColor;\\n\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/worldpos_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'worldpos_vertex'] = \"#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\\n\\n\t#ifdef USE_SKINNING\\n\\n\t\tvec4 worldPosition = modelMatrix * skinned;\\n\\n\t#elif defined( USE_MORPHTARGETS )\\n\\n\t\tvec4 worldPosition = modelMatrix * vec4( morphed, 1.0 );\\n\\n\t#else\\n\\n\t\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\\n\\n\t#endif\\n\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'shadowmap_pars_fragment'] = \"#ifdef USE_SHADOWMAP\\n\\n\tuniform sampler2D shadowMap[ MAX_SHADOWS ];\\n\tuniform vec2 shadowMapSize[ MAX_SHADOWS ];\\n\\n\tuniform float shadowDarkness[ MAX_SHADOWS ];\\n\tuniform float shadowBias[ MAX_SHADOWS ];\\n\\n\tvarying vec4 vShadowCoord[ MAX_SHADOWS ];\\n\\n\tfloat unpackDepth( const in vec4 rgba_depth ) {\\n\\n\t\tconst vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\\n\t\tfloat depth = dot( rgba_depth, bit_shift );\\n\t\treturn depth;\\n\\n\t}\\n\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/skinning_pars_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'skinning_pars_vertex'] = \"#ifdef USE_SKINNING\\n\\n\tuniform mat4 bindMatrix;\\n\tuniform mat4 bindMatrixInverse;\\n\\n\t#ifdef BONE_TEXTURE\\n\\n\t\tuniform sampler2D boneTexture;\\n\t\tuniform int boneTextureWidth;\\n\t\tuniform int boneTextureHeight;\\n\\n\t\tmat4 getBoneMatrix( const in float i ) {\\n\\n\t\t\tfloat j = i * 4.0;\\n\t\t\tfloat x = mod( j, float( boneTextureWidth ) );\\n\t\t\tfloat y = floor( j / float( boneTextureWidth ) );\\n\\n\t\t\tfloat dx = 1.0 / float( boneTextureWidth );\\n\t\t\tfloat dy = 1.0 / float( boneTextureHeight );\\n\\n\t\t\ty = dy * ( y + 0.5 );\\n\\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\\n\\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\\n\\n\t\t\treturn bone;\\n\\n\t\t}\\n\\n\t#else\\n\\n\t\tuniform mat4 boneGlobalMatrices[ MAX_BONES ];\\n\\n\t\tmat4 getBoneMatrix( const in float i ) {\\n\\n\t\t\tmat4 bone = boneGlobalMatrices[ int(i) ];\\n\t\t\treturn bone;\\n\\n\t\t}\\n\\n\t#endif\\n\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'logdepthbuf_pars_fragment'] = \"#ifdef USE_LOGDEPTHBUF\\n\\n\tuniform float logDepthBufFC;\\n\\n\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\n\t\t#extension GL_EXT_frag_depth : enable\\n\t\tvarying float vFragDepth;\\n\\n\t#endif\\n\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/alphamap_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'alphamap_fragment'] = \"#ifdef USE_ALPHAMAP\\n\\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\\n\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/alphamap_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'alphamap_pars_fragment'] = \"#ifdef USE_ALPHAMAP\\n\\n\tuniform sampler2D alphaMap;\\n\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/UniformsUtils.js\r\n\t\r\n\t/**\r\n\t * Uniform Utilities\r\n\t */\r\n\t\r\n\tTHREE.UniformsUtils = {\r\n\t\r\n\t\tmerge: function ( uniforms ) {\r\n\t\r\n\t\t\tvar merged = {};\r\n\t\r\n\t\t\tfor ( var u = 0; u < uniforms.length; u ++ ) {\r\n\t\r\n\t\t\t\tvar tmp = this.clone( uniforms[ u ] );\r\n\t\r\n\t\t\t\tfor ( var p in tmp ) {\r\n\t\r\n\t\t\t\t\tmerged[ p ] = tmp[ p ];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn merged;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function ( uniforms_src ) {\r\n\t\r\n\t\t\tvar uniforms_dst = {};\r\n\t\r\n\t\t\tfor ( var u in uniforms_src ) {\r\n\t\r\n\t\t\t\tuniforms_dst[ u ] = {};\r\n\t\r\n\t\t\t\tfor ( var p in uniforms_src[ u ] ) {\r\n\t\r\n\t\t\t\t\tvar parameter_src = uniforms_src[ u ][ p ];\r\n\t\r\n\t\t\t\t\tif ( parameter_src instanceof THREE.Color ||\r\n\t\t\t\t\t\t parameter_src instanceof THREE.Vector2 ||\r\n\t\t\t\t\t\t parameter_src instanceof THREE.Vector3 ||\r\n\t\t\t\t\t\t parameter_src instanceof THREE.Vector4 ||\r\n\t\t\t\t\t\t parameter_src instanceof THREE.Matrix4 ||\r\n\t\t\t\t\t\t parameter_src instanceof THREE.Texture ) {\r\n\t\r\n\t\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src.clone();\r\n\t\r\n\t\t\t\t\t} else if ( parameter_src instanceof Array ) {\r\n\t\r\n\t\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src.slice();\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn uniforms_dst;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/renderers/shaders/UniformsLib.js\r\n\t\r\n\t/**\r\n\t * Uniforms library for shared webgl shaders\r\n\t */\r\n\t\r\n\tTHREE.UniformsLib = {\r\n\t\r\n\t\tcommon: {\r\n\t\r\n\t\t\t\"diffuse\" : { type: \"c\", value: new THREE.Color( 0xeeeeee ) },\r\n\t\t\t\"opacity\" : { type: \"f\", value: 1.0 },\r\n\t\r\n\t\t\t\"map\" : { type: \"t\", value: null },\r\n\t\t\t\"offsetRepeat\" : { type: \"v4\", value: new THREE.Vector4( 0, 0, 1, 1 ) },\r\n\t\r\n\t\t\t\"lightMap\" : { type: \"t\", value: null },\r\n\t\t\t\"specularMap\" : { type: \"t\", value: null },\r\n\t\t\t\"alphaMap\" : { type: \"t\", value: null },\r\n\t\r\n\t\t\t\"envMap\" : { type: \"t\", value: null },\r\n\t\t\t\"flipEnvMap\" : { type: \"f\", value: - 1 },\r\n\t\t\t\"reflectivity\" : { type: \"f\", value: 1.0 },\r\n\t\t\t\"refractionRatio\" : { type: \"f\", value: 0.98 },\r\n\t\r\n\t\t\t\"morphTargetInfluences\" : { type: \"f\", value: 0 }\r\n\t\r\n\t\t},\r\n\t\r\n\t\tbump: {\r\n\t\r\n\t\t\t\"bumpMap\" : { type: \"t\", value: null },\r\n\t\t\t\"bumpScale\" : { type: \"f\", value: 1 }\r\n\t\r\n\t\t},\r\n\t\r\n\t\tnormalmap: {\r\n\t\r\n\t\t\t\"normalMap\" : { type: \"t\", value: null },\r\n\t\t\t\"normalScale\" : { type: \"v2\", value: new THREE.Vector2( 1, 1 ) }\r\n\t\t},\r\n\t\r\n\t\tfog : {\r\n\t\r\n\t\t\t\"fogDensity\" : { type: \"f\", value: 0.00025 },\r\n\t\t\t\"fogNear\" : { type: \"f\", value: 1 },\r\n\t\t\t\"fogFar\" : { type: \"f\", value: 2000 },\r\n\t\t\t\"fogColor\" : { type: \"c\", value: new THREE.Color( 0xffffff ) }\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlights: {\r\n\t\r\n\t\t\t\"ambientLightColor\" : { type: \"fv\", value: [] },\r\n\t\r\n\t\t\t\"directionalLightDirection\" : { type: \"fv\", value: [] },\r\n\t\t\t\"directionalLightColor\" : { type: \"fv\", value: [] },\r\n\t\r\n\t\t\t\"hemisphereLightDirection\" : { type: \"fv\", value: [] },\r\n\t\t\t\"hemisphereLightSkyColor\" : { type: \"fv\", value: [] },\r\n\t\t\t\"hemisphereLightGroundColor\" : { type: \"fv\", value: [] },\r\n\t\r\n\t\t\t\"pointLightColor\" : { type: \"fv\", value: [] },\r\n\t\t\t\"pointLightPosition\" : { type: \"fv\", value: [] },\r\n\t\t\t\"pointLightDistance\" : { type: \"fv1\", value: [] },\r\n\t\t\t\"pointLightDecay\" : { type: \"fv1\", value: [] },\r\n\t\r\n\t\t\t\"spotLightColor\" : { type: \"fv\", value: [] },\r\n\t\t\t\"spotLightPosition\" : { type: \"fv\", value: [] },\r\n\t\t\t\"spotLightDirection\" : { type: \"fv\", value: [] },\r\n\t\t\t\"spotLightDistance\" : { type: \"fv1\", value: [] },\r\n\t\t\t\"spotLightAngleCos\" : { type: \"fv1\", value: [] },\r\n\t\t\t\"spotLightExponent\" : { type: \"fv1\", value: [] },\r\n\t\t\t\"spotLightDecay\" : { type: \"fv1\", value: [] }\r\n\t\r\n\t\t},\r\n\t\r\n\t\tparticle: {\r\n\t\r\n\t\t\t\"psColor\" : { type: \"c\", value: new THREE.Color( 0xeeeeee ) },\r\n\t\t\t\"opacity\" : { type: \"f\", value: 1.0 },\r\n\t\t\t\"size\" : { type: \"f\", value: 1.0 },\r\n\t\t\t\"scale\" : { type: \"f\", value: 1.0 },\r\n\t\t\t\"map\" : { type: \"t\", value: null },\r\n\t\t\t\"offsetRepeat\" : { type: \"v4\", value: new THREE.Vector4( 0, 0, 1, 1 ) },\r\n\t\r\n\t\t\t\"fogDensity\" : { type: \"f\", value: 0.00025 },\r\n\t\t\t\"fogNear\" : { type: \"f\", value: 1 },\r\n\t\t\t\"fogFar\" : { type: \"f\", value: 2000 },\r\n\t\t\t\"fogColor\" : { type: \"c\", value: new THREE.Color( 0xffffff ) }\r\n\t\r\n\t\t},\r\n\t\r\n\t\tshadowmap: {\r\n\t\r\n\t\t\t\"shadowMap\": { type: \"tv\", value: [] },\r\n\t\t\t\"shadowMapSize\": { type: \"v2v\", value: [] },\r\n\t\r\n\t\t\t\"shadowBias\" : { type: \"fv1\", value: [] },\r\n\t\t\t\"shadowDarkness\": { type: \"fv1\", value: [] },\r\n\t\r\n\t\t\t\"shadowMatrix\" : { type: \"m4v\", value: [] }\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/renderers/shaders/ShaderLib.js\r\n\t\r\n\t/**\r\n\t * Webgl Shader Library for three.js\r\n\t *\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author mikael emtinger / http://gomo.se/\r\n\t */\r\n\t\r\n\t\r\n\tTHREE.ShaderLib = {\r\n\t\r\n\t\t'basic': {\r\n\t\r\n\t\t\tuniforms: THREE.UniformsUtils.merge( [\r\n\t\r\n\t\t\t\tTHREE.UniformsLib[ \"common\" ],\r\n\t\t\t\tTHREE.UniformsLib[ \"fog\" ],\r\n\t\t\t\tTHREE.UniformsLib[ \"shadowmap\" ]\r\n\t\r\n\t\t\t] ),\r\n\t\r\n\t\t\tvertexShader: [\r\n\t\r\n\t\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"map_pars_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"lightmap_pars_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"envmap_pars_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"color_pars_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"morphtarget_pars_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"skinning_pars_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_pars_vertex\" ],\r\n\t\r\n\t\t\t\t\"void main() {\",\r\n\t\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"map_vertex\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"lightmap_vertex\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"color_vertex\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"skinbase_vertex\" ],\r\n\t\r\n\t\t\t\t\"\t#ifdef USE_ENVMAP\",\r\n\t\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"morphnormal_vertex\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"skinnormal_vertex\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"defaultnormal_vertex\" ],\r\n\t\r\n\t\t\t\t\"\t#endif\",\r\n\t\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"morphtarget_vertex\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"skinning_vertex\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"default_vertex\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_vertex\" ],\r\n\t\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"worldpos_vertex\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"envmap_vertex\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_vertex\" ],\r\n\t\r\n\t\t\t\t\"}\"\r\n\t\r\n\t\t\t].join(\"\\n\"),\r\n\t\r\n\t\t\tfragmentShader: [\r\n\t\r\n\t\t\t\t\"uniform vec3 diffuse;\",\r\n\t\t\t\t\"uniform float opacity;\",\r\n\t\r\n\t\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"color_pars_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"map_pars_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"alphamap_pars_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"lightmap_pars_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"envmap_pars_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"fog_pars_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"specularmap_pars_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_pars_fragment\" ],\r\n\t\r\n\t\t\t\t\"void main() {\",\r\n\t\r\n\t\t\t\t\"\tvec3 outgoingLight = vec3( 0.0 );\",\t// outgoing light does not have an alpha, the surface does\r\n\t\t\t\t\"\tvec4 diffuseColor = vec4( diffuse, opacity );\",\r\n\t\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_fragment\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"map_fragment\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"color_fragment\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"alphamap_fragment\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"alphatest_fragment\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"specularmap_fragment\" ],\r\n\t\r\n\t\t\t\t\"\toutgoingLight = diffuseColor.rgb;\", // simple shader\r\n\t\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"lightmap_fragment\" ],\t\t// TODO: Light map on an otherwise unlit surface doesn't make sense.\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"envmap_fragment\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_fragment\" ],\t\t// TODO: Shadows on an otherwise unlit surface doesn't make sense.\r\n\t\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"linear_to_gamma_fragment\" ],\r\n\t\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"fog_fragment\" ],\r\n\t\r\n\t\t\t\t\"\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\",\t// TODO, this should be pre-multiplied to allow for bright highlights on very transparent objects\r\n\t\r\n\t\t\t\t\"}\"\r\n\t\r\n\t\t\t].join(\"\\n\")\r\n\t\r\n\t\t},\r\n\t\r\n\t\t'lambert': {\r\n\t\r\n\t\t\tuniforms: THREE.UniformsUtils.merge( [\r\n\t\r\n\t\t\t\tTHREE.UniformsLib[ \"common\" ],\r\n\t\t\t\tTHREE.UniformsLib[ \"fog\" ],\r\n\t\t\t\tTHREE.UniformsLib[ \"lights\" ],\r\n\t\t\t\tTHREE.UniformsLib[ \"shadowmap\" ],\r\n\t\r\n\t\t\t\t{\r\n\t\t\t\t\t\"emissive\" : { type: \"c\", value: new THREE.Color( 0x000000 ) },\r\n\t\t\t\t\t\"wrapRGB\"  : { type: \"v3\", value: new THREE.Vector3( 1, 1, 1 ) }\r\n\t\t\t\t}\r\n\t\r\n\t\t\t] ),\r\n\t\r\n\t\t\tvertexShader: [\r\n\t\r\n\t\t\t\t\"#define LAMBERT\",\r\n\t\r\n\t\t\t\t\"varying vec3 vLightFront;\",\r\n\t\r\n\t\t\t\t\"#ifdef DOUBLE_SIDED\",\r\n\t\r\n\t\t\t\t\"\tvarying vec3 vLightBack;\",\r\n\t\r\n\t\t\t\t\"#endif\",\r\n\t\r\n\t\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"map_pars_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"lightmap_pars_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"envmap_pars_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"lights_lambert_pars_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"color_pars_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"morphtarget_pars_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"skinning_pars_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_pars_vertex\" ],\r\n\t\r\n\t\t\t\t\"void main() {\",\r\n\t\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"map_vertex\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"lightmap_vertex\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"color_vertex\" ],\r\n\t\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"morphnormal_vertex\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"skinbase_vertex\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"skinnormal_vertex\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"defaultnormal_vertex\" ],\r\n\t\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"morphtarget_vertex\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"skinning_vertex\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"default_vertex\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_vertex\" ],\r\n\t\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"worldpos_vertex\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"envmap_vertex\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"lights_lambert_vertex\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_vertex\" ],\r\n\t\r\n\t\t\t\t\"}\"\r\n\t\r\n\t\t\t].join(\"\\n\"),\r\n\t\r\n\t\t\tfragmentShader: [\r\n\t\r\n\t\t\t\t\"uniform vec3 diffuse;\",\r\n\t\t\t\t\"uniform vec3 emissive;\",\r\n\t\t\t\t\"uniform float opacity;\",\r\n\t\r\n\t\t\t\t\"varying vec3 vLightFront;\",\r\n\t\r\n\t\t\t\t\"#ifdef DOUBLE_SIDED\",\r\n\t\r\n\t\t\t\t\"\tvarying vec3 vLightBack;\",\r\n\t\r\n\t\t\t\t\"#endif\",\r\n\t\r\n\t\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"color_pars_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"map_pars_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"alphamap_pars_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"lightmap_pars_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"envmap_pars_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"fog_pars_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"specularmap_pars_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_pars_fragment\" ],\r\n\t\r\n\t\t\t\t\"void main() {\",\r\n\t\r\n\t\t\t\t\"\tvec3 outgoingLight = vec3( 0.0 );\",\t// outgoing light does not have an alpha, the surface does\r\n\t\t\t\t\"\tvec4 diffuseColor = vec4( diffuse, opacity );\",\r\n\t\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_fragment\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"map_fragment\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"color_fragment\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"alphamap_fragment\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"alphatest_fragment\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"specularmap_fragment\" ],\r\n\t\r\n\t\t\t\t\"\t#ifdef DOUBLE_SIDED\",\r\n\t\r\n\t\t\t\t\t\t//\"float isFront = float( gl_FrontFacing );\",\r\n\t\t\t\t\t\t//\"gl_FragColor.xyz *= isFront * vLightFront + ( 1.0 - isFront ) * vLightBack;\",\r\n\t\r\n\t\t\t\t\"\t\tif ( gl_FrontFacing )\",\r\n\t\t\t\t\"\t\t\toutgoingLight += diffuseColor.rgb * vLightFront + emissive;\",\r\n\t\t\t\t\"\t\telse\",\r\n\t\t\t\t\"\t\t\toutgoingLight += diffuseColor.rgb * vLightBack + emissive;\",\r\n\t\r\n\t\t\t\t\"\t#else\",\r\n\t\r\n\t\t\t\t\"\t\toutgoingLight += diffuseColor.rgb * vLightFront + emissive;\",\r\n\t\r\n\t\t\t\t\"\t#endif\",\r\n\t\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"lightmap_fragment\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"envmap_fragment\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_fragment\" ],\r\n\t\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"linear_to_gamma_fragment\" ],\r\n\t\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"fog_fragment\" ],\r\n\t\r\n\t\t\t\t\"\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\",\t// TODO, this should be pre-multiplied to allow for bright highlights on very transparent objects\r\n\t\r\n\t\t\t\t\"}\"\r\n\t\r\n\t\t\t].join(\"\\n\")\r\n\t\r\n\t\t},\r\n\t\r\n\t\t'phong': {\r\n\t\r\n\t\t\tuniforms: THREE.UniformsUtils.merge( [\r\n\t\r\n\t\t\t\tTHREE.UniformsLib[ \"common\" ],\r\n\t\t\t\tTHREE.UniformsLib[ \"bump\" ],\r\n\t\t\t\tTHREE.UniformsLib[ \"normalmap\" ],\r\n\t\t\t\tTHREE.UniformsLib[ \"fog\" ],\r\n\t\t\t\tTHREE.UniformsLib[ \"lights\" ],\r\n\t\t\t\tTHREE.UniformsLib[ \"shadowmap\" ],\r\n\t\r\n\t\t\t\t{\r\n\t\t\t\t\t\"emissive\" : { type: \"c\", value: new THREE.Color( 0x000000 ) },\r\n\t\t\t\t\t\"specular\" : { type: \"c\", value: new THREE.Color( 0x111111 ) },\r\n\t\t\t\t\t\"shininess\": { type: \"f\", value: 30 },\r\n\t\t\t\t\t\"wrapRGB\"  : { type: \"v3\", value: new THREE.Vector3( 1, 1, 1 ) }\r\n\t\t\t\t}\r\n\t\r\n\t\t\t] ),\r\n\t\r\n\t\t\tvertexShader: [\r\n\t\r\n\t\t\t\t\"#define PHONG\",\r\n\t\r\n\t\t\t\t\"varying vec3 vViewPosition;\",\r\n\t\r\n\t\t\t\t\"#ifndef FLAT_SHADED\",\r\n\t\r\n\t\t\t\t\"\tvarying vec3 vNormal;\",\r\n\t\r\n\t\t\t\t\"#endif\",\r\n\t\r\n\t\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"map_pars_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"lightmap_pars_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"envmap_pars_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"lights_phong_pars_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"color_pars_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"morphtarget_pars_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"skinning_pars_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_pars_vertex\" ],\r\n\t\r\n\t\t\t\t\"void main() {\",\r\n\t\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"map_vertex\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"lightmap_vertex\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"color_vertex\" ],\r\n\t\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"morphnormal_vertex\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"skinbase_vertex\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"skinnormal_vertex\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"defaultnormal_vertex\" ],\r\n\t\r\n\t\t\t\t\"#ifndef FLAT_SHADED\", // Normal computed with derivatives when FLAT_SHADED\r\n\t\r\n\t\t\t\t\"\tvNormal = normalize( transformedNormal );\",\r\n\t\r\n\t\t\t\t\"#endif\",\r\n\t\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"morphtarget_vertex\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"skinning_vertex\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"default_vertex\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_vertex\" ],\r\n\t\r\n\t\t\t\t\"\tvViewPosition = -mvPosition.xyz;\",\r\n\t\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"worldpos_vertex\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"envmap_vertex\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"lights_phong_vertex\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_vertex\" ],\r\n\t\r\n\t\t\t\t\"}\"\r\n\t\r\n\t\t\t].join(\"\\n\"),\r\n\t\r\n\t\t\tfragmentShader: [\r\n\t\r\n\t\t\t\t\"#define PHONG\",\r\n\t\r\n\t\t\t\t\"uniform vec3 diffuse;\",\r\n\t\t\t\t\"uniform vec3 emissive;\",\r\n\t\t\t\t\"uniform vec3 specular;\",\r\n\t\t\t\t\"uniform float shininess;\",\r\n\t\t\t\t\"uniform float opacity;\",\r\n\t\r\n\t\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"color_pars_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"map_pars_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"alphamap_pars_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"lightmap_pars_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"envmap_pars_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"fog_pars_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"lights_phong_pars_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"bumpmap_pars_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"normalmap_pars_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"specularmap_pars_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_pars_fragment\" ],\r\n\t\r\n\t\t\t\t\"void main() {\",\r\n\t\r\n\t\t\t\t\"\tvec3 outgoingLight = vec3( 0.0 );\",\t// outgoing light does not have an alpha, the surface does\r\n\t\t\t\t\"\tvec4 diffuseColor = vec4( diffuse, opacity );\",\r\n\t\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_fragment\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"map_fragment\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"color_fragment\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"alphamap_fragment\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"alphatest_fragment\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"specularmap_fragment\" ],\r\n\t\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"lights_phong_fragment\" ],\r\n\t\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"lightmap_fragment\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"envmap_fragment\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_fragment\" ],\r\n\t\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"linear_to_gamma_fragment\" ],\r\n\t\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"fog_fragment\" ],\r\n\t\r\n\t\t\t\t\"\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\",\t// TODO, this should be pre-multiplied to allow for bright highlights on very transparent objects\r\n\t\r\n\t\t\t\t\"}\"\r\n\t\r\n\t\t\t].join(\"\\n\")\r\n\t\r\n\t\t},\r\n\t\r\n\t\t'particle_basic': {\r\n\t\r\n\t\t\tuniforms: THREE.UniformsUtils.merge( [\r\n\t\r\n\t\t\t\tTHREE.UniformsLib[ \"particle\" ],\r\n\t\t\t\tTHREE.UniformsLib[ \"shadowmap\" ]\r\n\t\r\n\t\t\t] ),\r\n\t\r\n\t\t\tvertexShader: [\r\n\t\r\n\t\t\t\t\"uniform float size;\",\r\n\t\t\t\t\"uniform float scale;\",\r\n\t\r\n\t\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"color_pars_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_pars_vertex\" ],\r\n\t\r\n\t\t\t\t\"void main() {\",\r\n\t\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"color_vertex\" ],\r\n\t\r\n\t\t\t\t\"\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\",\r\n\t\r\n\t\t\t\t\"\t#ifdef USE_SIZEATTENUATION\",\r\n\t\t\t\t\"\t\tgl_PointSize = size * ( scale / length( mvPosition.xyz ) );\",\r\n\t\t\t\t\"\t#else\",\r\n\t\t\t\t\"\t\tgl_PointSize = size;\",\r\n\t\t\t\t\"\t#endif\",\r\n\t\r\n\t\t\t\t\"\tgl_Position = projectionMatrix * mvPosition;\",\r\n\t\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_vertex\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"worldpos_vertex\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_vertex\" ],\r\n\t\r\n\t\t\t\t\"}\"\r\n\t\r\n\t\t\t].join(\"\\n\"),\r\n\t\r\n\t\t\tfragmentShader: [\r\n\t\r\n\t\t\t\t\"uniform vec3 psColor;\",\r\n\t\t\t\t\"uniform float opacity;\",\r\n\t\r\n\t\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"color_pars_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"map_particle_pars_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"fog_pars_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_pars_fragment\" ],\r\n\t\r\n\t\t\t\t\"void main() {\",\r\n\t\r\n\t\t\t\t\"\tvec3 outgoingLight = vec3( 0.0 );\",\t// outgoing light does not have an alpha, the surface does\r\n\t\t\t\t\"\tvec4 diffuseColor = vec4( psColor, opacity );\",\r\n\t\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_fragment\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"map_particle_fragment\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"color_fragment\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"alphatest_fragment\" ],\r\n\t\r\n\t\t\t\t\"\toutgoingLight = diffuseColor.rgb;\", // simple shader\r\n\t\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_fragment\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"fog_fragment\" ],\r\n\t\r\n\t\t\t\t\"\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\",\t// TODO, this should be pre-multiplied to allow for bright highlights on very transparent objects\r\n\t\r\n\t\t\t\t\"}\"\r\n\t\r\n\t\t\t].join(\"\\n\")\r\n\t\r\n\t\t},\r\n\t\r\n\t\t'dashed': {\r\n\t\r\n\t\t\tuniforms: THREE.UniformsUtils.merge( [\r\n\t\r\n\t\t\t\tTHREE.UniformsLib[ \"common\" ],\r\n\t\t\t\tTHREE.UniformsLib[ \"fog\" ],\r\n\t\r\n\t\t\t\t{\r\n\t\t\t\t\t\"scale\"    : { type: \"f\", value: 1 },\r\n\t\t\t\t\t\"dashSize\" : { type: \"f\", value: 1 },\r\n\t\t\t\t\t\"totalSize\": { type: \"f\", value: 2 }\r\n\t\t\t\t}\r\n\t\r\n\t\t\t] ),\r\n\t\r\n\t\t\tvertexShader: [\r\n\t\r\n\t\t\t\t\"uniform float scale;\",\r\n\t\t\t\t\"attribute float lineDistance;\",\r\n\t\r\n\t\t\t\t\"varying float vLineDistance;\",\r\n\t\r\n\t\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"color_pars_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_pars_vertex\" ],\r\n\t\r\n\t\t\t\t\"void main() {\",\r\n\t\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"color_vertex\" ],\r\n\t\r\n\t\t\t\t\"\tvLineDistance = scale * lineDistance;\",\r\n\t\r\n\t\t\t\t\"\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\",\r\n\t\t\t\t\"\tgl_Position = projectionMatrix * mvPosition;\",\r\n\t\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_vertex\" ],\r\n\t\r\n\t\t\t\t\"}\"\r\n\t\r\n\t\t\t].join(\"\\n\"),\r\n\t\r\n\t\t\tfragmentShader: [\r\n\t\r\n\t\t\t\t\"uniform vec3 diffuse;\",\r\n\t\t\t\t\"uniform float opacity;\",\r\n\t\r\n\t\t\t\t\"uniform float dashSize;\",\r\n\t\t\t\t\"uniform float totalSize;\",\r\n\t\r\n\t\t\t\t\"varying float vLineDistance;\",\r\n\t\r\n\t\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"color_pars_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"fog_pars_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_pars_fragment\" ],\r\n\t\r\n\t\t\t\t\"void main() {\",\r\n\t\r\n\t\t\t\t\"\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\",\r\n\t\r\n\t\t\t\t\"\t\tdiscard;\",\r\n\t\r\n\t\t\t\t\"\t}\",\r\n\t\r\n\t\t\t\t\"\tvec3 outgoingLight = vec3( 0.0 );\",\t// outgoing light does not have an alpha, the surface does\r\n\t\t\t\t\"\tvec4 diffuseColor = vec4( diffuse, opacity );\",\r\n\t\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_fragment\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"color_fragment\" ],\r\n\t\r\n\t\t\t\t\"\toutgoingLight = diffuseColor.rgb;\", // simple shader\r\n\t\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"fog_fragment\" ],\r\n\t\r\n\t\t\t\t\"\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\",\t// TODO, this should be pre-multiplied to allow for bright highlights on very transparent objects\r\n\t\r\n\t\t\t\t\"}\"\r\n\t\r\n\t\t\t].join(\"\\n\")\r\n\t\r\n\t\t},\r\n\t\r\n\t\t'depth': {\r\n\t\r\n\t\t\tuniforms: {\r\n\t\r\n\t\t\t\t\"mNear\": { type: \"f\", value: 1.0 },\r\n\t\t\t\t\"mFar\" : { type: \"f\", value: 2000.0 },\r\n\t\t\t\t\"opacity\" : { type: \"f\", value: 1.0 }\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\t\tvertexShader: [\r\n\t\r\n\t\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"morphtarget_pars_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_pars_vertex\" ],\r\n\t\r\n\t\t\t\t\"void main() {\",\r\n\t\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"morphtarget_vertex\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"default_vertex\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_vertex\" ],\r\n\t\r\n\t\t\t\t\"}\"\r\n\t\r\n\t\t\t].join(\"\\n\"),\r\n\t\r\n\t\t\tfragmentShader: [\r\n\t\r\n\t\t\t\t\"uniform float mNear;\",\r\n\t\t\t\t\"uniform float mFar;\",\r\n\t\t\t\t\"uniform float opacity;\",\r\n\t\r\n\t\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_pars_fragment\" ],\r\n\t\r\n\t\t\t\t\"void main() {\",\r\n\t\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_fragment\" ],\r\n\t\r\n\t\t\t\t\"\t#ifdef USE_LOGDEPTHBUF_EXT\",\r\n\t\r\n\t\t\t\t\"\t\tfloat depth = gl_FragDepthEXT / gl_FragCoord.w;\",\r\n\t\r\n\t\t\t\t\"\t#else\",\r\n\t\r\n\t\t\t\t\"\t\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\",\r\n\t\r\n\t\t\t\t\"\t#endif\",\r\n\t\r\n\t\t\t\t\"\tfloat color = 1.0 - smoothstep( mNear, mFar, depth );\",\r\n\t\t\t\t\"\tgl_FragColor = vec4( vec3( color ), opacity );\",   // TODO, this should be pre-multiplied to allow for bright highlights on very transparent objects\r\n\t\r\n\t\t\t\t\"}\"\r\n\t\r\n\t\t\t].join(\"\\n\")\r\n\t\r\n\t\t},\r\n\t\r\n\t\t'normal': {\r\n\t\r\n\t\t\tuniforms: {\r\n\t\r\n\t\t\t\t\"opacity\" : { type: \"f\", value: 1.0 }\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\t\tvertexShader: [\r\n\t\r\n\t\t\t\t\"varying vec3 vNormal;\",\r\n\t\r\n\t\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"morphtarget_pars_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_pars_vertex\" ],\r\n\t\r\n\t\t\t\t\"void main() {\",\r\n\t\r\n\t\t\t\t\"\tvNormal = normalize( normalMatrix * normal );\",\r\n\t\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"morphtarget_vertex\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"default_vertex\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_vertex\" ],\r\n\t\r\n\t\t\t\t\"}\"\r\n\t\r\n\t\t\t].join(\"\\n\"),\r\n\t\r\n\t\t\tfragmentShader: [\r\n\t\r\n\t\t\t\t\"uniform float opacity;\",\r\n\t\t\t\t\"varying vec3 vNormal;\",\r\n\t\r\n\t\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_pars_fragment\" ],\r\n\t\r\n\t\t\t\t\"void main() {\",\r\n\t\r\n\t\t\t\t\"\tgl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );\",\r\n\t\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_fragment\" ],\r\n\t\r\n\t\t\t\t\"}\"\r\n\t\r\n\t\t\t].join(\"\\n\")\r\n\t\r\n\t\t},\r\n\t\r\n\t\t/* -------------------------------------------------------------------------\r\n\t\t//\tCube map shader\r\n\t\t ------------------------------------------------------------------------- */\r\n\t\r\n\t\t'cube': {\r\n\t\r\n\t\t\tuniforms: { \"tCube\": { type: \"t\", value: null },\r\n\t\t\t\t\t\t\"tFlip\": { type: \"f\", value: - 1 } },\r\n\t\r\n\t\t\tvertexShader: [\r\n\t\r\n\t\t\t\t\"varying vec3 vWorldPosition;\",\r\n\t\r\n\t\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_pars_vertex\" ],\r\n\t\r\n\t\t\t\t\"void main() {\",\r\n\t\r\n\t\t\t\t\"\tvWorldPosition = transformDirection( position, modelMatrix );\",\r\n\t\r\n\t\t\t\t\"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\t\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_vertex\" ],\r\n\t\r\n\t\t\t\t\"}\"\r\n\t\r\n\t\t\t].join(\"\\n\"),\r\n\t\r\n\t\t\tfragmentShader: [\r\n\t\r\n\t\t\t\t\"uniform samplerCube tCube;\",\r\n\t\t\t\t\"uniform float tFlip;\",\r\n\t\r\n\t\t\t\t\"varying vec3 vWorldPosition;\",\r\n\t\r\n\t\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_pars_fragment\" ],\r\n\t\r\n\t\t\t\t\"void main() {\",\r\n\t\r\n\t\t\t\t\"\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\",\r\n\t\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_fragment\" ],\r\n\t\r\n\t\t\t\t\"}\"\r\n\t\r\n\t\t\t].join(\"\\n\")\r\n\t\r\n\t\t},\r\n\t\r\n\t\t/* -------------------------------------------------------------------------\r\n\t\t//\tCube map shader\r\n\t\t ------------------------------------------------------------------------- */\r\n\t\r\n\t\t'equirect': {\r\n\t\r\n\t\t\tuniforms: { \"tEquirect\": { type: \"t\", value: null },\r\n\t\t\t\t\t\t\"tFlip\": { type: \"f\", value: - 1 } },\r\n\t\r\n\t\t\tvertexShader: [\r\n\t\r\n\t\t\t\t\"varying vec3 vWorldPosition;\",\r\n\t\r\n\t\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_pars_vertex\" ],\r\n\t\r\n\t\t\t\t\"void main() {\",\r\n\t\r\n\t\t\t\t\"\tvWorldPosition = transformDirection( position, modelMatrix );\",\r\n\t\r\n\t\t\t\t\"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\t\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_vertex\" ],\r\n\t\r\n\t\t\t\t\"}\"\r\n\t\r\n\t\t\t].join(\"\\n\"),\r\n\t\r\n\t\t\tfragmentShader: [\r\n\t\r\n\t\t\t\t\"uniform sampler2D tEquirect;\",\r\n\t\t\t\t\"uniform float tFlip;\",\r\n\t\r\n\t\t\t\t\"varying vec3 vWorldPosition;\",\r\n\t\r\n\t\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_pars_fragment\" ],\r\n\t\r\n\t\t\t\t\"void main() {\",\r\n\t\r\n\t\t\t\t\t// \"\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\",\r\n\t\t\t\t\t\"vec3 direction = normalize( vWorldPosition );\",\r\n\t\t\t\t\t\"vec2 sampleUV;\",\r\n\t\t\t\t\t\"sampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );\",\r\n\t\t\t\t\t\"sampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\",\r\n\t\t\t\t\t\"gl_FragColor = texture2D( tEquirect, sampleUV );\",\r\n\t\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_fragment\" ],\r\n\t\r\n\t\t\t\t\"}\"\r\n\t\r\n\t\t\t].join(\"\\n\")\r\n\t\r\n\t\t},\r\n\t\r\n\t\t/* Depth encoding into RGBA texture\r\n\t\t *\r\n\t\t * based on SpiderGL shadow map example\r\n\t\t * http://spidergl.org/example.php?id=6\r\n\t\t *\r\n\t\t * originally from\r\n\t\t * http://www.gamedev.net/topic/442138-packing-a-float-into-a-a8r8g8b8-texture-shader/page__whichpage__1%25EF%25BF%25BD\r\n\t\t *\r\n\t\t * see also\r\n\t\t * http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/\r\n\t\t */\r\n\t\r\n\t\t'depthRGBA': {\r\n\t\r\n\t\t\tuniforms: {},\r\n\t\r\n\t\t\tvertexShader: [\r\n\t\r\n\t\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"morphtarget_pars_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"skinning_pars_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_pars_vertex\" ],\r\n\t\r\n\t\t\t\t\"void main() {\",\r\n\t\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"skinbase_vertex\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"morphtarget_vertex\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"skinning_vertex\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"default_vertex\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_vertex\" ],\r\n\t\r\n\t\t\t\t\"}\"\r\n\t\r\n\t\t\t].join(\"\\n\"),\r\n\t\r\n\t\t\tfragmentShader: [\r\n\t\r\n\t\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_pars_fragment\" ],\r\n\t\r\n\t\t\t\t\"vec4 pack_depth( const in float depth ) {\",\r\n\t\r\n\t\t\t\t\"\tconst vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );\",\r\n\t\t\t\t\"\tconst vec4 bit_mask = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );\",\r\n\t\t\t\t\"\tvec4 res = mod( depth * bit_shift * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );\", // \"\tvec4 res = fract( depth * bit_shift );\",\r\n\t\t\t\t\"\tres -= res.xxyz * bit_mask;\",\r\n\t\t\t\t\"\treturn res;\",\r\n\t\r\n\t\t\t\t\"}\",\r\n\t\r\n\t\t\t\t\"void main() {\",\r\n\t\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_fragment\" ],\r\n\t\r\n\t\t\t\t\"\t#ifdef USE_LOGDEPTHBUF_EXT\",\r\n\t\r\n\t\t\t\t\"\t\tgl_FragData[ 0 ] = pack_depth( gl_FragDepthEXT );\",\r\n\t\r\n\t\t\t\t\"\t#else\",\r\n\t\r\n\t\t\t\t\"\t\tgl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );\",\r\n\t\r\n\t\t\t\t\"\t#endif\",\r\n\t\r\n\t\t\t\t\t//\"gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z / gl_FragCoord.w );\",\r\n\t\t\t\t\t//\"float z = ( ( gl_FragCoord.z / gl_FragCoord.w ) - 3.0 ) / ( 4000.0 - 3.0 );\",\r\n\t\t\t\t\t//\"gl_FragData[ 0 ] = pack_depth( z );\",\r\n\t\t\t\t\t//\"gl_FragData[ 0 ] = vec4( z, z, z, 1.0 );\",\r\n\t\r\n\t\t\t\t\"}\"\r\n\t\r\n\t\t\t].join(\"\\n\")\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/renderers/WebGLRenderer.js\r\n\t\r\n\t/**\r\n\t * @author supereggbert / http://www.paulbrunt.co.uk/\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author szimek / https://github.com/szimek/\r\n\t */\r\n\t\r\n\tTHREE.WebGLRenderer = function ( parameters ) {\r\n\t\r\n\t\tconsole.log( 'THREE.WebGLRenderer', THREE.REVISION );\r\n\t\r\n\t\tparameters = parameters || {};\r\n\t\r\n\t\tvar _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElement( 'canvas' ),\r\n\t\t_context = parameters.context !== undefined ? parameters.context : null,\r\n\t\r\n\t\tpixelRatio = 1,\r\n\t\r\n\t\t_precision = parameters.precision !== undefined ? parameters.precision : 'highp',\r\n\t\r\n\t\t_alpha = parameters.alpha !== undefined ? parameters.alpha : false,\r\n\t\t_depth = parameters.depth !== undefined ? parameters.depth : true,\r\n\t\t_stencil = parameters.stencil !== undefined ? parameters.stencil : true,\r\n\t\t_antialias = parameters.antialias !== undefined ? parameters.antialias : false,\r\n\t\t_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,\r\n\t\t_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,\r\n\t\t_logarithmicDepthBuffer = parameters.logarithmicDepthBuffer !== undefined ? parameters.logarithmicDepthBuffer : false,\r\n\t\r\n\t\t_clearColor = new THREE.Color( 0x000000 ),\r\n\t\t_clearAlpha = 0;\r\n\t\r\n\t\tvar lights = [];\r\n\t\r\n\t\tvar _webglObjects = {};\r\n\t\tvar _webglObjectsImmediate = [];\r\n\t\r\n\t\tvar opaqueObjects = [];\r\n\t\tvar transparentObjects = [];\r\n\t\r\n\t\tvar sprites = [];\r\n\t\tvar lensFlares = [];\r\n\t\r\n\t\t// public properties\r\n\t\r\n\t\tthis.domElement = _canvas;\r\n\t\tthis.context = null;\r\n\t\r\n\t\t// clearing\r\n\t\r\n\t\tthis.autoClear = true;\r\n\t\tthis.autoClearColor = true;\r\n\t\tthis.autoClearDepth = true;\r\n\t\tthis.autoClearStencil = true;\r\n\t\r\n\t\t// scene graph\r\n\t\r\n\t\tthis.sortObjects = true;\r\n\t\r\n\t\t// physically based shading\r\n\t\r\n\t\tthis.gammaFactor = 2.0;\t// for backwards compatibility\r\n\t\tthis.gammaInput = false;\r\n\t\tthis.gammaOutput = false;\r\n\t\r\n\t\t// shadow map\r\n\t\r\n\t\tthis.shadowMapEnabled = false;\r\n\t\tthis.shadowMapType = THREE.PCFShadowMap;\r\n\t\tthis.shadowMapCullFace = THREE.CullFaceFront;\r\n\t\tthis.shadowMapDebug = false;\r\n\t\tthis.shadowMapCascade = false;\r\n\t\r\n\t\t// morphs\r\n\t\r\n\t\tthis.maxMorphTargets = 8;\r\n\t\tthis.maxMorphNormals = 4;\r\n\t\r\n\t\t// flags\r\n\t\r\n\t\tthis.autoScaleCubemaps = true;\r\n\t\r\n\t\t// info\r\n\t\r\n\t\tthis.info = {\r\n\t\r\n\t\t\tmemory: {\r\n\t\r\n\t\t\t\tprograms: 0,\r\n\t\t\t\tgeometries: 0,\r\n\t\t\t\ttextures: 0\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\t\trender: {\r\n\t\r\n\t\t\t\tcalls: 0,\r\n\t\t\t\tvertices: 0,\r\n\t\t\t\tfaces: 0,\r\n\t\t\t\tpoints: 0\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\t// internal properties\r\n\t\r\n\t\tvar _this = this,\r\n\t\r\n\t\t_programs = [],\r\n\t\r\n\t\t// internal state cache\r\n\t\r\n\t\t_currentProgram = null,\r\n\t\t_currentFramebuffer = null,\r\n\t\t_currentMaterialId = - 1,\r\n\t\t_currentGeometryProgram = '',\r\n\t\t_currentCamera = null,\r\n\t\r\n\t\t_usedTextureUnits = 0,\r\n\t\r\n\t\t_viewportX = 0,\r\n\t\t_viewportY = 0,\r\n\t\t_viewportWidth = _canvas.width,\r\n\t\t_viewportHeight = _canvas.height,\r\n\t\t_currentWidth = 0,\r\n\t\t_currentHeight = 0,\r\n\t\r\n\t\t// frustum\r\n\t\r\n\t\t_frustum = new THREE.Frustum(),\r\n\t\r\n\t\t // camera matrices cache\r\n\t\r\n\t\t_projScreenMatrix = new THREE.Matrix4(),\r\n\t\r\n\t\t_vector3 = new THREE.Vector3(),\r\n\t\r\n\t\t// light arrays cache\r\n\t\r\n\t\t_direction = new THREE.Vector3(),\r\n\t\r\n\t\t_lightsNeedUpdate = true,\r\n\t\r\n\t\t_lights = {\r\n\t\r\n\t\t\tambient: [ 0, 0, 0 ],\r\n\t\t\tdirectional: { length: 0, colors:[], positions: [] },\r\n\t\t\tpoint: { length: 0, colors: [], positions: [], distances: [], decays: [] },\r\n\t\t\tspot: { length: 0, colors: [], positions: [], distances: [], directions: [], anglesCos: [], exponents: [], decays: [] },\r\n\t\t\themi: { length: 0, skyColors: [], groundColors: [], positions: [] }\r\n\t\r\n\t\t};\r\n\t\r\n\t\t// initialize\r\n\t\r\n\t\tvar _gl;\r\n\t\r\n\t\ttry {\r\n\t\r\n\t\t\tvar attributes = {\r\n\t\t\t\talpha: _alpha,\r\n\t\t\t\tdepth: _depth,\r\n\t\t\t\tstencil: _stencil,\r\n\t\t\t\tantialias: _antialias,\r\n\t\t\t\tpremultipliedAlpha: _premultipliedAlpha,\r\n\t\t\t\tpreserveDrawingBuffer: _preserveDrawingBuffer\r\n\t\t\t};\r\n\t\r\n\t\t\t_gl = _context || _canvas.getContext( 'webgl', attributes ) || _canvas.getContext( 'experimental-webgl', attributes );\r\n\t\r\n\t\t\tif ( _gl === null ) {\r\n\t\r\n\t\t\t\tif ( _canvas.getContext( 'webgl') !== null ) {\r\n\t\r\n\t\t\t\t\tthrow 'Error creating WebGL context with your selected attributes.';\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tthrow 'Error creating WebGL context.';\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t_canvas.addEventListener( 'webglcontextlost', function ( event ) {\r\n\t\r\n\t\t\t\tevent.preventDefault();\r\n\t\r\n\t\t\t\tresetGLState();\r\n\t\t\t\tsetDefaultGLState();\r\n\t\r\n\t\t\t\t_webglObjects = {};\r\n\t\r\n\t\t\t}, false);\r\n\t\r\n\t\t} catch ( error ) {\r\n\t\r\n\t\t\tTHREE.error( 'THREE.WebGLRenderer: ' + error );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar state = new THREE.WebGLState( _gl, paramThreeToGL );\r\n\t\r\n\t\tif ( _gl.getShaderPrecisionFormat === undefined ) {\r\n\t\r\n\t\t\t_gl.getShaderPrecisionFormat = function () {\r\n\t\r\n\t\t\t\treturn {\r\n\t\t\t\t\t'rangeMin': 1,\r\n\t\t\t\t\t'rangeMax': 1,\r\n\t\t\t\t\t'precision': 1\r\n\t\t\t\t};\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar extensions = new THREE.WebGLExtensions( _gl );\r\n\t\r\n\t\textensions.get( 'OES_texture_float' );\r\n\t\textensions.get( 'OES_texture_float_linear' );\r\n\t\textensions.get( 'OES_texture_half_float' );\r\n\t\textensions.get( 'OES_texture_half_float_linear' );\r\n\t\textensions.get( 'OES_standard_derivatives' );\r\n\t\r\n\t\tif ( _logarithmicDepthBuffer ) {\r\n\t\r\n\t\t\textensions.get( 'EXT_frag_depth' );\r\n\t\r\n\t\t}\r\n\t\r\n\t\t//\r\n\t\r\n\t\tvar glClearColor = function ( r, g, b, a ) {\r\n\t\r\n\t\t\tif ( _premultipliedAlpha === true ) {\r\n\t\r\n\t\t\t\tr *= a; g *= a; b *= a;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t_gl.clearColor( r, g, b, a );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tvar setDefaultGLState = function () {\r\n\t\r\n\t\t\t_gl.clearColor( 0, 0, 0, 1 );\r\n\t\t\t_gl.clearDepth( 1 );\r\n\t\t\t_gl.clearStencil( 0 );\r\n\t\r\n\t\t\t_gl.enable( _gl.DEPTH_TEST );\r\n\t\t\t_gl.depthFunc( _gl.LEQUAL );\r\n\t\r\n\t\t\t_gl.frontFace( _gl.CCW );\r\n\t\t\t_gl.cullFace( _gl.BACK );\r\n\t\t\t_gl.enable( _gl.CULL_FACE );\r\n\t\r\n\t\t\t_gl.enable( _gl.BLEND );\r\n\t\t\t_gl.blendEquation( _gl.FUNC_ADD );\r\n\t\t\t_gl.blendFunc( _gl.SRC_ALPHA, _gl.ONE_MINUS_SRC_ALPHA );\r\n\t\r\n\t\t\t_gl.viewport( _viewportX, _viewportY, _viewportWidth, _viewportHeight );\r\n\t\r\n\t\t\tglClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tvar resetGLState = function () {\r\n\t\r\n\t\t\t_currentProgram = null;\r\n\t\t\t_currentCamera = null;\r\n\t\r\n\t\t\t_currentGeometryProgram = '';\r\n\t\t\t_currentMaterialId = - 1;\r\n\t\r\n\t\t\t_lightsNeedUpdate = true;\r\n\t\r\n\t\t\tstate.reset();\r\n\t\r\n\t\t};\r\n\t\r\n\t\tsetDefaultGLState();\r\n\t\r\n\t\tthis.context = _gl;\r\n\t\tthis.state = state;\r\n\t\r\n\t\t// GPU capabilities\r\n\t\r\n\t\tvar _maxTextures = _gl.getParameter( _gl.MAX_TEXTURE_IMAGE_UNITS );\r\n\t\tvar _maxVertexTextures = _gl.getParameter( _gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );\r\n\t\tvar _maxTextureSize = _gl.getParameter( _gl.MAX_TEXTURE_SIZE );\r\n\t\tvar _maxCubemapSize = _gl.getParameter( _gl.MAX_CUBE_MAP_TEXTURE_SIZE );\r\n\t\r\n\t\tvar _supportsVertexTextures = _maxVertexTextures > 0;\r\n\t\tvar _supportsBoneTextures = _supportsVertexTextures && extensions.get( 'OES_texture_float' );\r\n\t\r\n\t\t//\r\n\t\r\n\t\tvar _vertexShaderPrecisionHighpFloat = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.HIGH_FLOAT );\r\n\t\tvar _vertexShaderPrecisionMediumpFloat = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.MEDIUM_FLOAT );\r\n\t\r\n\t\tvar _fragmentShaderPrecisionHighpFloat = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.HIGH_FLOAT );\r\n\t\tvar _fragmentShaderPrecisionMediumpFloat = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.MEDIUM_FLOAT );\r\n\t\r\n\t\tvar getCompressedTextureFormats = ( function () {\r\n\t\r\n\t\t\tvar array;\r\n\t\r\n\t\t\treturn function () {\r\n\t\r\n\t\t\t\tif ( array !== undefined ) {\r\n\t\r\n\t\t\t\t\treturn array;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tarray = [];\r\n\t\r\n\t\t\t\tif ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) || extensions.get( 'WEBGL_compressed_texture_s3tc' ) ) {\r\n\t\r\n\t\t\t\t\tvar formats = _gl.getParameter( _gl.COMPRESSED_TEXTURE_FORMATS );\r\n\t\r\n\t\t\t\t\tfor ( var i = 0; i < formats.length; i ++ ) {\r\n\t\r\n\t\t\t\t\t\tarray.push( formats[ i ] );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn array;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t} )();\r\n\t\r\n\t\t// clamp precision to maximum available\r\n\t\r\n\t\tvar highpAvailable = _vertexShaderPrecisionHighpFloat.precision > 0 && _fragmentShaderPrecisionHighpFloat.precision > 0;\r\n\t\tvar mediumpAvailable = _vertexShaderPrecisionMediumpFloat.precision > 0 && _fragmentShaderPrecisionMediumpFloat.precision > 0;\r\n\t\r\n\t\tif ( _precision === 'highp' && ! highpAvailable ) {\r\n\t\r\n\t\t\tif ( mediumpAvailable ) {\r\n\t\r\n\t\t\t\t_precision = 'mediump';\r\n\t\t\t\tTHREE.warn( 'THREE.WebGLRenderer: highp not supported, using mediump.' );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\t_precision = 'lowp';\r\n\t\t\t\tTHREE.warn( 'THREE.WebGLRenderer: highp and mediump not supported, using lowp.' );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tif ( _precision === 'mediump' && ! mediumpAvailable ) {\r\n\t\r\n\t\t\t_precision = 'lowp';\r\n\t\t\tTHREE.warn( 'THREE.WebGLRenderer: mediump not supported, using lowp.' );\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// Plugins\r\n\t\r\n\t\tvar shadowMapPlugin = new THREE.ShadowMapPlugin( this, lights, _webglObjects, _webglObjectsImmediate );\r\n\t\r\n\t\tvar spritePlugin = new THREE.SpritePlugin( this, sprites );\r\n\t\tvar lensFlarePlugin = new THREE.LensFlarePlugin( this, lensFlares );\r\n\t\r\n\t\t// API\r\n\t\r\n\t\tthis.getContext = function () {\r\n\t\r\n\t\t\treturn _gl;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.forceContextLoss = function () {\r\n\t\r\n\t\t\textensions.get( 'WEBGL_lose_context' ).loseContext();\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.supportsVertexTextures = function () {\r\n\t\r\n\t\t\treturn _supportsVertexTextures;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.supportsFloatTextures = function () {\r\n\t\r\n\t\t\treturn extensions.get( 'OES_texture_float' );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.supportsHalfFloatTextures = function () {\r\n\t\r\n\t\t\treturn extensions.get( 'OES_texture_half_float' );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.supportsStandardDerivatives = function () {\r\n\t\r\n\t\t\treturn extensions.get( 'OES_standard_derivatives' );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.supportsCompressedTextureS3TC = function () {\r\n\t\r\n\t\t\treturn extensions.get( 'WEBGL_compressed_texture_s3tc' );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.supportsCompressedTexturePVRTC = function () {\r\n\t\r\n\t\t\treturn extensions.get( 'WEBGL_compressed_texture_pvrtc' );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.supportsBlendMinMax = function () {\r\n\t\r\n\t\t\treturn extensions.get( 'EXT_blend_minmax' );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.getMaxAnisotropy = ( function () {\r\n\t\r\n\t\t\tvar value;\r\n\t\r\n\t\t\treturn function () {\r\n\t\r\n\t\t\t\tif ( value !== undefined ) {\r\n\t\r\n\t\t\t\t\treturn value;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar extension = extensions.get( 'EXT_texture_filter_anisotropic' );\r\n\t\r\n\t\t\t\tvalue = extension !== null ? _gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT ) : 0;\r\n\t\r\n\t\t\t\treturn value;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t} )();\r\n\t\r\n\t\tthis.getPrecision = function () {\r\n\t\r\n\t\t\treturn _precision;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.getPixelRatio = function () {\r\n\t\r\n\t\t\treturn pixelRatio;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setPixelRatio = function ( value ) {\r\n\t\r\n\t\t\tpixelRatio = value;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setSize = function ( width, height, updateStyle ) {\r\n\t\r\n\t\t\t_canvas.width = width * pixelRatio;\r\n\t\t\t_canvas.height = height * pixelRatio;\r\n\t\r\n\t\t\tif ( updateStyle !== false ) {\r\n\t\r\n\t\t\t\t_canvas.style.width = width + 'px';\r\n\t\t\t\t_canvas.style.height = height + 'px';\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.setViewport( 0, 0, width, height );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setViewport = function ( x, y, width, height ) {\r\n\t\r\n\t\t\t_viewportX = x * pixelRatio;\r\n\t\t\t_viewportY = y * pixelRatio;\r\n\t\r\n\t\t\t_viewportWidth = width * pixelRatio;\r\n\t\t\t_viewportHeight = height * pixelRatio;\r\n\t\r\n\t\t\t_gl.viewport( _viewportX, _viewportY, _viewportWidth, _viewportHeight );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setScissor = function ( x, y, width, height ) {\r\n\t\r\n\t\t\t_gl.scissor(\r\n\t\t\t\tx * pixelRatio,\r\n\t\t\t\ty * pixelRatio,\r\n\t\t\t\twidth * pixelRatio,\r\n\t\t\t\theight * pixelRatio\r\n\t\t\t);\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.enableScissorTest = function ( enable ) {\r\n\t\r\n\t\t\tenable ? _gl.enable( _gl.SCISSOR_TEST ) : _gl.disable( _gl.SCISSOR_TEST );\r\n\t\r\n\t\t};\r\n\t\r\n\t\t// Clearing\r\n\t\r\n\t\tthis.getClearColor = function () {\r\n\t\r\n\t\t\treturn _clearColor;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setClearColor = function ( color, alpha ) {\r\n\t\r\n\t\t\t_clearColor.set( color );\r\n\t\r\n\t\t\t_clearAlpha = alpha !== undefined ? alpha : 1;\r\n\t\r\n\t\t\tglClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.getClearAlpha = function () {\r\n\t\r\n\t\t\treturn _clearAlpha;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setClearAlpha = function ( alpha ) {\r\n\t\r\n\t\t\t_clearAlpha = alpha;\r\n\t\r\n\t\t\tglClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.clear = function ( color, depth, stencil ) {\r\n\t\r\n\t\t\tvar bits = 0;\r\n\t\r\n\t\t\tif ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;\r\n\t\t\tif ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;\r\n\t\t\tif ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;\r\n\t\r\n\t\t\t_gl.clear( bits );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.clearColor = function () {\r\n\t\r\n\t\t\t_gl.clear( _gl.COLOR_BUFFER_BIT );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.clearDepth = function () {\r\n\t\r\n\t\t\t_gl.clear( _gl.DEPTH_BUFFER_BIT );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.clearStencil = function () {\r\n\t\r\n\t\t\t_gl.clear( _gl.STENCIL_BUFFER_BIT );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.clearTarget = function ( renderTarget, color, depth, stencil ) {\r\n\t\r\n\t\t\tthis.setRenderTarget( renderTarget );\r\n\t\t\tthis.clear( color, depth, stencil );\r\n\t\r\n\t\t};\r\n\t\r\n\t\t// Reset\r\n\t\r\n\t\tthis.resetGLState = resetGLState;\r\n\t\r\n\t\t// Buffer allocation\r\n\t\r\n\t\tfunction createParticleBuffers ( geometry ) {\r\n\t\r\n\t\t\tgeometry.__webglVertexBuffer = _gl.createBuffer();\r\n\t\t\tgeometry.__webglColorBuffer = _gl.createBuffer();\r\n\t\r\n\t\t\t_this.info.memory.geometries ++;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tfunction createLineBuffers ( geometry ) {\r\n\t\r\n\t\t\tgeometry.__webglVertexBuffer = _gl.createBuffer();\r\n\t\t\tgeometry.__webglColorBuffer = _gl.createBuffer();\r\n\t\t\tgeometry.__webglLineDistanceBuffer = _gl.createBuffer();\r\n\t\r\n\t\t\t_this.info.memory.geometries ++;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tfunction createMeshBuffers ( geometryGroup ) {\r\n\t\r\n\t\t\tgeometryGroup.__webglVertexBuffer = _gl.createBuffer();\r\n\t\t\tgeometryGroup.__webglNormalBuffer = _gl.createBuffer();\r\n\t\t\tgeometryGroup.__webglTangentBuffer = _gl.createBuffer();\r\n\t\t\tgeometryGroup.__webglColorBuffer = _gl.createBuffer();\r\n\t\t\tgeometryGroup.__webglUVBuffer = _gl.createBuffer();\r\n\t\t\tgeometryGroup.__webglUV2Buffer = _gl.createBuffer();\r\n\t\r\n\t\t\tgeometryGroup.__webglSkinIndicesBuffer = _gl.createBuffer();\r\n\t\t\tgeometryGroup.__webglSkinWeightsBuffer = _gl.createBuffer();\r\n\t\r\n\t\t\tgeometryGroup.__webglFaceBuffer = _gl.createBuffer();\r\n\t\t\tgeometryGroup.__webglLineBuffer = _gl.createBuffer();\r\n\t\r\n\t\t\tvar numMorphTargets = geometryGroup.numMorphTargets;\r\n\t\r\n\t\t\tif ( numMorphTargets ) {\r\n\t\r\n\t\t\t\tgeometryGroup.__webglMorphTargetsBuffers = [];\r\n\t\r\n\t\t\t\tfor ( var m = 0, ml = numMorphTargets; m < ml; m ++ ) {\r\n\t\r\n\t\t\t\t\tgeometryGroup.__webglMorphTargetsBuffers.push( _gl.createBuffer() );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar numMorphNormals = geometryGroup.numMorphNormals;\r\n\t\r\n\t\t\tif ( numMorphNormals ) {\r\n\t\r\n\t\t\t\tgeometryGroup.__webglMorphNormalsBuffers = [];\r\n\t\r\n\t\t\t\tfor ( var m = 0, ml = numMorphNormals; m < ml; m ++ ) {\r\n\t\r\n\t\t\t\t\tgeometryGroup.__webglMorphNormalsBuffers.push( _gl.createBuffer() );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t_this.info.memory.geometries ++;\r\n\t\r\n\t\t};\r\n\t\r\n\t\t// Events\r\n\t\r\n\t\tvar onObjectRemoved = function ( event ) {\r\n\t\r\n\t\t\tvar object = event.target;\r\n\t\r\n\t\t\tobject.traverse( function ( child ) {\r\n\t\r\n\t\t\t\tchild.removeEventListener( 'remove', onObjectRemoved );\r\n\t\r\n\t\t\t\tremoveObject( child );\r\n\t\r\n\t\t\t} );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tvar onGeometryDispose = function ( event ) {\r\n\t\r\n\t\t\tvar geometry = event.target;\r\n\t\r\n\t\t\tgeometry.removeEventListener( 'dispose', onGeometryDispose );\r\n\t\r\n\t\t\tdeallocateGeometry( geometry );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tvar onTextureDispose = function ( event ) {\r\n\t\r\n\t\t\tvar texture = event.target;\r\n\t\r\n\t\t\ttexture.removeEventListener( 'dispose', onTextureDispose );\r\n\t\r\n\t\t\tdeallocateTexture( texture );\r\n\t\r\n\t\t\t_this.info.memory.textures --;\r\n\t\r\n\t\r\n\t\t};\r\n\t\r\n\t\tvar onRenderTargetDispose = function ( event ) {\r\n\t\r\n\t\t\tvar renderTarget = event.target;\r\n\t\r\n\t\t\trenderTarget.removeEventListener( 'dispose', onRenderTargetDispose );\r\n\t\r\n\t\t\tdeallocateRenderTarget( renderTarget );\r\n\t\r\n\t\t\t_this.info.memory.textures --;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tvar onMaterialDispose = function ( event ) {\r\n\t\r\n\t\t\tvar material = event.target;\r\n\t\r\n\t\t\tmaterial.removeEventListener( 'dispose', onMaterialDispose );\r\n\t\r\n\t\t\tdeallocateMaterial( material );\r\n\t\r\n\t\t};\r\n\t\r\n\t\t// Buffer deallocation\r\n\t\r\n\t\tvar deleteBuffers = function ( geometry ) {\r\n\t\r\n\t\t\tvar buffers = [\r\n\t\t\t\t'__webglVertexBuffer',\r\n\t\t\t\t'__webglNormalBuffer',\r\n\t\t\t\t'__webglTangentBuffer',\r\n\t\t\t\t'__webglColorBuffer',\r\n\t\t\t\t'__webglUVBuffer',\r\n\t\t\t\t'__webglUV2Buffer',\r\n\t\r\n\t\t\t\t'__webglSkinIndicesBuffer',\r\n\t\t\t\t'__webglSkinWeightsBuffer',\r\n\t\r\n\t\t\t\t'__webglFaceBuffer',\r\n\t\t\t\t'__webglLineBuffer',\r\n\t\r\n\t\t\t\t'__webglLineDistanceBuffer'\r\n\t\t\t];\r\n\t\r\n\t\t\tfor ( var i = 0, l = buffers.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tvar name = buffers[ i ];\r\n\t\r\n\t\t\t\tif ( geometry[ name ] !== undefined ) {\r\n\t\r\n\t\t\t\t\t_gl.deleteBuffer( geometry[ name ] );\r\n\t\r\n\t\t\t\t\tdelete geometry[ name ];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// custom attributes\r\n\t\r\n\t\t\tif ( geometry.__webglCustomAttributesList !== undefined ) {\r\n\t\r\n\t\t\t\tfor ( var name in geometry.__webglCustomAttributesList ) {\r\n\t\r\n\t\t\t\t\t_gl.deleteBuffer( geometry.__webglCustomAttributesList[ name ].buffer );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tdelete geometry.__webglCustomAttributesList;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t_this.info.memory.geometries --;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tvar deallocateGeometry = function ( geometry ) {\r\n\t\r\n\t\t\tdelete geometry.__webglInit;\r\n\t\r\n\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\r\n\t\r\n\t\t\t\tfor ( var name in geometry.attributes ) {\r\n\t\r\n\t\t\t\t\tvar attribute = geometry.attributes[ name ];\r\n\t\r\n\t\t\t\t\tif ( attribute.buffer !== undefined ) {\r\n\t\r\n\t\t\t\t\t\t_gl.deleteBuffer( attribute.buffer );\r\n\t\r\n\t\t\t\t\t\tdelete attribute.buffer;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t_this.info.memory.geometries --;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tvar geometryGroupsList = geometryGroups[ geometry.id ];\r\n\t\r\n\t\t\t\tif ( geometryGroupsList !== undefined ) {\r\n\t\r\n\t\t\t\t\tfor ( var i = 0, l = geometryGroupsList.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\t\tvar geometryGroup = geometryGroupsList[ i ];\r\n\t\r\n\t\t\t\t\t\tif ( geometryGroup.numMorphTargets !== undefined ) {\r\n\t\r\n\t\t\t\t\t\t\tfor ( var m = 0, ml = geometryGroup.numMorphTargets; m < ml; m ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\t_gl.deleteBuffer( geometryGroup.__webglMorphTargetsBuffers[ m ] );\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\tdelete geometryGroup.__webglMorphTargetsBuffers;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tif ( geometryGroup.numMorphNormals !== undefined ) {\r\n\t\r\n\t\t\t\t\t\t\tfor ( var m = 0, ml = geometryGroup.numMorphNormals; m < ml; m ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\t_gl.deleteBuffer( geometryGroup.__webglMorphNormalsBuffers[ m ] );\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\tdelete geometryGroup.__webglMorphNormalsBuffers;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tdeleteBuffers( geometryGroup );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tdelete geometryGroups[ geometry.id ];\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tdeleteBuffers( geometry );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// TOFIX: Workaround for deleted geometry being currently bound\r\n\t\r\n\t\t\t_currentGeometryProgram = '';\r\n\t\r\n\t\t};\r\n\t\r\n\t\tvar deallocateTexture = function ( texture ) {\r\n\t\r\n\t\t\tif ( texture.image && texture.image.__webglTextureCube ) {\r\n\t\r\n\t\t\t\t// cube texture\r\n\t\r\n\t\t\t\t_gl.deleteTexture( texture.image.__webglTextureCube );\r\n\t\r\n\t\t\t\tdelete texture.image.__webglTextureCube;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\t// 2D texture\r\n\t\r\n\t\t\t\tif ( texture.__webglInit === undefined ) return;\r\n\t\r\n\t\t\t\t_gl.deleteTexture( texture.__webglTexture );\r\n\t\r\n\t\t\t\tdelete texture.__webglTexture;\r\n\t\t\t\tdelete texture.__webglInit;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tvar deallocateRenderTarget = function ( renderTarget ) {\r\n\t\r\n\t\t\tif ( ! renderTarget || renderTarget.__webglTexture === undefined ) return;\r\n\t\r\n\t\t\t_gl.deleteTexture( renderTarget.__webglTexture );\r\n\t\r\n\t\t\tdelete renderTarget.__webglTexture;\r\n\t\r\n\t\t\tif ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {\r\n\t\r\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\t\r\n\t\t\t\t\t_gl.deleteFramebuffer( renderTarget.__webglFramebuffer[ i ] );\r\n\t\t\t\t\t_gl.deleteRenderbuffer( renderTarget.__webglRenderbuffer[ i ] );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\t_gl.deleteFramebuffer( renderTarget.__webglFramebuffer );\r\n\t\t\t\t_gl.deleteRenderbuffer( renderTarget.__webglRenderbuffer );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tdelete renderTarget.__webglFramebuffer;\r\n\t\t\tdelete renderTarget.__webglRenderbuffer;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tvar deallocateMaterial = function ( material ) {\r\n\t\r\n\t\t\tvar program = material.program.program;\r\n\t\r\n\t\t\tif ( program === undefined ) return;\r\n\t\r\n\t\t\tmaterial.program = undefined;\r\n\t\r\n\t\t\t// only deallocate GL program if this was the last use of shared program\r\n\t\t\t// assumed there is only single copy of any program in the _programs list\r\n\t\t\t// (that's how it's constructed)\r\n\t\r\n\t\t\tvar i, il, programInfo;\r\n\t\t\tvar deleteProgram = false;\r\n\t\r\n\t\t\tfor ( i = 0, il = _programs.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tprogramInfo = _programs[ i ];\r\n\t\r\n\t\t\t\tif ( programInfo.program === program ) {\r\n\t\r\n\t\t\t\t\tprogramInfo.usedTimes --;\r\n\t\r\n\t\t\t\t\tif ( programInfo.usedTimes === 0 ) {\r\n\t\r\n\t\t\t\t\t\tdeleteProgram = true;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( deleteProgram === true ) {\r\n\t\r\n\t\t\t\t// avoid using array.splice, this is costlier than creating new array from scratch\r\n\t\r\n\t\t\t\tvar newPrograms = [];\r\n\t\r\n\t\t\t\tfor ( i = 0, il = _programs.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\tprogramInfo = _programs[ i ];\r\n\t\r\n\t\t\t\t\tif ( programInfo.program !== program ) {\r\n\t\r\n\t\t\t\t\t\tnewPrograms.push( programInfo );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t_programs = newPrograms;\r\n\t\r\n\t\t\t\t_gl.deleteProgram( program );\r\n\t\r\n\t\t\t\t_this.info.memory.programs --;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\t// Buffer initialization\r\n\t\r\n\t\tfunction initCustomAttributes ( object ) {\r\n\t\r\n\t\t\tvar geometry = object.geometry;\r\n\t\t\tvar material = object.material;\r\n\t\r\n\t\t\tvar nvertices = geometry.vertices.length;\r\n\t\r\n\t\t\tif ( material.attributes ) {\r\n\t\r\n\t\t\t\tif ( geometry.__webglCustomAttributesList === undefined ) {\r\n\t\r\n\t\t\t\t\tgeometry.__webglCustomAttributesList = [];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tfor ( var name in material.attributes ) {\r\n\t\r\n\t\t\t\t\tvar attribute = material.attributes[ name ];\r\n\t\r\n\t\t\t\t\tif ( ! attribute.__webglInitialized || attribute.createUniqueBuffers ) {\r\n\t\r\n\t\t\t\t\t\tattribute.__webglInitialized = true;\r\n\t\r\n\t\t\t\t\t\tvar size = 1;   // \"f\" and \"i\"\r\n\t\r\n\t\t\t\t\t\tif ( attribute.type === 'v2' ) size = 2;\r\n\t\t\t\t\t\telse if ( attribute.type === 'v3' ) size = 3;\r\n\t\t\t\t\t\telse if ( attribute.type === 'v4' ) size = 4;\r\n\t\t\t\t\t\telse if ( attribute.type === 'c'  ) size = 3;\r\n\t\r\n\t\t\t\t\t\tattribute.size = size;\r\n\t\r\n\t\t\t\t\t\tattribute.array = new Float32Array( nvertices * size );\r\n\t\r\n\t\t\t\t\t\tattribute.buffer = _gl.createBuffer();\r\n\t\t\t\t\t\tattribute.buffer.belongsToAttribute = name;\r\n\t\r\n\t\t\t\t\t\tattribute.needsUpdate = true;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tgeometry.__webglCustomAttributesList.push( attribute );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tfunction initParticleBuffers ( geometry, object ) {\r\n\t\r\n\t\t\tvar nvertices = geometry.vertices.length;\r\n\t\r\n\t\t\tgeometry.__vertexArray = new Float32Array( nvertices * 3 );\r\n\t\t\tgeometry.__colorArray = new Float32Array( nvertices * 3 );\r\n\t\r\n\t\t\tgeometry.__webglParticleCount = nvertices;\r\n\t\r\n\t\t\tinitCustomAttributes( object );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tfunction initLineBuffers ( geometry, object ) {\r\n\t\r\n\t\t\tvar nvertices = geometry.vertices.length;\r\n\t\r\n\t\t\tgeometry.__vertexArray = new Float32Array( nvertices * 3 );\r\n\t\t\tgeometry.__colorArray = new Float32Array( nvertices * 3 );\r\n\t\t\tgeometry.__lineDistanceArray = new Float32Array( nvertices * 1 );\r\n\t\r\n\t\t\tgeometry.__webglLineCount = nvertices;\r\n\t\r\n\t\t\tinitCustomAttributes( object );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tfunction initMeshBuffers ( geometryGroup, object ) {\r\n\t\r\n\t\t\tvar geometry = object.geometry,\r\n\t\t\t\tfaces3 = geometryGroup.faces3,\r\n\t\r\n\t\t\t\tnvertices = faces3.length * 3,\r\n\t\t\t\tntris     = faces3.length * 1,\r\n\t\t\t\tnlines    = faces3.length * 3,\r\n\t\r\n\t\t\t\tmaterial = getBufferMaterial( object, geometryGroup );\r\n\t\r\n\t\t\tgeometryGroup.__vertexArray = new Float32Array( nvertices * 3 );\r\n\t\t\tgeometryGroup.__normalArray = new Float32Array( nvertices * 3 );\r\n\t\t\tgeometryGroup.__colorArray = new Float32Array( nvertices * 3 );\r\n\t\t\tgeometryGroup.__uvArray = new Float32Array( nvertices * 2 );\r\n\t\r\n\t\t\tif ( geometry.faceVertexUvs.length > 1 ) {\r\n\t\r\n\t\t\t\tgeometryGroup.__uv2Array = new Float32Array( nvertices * 2 );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( geometry.hasTangents ) {\r\n\t\r\n\t\t\t\tgeometryGroup.__tangentArray = new Float32Array( nvertices * 4 );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( object.geometry.skinWeights.length && object.geometry.skinIndices.length ) {\r\n\t\r\n\t\t\t\tgeometryGroup.__skinIndexArray = new Float32Array( nvertices * 4 );\r\n\t\t\t\tgeometryGroup.__skinWeightArray = new Float32Array( nvertices * 4 );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar UintArray = extensions.get( 'OES_element_index_uint' ) !== null && ntris > 21845 ? Uint32Array : Uint16Array; // 65535 / 3\r\n\t\r\n\t\t\tgeometryGroup.__typeArray = UintArray;\r\n\t\t\tgeometryGroup.__faceArray = new UintArray( ntris * 3 );\r\n\t\t\tgeometryGroup.__lineArray = new UintArray( nlines * 2 );\r\n\t\r\n\t\t\tvar numMorphTargets = geometryGroup.numMorphTargets;\r\n\t\r\n\t\t\tif ( numMorphTargets ) {\r\n\t\r\n\t\t\t\tgeometryGroup.__morphTargetsArrays = [];\r\n\t\r\n\t\t\t\tfor ( var m = 0, ml = numMorphTargets; m < ml; m ++ ) {\r\n\t\r\n\t\t\t\t\tgeometryGroup.__morphTargetsArrays.push( new Float32Array( nvertices * 3 ) );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar numMorphNormals = geometryGroup.numMorphNormals;\r\n\t\r\n\t\t\tif ( numMorphNormals ) {\r\n\t\r\n\t\t\t\tgeometryGroup.__morphNormalsArrays = [];\r\n\t\r\n\t\t\t\tfor ( var m = 0, ml = numMorphNormals; m < ml; m ++ ) {\r\n\t\r\n\t\t\t\t\tgeometryGroup.__morphNormalsArrays.push( new Float32Array( nvertices * 3 ) );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tgeometryGroup.__webglFaceCount = ntris * 3;\r\n\t\t\tgeometryGroup.__webglLineCount = nlines * 2;\r\n\t\r\n\t\r\n\t\t\t// custom attributes\r\n\t\r\n\t\t\tif ( material.attributes ) {\r\n\t\r\n\t\t\t\tif ( geometryGroup.__webglCustomAttributesList === undefined ) {\r\n\t\r\n\t\t\t\t\tgeometryGroup.__webglCustomAttributesList = [];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tfor ( var name in material.attributes ) {\r\n\t\r\n\t\t\t\t\t// Do a shallow copy of the attribute object so different geometryGroup chunks use different\r\n\t\t\t\t\t// attribute buffers which are correctly indexed in the setMeshBuffers function\r\n\t\r\n\t\t\t\t\tvar originalAttribute = material.attributes[ name ];\r\n\t\r\n\t\t\t\t\tvar attribute = {};\r\n\t\r\n\t\t\t\t\tfor ( var property in originalAttribute ) {\r\n\t\r\n\t\t\t\t\t\tattribute[ property ] = originalAttribute[ property ];\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( ! attribute.__webglInitialized || attribute.createUniqueBuffers ) {\r\n\t\r\n\t\t\t\t\t\tattribute.__webglInitialized = true;\r\n\t\r\n\t\t\t\t\t\tvar size = 1;   // \"f\" and \"i\"\r\n\t\r\n\t\t\t\t\t\tif ( attribute.type === 'v2' ) size = 2;\r\n\t\t\t\t\t\telse if ( attribute.type === 'v3' ) size = 3;\r\n\t\t\t\t\t\telse if ( attribute.type === 'v4' ) size = 4;\r\n\t\t\t\t\t\telse if ( attribute.type === 'c'  ) size = 3;\r\n\t\r\n\t\t\t\t\t\tattribute.size = size;\r\n\t\r\n\t\t\t\t\t\tattribute.array = new Float32Array( nvertices * size );\r\n\t\r\n\t\t\t\t\t\tattribute.buffer = _gl.createBuffer();\r\n\t\t\t\t\t\tattribute.buffer.belongsToAttribute = name;\r\n\t\r\n\t\t\t\t\t\toriginalAttribute.needsUpdate = true;\r\n\t\t\t\t\t\tattribute.__original = originalAttribute;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tgeometryGroup.__webglCustomAttributesList.push( attribute );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tgeometryGroup.__inittedArrays = true;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tfunction getBufferMaterial( object, geometryGroup ) {\r\n\t\r\n\t\t\treturn object.material instanceof THREE.MeshFaceMaterial\r\n\t\t\t\t ? object.material.materials[ geometryGroup.materialIndex ]\r\n\t\t\t\t : object.material;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction materialNeedsFaceNormals ( material ) {\r\n\t\r\n\t\t\treturn material instanceof THREE.MeshPhongMaterial === false && material.shading === THREE.FlatShading;\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// Buffer setting\r\n\t\r\n\t\tfunction setParticleBuffers ( geometry, hint, object ) {\r\n\t\r\n\t\t\tvar v, c, vertex, offset, color,\r\n\t\r\n\t\t\tvertices = geometry.vertices,\r\n\t\t\tvl = vertices.length,\r\n\t\r\n\t\t\tcolors = geometry.colors,\r\n\t\t\tcl = colors.length,\r\n\t\r\n\t\t\tvertexArray = geometry.__vertexArray,\r\n\t\t\tcolorArray = geometry.__colorArray,\r\n\t\r\n\t\t\tdirtyVertices = geometry.verticesNeedUpdate,\r\n\t\t\tdirtyColors = geometry.colorsNeedUpdate,\r\n\t\r\n\t\t\tcustomAttributes = geometry.__webglCustomAttributesList,\r\n\t\t\ti, il,\r\n\t\t\tca, cal, value,\r\n\t\t\tcustomAttribute;\r\n\t\r\n\t\t\tif ( dirtyVertices ) {\r\n\t\r\n\t\t\t\tfor ( v = 0; v < vl; v ++ ) {\r\n\t\r\n\t\t\t\t\tvertex = vertices[ v ];\r\n\t\r\n\t\t\t\t\toffset = v * 3;\r\n\t\r\n\t\t\t\t\tvertexArray[ offset ]     = vertex.x;\r\n\t\t\t\t\tvertexArray[ offset + 1 ] = vertex.y;\r\n\t\t\t\t\tvertexArray[ offset + 2 ] = vertex.z;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglVertexBuffer );\r\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( dirtyColors ) {\r\n\t\r\n\t\t\t\tfor ( c = 0; c < cl; c ++ ) {\r\n\t\r\n\t\t\t\t\tcolor = colors[ c ];\r\n\t\r\n\t\t\t\t\toffset = c * 3;\r\n\t\r\n\t\t\t\t\tcolorArray[ offset ]     = color.r;\r\n\t\t\t\t\tcolorArray[ offset + 1 ] = color.g;\r\n\t\t\t\t\tcolorArray[ offset + 2 ] = color.b;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglColorBuffer );\r\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( customAttributes ) {\r\n\t\r\n\t\t\t\tfor ( i = 0, il = customAttributes.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\tcustomAttribute = customAttributes[ i ];\r\n\t\r\n\t\t\t\t\tif ( customAttribute.needsUpdate && ( customAttribute.boundTo === undefined ||  customAttribute.boundTo === 'vertices' ) ) {\r\n\t\r\n\t\t\t\t\t\tcal = customAttribute.value.length;\r\n\t\r\n\t\t\t\t\t\toffset = 0;\r\n\t\r\n\t\t\t\t\t\tif ( customAttribute.size === 1 ) {\r\n\t\r\n\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ ca ] = customAttribute.value[ ca ];\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t} else if ( customAttribute.size === 2 ) {\r\n\t\r\n\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\r\n\t\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset ]   = value.x;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.y;\r\n\t\r\n\t\t\t\t\t\t\t\toffset += 2;\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t} else if ( customAttribute.size === 3 ) {\r\n\t\r\n\t\t\t\t\t\t\tif ( customAttribute.type === 'c' ) {\r\n\t\r\n\t\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\r\n\t\r\n\t\t\t\t\t\t\t\t\tcustomAttribute.array[ offset ]   = value.r;\r\n\t\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.g;\r\n\t\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2 ] = value.b;\r\n\t\r\n\t\t\t\t\t\t\t\t\toffset += 3;\r\n\t\r\n\t\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\r\n\t\r\n\t\t\t\t\t\t\t\t\tcustomAttribute.array[ offset ]   = value.x;\r\n\t\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.y;\r\n\t\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2 ] = value.z;\r\n\t\r\n\t\t\t\t\t\t\t\t\toffset += 3;\r\n\t\r\n\t\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t} else if ( customAttribute.size === 4 ) {\r\n\t\r\n\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\r\n\t\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset ]      = value.x;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1  ] = value.y;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2  ] = value.z;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 3  ] = value.w;\r\n\t\r\n\t\t\t\t\t\t\t\toffset += 4;\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );\r\n\t\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );\r\n\t\r\n\t\t\t\t\tcustomAttribute.needsUpdate = false;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction setLineBuffers ( geometry, hint ) {\r\n\t\r\n\t\t\tvar v, c, d, vertex, offset, color,\r\n\t\r\n\t\t\tvertices = geometry.vertices,\r\n\t\t\tcolors = geometry.colors,\r\n\t\t\tlineDistances = geometry.lineDistances,\r\n\t\r\n\t\t\tvl = vertices.length,\r\n\t\t\tcl = colors.length,\r\n\t\t\tdl = lineDistances.length,\r\n\t\r\n\t\t\tvertexArray = geometry.__vertexArray,\r\n\t\t\tcolorArray = geometry.__colorArray,\r\n\t\t\tlineDistanceArray = geometry.__lineDistanceArray,\r\n\t\r\n\t\t\tdirtyVertices = geometry.verticesNeedUpdate,\r\n\t\t\tdirtyColors = geometry.colorsNeedUpdate,\r\n\t\t\tdirtyLineDistances = geometry.lineDistancesNeedUpdate,\r\n\t\r\n\t\t\tcustomAttributes = geometry.__webglCustomAttributesList,\r\n\t\r\n\t\t\ti, il,\r\n\t\t\tca, cal, value,\r\n\t\t\tcustomAttribute;\r\n\t\r\n\t\t\tif ( dirtyVertices ) {\r\n\t\r\n\t\t\t\tfor ( v = 0; v < vl; v ++ ) {\r\n\t\r\n\t\t\t\t\tvertex = vertices[ v ];\r\n\t\r\n\t\t\t\t\toffset = v * 3;\r\n\t\r\n\t\t\t\t\tvertexArray[ offset ]     = vertex.x;\r\n\t\t\t\t\tvertexArray[ offset + 1 ] = vertex.y;\r\n\t\t\t\t\tvertexArray[ offset + 2 ] = vertex.z;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglVertexBuffer );\r\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( dirtyColors ) {\r\n\t\r\n\t\t\t\tfor ( c = 0; c < cl; c ++ ) {\r\n\t\r\n\t\t\t\t\tcolor = colors[ c ];\r\n\t\r\n\t\t\t\t\toffset = c * 3;\r\n\t\r\n\t\t\t\t\tcolorArray[ offset ]     = color.r;\r\n\t\t\t\t\tcolorArray[ offset + 1 ] = color.g;\r\n\t\t\t\t\tcolorArray[ offset + 2 ] = color.b;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglColorBuffer );\r\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( dirtyLineDistances ) {\r\n\t\r\n\t\t\t\tfor ( d = 0; d < dl; d ++ ) {\r\n\t\r\n\t\t\t\t\tlineDistanceArray[ d ] = lineDistances[ d ];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglLineDistanceBuffer );\r\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, lineDistanceArray, hint );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( customAttributes ) {\r\n\t\r\n\t\t\t\tfor ( i = 0, il = customAttributes.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\tcustomAttribute = customAttributes[ i ];\r\n\t\r\n\t\t\t\t\tif ( customAttribute.needsUpdate && ( customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices' ) ) {\r\n\t\r\n\t\t\t\t\t\toffset = 0;\r\n\t\r\n\t\t\t\t\t\tcal = customAttribute.value.length;\r\n\t\r\n\t\t\t\t\t\tif ( customAttribute.size === 1 ) {\r\n\t\r\n\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ ca ] = customAttribute.value[ ca ];\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t} else if ( customAttribute.size === 2 ) {\r\n\t\r\n\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\r\n\t\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset ]   = value.x;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.y;\r\n\t\r\n\t\t\t\t\t\t\t\toffset += 2;\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t} else if ( customAttribute.size === 3 ) {\r\n\t\r\n\t\t\t\t\t\t\tif ( customAttribute.type === 'c' ) {\r\n\t\r\n\t\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\r\n\t\r\n\t\t\t\t\t\t\t\t\tcustomAttribute.array[ offset ]   = value.r;\r\n\t\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.g;\r\n\t\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2 ] = value.b;\r\n\t\r\n\t\t\t\t\t\t\t\t\toffset += 3;\r\n\t\r\n\t\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\r\n\t\r\n\t\t\t\t\t\t\t\t\tcustomAttribute.array[ offset ]   = value.x;\r\n\t\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.y;\r\n\t\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2 ] = value.z;\r\n\t\r\n\t\t\t\t\t\t\t\t\toffset += 3;\r\n\t\r\n\t\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t} else if ( customAttribute.size === 4 ) {\r\n\t\r\n\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\r\n\t\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset ]    = value.x;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1  ] = value.y;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2  ] = value.z;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 3  ] = value.w;\r\n\t\r\n\t\t\t\t\t\t\t\toffset += 4;\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );\r\n\t\t\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );\r\n\t\r\n\t\t\t\t\t\tcustomAttribute.needsUpdate = false;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction setMeshBuffers( geometryGroup, object, hint, dispose, material ) {\r\n\t\r\n\t\t\tif ( ! geometryGroup.__inittedArrays ) {\r\n\t\r\n\t\t\t\treturn;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar needsFaceNormals = materialNeedsFaceNormals( material );\r\n\t\r\n\t\t\tvar f, fl, fi, face,\r\n\t\t\tvertexNormals, faceNormal,\r\n\t\t\tvertexColors, faceColor,\r\n\t\t\tvertexTangents,\r\n\t\t\tuv, uv2, v1, v2, v3, t1, t2, t3, n1, n2, n3,\r\n\t\t\tc1, c2, c3,\r\n\t\t\tsw1, sw2, sw3,\r\n\t\t\tsi1, si2, si3,\r\n\t\t\ti, il,\r\n\t\t\tvn, uvi, uv2i,\r\n\t\t\tvk, vkl, vka,\r\n\t\t\tnka, chf, faceVertexNormals,\r\n\t\r\n\t\t\tvertexIndex = 0,\r\n\t\r\n\t\t\toffset = 0,\r\n\t\t\toffset_uv = 0,\r\n\t\t\toffset_uv2 = 0,\r\n\t\t\toffset_face = 0,\r\n\t\t\toffset_normal = 0,\r\n\t\t\toffset_tangent = 0,\r\n\t\t\toffset_line = 0,\r\n\t\t\toffset_color = 0,\r\n\t\t\toffset_skin = 0,\r\n\t\t\toffset_morphTarget = 0,\r\n\t\t\toffset_custom = 0,\r\n\t\r\n\t\t\tvalue,\r\n\t\r\n\t\t\tvertexArray = geometryGroup.__vertexArray,\r\n\t\t\tuvArray = geometryGroup.__uvArray,\r\n\t\t\tuv2Array = geometryGroup.__uv2Array,\r\n\t\t\tnormalArray = geometryGroup.__normalArray,\r\n\t\t\ttangentArray = geometryGroup.__tangentArray,\r\n\t\t\tcolorArray = geometryGroup.__colorArray,\r\n\t\r\n\t\t\tskinIndexArray = geometryGroup.__skinIndexArray,\r\n\t\t\tskinWeightArray = geometryGroup.__skinWeightArray,\r\n\t\r\n\t\t\tmorphTargetsArrays = geometryGroup.__morphTargetsArrays,\r\n\t\t\tmorphNormalsArrays = geometryGroup.__morphNormalsArrays,\r\n\t\r\n\t\t\tcustomAttributes = geometryGroup.__webglCustomAttributesList,\r\n\t\t\tcustomAttribute,\r\n\t\r\n\t\t\tfaceArray = geometryGroup.__faceArray,\r\n\t\t\tlineArray = geometryGroup.__lineArray,\r\n\t\r\n\t\t\tgeometry = object.geometry, // this is shared for all chunks\r\n\t\r\n\t\t\tdirtyVertices = geometry.verticesNeedUpdate,\r\n\t\t\tdirtyElements = geometry.elementsNeedUpdate,\r\n\t\t\tdirtyUvs = geometry.uvsNeedUpdate,\r\n\t\t\tdirtyNormals = geometry.normalsNeedUpdate,\r\n\t\t\tdirtyTangents = geometry.tangentsNeedUpdate,\r\n\t\t\tdirtyColors = geometry.colorsNeedUpdate,\r\n\t\t\tdirtyMorphTargets = geometry.morphTargetsNeedUpdate,\r\n\t\r\n\t\t\tvertices = geometry.vertices,\r\n\t\t\tchunk_faces3 = geometryGroup.faces3,\r\n\t\t\tobj_faces = geometry.faces,\r\n\t\r\n\t\t\tobj_uvs  = geometry.faceVertexUvs[ 0 ],\r\n\t\t\tobj_uvs2 = geometry.faceVertexUvs[ 1 ],\r\n\t\r\n\t\t\tobj_skinIndices = geometry.skinIndices,\r\n\t\t\tobj_skinWeights = geometry.skinWeights,\r\n\t\r\n\t\t\tmorphTargets = geometry.morphTargets,\r\n\t\t\tmorphNormals = geometry.morphNormals;\r\n\t\r\n\t\t\tif ( dirtyVertices ) {\r\n\t\r\n\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\t\r\n\t\t\t\t\tface = obj_faces[ chunk_faces3[ f ] ];\r\n\t\r\n\t\t\t\t\tv1 = vertices[ face.a ];\r\n\t\t\t\t\tv2 = vertices[ face.b ];\r\n\t\t\t\t\tv3 = vertices[ face.c ];\r\n\t\r\n\t\t\t\t\tvertexArray[ offset ]     = v1.x;\r\n\t\t\t\t\tvertexArray[ offset + 1 ] = v1.y;\r\n\t\t\t\t\tvertexArray[ offset + 2 ] = v1.z;\r\n\t\r\n\t\t\t\t\tvertexArray[ offset + 3 ] = v2.x;\r\n\t\t\t\t\tvertexArray[ offset + 4 ] = v2.y;\r\n\t\t\t\t\tvertexArray[ offset + 5 ] = v2.z;\r\n\t\r\n\t\t\t\t\tvertexArray[ offset + 6 ] = v3.x;\r\n\t\t\t\t\tvertexArray[ offset + 7 ] = v3.y;\r\n\t\t\t\t\tvertexArray[ offset + 8 ] = v3.z;\r\n\t\r\n\t\t\t\t\toffset += 9;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );\r\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( dirtyMorphTargets ) {\r\n\t\r\n\t\t\t\tfor ( vk = 0, vkl = morphTargets.length; vk < vkl; vk ++ ) {\r\n\t\r\n\t\t\t\t\toffset_morphTarget = 0;\r\n\t\r\n\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\t\r\n\t\t\t\t\t\tchf = chunk_faces3[ f ];\r\n\t\t\t\t\t\tface = obj_faces[ chf ];\r\n\t\r\n\t\t\t\t\t\t// morph positions\r\n\t\r\n\t\t\t\t\t\tv1 = morphTargets[ vk ].vertices[ face.a ];\r\n\t\t\t\t\t\tv2 = morphTargets[ vk ].vertices[ face.b ];\r\n\t\t\t\t\t\tv3 = morphTargets[ vk ].vertices[ face.c ];\r\n\t\r\n\t\t\t\t\t\tvka = morphTargetsArrays[ vk ];\r\n\t\r\n\t\t\t\t\t\tvka[ offset_morphTarget ]     = v1.x;\r\n\t\t\t\t\t\tvka[ offset_morphTarget + 1 ] = v1.y;\r\n\t\t\t\t\t\tvka[ offset_morphTarget + 2 ] = v1.z;\r\n\t\r\n\t\t\t\t\t\tvka[ offset_morphTarget + 3 ] = v2.x;\r\n\t\t\t\t\t\tvka[ offset_morphTarget + 4 ] = v2.y;\r\n\t\t\t\t\t\tvka[ offset_morphTarget + 5 ] = v2.z;\r\n\t\r\n\t\t\t\t\t\tvka[ offset_morphTarget + 6 ] = v3.x;\r\n\t\t\t\t\t\tvka[ offset_morphTarget + 7 ] = v3.y;\r\n\t\t\t\t\t\tvka[ offset_morphTarget + 8 ] = v3.z;\r\n\t\r\n\t\t\t\t\t\t// morph normals\r\n\t\r\n\t\t\t\t\t\tif ( material.morphNormals ) {\r\n\t\r\n\t\t\t\t\t\t\tif ( needsFaceNormals ) {\r\n\t\r\n\t\t\t\t\t\t\t\tn1 = morphNormals[ vk ].faceNormals[ chf ];\r\n\t\t\t\t\t\t\t\tn2 = n1;\r\n\t\t\t\t\t\t\t\tn3 = n1;\r\n\t\r\n\t\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\t\tfaceVertexNormals = morphNormals[ vk ].vertexNormals[ chf ];\r\n\t\r\n\t\t\t\t\t\t\t\tn1 = faceVertexNormals.a;\r\n\t\t\t\t\t\t\t\tn2 = faceVertexNormals.b;\r\n\t\t\t\t\t\t\t\tn3 = faceVertexNormals.c;\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\tnka = morphNormalsArrays[ vk ];\r\n\t\r\n\t\t\t\t\t\t\tnka[ offset_morphTarget ]     = n1.x;\r\n\t\t\t\t\t\t\tnka[ offset_morphTarget + 1 ] = n1.y;\r\n\t\t\t\t\t\t\tnka[ offset_morphTarget + 2 ] = n1.z;\r\n\t\r\n\t\t\t\t\t\t\tnka[ offset_morphTarget + 3 ] = n2.x;\r\n\t\t\t\t\t\t\tnka[ offset_morphTarget + 4 ] = n2.y;\r\n\t\t\t\t\t\t\tnka[ offset_morphTarget + 5 ] = n2.z;\r\n\t\r\n\t\t\t\t\t\t\tnka[ offset_morphTarget + 6 ] = n3.x;\r\n\t\t\t\t\t\t\tnka[ offset_morphTarget + 7 ] = n3.y;\r\n\t\t\t\t\t\t\tnka[ offset_morphTarget + 8 ] = n3.z;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t//\r\n\t\r\n\t\t\t\t\t\toffset_morphTarget += 9;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ vk ] );\r\n\t\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, morphTargetsArrays[ vk ], hint );\r\n\t\r\n\t\t\t\t\tif ( material.morphNormals ) {\r\n\t\r\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[ vk ] );\r\n\t\t\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, morphNormalsArrays[ vk ], hint );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( obj_skinWeights.length ) {\r\n\t\r\n\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\t\r\n\t\t\t\t\tface = obj_faces[ chunk_faces3[ f ] ];\r\n\t\r\n\t\t\t\t\t// weights\r\n\t\r\n\t\t\t\t\tsw1 = obj_skinWeights[ face.a ];\r\n\t\t\t\t\tsw2 = obj_skinWeights[ face.b ];\r\n\t\t\t\t\tsw3 = obj_skinWeights[ face.c ];\r\n\t\r\n\t\t\t\t\tskinWeightArray[ offset_skin ]     = sw1.x;\r\n\t\t\t\t\tskinWeightArray[ offset_skin + 1 ] = sw1.y;\r\n\t\t\t\t\tskinWeightArray[ offset_skin + 2 ] = sw1.z;\r\n\t\t\t\t\tskinWeightArray[ offset_skin + 3 ] = sw1.w;\r\n\t\r\n\t\t\t\t\tskinWeightArray[ offset_skin + 4 ] = sw2.x;\r\n\t\t\t\t\tskinWeightArray[ offset_skin + 5 ] = sw2.y;\r\n\t\t\t\t\tskinWeightArray[ offset_skin + 6 ] = sw2.z;\r\n\t\t\t\t\tskinWeightArray[ offset_skin + 7 ] = sw2.w;\r\n\t\r\n\t\t\t\t\tskinWeightArray[ offset_skin + 8 ]  = sw3.x;\r\n\t\t\t\t\tskinWeightArray[ offset_skin + 9 ]  = sw3.y;\r\n\t\t\t\t\tskinWeightArray[ offset_skin + 10 ] = sw3.z;\r\n\t\t\t\t\tskinWeightArray[ offset_skin + 11 ] = sw3.w;\r\n\t\r\n\t\t\t\t\t// indices\r\n\t\r\n\t\t\t\t\tsi1 = obj_skinIndices[ face.a ];\r\n\t\t\t\t\tsi2 = obj_skinIndices[ face.b ];\r\n\t\t\t\t\tsi3 = obj_skinIndices[ face.c ];\r\n\t\r\n\t\t\t\t\tskinIndexArray[ offset_skin ]     = si1.x;\r\n\t\t\t\t\tskinIndexArray[ offset_skin + 1 ] = si1.y;\r\n\t\t\t\t\tskinIndexArray[ offset_skin + 2 ] = si1.z;\r\n\t\t\t\t\tskinIndexArray[ offset_skin + 3 ] = si1.w;\r\n\t\r\n\t\t\t\t\tskinIndexArray[ offset_skin + 4 ] = si2.x;\r\n\t\t\t\t\tskinIndexArray[ offset_skin + 5 ] = si2.y;\r\n\t\t\t\t\tskinIndexArray[ offset_skin + 6 ] = si2.z;\r\n\t\t\t\t\tskinIndexArray[ offset_skin + 7 ] = si2.w;\r\n\t\r\n\t\t\t\t\tskinIndexArray[ offset_skin + 8 ]  = si3.x;\r\n\t\t\t\t\tskinIndexArray[ offset_skin + 9 ]  = si3.y;\r\n\t\t\t\t\tskinIndexArray[ offset_skin + 10 ] = si3.z;\r\n\t\t\t\t\tskinIndexArray[ offset_skin + 11 ] = si3.w;\r\n\t\r\n\t\t\t\t\toffset_skin += 12;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( offset_skin > 0 ) {\r\n\t\r\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinIndicesBuffer );\r\n\t\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, skinIndexArray, hint );\r\n\t\r\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinWeightsBuffer );\r\n\t\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, skinWeightArray, hint );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( dirtyColors ) {\r\n\t\r\n\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\t\r\n\t\t\t\t\tface = obj_faces[ chunk_faces3[ f ] ];\r\n\t\r\n\t\t\t\t\tvertexColors = face.vertexColors;\r\n\t\t\t\t\tfaceColor = face.color;\r\n\t\r\n\t\t\t\t\tif ( vertexColors.length === 3 && material.vertexColors === THREE.VertexColors ) {\r\n\t\r\n\t\t\t\t\t\tc1 = vertexColors[ 0 ];\r\n\t\t\t\t\t\tc2 = vertexColors[ 1 ];\r\n\t\t\t\t\t\tc3 = vertexColors[ 2 ];\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tc1 = faceColor;\r\n\t\t\t\t\t\tc2 = faceColor;\r\n\t\t\t\t\t\tc3 = faceColor;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tcolorArray[ offset_color ]     = c1.r;\r\n\t\t\t\t\tcolorArray[ offset_color + 1 ] = c1.g;\r\n\t\t\t\t\tcolorArray[ offset_color + 2 ] = c1.b;\r\n\t\r\n\t\t\t\t\tcolorArray[ offset_color + 3 ] = c2.r;\r\n\t\t\t\t\tcolorArray[ offset_color + 4 ] = c2.g;\r\n\t\t\t\t\tcolorArray[ offset_color + 5 ] = c2.b;\r\n\t\r\n\t\t\t\t\tcolorArray[ offset_color + 6 ] = c3.r;\r\n\t\t\t\t\tcolorArray[ offset_color + 7 ] = c3.g;\r\n\t\t\t\t\tcolorArray[ offset_color + 8 ] = c3.b;\r\n\t\r\n\t\t\t\t\toffset_color += 9;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( offset_color > 0 ) {\r\n\t\r\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglColorBuffer );\r\n\t\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( dirtyTangents && geometry.hasTangents ) {\r\n\t\r\n\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\t\r\n\t\t\t\t\tface = obj_faces[ chunk_faces3[ f ] ];\r\n\t\r\n\t\t\t\t\tvertexTangents = face.vertexTangents;\r\n\t\r\n\t\t\t\t\tt1 = vertexTangents[ 0 ];\r\n\t\t\t\t\tt2 = vertexTangents[ 1 ];\r\n\t\t\t\t\tt3 = vertexTangents[ 2 ];\r\n\t\r\n\t\t\t\t\ttangentArray[ offset_tangent ]     = t1.x;\r\n\t\t\t\t\ttangentArray[ offset_tangent + 1 ] = t1.y;\r\n\t\t\t\t\ttangentArray[ offset_tangent + 2 ] = t1.z;\r\n\t\t\t\t\ttangentArray[ offset_tangent + 3 ] = t1.w;\r\n\t\r\n\t\t\t\t\ttangentArray[ offset_tangent + 4 ] = t2.x;\r\n\t\t\t\t\ttangentArray[ offset_tangent + 5 ] = t2.y;\r\n\t\t\t\t\ttangentArray[ offset_tangent + 6 ] = t2.z;\r\n\t\t\t\t\ttangentArray[ offset_tangent + 7 ] = t2.w;\r\n\t\r\n\t\t\t\t\ttangentArray[ offset_tangent + 8 ]  = t3.x;\r\n\t\t\t\t\ttangentArray[ offset_tangent + 9 ]  = t3.y;\r\n\t\t\t\t\ttangentArray[ offset_tangent + 10 ] = t3.z;\r\n\t\t\t\t\ttangentArray[ offset_tangent + 11 ] = t3.w;\r\n\t\r\n\t\t\t\t\toffset_tangent += 12;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglTangentBuffer );\r\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, tangentArray, hint );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( dirtyNormals ) {\r\n\t\r\n\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\t\r\n\t\t\t\t\tface = obj_faces[ chunk_faces3[ f ] ];\r\n\t\r\n\t\t\t\t\tvertexNormals = face.vertexNormals;\r\n\t\t\t\t\tfaceNormal = face.normal;\r\n\t\r\n\t\t\t\t\tif ( vertexNormals.length === 3 && needsFaceNormals === false ) {\r\n\t\r\n\t\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\r\n\t\r\n\t\t\t\t\t\t\tvn = vertexNormals[ i ];\r\n\t\r\n\t\t\t\t\t\t\tnormalArray[ offset_normal ]     = vn.x;\r\n\t\t\t\t\t\t\tnormalArray[ offset_normal + 1 ] = vn.y;\r\n\t\t\t\t\t\t\tnormalArray[ offset_normal + 2 ] = vn.z;\r\n\t\r\n\t\t\t\t\t\t\toffset_normal += 3;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\r\n\t\r\n\t\t\t\t\t\t\tnormalArray[ offset_normal ]     = faceNormal.x;\r\n\t\t\t\t\t\t\tnormalArray[ offset_normal + 1 ] = faceNormal.y;\r\n\t\t\t\t\t\t\tnormalArray[ offset_normal + 2 ] = faceNormal.z;\r\n\t\r\n\t\t\t\t\t\t\toffset_normal += 3;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglNormalBuffer );\r\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, normalArray, hint );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( dirtyUvs && obj_uvs ) {\r\n\t\r\n\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\t\r\n\t\t\t\t\tfi = chunk_faces3[ f ];\r\n\t\r\n\t\t\t\t\tuv = obj_uvs[ fi ];\r\n\t\r\n\t\t\t\t\tif ( uv === undefined ) continue;\r\n\t\r\n\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\r\n\t\r\n\t\t\t\t\t\tuvi = uv[ i ];\r\n\t\r\n\t\t\t\t\t\tuvArray[ offset_uv ]     = uvi.x;\r\n\t\t\t\t\t\tuvArray[ offset_uv + 1 ] = uvi.y;\r\n\t\r\n\t\t\t\t\t\toffset_uv += 2;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( offset_uv > 0 ) {\r\n\t\r\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUVBuffer );\r\n\t\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, uvArray, hint );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( dirtyUvs && obj_uvs2 ) {\r\n\t\r\n\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\t\r\n\t\t\t\t\tfi = chunk_faces3[ f ];\r\n\t\r\n\t\t\t\t\tuv2 = obj_uvs2[ fi ];\r\n\t\r\n\t\t\t\t\tif ( uv2 === undefined ) continue;\r\n\t\r\n\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\r\n\t\r\n\t\t\t\t\t\tuv2i = uv2[ i ];\r\n\t\r\n\t\t\t\t\t\tuv2Array[ offset_uv2 ]     = uv2i.x;\r\n\t\t\t\t\t\tuv2Array[ offset_uv2 + 1 ] = uv2i.y;\r\n\t\r\n\t\t\t\t\t\toffset_uv2 += 2;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( offset_uv2 > 0 ) {\r\n\t\r\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUV2Buffer );\r\n\t\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, uv2Array, hint );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( dirtyElements ) {\r\n\t\r\n\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\t\r\n\t\t\t\t\tfaceArray[ offset_face ]   = vertexIndex;\r\n\t\t\t\t\tfaceArray[ offset_face + 1 ] = vertexIndex + 1;\r\n\t\t\t\t\tfaceArray[ offset_face + 2 ] = vertexIndex + 2;\r\n\t\r\n\t\t\t\t\toffset_face += 3;\r\n\t\r\n\t\t\t\t\tlineArray[ offset_line ]     = vertexIndex;\r\n\t\t\t\t\tlineArray[ offset_line + 1 ] = vertexIndex + 1;\r\n\t\r\n\t\t\t\t\tlineArray[ offset_line + 2 ] = vertexIndex;\r\n\t\t\t\t\tlineArray[ offset_line + 3 ] = vertexIndex + 2;\r\n\t\r\n\t\t\t\t\tlineArray[ offset_line + 4 ] = vertexIndex + 1;\r\n\t\t\t\t\tlineArray[ offset_line + 5 ] = vertexIndex + 2;\r\n\t\r\n\t\t\t\t\toffset_line += 6;\r\n\t\r\n\t\t\t\t\tvertexIndex += 3;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglFaceBuffer );\r\n\t\t\t\t_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, faceArray, hint );\r\n\t\r\n\t\t\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglLineBuffer );\r\n\t\t\t\t_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, lineArray, hint );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( customAttributes ) {\r\n\t\r\n\t\t\t\tfor ( i = 0, il = customAttributes.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\tcustomAttribute = customAttributes[ i ];\r\n\t\r\n\t\t\t\t\tif ( ! customAttribute.__original.needsUpdate ) continue;\r\n\t\r\n\t\t\t\t\toffset_custom = 0;\r\n\t\r\n\t\t\t\t\tif ( customAttribute.size === 1 ) {\r\n\t\r\n\t\t\t\t\t\tif ( customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices' ) {\r\n\t\r\n\t\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\tface = obj_faces[ chunk_faces3[ f ] ];\r\n\t\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ]     = customAttribute.value[ face.a ];\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = customAttribute.value[ face.b ];\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = customAttribute.value[ face.c ];\r\n\t\r\n\t\t\t\t\t\t\t\toffset_custom += 3;\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t} else if ( customAttribute.boundTo === 'faces' ) {\r\n\t\r\n\t\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\tvalue = customAttribute.value[ chunk_faces3[ f ] ];\r\n\t\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ]     = value;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = value;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = value;\r\n\t\r\n\t\t\t\t\t\t\t\toffset_custom += 3;\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t} else if ( customAttribute.size === 2 ) {\r\n\t\r\n\t\t\t\t\t\tif ( customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices' ) {\r\n\t\r\n\t\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\tface = obj_faces[ chunk_faces3[ f ] ];\r\n\t\r\n\t\t\t\t\t\t\t\tv1 = customAttribute.value[ face.a ];\r\n\t\t\t\t\t\t\t\tv2 = customAttribute.value[ face.b ];\r\n\t\t\t\t\t\t\t\tv3 = customAttribute.value[ face.c ];\r\n\t\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ]     = v1.x;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = v1.y;\r\n\t\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = v2.x;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3 ] = v2.y;\r\n\t\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4 ] = v3.x;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5 ] = v3.y;\r\n\t\r\n\t\t\t\t\t\t\t\toffset_custom += 6;\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t} else if ( customAttribute.boundTo === 'faces' ) {\r\n\t\r\n\t\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\tvalue = customAttribute.value[ chunk_faces3[ f ] ];\r\n\t\r\n\t\t\t\t\t\t\t\tv1 = value;\r\n\t\t\t\t\t\t\t\tv2 = value;\r\n\t\t\t\t\t\t\t\tv3 = value;\r\n\t\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ]     = v1.x;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = v1.y;\r\n\t\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = v2.x;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3 ] = v2.y;\r\n\t\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4 ] = v3.x;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5 ] = v3.y;\r\n\t\r\n\t\t\t\t\t\t\t\toffset_custom += 6;\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t} else if ( customAttribute.size === 3 ) {\r\n\t\r\n\t\t\t\t\t\tvar pp;\r\n\t\r\n\t\t\t\t\t\tif ( customAttribute.type === 'c' ) {\r\n\t\r\n\t\t\t\t\t\t\tpp = [ 'r', 'g', 'b' ];\r\n\t\r\n\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\tpp = [ 'x', 'y', 'z' ];\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tif ( customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices' ) {\r\n\t\r\n\t\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\tface = obj_faces[ chunk_faces3[ f ] ];\r\n\t\r\n\t\t\t\t\t\t\t\tv1 = customAttribute.value[ face.a ];\r\n\t\t\t\t\t\t\t\tv2 = customAttribute.value[ face.b ];\r\n\t\t\t\t\t\t\t\tv3 = customAttribute.value[ face.c ];\r\n\t\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ]     = v1[ pp[ 0 ] ];\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];\r\n\t\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];\r\n\t\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];\r\n\t\r\n\t\t\t\t\t\t\t\toffset_custom += 9;\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t} else if ( customAttribute.boundTo === 'faces' ) {\r\n\t\r\n\t\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\tvalue = customAttribute.value[ chunk_faces3[ f ] ];\r\n\t\r\n\t\t\t\t\t\t\t\tv1 = value;\r\n\t\t\t\t\t\t\t\tv2 = value;\r\n\t\t\t\t\t\t\t\tv3 = value;\r\n\t\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ]     = v1[ pp[ 0 ] ];\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];\r\n\t\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];\r\n\t\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];\r\n\t\r\n\t\t\t\t\t\t\t\toffset_custom += 9;\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t} else if ( customAttribute.boundTo === 'faceVertices' ) {\r\n\t\r\n\t\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\tvalue = customAttribute.value[ chunk_faces3[ f ] ];\r\n\t\r\n\t\t\t\t\t\t\t\tv1 = value[ 0 ];\r\n\t\t\t\t\t\t\t\tv2 = value[ 1 ];\r\n\t\t\t\t\t\t\t\tv3 = value[ 2 ];\r\n\t\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ]     = v1[ pp[ 0 ] ];\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];\r\n\t\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];\r\n\t\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];\r\n\t\r\n\t\t\t\t\t\t\t\toffset_custom += 9;\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t} else if ( customAttribute.size === 4 ) {\r\n\t\r\n\t\t\t\t\t\tif ( customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices' ) {\r\n\t\r\n\t\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\tface = obj_faces[ chunk_faces3[ f ] ];\r\n\t\r\n\t\t\t\t\t\t\t\tv1 = customAttribute.value[ face.a ];\r\n\t\t\t\t\t\t\t\tv2 = customAttribute.value[ face.b ];\r\n\t\t\t\t\t\t\t\tv3 = customAttribute.value[ face.c ];\r\n\t\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom  ]   = v1.x;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1  ] = v1.y;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2  ] = v1.z;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3  ] = v1.w;\r\n\t\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4  ] = v2.x;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5  ] = v2.y;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6  ] = v2.z;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7  ] = v2.w;\r\n\t\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 8  ] = v3.x;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 9  ] = v3.y;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 10 ] = v3.z;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 11 ] = v3.w;\r\n\t\r\n\t\t\t\t\t\t\t\toffset_custom += 12;\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t} else if ( customAttribute.boundTo === 'faces' ) {\r\n\t\r\n\t\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\tvalue = customAttribute.value[ chunk_faces3[ f ] ];\r\n\t\r\n\t\t\t\t\t\t\t\tv1 = value;\r\n\t\t\t\t\t\t\t\tv2 = value;\r\n\t\t\t\t\t\t\t\tv3 = value;\r\n\t\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom  ]   = v1.x;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1  ] = v1.y;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2  ] = v1.z;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3  ] = v1.w;\r\n\t\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4  ] = v2.x;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5  ] = v2.y;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6  ] = v2.z;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7  ] = v2.w;\r\n\t\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 8  ] = v3.x;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 9  ] = v3.y;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 10 ] = v3.z;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 11 ] = v3.w;\r\n\t\r\n\t\t\t\t\t\t\t\toffset_custom += 12;\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t} else if ( customAttribute.boundTo === 'faceVertices' ) {\r\n\t\r\n\t\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\tvalue = customAttribute.value[ chunk_faces3[ f ] ];\r\n\t\r\n\t\t\t\t\t\t\t\tv1 = value[ 0 ];\r\n\t\t\t\t\t\t\t\tv2 = value[ 1 ];\r\n\t\t\t\t\t\t\t\tv3 = value[ 2 ];\r\n\t\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom  ]   = v1.x;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1  ] = v1.y;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2  ] = v1.z;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3  ] = v1.w;\r\n\t\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4  ] = v2.x;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5  ] = v2.y;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6  ] = v2.z;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7  ] = v2.w;\r\n\t\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 8  ] = v3.x;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 9  ] = v3.y;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 10 ] = v3.z;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 11 ] = v3.w;\r\n\t\r\n\t\t\t\t\t\t\t\toffset_custom += 12;\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );\r\n\t\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( dispose ) {\r\n\t\r\n\t\t\t\tdelete geometryGroup.__inittedArrays;\r\n\t\t\t\tdelete geometryGroup.__colorArray;\r\n\t\t\t\tdelete geometryGroup.__normalArray;\r\n\t\t\t\tdelete geometryGroup.__tangentArray;\r\n\t\t\t\tdelete geometryGroup.__uvArray;\r\n\t\t\t\tdelete geometryGroup.__uv2Array;\r\n\t\t\t\tdelete geometryGroup.__faceArray;\r\n\t\t\t\tdelete geometryGroup.__vertexArray;\r\n\t\t\t\tdelete geometryGroup.__lineArray;\r\n\t\t\t\tdelete geometryGroup.__skinIndexArray;\r\n\t\t\t\tdelete geometryGroup.__skinWeightArray;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\t// Buffer rendering\r\n\t\r\n\t\tthis.renderBufferImmediate = function ( object, program, material ) {\r\n\t\r\n\t\t\tstate.initAttributes();\r\n\t\r\n\t\t\tif ( object.hasPositions && ! object.__webglVertexBuffer ) object.__webglVertexBuffer = _gl.createBuffer();\r\n\t\t\tif ( object.hasNormals && ! object.__webglNormalBuffer ) object.__webglNormalBuffer = _gl.createBuffer();\r\n\t\t\tif ( object.hasUvs && ! object.__webglUvBuffer ) object.__webglUvBuffer = _gl.createBuffer();\r\n\t\t\tif ( object.hasColors && ! object.__webglColorBuffer ) object.__webglColorBuffer = _gl.createBuffer();\r\n\t\r\n\t\t\tif ( object.hasPositions ) {\r\n\t\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglVertexBuffer );\r\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );\r\n\t\r\n\t\t\t\tstate.enableAttribute( program.attributes.position );\r\n\t\r\n\t\t\t\t_gl.vertexAttribPointer( program.attributes.position, 3, _gl.FLOAT, false, 0, 0 );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( object.hasNormals ) {\r\n\t\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglNormalBuffer );\r\n\t\r\n\t\t\t\tif ( material instanceof THREE.MeshPhongMaterial === false &&\r\n\t\t\t\t\t   material.shading === THREE.FlatShading ) {\r\n\t\r\n\t\t\t\t\tvar nx, ny, nz,\r\n\t\t\t\t\t\tnax, nbx, ncx, nay, nby, ncy, naz, nbz, ncz,\r\n\t\t\t\t\t\tnormalArray,\r\n\t\t\t\t\t\ti, il = object.count * 3;\r\n\t\r\n\t\t\t\t\tfor ( i = 0; i < il; i += 9 ) {\r\n\t\r\n\t\t\t\t\t\tnormalArray = object.normalArray;\r\n\t\r\n\t\t\t\t\t\tnax  = normalArray[ i ];\r\n\t\t\t\t\t\tnay  = normalArray[ i + 1 ];\r\n\t\t\t\t\t\tnaz  = normalArray[ i + 2 ];\r\n\t\r\n\t\t\t\t\t\tnbx  = normalArray[ i + 3 ];\r\n\t\t\t\t\t\tnby  = normalArray[ i + 4 ];\r\n\t\t\t\t\t\tnbz  = normalArray[ i + 5 ];\r\n\t\r\n\t\t\t\t\t\tncx  = normalArray[ i + 6 ];\r\n\t\t\t\t\t\tncy  = normalArray[ i + 7 ];\r\n\t\t\t\t\t\tncz  = normalArray[ i + 8 ];\r\n\t\r\n\t\t\t\t\t\tnx = ( nax + nbx + ncx ) / 3;\r\n\t\t\t\t\t\tny = ( nay + nby + ncy ) / 3;\r\n\t\t\t\t\t\tnz = ( naz + nbz + ncz ) / 3;\r\n\t\r\n\t\t\t\t\t\tnormalArray[ i ]   = nx;\r\n\t\t\t\t\t\tnormalArray[ i + 1 ] = ny;\r\n\t\t\t\t\t\tnormalArray[ i + 2 ] = nz;\r\n\t\r\n\t\t\t\t\t\tnormalArray[ i + 3 ] = nx;\r\n\t\t\t\t\t\tnormalArray[ i + 4 ] = ny;\r\n\t\t\t\t\t\tnormalArray[ i + 5 ] = nz;\r\n\t\r\n\t\t\t\t\t\tnormalArray[ i + 6 ] = nx;\r\n\t\t\t\t\t\tnormalArray[ i + 7 ] = ny;\r\n\t\t\t\t\t\tnormalArray[ i + 8 ] = nz;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );\r\n\t\r\n\t\t\t\tstate.enableAttribute( program.attributes.normal );\r\n\t\r\n\t\t\t\t_gl.vertexAttribPointer( program.attributes.normal, 3, _gl.FLOAT, false, 0, 0 );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( object.hasUvs && material.map ) {\r\n\t\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglUvBuffer );\r\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );\r\n\t\r\n\t\t\t\tstate.enableAttribute( program.attributes.uv );\r\n\t\r\n\t\t\t\t_gl.vertexAttribPointer( program.attributes.uv, 2, _gl.FLOAT, false, 0, 0 );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( object.hasColors && material.vertexColors !== THREE.NoColors ) {\r\n\t\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglColorBuffer );\r\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );\r\n\t\r\n\t\t\t\tstate.enableAttribute( program.attributes.color );\r\n\t\r\n\t\t\t\t_gl.vertexAttribPointer( program.attributes.color, 3, _gl.FLOAT, false, 0, 0 );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tstate.disableUnusedAttributes();\r\n\t\r\n\t\t\t_gl.drawArrays( _gl.TRIANGLES, 0, object.count );\r\n\t\r\n\t\t\tobject.count = 0;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tfunction setupVertexAttributes( material, program, geometry, startIndex ) {\r\n\t\r\n\t\t\tvar geometryAttributes = geometry.attributes;\r\n\t\r\n\t\t\tvar programAttributes = program.attributes;\r\n\t\t\tvar programAttributesKeys = program.attributesKeys;\r\n\t\r\n\t\t\tfor ( var i = 0, l = programAttributesKeys.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tvar key = programAttributesKeys[ i ];\r\n\t\t\t\tvar programAttribute = programAttributes[ key ];\r\n\t\r\n\t\t\t\tif ( programAttribute >= 0 ) {\r\n\t\r\n\t\t\t\t\tvar geometryAttribute = geometryAttributes[ key ];\r\n\t\r\n\t\t\t\t\tif ( geometryAttribute !== undefined ) {\r\n\t\r\n\t\t\t\t\t\tvar size = geometryAttribute.itemSize;\r\n\t\r\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryAttribute.buffer );\r\n\t\r\n\t\t\t\t\t\tstate.enableAttribute( programAttribute );\r\n\t\r\n\t\t\t\t\t\t_gl.vertexAttribPointer( programAttribute, size, _gl.FLOAT, false, 0, startIndex * size * 4 ); // 4 bytes per Float32\r\n\t\r\n\t\t\t\t\t} else if ( material.defaultAttributeValues !== undefined ) {\r\n\t\r\n\t\t\t\t\t\tif ( material.defaultAttributeValues[ key ].length === 2 ) {\r\n\t\r\n\t\t\t\t\t\t\t_gl.vertexAttrib2fv( programAttribute, material.defaultAttributeValues[ key ] );\r\n\t\r\n\t\t\t\t\t\t} else if ( material.defaultAttributeValues[ key ].length === 3 ) {\r\n\t\r\n\t\t\t\t\t\t\t_gl.vertexAttrib3fv( programAttribute, material.defaultAttributeValues[ key ] );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tstate.disableUnusedAttributes();\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.renderBufferDirect = function ( camera, lights, fog, material, geometry, object ) {\r\n\t\r\n\t\t\tif ( material.visible === false ) return;\r\n\t\r\n\t\t\tupdateObject( object );\r\n\t\r\n\t\t\tvar program = setProgram( camera, lights, fog, material, object );\r\n\t\r\n\t\t\tvar updateBuffers = false,\r\n\t\t\t\twireframeBit = material.wireframe ? 1 : 0,\r\n\t\t\t\tgeometryProgram = 'direct_' + geometry.id + '_' + program.id + '_' + wireframeBit;\r\n\t\r\n\t\t\tif ( geometryProgram !== _currentGeometryProgram ) {\r\n\t\r\n\t\t\t\t_currentGeometryProgram = geometryProgram;\r\n\t\t\t\tupdateBuffers = true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( updateBuffers ) {\r\n\t\r\n\t\t\t\tstate.initAttributes();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// render mesh\r\n\t\r\n\t\t\tif ( object instanceof THREE.Mesh ) {\r\n\t\r\n\t\t\t\tvar mode = material.wireframe === true ? _gl.LINES : _gl.TRIANGLES;\r\n\t\r\n\t\t\t\tvar index = geometry.attributes.index;\r\n\t\r\n\t\t\t\tif ( index ) {\r\n\t\r\n\t\t\t\t\t// indexed triangles\r\n\t\r\n\t\t\t\t\tvar type, size;\r\n\t\r\n\t\t\t\t\tif ( index.array instanceof Uint32Array && extensions.get( 'OES_element_index_uint' ) ) {\r\n\t\r\n\t\t\t\t\t\ttype = _gl.UNSIGNED_INT;\r\n\t\t\t\t\t\tsize = 4;\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\ttype = _gl.UNSIGNED_SHORT;\r\n\t\t\t\t\t\tsize = 2;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tvar offsets = geometry.offsets;\r\n\t\r\n\t\t\t\t\tif ( offsets.length === 0 ) {\r\n\t\r\n\t\t\t\t\t\tif ( updateBuffers ) {\r\n\t\r\n\t\t\t\t\t\t\tsetupVertexAttributes( material, program, geometry, 0 );\r\n\t\t\t\t\t\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t_gl.drawElements( mode, index.array.length, type, 0 );\r\n\t\r\n\t\t\t\t\t\t_this.info.render.calls ++;\r\n\t\t\t\t\t\t_this.info.render.vertices += index.array.length; // not really true, here vertices can be shared\r\n\t\t\t\t\t\t_this.info.render.faces += index.array.length / 3;\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t// if there is more than 1 chunk\r\n\t\t\t\t\t\t// must set attribute pointers to use new offsets for each chunk\r\n\t\t\t\t\t\t// even if geometry and materials didn't change\r\n\t\r\n\t\t\t\t\t\tupdateBuffers = true;\r\n\t\r\n\t\t\t\t\t\tfor ( var i = 0, il = offsets.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\t\t\tvar startIndex = offsets[ i ].index;\r\n\t\r\n\t\t\t\t\t\t\tif ( updateBuffers ) {\r\n\t\r\n\t\t\t\t\t\t\t\tsetupVertexAttributes( material, program, geometry, startIndex );\r\n\t\t\t\t\t\t\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\t// render indexed triangles\r\n\t\r\n\t\t\t\t\t\t\t_gl.drawElements( mode, offsets[ i ].count, type, offsets[ i ].start * size );\r\n\t\r\n\t\t\t\t\t\t\t_this.info.render.calls ++;\r\n\t\t\t\t\t\t\t_this.info.render.vertices += offsets[ i ].count; // not really true, here vertices can be shared\r\n\t\t\t\t\t\t\t_this.info.render.faces += offsets[ i ].count / 3;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t// non-indexed triangles\r\n\t\r\n\t\t\t\t\tif ( updateBuffers ) {\r\n\t\r\n\t\t\t\t\t\tsetupVertexAttributes( material, program, geometry, 0 );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tvar position = geometry.attributes[ 'position' ];\r\n\t\r\n\t\t\t\t\t// render non-indexed triangles\r\n\t\r\n\t\t\t\t\t_gl.drawArrays( mode, 0, position.array.length / position.itemSize );\r\n\t\r\n\t\t\t\t\t_this.info.render.calls ++;\r\n\t\t\t\t\t_this.info.render.vertices += position.array.length / position.itemSize;\r\n\t\t\t\t\t_this.info.render.faces += position.array.length / ( 3 * position.itemSize );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else if ( object instanceof THREE.PointCloud ) {\r\n\t\r\n\t\t\t\t// render particles\r\n\t\r\n\t\t\t\tvar mode = _gl.POINTS;\r\n\t\r\n\t\t\t\tvar index = geometry.attributes.index;\r\n\t\r\n\t\t\t\tif ( index ) {\r\n\t\r\n\t\t\t\t\t// indexed points\r\n\t\r\n\t\t\t\t\tvar type, size;\r\n\t\r\n\t\t\t\t\tif ( index.array instanceof Uint32Array && extensions.get( 'OES_element_index_uint' ) ) {\r\n\t\r\n\t\t\t\t\t\ttype = _gl.UNSIGNED_INT;\r\n\t\t\t\t\t\tsize = 4;\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\ttype = _gl.UNSIGNED_SHORT;\r\n\t\t\t\t\t\tsize = 2;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tvar offsets = geometry.offsets;\r\n\t\r\n\t\t\t\t\tif ( offsets.length === 0 ) {\r\n\t\r\n\t\t\t\t\t\tif ( updateBuffers ) {\r\n\t\r\n\t\t\t\t\t\t\tsetupVertexAttributes( material, program, geometry, 0 );\r\n\t\t\t\t\t\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t_gl.drawElements( mode, index.array.length, type, 0);\r\n\t\r\n\t\t\t\t\t\t_this.info.render.calls ++;\r\n\t\t\t\t\t\t_this.info.render.points += index.array.length;\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t// if there is more than 1 chunk\r\n\t\t\t\t\t\t// must set attribute pointers to use new offsets for each chunk\r\n\t\t\t\t\t\t// even if geometry and materials didn't change\r\n\t\r\n\t\t\t\t\t\tif ( offsets.length > 1 ) updateBuffers = true;\r\n\t\r\n\t\t\t\t\t\tfor ( var i = 0, il = offsets.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\t\t\tvar startIndex = offsets[ i ].index;\r\n\t\r\n\t\t\t\t\t\t\tif ( updateBuffers ) {\r\n\t\r\n\t\t\t\t\t\t\t\tsetupVertexAttributes( material, program, geometry, startIndex );\r\n\t\t\t\t\t\t\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\t// render indexed points\r\n\t\r\n\t\t\t\t\t\t\t_gl.drawElements( mode, offsets[ i ].count, type, offsets[ i ].start * size );\r\n\t\r\n\t\t\t\t\t\t\t_this.info.render.calls ++;\r\n\t\t\t\t\t\t\t_this.info.render.points += offsets[ i ].count;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t// non-indexed points\r\n\t\r\n\t\t\t\t\tif ( updateBuffers ) {\r\n\t\r\n\t\t\t\t\t\tsetupVertexAttributes( material, program, geometry, 0 );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tvar position = geometry.attributes.position;\r\n\t\t\t\t\tvar offsets = geometry.offsets;\r\n\t\r\n\t\t\t\t\tif ( offsets.length === 0 ) {\r\n\t\r\n\t\t\t\t\t\t_gl.drawArrays( mode, 0, position.array.length / 3 );\r\n\t\r\n\t\t\t\t\t\t_this.info.render.calls ++;\r\n\t\t\t\t\t\t_this.info.render.points += position.array.length / 3;\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tfor ( var i = 0, il = offsets.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t_gl.drawArrays( mode, offsets[ i ].index, offsets[ i ].count );\r\n\t\r\n\t\t\t\t\t\t\t_this.info.render.calls ++;\r\n\t\t\t\t\t\t\t_this.info.render.points += offsets[ i ].count;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else if ( object instanceof THREE.Line ) {\r\n\t\r\n\t\t\t\tvar mode = ( object.mode === THREE.LineStrip ) ? _gl.LINE_STRIP : _gl.LINES;\r\n\t\r\n\t\t\t\tstate.setLineWidth( material.linewidth * pixelRatio );\r\n\t\r\n\t\t\t\tvar index = geometry.attributes.index;\r\n\t\r\n\t\t\t\tif ( index ) {\r\n\t\r\n\t\t\t\t\t// indexed lines\r\n\t\r\n\t\t\t\t\tvar type, size;\r\n\t\r\n\t\t\t\t\tif ( index.array instanceof Uint32Array ) {\r\n\t\r\n\t\t\t\t\t\ttype = _gl.UNSIGNED_INT;\r\n\t\t\t\t\t\tsize = 4;\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\ttype = _gl.UNSIGNED_SHORT;\r\n\t\t\t\t\t\tsize = 2;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tvar offsets = geometry.offsets;\r\n\t\r\n\t\t\t\t\tif ( offsets.length === 0 ) {\r\n\t\r\n\t\t\t\t\t\tif ( updateBuffers ) {\r\n\t\r\n\t\t\t\t\t\t\tsetupVertexAttributes( material, program, geometry, 0 );\r\n\t\t\t\t\t\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t_gl.drawElements( mode, index.array.length, type, 0 ); // 2 bytes per Uint16Array\r\n\t\r\n\t\t\t\t\t\t_this.info.render.calls ++;\r\n\t\t\t\t\t\t_this.info.render.vertices += index.array.length; // not really true, here vertices can be shared\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t// if there is more than 1 chunk\r\n\t\t\t\t\t\t// must set attribute pointers to use new offsets for each chunk\r\n\t\t\t\t\t\t// even if geometry and materials didn't change\r\n\t\r\n\t\t\t\t\t\tif ( offsets.length > 1 ) updateBuffers = true;\r\n\t\r\n\t\t\t\t\t\tfor ( var i = 0, il = offsets.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\t\t\tvar startIndex = offsets[ i ].index;\r\n\t\r\n\t\t\t\t\t\t\tif ( updateBuffers ) {\r\n\t\r\n\t\t\t\t\t\t\t\tsetupVertexAttributes( material, program, geometry, startIndex );\r\n\t\t\t\t\t\t\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\t// render indexed lines\r\n\t\r\n\t\t\t\t\t\t\t_gl.drawElements( mode, offsets[ i ].count, type, offsets[ i ].start * size ); // 2 bytes per Uint16Array\r\n\t\r\n\t\t\t\t\t\t\t_this.info.render.calls ++;\r\n\t\t\t\t\t\t\t_this.info.render.vertices += offsets[ i ].count; // not really true, here vertices can be shared\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t// non-indexed lines\r\n\t\r\n\t\t\t\t\tif ( updateBuffers ) {\r\n\t\r\n\t\t\t\t\t\tsetupVertexAttributes( material, program, geometry, 0 );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tvar position = geometry.attributes.position;\r\n\t\t\t\t\tvar offsets = geometry.offsets;\r\n\t\r\n\t\t\t\t\tif ( offsets.length === 0 ) {\r\n\t\r\n\t\t\t\t\t\t_gl.drawArrays( mode, 0, position.array.length / 3 );\r\n\t\r\n\t\t\t\t\t\t_this.info.render.calls ++;\r\n\t\t\t\t\t\t_this.info.render.vertices += position.array.length / 3;\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tfor ( var i = 0, il = offsets.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t_gl.drawArrays( mode, offsets[ i ].index, offsets[ i ].count );\r\n\t\r\n\t\t\t\t\t\t\t_this.info.render.calls ++;\r\n\t\t\t\t\t\t\t_this.info.render.vertices += offsets[ i ].count;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.renderBuffer = function ( camera, lights, fog, material, geometryGroup, object ) {\r\n\t\r\n\t\t\tif ( material.visible === false ) return;\r\n\t\r\n\t\t\tupdateObject( object );\r\n\t\r\n\t\t\tvar program = setProgram( camera, lights, fog, material, object );\r\n\t\r\n\t\t\tvar attributes = program.attributes;\r\n\t\r\n\t\t\tvar updateBuffers = false,\r\n\t\t\t\twireframeBit = material.wireframe ? 1 : 0,\r\n\t\t\t\tgeometryProgram = geometryGroup.id + '_' + program.id + '_' + wireframeBit;\r\n\t\r\n\t\t\tif ( geometryProgram !== _currentGeometryProgram ) {\r\n\t\r\n\t\t\t\t_currentGeometryProgram = geometryProgram;\r\n\t\t\t\tupdateBuffers = true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( updateBuffers ) {\r\n\t\r\n\t\t\t\tstate.initAttributes();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// vertices\r\n\t\r\n\t\t\tif ( ! material.morphTargets && attributes.position >= 0 ) {\r\n\t\r\n\t\t\t\tif ( updateBuffers ) {\r\n\t\r\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );\r\n\t\r\n\t\t\t\t\tstate.enableAttribute( attributes.position );\r\n\t\r\n\t\t\t\t\t_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tif ( object.morphTargetBase ) {\r\n\t\r\n\t\t\t\t\tsetupMorphTargets( material, geometryGroup, object );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\r\n\t\t\tif ( updateBuffers ) {\r\n\t\r\n\t\t\t\t// custom attributes\r\n\t\r\n\t\t\t\t// Use the per-geometryGroup custom attribute arrays which are setup in initMeshBuffers\r\n\t\r\n\t\t\t\tif ( geometryGroup.__webglCustomAttributesList ) {\r\n\t\r\n\t\t\t\t\tfor ( var i = 0, il = geometryGroup.__webglCustomAttributesList.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\t\tvar attribute = geometryGroup.__webglCustomAttributesList[ i ];\r\n\t\r\n\t\t\t\t\t\tif ( attributes[ attribute.buffer.belongsToAttribute ] >= 0 ) {\r\n\t\r\n\t\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, attribute.buffer );\r\n\t\r\n\t\t\t\t\t\t\tstate.enableAttribute( attributes[ attribute.buffer.belongsToAttribute ] );\r\n\t\r\n\t\t\t\t\t\t\t_gl.vertexAttribPointer( attributes[ attribute.buffer.belongsToAttribute ], attribute.size, _gl.FLOAT, false, 0, 0 );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\r\n\t\t\t\t// colors\r\n\t\r\n\t\t\t\tif ( attributes.color >= 0 ) {\r\n\t\r\n\t\t\t\t\tif ( object.geometry.colors.length > 0 || object.geometry.faces.length > 0 ) {\r\n\t\r\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglColorBuffer );\r\n\t\r\n\t\t\t\t\t\tstate.enableAttribute( attributes.color );\r\n\t\r\n\t\t\t\t\t\t_gl.vertexAttribPointer( attributes.color, 3, _gl.FLOAT, false, 0, 0 );\r\n\t\r\n\t\t\t\t\t} else if ( material.defaultAttributeValues !== undefined ) {\r\n\t\r\n\t\r\n\t\t\t\t\t\t_gl.vertexAttrib3fv( attributes.color, material.defaultAttributeValues.color );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// normals\r\n\t\r\n\t\t\t\tif ( attributes.normal >= 0 ) {\r\n\t\r\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglNormalBuffer );\r\n\t\r\n\t\t\t\t\tstate.enableAttribute( attributes.normal );\r\n\t\r\n\t\t\t\t\t_gl.vertexAttribPointer( attributes.normal, 3, _gl.FLOAT, false, 0, 0 );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// tangents\r\n\t\r\n\t\t\t\tif ( attributes.tangent >= 0 ) {\r\n\t\r\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglTangentBuffer );\r\n\t\r\n\t\t\t\t\tstate.enableAttribute( attributes.tangent );\r\n\t\r\n\t\t\t\t\t_gl.vertexAttribPointer( attributes.tangent, 4, _gl.FLOAT, false, 0, 0 );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// uvs\r\n\t\r\n\t\t\t\tif ( attributes.uv >= 0 ) {\r\n\t\r\n\t\t\t\t\tif ( object.geometry.faceVertexUvs[ 0 ] ) {\r\n\t\r\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUVBuffer );\r\n\t\r\n\t\t\t\t\t\tstate.enableAttribute( attributes.uv );\r\n\t\r\n\t\t\t\t\t\t_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 0, 0 );\r\n\t\r\n\t\t\t\t\t} else if ( material.defaultAttributeValues !== undefined ) {\r\n\t\r\n\t\r\n\t\t\t\t\t\t_gl.vertexAttrib2fv( attributes.uv, material.defaultAttributeValues.uv );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( attributes.uv2 >= 0 ) {\r\n\t\r\n\t\t\t\t\tif ( object.geometry.faceVertexUvs[ 1 ] ) {\r\n\t\r\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUV2Buffer );\r\n\t\r\n\t\t\t\t\t\tstate.enableAttribute( attributes.uv2 );\r\n\t\r\n\t\t\t\t\t\t_gl.vertexAttribPointer( attributes.uv2, 2, _gl.FLOAT, false, 0, 0 );\r\n\t\r\n\t\t\t\t\t} else if ( material.defaultAttributeValues !== undefined ) {\r\n\t\r\n\t\r\n\t\t\t\t\t\t_gl.vertexAttrib2fv( attributes.uv2, material.defaultAttributeValues.uv2 );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( material.skinning &&\r\n\t\t\t\t\t attributes.skinIndex >= 0 && attributes.skinWeight >= 0 ) {\r\n\t\r\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinIndicesBuffer );\r\n\t\r\n\t\t\t\t\tstate.enableAttribute( attributes.skinIndex );\r\n\t\r\n\t\t\t\t\t_gl.vertexAttribPointer( attributes.skinIndex, 4, _gl.FLOAT, false, 0, 0 );\r\n\t\r\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinWeightsBuffer );\r\n\t\r\n\t\t\t\t\tstate.enableAttribute( attributes.skinWeight );\r\n\t\r\n\t\t\t\t\t_gl.vertexAttribPointer( attributes.skinWeight, 4, _gl.FLOAT, false, 0, 0 );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// line distances\r\n\t\r\n\t\t\t\tif ( attributes.lineDistance >= 0 ) {\r\n\t\r\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglLineDistanceBuffer );\r\n\t\r\n\t\t\t\t\tstate.enableAttribute( attributes.lineDistance );\r\n\t\r\n\t\t\t\t\t_gl.vertexAttribPointer( attributes.lineDistance, 1, _gl.FLOAT, false, 0, 0 );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tstate.disableUnusedAttributes();\r\n\t\r\n\t\t\t// render mesh\r\n\t\r\n\t\t\tif ( object instanceof THREE.Mesh ) {\r\n\t\r\n\t\t\t\tvar type = geometryGroup.__typeArray === Uint32Array ? _gl.UNSIGNED_INT : _gl.UNSIGNED_SHORT;\r\n\t\r\n\t\t\t\t// wireframe\r\n\t\r\n\t\t\t\tif ( material.wireframe ) {\r\n\t\r\n\t\t\t\t\tstate.setLineWidth( material.wireframeLinewidth * pixelRatio );\r\n\t\r\n\t\t\t\t\tif ( updateBuffers ) _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglLineBuffer );\r\n\t\t\t\t\t_gl.drawElements( _gl.LINES, geometryGroup.__webglLineCount, type, 0 );\r\n\t\r\n\t\t\t\t// triangles\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tif ( updateBuffers ) _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglFaceBuffer );\r\n\t\t\t\t\t_gl.drawElements( _gl.TRIANGLES, geometryGroup.__webglFaceCount, type, 0 );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t_this.info.render.calls ++;\r\n\t\t\t\t_this.info.render.vertices += geometryGroup.__webglFaceCount;\r\n\t\t\t\t_this.info.render.faces += geometryGroup.__webglFaceCount / 3;\r\n\t\r\n\t\t\t// render lines\r\n\t\r\n\t\t\t} else if ( object instanceof THREE.Line ) {\r\n\t\r\n\t\t\t\tvar mode = ( object.mode === THREE.LineStrip ) ? _gl.LINE_STRIP : _gl.LINES;\r\n\t\r\n\t\t\t\tstate.setLineWidth( material.linewidth * pixelRatio );\r\n\t\r\n\t\t\t\t_gl.drawArrays( mode, 0, geometryGroup.__webglLineCount );\r\n\t\r\n\t\t\t\t_this.info.render.calls ++;\r\n\t\r\n\t\t\t// render particles\r\n\t\r\n\t\t\t} else if ( object instanceof THREE.PointCloud ) {\r\n\t\r\n\t\t\t\t_gl.drawArrays( _gl.POINTS, 0, geometryGroup.__webglParticleCount );\r\n\t\r\n\t\t\t\t_this.info.render.calls ++;\r\n\t\t\t\t_this.info.render.points += geometryGroup.__webglParticleCount;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tfunction setupMorphTargets ( material, geometryGroup, object ) {\r\n\t\r\n\t\t\t// set base\r\n\t\r\n\t\t\tvar attributes = material.program.attributes;\r\n\t\r\n\t\t\tif ( object.morphTargetBase !== - 1 && attributes.position >= 0 ) {\r\n\t\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ object.morphTargetBase ] );\r\n\t\r\n\t\t\t\tstate.enableAttribute( attributes.position );\r\n\t\r\n\t\t\t\t_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );\r\n\t\r\n\t\t\t} else if ( attributes.position >= 0 ) {\r\n\t\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );\r\n\t\r\n\t\t\t\tstate.enableAttribute( attributes.position );\r\n\t\r\n\t\t\t\t_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( object.morphTargetForcedOrder.length ) {\r\n\t\r\n\t\t\t\t// set forced order\r\n\t\r\n\t\t\t\tvar m = 0;\r\n\t\t\t\tvar order = object.morphTargetForcedOrder;\r\n\t\t\t\tvar influences = object.morphTargetInfluences;\r\n\t\r\n\t\t\t\tvar attribute;\r\n\t\r\n\t\t\t\twhile ( m < material.numSupportedMorphTargets && m < order.length ) {\r\n\t\r\n\t\t\t\t\tattribute = attributes[ 'morphTarget' + m ];\r\n\t\r\n\t\t\t\t\tif ( attribute >= 0 ) {\r\n\t\r\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ order[ m ] ] );\r\n\t\r\n\t\t\t\t\t\tstate.enableAttribute( attribute );\r\n\t\r\n\t\t\t\t\t\t_gl.vertexAttribPointer( attribute, 3, _gl.FLOAT, false, 0, 0 );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tattribute = attributes[ 'morphNormal' + m ];\r\n\t\r\n\t\t\t\t\tif ( attribute >= 0 && material.morphNormals ) {\r\n\t\r\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[ order[ m ] ] );\r\n\t\r\n\t\t\t\t\t\tstate.enableAttribute( attribute );\r\n\t\r\n\t\t\t\t\t\t_gl.vertexAttribPointer( attribute, 3, _gl.FLOAT, false, 0, 0 );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tobject.__webglMorphTargetInfluences[ m ] = influences[ order[ m ] ];\r\n\t\r\n\t\t\t\t\tm ++;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\t// find the most influencing\r\n\t\r\n\t\t\t\tvar activeInfluenceIndices = [];\r\n\t\t\t\tvar influences = object.morphTargetInfluences;\r\n\t\t\t\tvar morphTargets = object.geometry.morphTargets;\r\n\t\r\n\t\t\t\tif ( influences.length > morphTargets.length ) {\r\n\t\r\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Influences array is bigger than morphTargets array.' );\r\n\t\t\t\t\tinfluences.length = morphTargets.length;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tfor ( var i = 0, il = influences.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\tvar influence = influences[ i ];\r\n\t\r\n\t\t\t\t\tactiveInfluenceIndices.push( [ influence, i ] );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( activeInfluenceIndices.length > material.numSupportedMorphTargets ) {\r\n\t\r\n\t\t\t\t\tactiveInfluenceIndices.sort( numericalSort );\r\n\t\t\t\t\tactiveInfluenceIndices.length = material.numSupportedMorphTargets;\r\n\t\r\n\t\t\t\t} else if ( activeInfluenceIndices.length > material.numSupportedMorphNormals ) {\r\n\t\r\n\t\t\t\t\tactiveInfluenceIndices.sort( numericalSort );\r\n\t\r\n\t\t\t\t} else if ( activeInfluenceIndices.length === 0 ) {\r\n\t\r\n\t\t\t\t\tactiveInfluenceIndices.push( [ 0, 0 ] );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar attribute;\r\n\t\r\n\t\t\t\tfor ( var m = 0, ml = material.numSupportedMorphTargets; m < ml; m ++ ) {\r\n\t\r\n\t\t\t\t\tif ( activeInfluenceIndices[ m ] ) {\r\n\t\r\n\t\t\t\t\t\tvar influenceIndex = activeInfluenceIndices[ m ][ 1 ];\r\n\t\r\n\t\t\t\t\t\tattribute = attributes[ 'morphTarget' + m ];\r\n\t\r\n\t\t\t\t\t\tif ( attribute >= 0 ) {\r\n\t\r\n\t\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ influenceIndex ] );\r\n\t\r\n\t\t\t\t\t\t\tstate.enableAttribute( attribute );\r\n\t\r\n\t\t\t\t\t\t\t_gl.vertexAttribPointer( attribute, 3, _gl.FLOAT, false, 0, 0 );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tattribute = attributes[ 'morphNormal' + m ];\r\n\t\r\n\t\t\t\t\t\tif ( attribute >= 0 && material.morphNormals ) {\r\n\t\r\n\t\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[ influenceIndex ] );\r\n\t\r\n\t\t\t\t\t\t\tstate.enableAttribute( attribute );\r\n\t\r\n\t\t\t\t\t\t\t_gl.vertexAttribPointer( attribute, 3, _gl.FLOAT, false, 0, 0 );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tobject.__webglMorphTargetInfluences[ m ] = influences[ influenceIndex ];\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t/*\r\n\t\t\t\t\t\t_gl.vertexAttribPointer( attributes[ \"morphTarget\" + m ], 3, _gl.FLOAT, false, 0, 0 );\r\n\t\r\n\t\t\t\t\t\tif ( material.morphNormals ) {\r\n\t\r\n\t\t\t\t\t\t\t_gl.vertexAttribPointer( attributes[ \"morphNormal\" + m ], 3, _gl.FLOAT, false, 0, 0 );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t*/\r\n\t\r\n\t\t\t\t\t\tobject.__webglMorphTargetInfluences[ m ] = 0;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// load updated influences uniform\r\n\t\r\n\t\t\tif ( material.program.uniforms.morphTargetInfluences !== null ) {\r\n\t\r\n\t\t\t\t_gl.uniform1fv( material.program.uniforms.morphTargetInfluences, object.__webglMorphTargetInfluences );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// Sorting\r\n\t\r\n\t\tfunction painterSortStable ( a, b ) {\r\n\t\r\n\t\t\tif ( a.object.renderOrder !== b.object.renderOrder ) {\r\n\t\r\n\t\t\t\treturn a.object.renderOrder - b.object.renderOrder;\r\n\t\r\n\t\t\t} else if ( a.material.id !== b.material.id ) {\r\n\t\r\n\t\t\t\treturn a.material.id - b.material.id;\r\n\t\r\n\t\t\t} else if ( a.z !== b.z ) {\r\n\t\r\n\t\t\t\treturn a.z - b.z;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\treturn a.id - b.id;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction reversePainterSortStable ( a, b ) {\r\n\t\r\n\t\t\tif ( a.object.renderOrder !== b.object.renderOrder ) {\r\n\t\r\n\t\t\t\treturn a.object.renderOrder - b.object.renderOrder;\r\n\t\r\n\t\t\t} if ( a.z !== b.z ) {\r\n\t\r\n\t\t\t\treturn b.z - a.z;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\treturn a.id - b.id;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction numericalSort ( a, b ) {\r\n\t\r\n\t\t\treturn b[ 0 ] - a[ 0 ];\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// Rendering\r\n\t\r\n\t\tthis.render = function ( scene, camera, renderTarget, forceClear ) {\r\n\t\r\n\t\t\tif ( camera instanceof THREE.Camera === false ) {\r\n\t\r\n\t\t\t\tTHREE.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );\r\n\t\t\t\treturn;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar fog = scene.fog;\r\n\t\r\n\t\t\t// reset caching for this frame\r\n\t\r\n\t\t\t_currentGeometryProgram = '';\r\n\t\t\t_currentMaterialId = - 1;\r\n\t\t\t_currentCamera = null;\r\n\t\t\t_lightsNeedUpdate = true;\r\n\t\r\n\t\t\t// update scene graph\r\n\t\r\n\t\t\tif ( scene.autoUpdate === true ) scene.updateMatrixWorld();\r\n\t\r\n\t\t\t// update camera matrices and frustum\r\n\t\r\n\t\t\tif ( camera.parent === undefined ) camera.updateMatrixWorld();\r\n\t\r\n\t\t\t// update Skeleton objects\r\n\t\r\n\t\t\tscene.traverse( function ( object ) {\r\n\t\r\n\t\t\t\tif ( object instanceof THREE.SkinnedMesh ) {\r\n\t\r\n\t\t\t\t\tobject.skeleton.update();\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} );\r\n\t\r\n\t\t\tcamera.matrixWorldInverse.getInverse( camera.matrixWorld );\r\n\t\r\n\t\t\t_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );\r\n\t\t\t_frustum.setFromMatrix( _projScreenMatrix );\r\n\t\r\n\t\t\tlights.length = 0;\r\n\t\t\topaqueObjects.length = 0;\r\n\t\t\ttransparentObjects.length = 0;\r\n\t\r\n\t\t\tsprites.length = 0;\r\n\t\t\tlensFlares.length = 0;\r\n\t\r\n\t\t\tprojectObject( scene );\r\n\t\r\n\t\t\tif ( _this.sortObjects === true ) {\r\n\t\r\n\t\t\t\topaqueObjects.sort( painterSortStable );\r\n\t\t\t\ttransparentObjects.sort( reversePainterSortStable );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// custom render plugins (pre pass)\r\n\t\r\n\t\t\tshadowMapPlugin.render( scene, camera );\r\n\t\r\n\t\t\t//\r\n\t\r\n\t\t\t_this.info.render.calls = 0;\r\n\t\t\t_this.info.render.vertices = 0;\r\n\t\t\t_this.info.render.faces = 0;\r\n\t\t\t_this.info.render.points = 0;\r\n\t\r\n\t\t\tthis.setRenderTarget( renderTarget );\r\n\t\r\n\t\t\tif ( this.autoClear || forceClear ) {\r\n\t\r\n\t\t\t\tthis.clear( this.autoClearColor, this.autoClearDepth, this.autoClearStencil );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// set matrices for immediate objects\r\n\t\r\n\t\t\tfor ( var i = 0, il = _webglObjectsImmediate.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tvar webglObject = _webglObjectsImmediate[ i ];\r\n\t\t\t\tvar object = webglObject.object;\r\n\t\r\n\t\t\t\tif ( object.visible ) {\r\n\t\r\n\t\t\t\t\tsetupMatrices( object, camera );\r\n\t\r\n\t\t\t\t\tunrollImmediateBufferMaterial( webglObject );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( scene.overrideMaterial ) {\r\n\t\r\n\t\t\t\tvar overrideMaterial = scene.overrideMaterial;\r\n\t\r\n\t\t\t\tsetMaterial( overrideMaterial );\r\n\t\r\n\t\t\t\trenderObjects( opaqueObjects, camera, lights, fog, overrideMaterial );\r\n\t\t\t\trenderObjects( transparentObjects, camera, lights, fog, overrideMaterial );\r\n\t\t\t\trenderObjectsImmediate( _webglObjectsImmediate, '', camera, lights, fog, overrideMaterial );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\t// opaque pass (front-to-back order)\r\n\t\r\n\t\t\t\tstate.setBlending( THREE.NoBlending );\r\n\t\r\n\t\t\t\trenderObjects( opaqueObjects, camera, lights, fog, null );\r\n\t\t\t\trenderObjectsImmediate( _webglObjectsImmediate, 'opaque', camera, lights, fog, null );\r\n\t\r\n\t\t\t\t// transparent pass (back-to-front order)\r\n\t\r\n\t\t\t\trenderObjects( transparentObjects, camera, lights, fog, null );\r\n\t\t\t\trenderObjectsImmediate( _webglObjectsImmediate, 'transparent', camera, lights, fog, null );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// custom render plugins (post pass)\r\n\t\r\n\t\t\tspritePlugin.render( scene, camera );\r\n\t\t\tlensFlarePlugin.render( scene, camera, _currentWidth, _currentHeight );\r\n\t\r\n\t\t\t// Generate mipmap if we're using any kind of mipmap filtering\r\n\t\r\n\t\t\tif ( renderTarget && renderTarget.generateMipmaps && renderTarget.minFilter !== THREE.NearestFilter && renderTarget.minFilter !== THREE.LinearFilter ) {\r\n\t\r\n\t\t\t\tupdateRenderTargetMipmap( renderTarget );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// Ensure depth buffer writing is enabled so it can be cleared on next render\r\n\t\r\n\t\t\tstate.setDepthTest( true );\r\n\t\t\tstate.setDepthWrite( true );\r\n\t\t\tstate.setColorWrite( true );\r\n\t\r\n\t\t\t// _gl.finish();\r\n\t\r\n\t\t};\r\n\t\r\n\t\tfunction projectObject( object ) {\r\n\t\r\n\t\t\tif ( object.visible === false ) return;\r\n\t\r\n\t\t\tif ( object instanceof THREE.Scene || object instanceof THREE.Group ) {\r\n\t\r\n\t\t\t\t// skip\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tinitObject( object );\r\n\t\r\n\t\t\t\tif ( object instanceof THREE.Light ) {\r\n\t\r\n\t\t\t\t\tlights.push( object );\r\n\t\r\n\t\t\t\t} else if ( object instanceof THREE.Sprite ) {\r\n\t\r\n\t\t\t\t\tsprites.push( object );\r\n\t\r\n\t\t\t\t} else if ( object instanceof THREE.LensFlare ) {\r\n\t\r\n\t\t\t\t\tlensFlares.push( object );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tvar webglObjects = _webglObjects[ object.id ];\r\n\t\r\n\t\t\t\t\tif ( webglObjects && ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) ) {\r\n\t\r\n\t\t\t\t\t\tfor ( var i = 0, l = webglObjects.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\t\t\tvar webglObject = webglObjects[ i ];\r\n\t\r\n\t\t\t\t\t\t\tunrollBufferMaterial( webglObject );\r\n\t\r\n\t\t\t\t\t\t\twebglObject.render = true;\r\n\t\r\n\t\t\t\t\t\t\tif ( _this.sortObjects === true ) {\r\n\t\r\n\t\t\t\t\t\t\t\t_vector3.setFromMatrixPosition( object.matrixWorld );\r\n\t\t\t\t\t\t\t\t_vector3.applyProjection( _projScreenMatrix );\r\n\t\r\n\t\t\t\t\t\t\t\twebglObject.z = _vector3.z;\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfor ( var i = 0, l = object.children.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tprojectObject( object.children[ i ] );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction renderObjects( renderList, camera, lights, fog, overrideMaterial ) {\r\n\t\r\n\t\t\tvar material;\r\n\t\r\n\t\t\tfor ( var i = 0, l = renderList.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tvar webglObject = renderList[ i ];\r\n\t\r\n\t\t\t\tvar object = webglObject.object;\r\n\t\t\t\tvar buffer = webglObject.buffer;\r\n\t\r\n\t\t\t\tsetupMatrices( object, camera );\r\n\t\r\n\t\t\t\tif ( overrideMaterial ) {\r\n\t\r\n\t\t\t\t\tmaterial = overrideMaterial;\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tmaterial = webglObject.material;\r\n\t\r\n\t\t\t\t\tif ( ! material ) continue;\r\n\t\r\n\t\t\t\t\tsetMaterial( material );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t_this.setMaterialFaces( material );\r\n\t\r\n\t\t\t\tif ( buffer instanceof THREE.BufferGeometry ) {\r\n\t\r\n\t\t\t\t\t_this.renderBufferDirect( camera, lights, fog, material, buffer, object );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t_this.renderBuffer( camera, lights, fog, material, buffer, object );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction renderObjectsImmediate ( renderList, materialType, camera, lights, fog, overrideMaterial ) {\r\n\t\r\n\t\t\tvar material;\r\n\t\r\n\t\t\tfor ( var i = 0, l = renderList.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tvar webglObject = renderList[ i ];\r\n\t\t\t\tvar object = webglObject.object;\r\n\t\r\n\t\t\t\tif ( object.visible ) {\r\n\t\r\n\t\t\t\t\tif ( overrideMaterial ) {\r\n\t\r\n\t\t\t\t\t\tmaterial = overrideMaterial;\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tmaterial = webglObject[ materialType ];\r\n\t\r\n\t\t\t\t\t\tif ( ! material ) continue;\r\n\t\r\n\t\t\t\t\t\tsetMaterial( material );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t_this.renderImmediateObject( camera, lights, fog, material, object );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.renderImmediateObject = function ( camera, lights, fog, material, object ) {\r\n\t\r\n\t\t\tvar program = setProgram( camera, lights, fog, material, object );\r\n\t\r\n\t\t\t_currentGeometryProgram = '';\r\n\t\r\n\t\t\t_this.setMaterialFaces( material );\r\n\t\r\n\t\t\tif ( object.immediateRenderCallback ) {\r\n\t\r\n\t\t\t\tobject.immediateRenderCallback( program, _gl, _frustum );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tobject.render( function ( object ) { _this.renderBufferImmediate( object, program, material ); } );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tfunction unrollImmediateBufferMaterial ( globject ) {\r\n\t\r\n\t\t\tvar object = globject.object,\r\n\t\t\t\tmaterial = object.material;\r\n\t\r\n\t\t\tif ( material.transparent ) {\r\n\t\r\n\t\t\t\tglobject.transparent = material;\r\n\t\t\t\tglobject.opaque = null;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tglobject.opaque = material;\r\n\t\t\t\tglobject.transparent = null;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction unrollBufferMaterial ( globject ) {\r\n\t\r\n\t\t\tvar object = globject.object;\r\n\t\t\tvar buffer = globject.buffer;\r\n\t\r\n\t\t\tvar geometry = object.geometry;\r\n\t\t\tvar material = object.material;\r\n\t\r\n\t\t\tif ( material instanceof THREE.MeshFaceMaterial ) {\r\n\t\r\n\t\t\t\tvar materialIndex = geometry instanceof THREE.BufferGeometry ? 0 : buffer.materialIndex;\r\n\t\r\n\t\t\t\tmaterial = material.materials[ materialIndex ];\r\n\t\r\n\t\t\t\tglobject.material = material;\r\n\t\r\n\t\t\t\tif ( material.transparent ) {\r\n\t\r\n\t\t\t\t\ttransparentObjects.push( globject );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\topaqueObjects.push( globject );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else if ( material ) {\r\n\t\r\n\t\t\t\tglobject.material = material;\r\n\t\r\n\t\t\t\tif ( material.transparent ) {\r\n\t\r\n\t\t\t\t\ttransparentObjects.push( globject );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\topaqueObjects.push( globject );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction initObject( object ) {\r\n\t\r\n\t\t\tif ( object.__webglInit === undefined ) {\r\n\t\r\n\t\t\t\tobject.__webglInit = true;\r\n\t\t\t\tobject._modelViewMatrix = new THREE.Matrix4();\r\n\t\t\t\tobject._normalMatrix = new THREE.Matrix3();\r\n\t\r\n\t\t\t\tobject.addEventListener( 'removed', onObjectRemoved );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar geometry = object.geometry;\r\n\t\r\n\t\t\tif ( geometry === undefined ) {\r\n\t\r\n\t\t\t\t// ImmediateRenderObject\r\n\t\r\n\t\t\t} else if ( geometry.__webglInit === undefined ) {\r\n\t\r\n\t\t\t\tgeometry.__webglInit = true;\r\n\t\t\t\tgeometry.addEventListener( 'dispose', onGeometryDispose );\r\n\t\r\n\t\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\r\n\t\r\n\t\t\t\t\t_this.info.memory.geometries ++;\r\n\t\r\n\t\t\t\t} else if ( object instanceof THREE.Mesh ) {\r\n\t\r\n\t\t\t\t\tinitGeometryGroups( object, geometry );\r\n\t\r\n\t\t\t\t} else if ( object instanceof THREE.Line ) {\r\n\t\r\n\t\t\t\t\tif ( geometry.__webglVertexBuffer === undefined ) {\r\n\t\r\n\t\t\t\t\t\tcreateLineBuffers( geometry );\r\n\t\t\t\t\t\tinitLineBuffers( geometry, object );\r\n\t\r\n\t\t\t\t\t\tgeometry.verticesNeedUpdate = true;\r\n\t\t\t\t\t\tgeometry.colorsNeedUpdate = true;\r\n\t\t\t\t\t\tgeometry.lineDistancesNeedUpdate = true;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else if ( object instanceof THREE.PointCloud ) {\r\n\t\r\n\t\t\t\t\tif ( geometry.__webglVertexBuffer === undefined ) {\r\n\t\r\n\t\t\t\t\t\tcreateParticleBuffers( geometry );\r\n\t\t\t\t\t\tinitParticleBuffers( geometry, object );\r\n\t\r\n\t\t\t\t\t\tgeometry.verticesNeedUpdate = true;\r\n\t\t\t\t\t\tgeometry.colorsNeedUpdate = true;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( object.__webglActive === undefined) {\r\n\t\r\n\t\t\t\tobject.__webglActive = true;\r\n\t\r\n\t\t\t\tif ( object instanceof THREE.Mesh ) {\r\n\t\r\n\t\t\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\r\n\t\r\n\t\t\t\t\t\taddBuffer( _webglObjects, geometry, object );\r\n\t\r\n\t\t\t\t\t} else if ( geometry instanceof THREE.Geometry ) {\r\n\t\r\n\t\t\t\t\t\tvar geometryGroupsList = geometryGroups[ geometry.id ];\r\n\t\r\n\t\t\t\t\t\tfor ( var i = 0,l = geometryGroupsList.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\t\t\taddBuffer( _webglObjects, geometryGroupsList[ i ], object );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else if ( object instanceof THREE.Line || object instanceof THREE.PointCloud ) {\r\n\t\r\n\t\t\t\t\taddBuffer( _webglObjects, geometry, object );\r\n\t\r\n\t\t\t\t} else if ( object instanceof THREE.ImmediateRenderObject || object.immediateRenderCallback ) {\r\n\t\r\n\t\t\t\t\taddBufferImmediate( _webglObjectsImmediate, object );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// Geometry splitting\r\n\t\r\n\t\tvar geometryGroups = {};\r\n\t\tvar geometryGroupCounter = 0;\r\n\t\r\n\t\tfunction makeGroups( geometry, usesFaceMaterial ) {\r\n\t\r\n\t\t\tvar maxVerticesInGroup = extensions.get( 'OES_element_index_uint' ) ? 4294967296 : 65535;\r\n\t\r\n\t\t\tvar groupHash, hash_map = {};\r\n\t\r\n\t\t\tvar numMorphTargets = geometry.morphTargets.length;\r\n\t\t\tvar numMorphNormals = geometry.morphNormals.length;\r\n\t\r\n\t\t\tvar group;\r\n\t\t\tvar groups = {};\r\n\t\t\tvar groupsList = [];\r\n\t\r\n\t\t\tfor ( var f = 0, fl = geometry.faces.length; f < fl; f ++ ) {\r\n\t\r\n\t\t\t\tvar face = geometry.faces[ f ];\r\n\t\t\t\tvar materialIndex = usesFaceMaterial ? face.materialIndex : 0;\r\n\t\r\n\t\t\t\tif ( ! ( materialIndex in hash_map ) ) {\r\n\t\r\n\t\t\t\t\thash_map[ materialIndex ] = { hash: materialIndex, counter: 0 };\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tgroupHash = hash_map[ materialIndex ].hash + '_' + hash_map[ materialIndex ].counter;\r\n\t\r\n\t\t\t\tif ( ! ( groupHash in groups ) ) {\r\n\t\r\n\t\t\t\t\tgroup = {\r\n\t\t\t\t\t\tid: geometryGroupCounter ++,\r\n\t\t\t\t\t\tfaces3: [],\r\n\t\t\t\t\t\tmaterialIndex: materialIndex,\r\n\t\t\t\t\t\tvertices: 0,\r\n\t\t\t\t\t\tnumMorphTargets: numMorphTargets,\r\n\t\t\t\t\t\tnumMorphNormals: numMorphNormals\r\n\t\t\t\t\t};\r\n\t\r\n\t\t\t\t\tgroups[ groupHash ] = group;\r\n\t\t\t\t\tgroupsList.push( group );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( groups[ groupHash ].vertices + 3 > maxVerticesInGroup ) {\r\n\t\r\n\t\t\t\t\thash_map[ materialIndex ].counter += 1;\r\n\t\t\t\t\tgroupHash = hash_map[ materialIndex ].hash + '_' + hash_map[ materialIndex ].counter;\r\n\t\r\n\t\t\t\t\tif ( ! ( groupHash in groups ) ) {\r\n\t\r\n\t\t\t\t\t\tgroup = {\r\n\t\t\t\t\t\t\tid: geometryGroupCounter ++,\r\n\t\t\t\t\t\t\tfaces3: [],\r\n\t\t\t\t\t\t\tmaterialIndex: materialIndex,\r\n\t\t\t\t\t\t\tvertices: 0,\r\n\t\t\t\t\t\t\tnumMorphTargets: numMorphTargets,\r\n\t\t\t\t\t\t\tnumMorphNormals: numMorphNormals\r\n\t\t\t\t\t\t};\r\n\t\r\n\t\t\t\t\t\tgroups[ groupHash ] = group;\r\n\t\t\t\t\t\tgroupsList.push( group );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tgroups[ groupHash ].faces3.push( f );\r\n\t\t\t\tgroups[ groupHash ].vertices += 3;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn groupsList;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction initGeometryGroups( object, geometry ) {\r\n\t\r\n\t\t\tvar material = object.material, addBuffers = false;\r\n\t\r\n\t\t\tif ( geometryGroups[ geometry.id ] === undefined || geometry.groupsNeedUpdate === true ) {\r\n\t\r\n\t\t\t\tdelete _webglObjects[ object.id ];\r\n\t\r\n\t\t\t\tgeometryGroups[ geometry.id ] = makeGroups( geometry, material instanceof THREE.MeshFaceMaterial );\r\n\t\r\n\t\t\t\tgeometry.groupsNeedUpdate = false;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar geometryGroupsList = geometryGroups[ geometry.id ];\r\n\t\r\n\t\t\t// create separate VBOs per geometry chunk\r\n\t\r\n\t\t\tfor ( var i = 0, il = geometryGroupsList.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tvar geometryGroup = geometryGroupsList[ i ];\r\n\t\r\n\t\t\t\t// initialise VBO on the first access\r\n\t\r\n\t\t\t\tif ( geometryGroup.__webglVertexBuffer === undefined ) {\r\n\t\r\n\t\t\t\t\tcreateMeshBuffers( geometryGroup );\r\n\t\t\t\t\tinitMeshBuffers( geometryGroup, object );\r\n\t\r\n\t\t\t\t\tgeometry.verticesNeedUpdate = true;\r\n\t\t\t\t\tgeometry.morphTargetsNeedUpdate = true;\r\n\t\t\t\t\tgeometry.elementsNeedUpdate = true;\r\n\t\t\t\t\tgeometry.uvsNeedUpdate = true;\r\n\t\t\t\t\tgeometry.normalsNeedUpdate = true;\r\n\t\t\t\t\tgeometry.tangentsNeedUpdate = true;\r\n\t\t\t\t\tgeometry.colorsNeedUpdate = true;\r\n\t\r\n\t\t\t\t\taddBuffers = true;\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\taddBuffers = false;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( addBuffers || object.__webglActive === undefined ) {\r\n\t\r\n\t\t\t\t\taddBuffer( _webglObjects, geometryGroup, object );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tobject.__webglActive = true;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction addBuffer( objlist, buffer, object ) {\r\n\t\r\n\t\t\tvar id = object.id;\r\n\t\t\tobjlist[id] = objlist[id] || [];\r\n\t\t\tobjlist[id].push(\r\n\t\t\t\t{\r\n\t\t\t\t\tid: id,\r\n\t\t\t\t\tbuffer: buffer,\r\n\t\t\t\t\tobject: object,\r\n\t\t\t\t\tmaterial: null,\r\n\t\t\t\t\tz: 0\r\n\t\t\t\t}\r\n\t\t\t);\r\n\t\r\n\t\t};\r\n\t\r\n\t\tfunction addBufferImmediate( objlist, object ) {\r\n\t\r\n\t\t\tobjlist.push(\r\n\t\t\t\t{\r\n\t\t\t\t\tid: null,\r\n\t\t\t\t\tobject: object,\r\n\t\t\t\t\topaque: null,\r\n\t\t\t\t\ttransparent: null,\r\n\t\t\t\t\tz: 0\r\n\t\t\t\t}\r\n\t\t\t);\r\n\t\r\n\t\t};\r\n\t\r\n\t\t// Objects updates\r\n\t\r\n\t\tfunction updateObject( object ) {\r\n\t\r\n\t\t\tvar geometry = object.geometry;\r\n\t\r\n\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\r\n\t\r\n\t\t\t\tvar attributes = geometry.attributes;\r\n\t\t\t\tvar attributesKeys = geometry.attributesKeys;\r\n\t\r\n\t\t\t\tfor ( var i = 0, l = attributesKeys.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\tvar key = attributesKeys[ i ];\r\n\t\t\t\t\tvar attribute = attributes[ key ];\r\n\t\t\t\t\tvar bufferType = ( key === 'index' ) ? _gl.ELEMENT_ARRAY_BUFFER : _gl.ARRAY_BUFFER;\r\n\t\r\n\t\t\t\t\tif ( attribute.buffer === undefined ) {\r\n\t\r\n\t\t\t\t\t\tattribute.buffer = _gl.createBuffer();\r\n\t\t\t\t\t\t_gl.bindBuffer( bufferType, attribute.buffer );\r\n\t\t\t\t\t\t_gl.bufferData( bufferType, attribute.array, ( attribute instanceof THREE.DynamicBufferAttribute ) ? _gl.DYNAMIC_DRAW : _gl.STATIC_DRAW );\r\n\t\r\n\t\t\t\t\t\tattribute.needsUpdate = false;\r\n\t\r\n\t\t\t\t\t} else if ( attribute.needsUpdate === true ) {\r\n\t\r\n\t\t\t\t\t\t_gl.bindBuffer( bufferType, attribute.buffer );\r\n\t\r\n\t\t\t\t\t\tif ( attribute.updateRange === undefined || attribute.updateRange.count === -1 ) { // Not using update ranges\r\n\t\r\n\t\t\t\t\t\t\t_gl.bufferSubData( bufferType, 0, attribute.array );\r\n\t\r\n\t\t\t\t\t\t} else if ( attribute.updateRange.count === 0 ) {\r\n\t\r\n\t\t\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.updateObject: using updateRange for THREE.DynamicBufferAttribute and marked as needsUpdate but count is 0, ensure you are using set methods or updating manually.' );\r\n\t\r\n\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\t_gl.bufferSubData( bufferType, attribute.updateRange.offset * attribute.array.BYTES_PER_ELEMENT,\r\n\t\t\t\t\t\t\t\t\t\t\t   attribute.array.subarray( attribute.updateRange.offset, attribute.updateRange.offset + attribute.updateRange.count ) );\r\n\t\r\n\t\t\t\t\t\t\tattribute.updateRange.count = 0; // reset range\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tattribute.needsUpdate = false;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else if ( object instanceof THREE.Mesh ) {\r\n\t\r\n\t\t\t\t// check all geometry groups\r\n\t\r\n\t\t\t\tif ( geometry.groupsNeedUpdate === true ) {\r\n\t\r\n\t\t\t\t\tinitGeometryGroups( object, geometry );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar geometryGroupsList = geometryGroups[ geometry.id ];\r\n\t\r\n\t\t\t\tfor ( var i = 0, il = geometryGroupsList.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\tvar geometryGroup = geometryGroupsList[ i ];\r\n\t\t\t\t\tvar material = getBufferMaterial( object, geometryGroup );\r\n\t\r\n\t\t\t\t\tvar customAttributesDirty = material.attributes && areCustomAttributesDirty( material );\r\n\t\r\n\t\t\t\t\tif ( geometry.verticesNeedUpdate || geometry.morphTargetsNeedUpdate || geometry.elementsNeedUpdate ||\r\n\t\t\t\t\t\t geometry.uvsNeedUpdate || geometry.normalsNeedUpdate ||\r\n\t\t\t\t\t\t geometry.colorsNeedUpdate || geometry.tangentsNeedUpdate || customAttributesDirty ) {\r\n\t\r\n\t\t\t\t\t\tsetMeshBuffers( geometryGroup, object, _gl.DYNAMIC_DRAW, ! geometry.dynamic, material );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tgeometry.verticesNeedUpdate = false;\r\n\t\t\t\tgeometry.morphTargetsNeedUpdate = false;\r\n\t\t\t\tgeometry.elementsNeedUpdate = false;\r\n\t\t\t\tgeometry.uvsNeedUpdate = false;\r\n\t\t\t\tgeometry.normalsNeedUpdate = false;\r\n\t\t\t\tgeometry.colorsNeedUpdate = false;\r\n\t\t\t\tgeometry.tangentsNeedUpdate = false;\r\n\t\r\n\t\t\t\tmaterial.attributes && clearCustomAttributes( material );\r\n\t\r\n\t\t\t} else if ( object instanceof THREE.Line ) {\r\n\t\r\n\t\t\t\tvar material = getBufferMaterial( object, geometry );\r\n\t\t\t\tvar customAttributesDirty = material.attributes && areCustomAttributesDirty( material );\r\n\t\r\n\t\t\t\tif ( geometry.verticesNeedUpdate || geometry.colorsNeedUpdate || geometry.lineDistancesNeedUpdate || customAttributesDirty ) {\r\n\t\r\n\t\t\t\t\tsetLineBuffers( geometry, _gl.DYNAMIC_DRAW );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tgeometry.verticesNeedUpdate = false;\r\n\t\t\t\tgeometry.colorsNeedUpdate = false;\r\n\t\t\t\tgeometry.lineDistancesNeedUpdate = false;\r\n\t\r\n\t\t\t\tmaterial.attributes && clearCustomAttributes( material );\r\n\t\r\n\t\t\t} else if ( object instanceof THREE.PointCloud ) {\r\n\t\r\n\t\t\t\tvar material = getBufferMaterial( object, geometry );\r\n\t\t\t\tvar customAttributesDirty = material.attributes && areCustomAttributesDirty( material );\r\n\t\r\n\t\t\t\tif ( geometry.verticesNeedUpdate || geometry.colorsNeedUpdate || customAttributesDirty ) {\r\n\t\r\n\t\t\t\t\tsetParticleBuffers( geometry, _gl.DYNAMIC_DRAW, object );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tgeometry.verticesNeedUpdate = false;\r\n\t\t\t\tgeometry.colorsNeedUpdate = false;\r\n\t\r\n\t\t\t\tmaterial.attributes && clearCustomAttributes( material );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// Objects updates - custom attributes check\r\n\t\r\n\t\tfunction areCustomAttributesDirty( material ) {\r\n\t\r\n\t\t\tfor ( var name in material.attributes ) {\r\n\t\r\n\t\t\t\tif ( material.attributes[ name ].needsUpdate ) return true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn false;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction clearCustomAttributes( material ) {\r\n\t\r\n\t\t\tfor ( var name in material.attributes ) {\r\n\t\r\n\t\t\t\tmaterial.attributes[ name ].needsUpdate = false;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// Objects removal\r\n\t\r\n\t\tfunction removeObject( object ) {\r\n\t\r\n\t\t\tif ( object instanceof THREE.Mesh  ||\r\n\t\t\t\t object instanceof THREE.PointCloud ||\r\n\t\t\t\t object instanceof THREE.Line ) {\r\n\t\r\n\t\t\t\tdelete _webglObjects[ object.id ];\r\n\t\r\n\t\t\t} else if ( object instanceof THREE.ImmediateRenderObject || object.immediateRenderCallback ) {\r\n\t\r\n\t\t\t\tremoveInstances( _webglObjectsImmediate, object );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tdelete object.__webglInit;\r\n\t\t\tdelete object._modelViewMatrix;\r\n\t\t\tdelete object._normalMatrix;\r\n\t\r\n\t\t\tdelete object.__webglActive;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction removeInstances( objlist, object ) {\r\n\t\r\n\t\t\tfor ( var o = objlist.length - 1; o >= 0; o -- ) {\r\n\t\r\n\t\t\t\tif ( objlist[ o ].object === object ) {\r\n\t\r\n\t\t\t\t\tobjlist.splice( o, 1 );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// Materials\r\n\t\r\n\t\tvar shaderIDs = {\r\n\t\t\tMeshDepthMaterial: 'depth',\r\n\t\t\tMeshNormalMaterial: 'normal',\r\n\t\t\tMeshBasicMaterial: 'basic',\r\n\t\t\tMeshLambertMaterial: 'lambert',\r\n\t\t\tMeshPhongMaterial: 'phong',\r\n\t\t\tLineBasicMaterial: 'basic',\r\n\t\t\tLineDashedMaterial: 'dashed',\r\n\t\t\tPointCloudMaterial: 'particle_basic'\r\n\t\t};\r\n\t\r\n\t\tfunction initMaterial( material, lights, fog, object ) {\r\n\t\r\n\t\t\tmaterial.addEventListener( 'dispose', onMaterialDispose );\r\n\t\r\n\t\t\tvar shaderID = shaderIDs[ material.type ];\r\n\t\r\n\t\t\tif ( shaderID ) {\r\n\t\r\n\t\t\t\tvar shader = THREE.ShaderLib[ shaderID ];\r\n\t\r\n\t\t\t\tmaterial.__webglShader = {\r\n\t\t\t\t\tuniforms: THREE.UniformsUtils.clone( shader.uniforms ),\r\n\t\t\t\t\tvertexShader: shader.vertexShader,\r\n\t\t\t\t\tfragmentShader: shader.fragmentShader\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tmaterial.__webglShader = {\r\n\t\t\t\t\tuniforms: material.uniforms,\r\n\t\t\t\t\tvertexShader: material.vertexShader,\r\n\t\t\t\t\tfragmentShader: material.fragmentShader\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// heuristics to create shader parameters according to lights in the scene\r\n\t\t\t// (not to blow over maxLights budget)\r\n\t\r\n\t\t\tvar maxLightCount = allocateLights( lights );\r\n\t\t\tvar maxShadows = allocateShadows( lights );\r\n\t\t\tvar maxBones = allocateBones( object );\r\n\t\r\n\t\t\tvar parameters = {\r\n\t\r\n\t\t\t\tprecision: _precision,\r\n\t\t\t\tsupportsVertexTextures: _supportsVertexTextures,\r\n\t\r\n\t\t\t\tmap: !! material.map,\r\n\t\t\t\tenvMap: !! material.envMap,\r\n\t\t\t\tenvMapMode: material.envMap && material.envMap.mapping,\r\n\t\t\t\tlightMap: !! material.lightMap,\r\n\t\t\t\tbumpMap: !! material.bumpMap,\r\n\t\t\t\tnormalMap: !! material.normalMap,\r\n\t\t\t\tspecularMap: !! material.specularMap,\r\n\t\t\t\talphaMap: !! material.alphaMap,\r\n\t\r\n\t\t\t\tcombine: material.combine,\r\n\t\r\n\t\t\t\tvertexColors: material.vertexColors,\r\n\t\r\n\t\t\t\tfog: fog,\r\n\t\t\t\tuseFog: material.fog,\r\n\t\t\t\tfogExp: fog instanceof THREE.FogExp2,\r\n\t\r\n\t\t\t\tflatShading: material.shading === THREE.FlatShading,\r\n\t\r\n\t\t\t\tsizeAttenuation: material.sizeAttenuation,\r\n\t\t\t\tlogarithmicDepthBuffer: _logarithmicDepthBuffer,\r\n\t\r\n\t\t\t\tskinning: material.skinning,\r\n\t\t\t\tmaxBones: maxBones,\r\n\t\t\t\tuseVertexTexture: _supportsBoneTextures && object && object.skeleton && object.skeleton.useVertexTexture,\r\n\t\r\n\t\t\t\tmorphTargets: material.morphTargets,\r\n\t\t\t\tmorphNormals: material.morphNormals,\r\n\t\t\t\tmaxMorphTargets: _this.maxMorphTargets,\r\n\t\t\t\tmaxMorphNormals: _this.maxMorphNormals,\r\n\t\r\n\t\t\t\tmaxDirLights: maxLightCount.directional,\r\n\t\t\t\tmaxPointLights: maxLightCount.point,\r\n\t\t\t\tmaxSpotLights: maxLightCount.spot,\r\n\t\t\t\tmaxHemiLights: maxLightCount.hemi,\r\n\t\r\n\t\t\t\tmaxShadows: maxShadows,\r\n\t\t\t\tshadowMapEnabled: _this.shadowMapEnabled && object.receiveShadow && maxShadows > 0,\r\n\t\t\t\tshadowMapType: _this.shadowMapType,\r\n\t\t\t\tshadowMapDebug: _this.shadowMapDebug,\r\n\t\t\t\tshadowMapCascade: _this.shadowMapCascade,\r\n\t\r\n\t\t\t\talphaTest: material.alphaTest,\r\n\t\t\t\tmetal: material.metal,\r\n\t\t\t\twrapAround: material.wrapAround,\r\n\t\t\t\tdoubleSided: material.side === THREE.DoubleSide,\r\n\t\t\t\tflipSided: material.side === THREE.BackSide\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t\t// Generate code\r\n\t\r\n\t\t\tvar chunks = [];\r\n\t\r\n\t\t\tif ( shaderID ) {\r\n\t\r\n\t\t\t\tchunks.push( shaderID );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tchunks.push( material.fragmentShader );\r\n\t\t\t\tchunks.push( material.vertexShader );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( material.defines !== undefined ) {\r\n\t\r\n\t\t\t\tfor ( var name in material.defines ) {\r\n\t\r\n\t\t\t\t\tchunks.push( name );\r\n\t\t\t\t\tchunks.push( material.defines[ name ] );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfor ( var name in parameters ) {\r\n\t\r\n\t\t\t\tchunks.push( name );\r\n\t\t\t\tchunks.push( parameters[ name ] );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar code = chunks.join();\r\n\t\r\n\t\t\tvar program;\r\n\t\r\n\t\t\t// Check if code has been already compiled\r\n\t\r\n\t\t\tfor ( var p = 0, pl = _programs.length; p < pl; p ++ ) {\r\n\t\r\n\t\t\t\tvar programInfo = _programs[ p ];\r\n\t\r\n\t\t\t\tif ( programInfo.code === code ) {\r\n\t\r\n\t\t\t\t\tprogram = programInfo;\r\n\t\t\t\t\tprogram.usedTimes ++;\r\n\t\r\n\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( program === undefined ) {\r\n\t\r\n\t\t\t\tprogram = new THREE.WebGLProgram( _this, code, material, parameters );\r\n\t\t\t\t_programs.push( program );\r\n\t\r\n\t\t\t\t_this.info.memory.programs = _programs.length;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tmaterial.program = program;\r\n\t\r\n\t\t\tvar attributes = program.attributes;\r\n\t\r\n\t\t\tif ( material.morphTargets ) {\r\n\t\r\n\t\t\t\tmaterial.numSupportedMorphTargets = 0;\r\n\t\r\n\t\t\t\tvar id, base = 'morphTarget';\r\n\t\r\n\t\t\t\tfor ( var i = 0; i < _this.maxMorphTargets; i ++ ) {\r\n\t\r\n\t\t\t\t\tid = base + i;\r\n\t\r\n\t\t\t\t\tif ( attributes[ id ] >= 0 ) {\r\n\t\r\n\t\t\t\t\t\tmaterial.numSupportedMorphTargets ++;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( material.morphNormals ) {\r\n\t\r\n\t\t\t\tmaterial.numSupportedMorphNormals = 0;\r\n\t\r\n\t\t\t\tvar id, base = 'morphNormal';\r\n\t\r\n\t\t\t\tfor ( i = 0; i < _this.maxMorphNormals; i ++ ) {\r\n\t\r\n\t\t\t\t\tid = base + i;\r\n\t\r\n\t\t\t\t\tif ( attributes[ id ] >= 0 ) {\r\n\t\r\n\t\t\t\t\t\tmaterial.numSupportedMorphNormals ++;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tmaterial.uniformsList = [];\r\n\t\r\n\t\t\tfor ( var u in material.__webglShader.uniforms ) {\r\n\t\r\n\t\t\t\tvar location = material.program.uniforms[ u ];\r\n\t\r\n\t\t\t\tif ( location ) {\r\n\t\t\t\t\tmaterial.uniformsList.push( [ material.__webglShader.uniforms[ u ], location ] );\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction setMaterial( material ) {\r\n\t\r\n\t\t\tif ( material.transparent === true ) {\r\n\t\r\n\t\t\t\tstate.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tstate.setBlending( THREE.NoBlending );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tstate.setDepthTest( material.depthTest );\r\n\t\t\tstate.setDepthWrite( material.depthWrite );\r\n\t\t\tstate.setColorWrite( material.colorWrite );\r\n\t\t\tstate.setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction setProgram( camera, lights, fog, material, object ) {\r\n\t\r\n\t\t\t_usedTextureUnits = 0;\r\n\t\r\n\t\t\tif ( material.needsUpdate ) {\r\n\t\r\n\t\t\t\tif ( material.program ) deallocateMaterial( material );\r\n\t\r\n\t\t\t\tinitMaterial( material, lights, fog, object );\r\n\t\t\t\tmaterial.needsUpdate = false;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( material.morphTargets ) {\r\n\t\r\n\t\t\t\tif ( ! object.__webglMorphTargetInfluences ) {\r\n\t\r\n\t\t\t\t\tobject.__webglMorphTargetInfluences = new Float32Array( _this.maxMorphTargets );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar refreshProgram = false;\r\n\t\t\tvar refreshMaterial = false;\r\n\t\t\tvar refreshLights = false;\r\n\t\r\n\t\t\tvar program = material.program,\r\n\t\t\t\tp_uniforms = program.uniforms,\r\n\t\t\t\tm_uniforms = material.__webglShader.uniforms;\r\n\t\r\n\t\t\tif ( program.id !== _currentProgram ) {\r\n\t\r\n\t\t\t\t_gl.useProgram( program.program );\r\n\t\t\t\t_currentProgram = program.id;\r\n\t\r\n\t\t\t\trefreshProgram = true;\r\n\t\t\t\trefreshMaterial = true;\r\n\t\t\t\trefreshLights = true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( material.id !== _currentMaterialId ) {\r\n\t\r\n\t\t\t\tif ( _currentMaterialId === -1 ) refreshLights = true;\r\n\t\t\t\t_currentMaterialId = material.id;\r\n\t\r\n\t\t\t\trefreshMaterial = true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( refreshProgram || camera !== _currentCamera ) {\r\n\t\r\n\t\t\t\t_gl.uniformMatrix4fv( p_uniforms.projectionMatrix, false, camera.projectionMatrix.elements );\r\n\t\r\n\t\t\t\tif ( _logarithmicDepthBuffer ) {\r\n\t\r\n\t\t\t\t\t_gl.uniform1f( p_uniforms.logDepthBufFC, 2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\r\n\t\t\t\tif ( camera !== _currentCamera ) _currentCamera = camera;\r\n\t\r\n\t\t\t\t// load material specific uniforms\r\n\t\t\t\t// (shader material also gets them for the sake of genericity)\r\n\t\r\n\t\t\t\tif ( material instanceof THREE.ShaderMaterial ||\r\n\t\t\t\t\t material instanceof THREE.MeshPhongMaterial ||\r\n\t\t\t\t\t material.envMap ) {\r\n\t\r\n\t\t\t\t\tif ( p_uniforms.cameraPosition !== null ) {\r\n\t\r\n\t\t\t\t\t\t_vector3.setFromMatrixPosition( camera.matrixWorld );\r\n\t\t\t\t\t\t_gl.uniform3f( p_uniforms.cameraPosition, _vector3.x, _vector3.y, _vector3.z );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( material instanceof THREE.MeshPhongMaterial ||\r\n\t\t\t\t\t material instanceof THREE.MeshLambertMaterial ||\r\n\t\t\t\t\t material instanceof THREE.MeshBasicMaterial ||\r\n\t\t\t\t\t material instanceof THREE.ShaderMaterial ||\r\n\t\t\t\t\t material.skinning ) {\r\n\t\r\n\t\t\t\t\tif ( p_uniforms.viewMatrix !== null ) {\r\n\t\r\n\t\t\t\t\t\t_gl.uniformMatrix4fv( p_uniforms.viewMatrix, false, camera.matrixWorldInverse.elements );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// skinning uniforms must be set even if material didn't change\r\n\t\t\t// auto-setting of texture unit for bone texture must go before other textures\r\n\t\t\t// not sure why, but otherwise weird things happen\r\n\t\r\n\t\t\tif ( material.skinning ) {\r\n\t\r\n\t\t\t\tif ( object.bindMatrix && p_uniforms.bindMatrix !== null ) {\r\n\t\r\n\t\t\t\t\t_gl.uniformMatrix4fv( p_uniforms.bindMatrix, false, object.bindMatrix.elements );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( object.bindMatrixInverse && p_uniforms.bindMatrixInverse !== null ) {\r\n\t\r\n\t\t\t\t\t_gl.uniformMatrix4fv( p_uniforms.bindMatrixInverse, false, object.bindMatrixInverse.elements );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( _supportsBoneTextures && object.skeleton && object.skeleton.useVertexTexture ) {\r\n\t\r\n\t\t\t\t\tif ( p_uniforms.boneTexture !== null ) {\r\n\t\r\n\t\t\t\t\t\tvar textureUnit = getTextureUnit();\r\n\t\r\n\t\t\t\t\t\t_gl.uniform1i( p_uniforms.boneTexture, textureUnit );\r\n\t\t\t\t\t\t_this.setTexture( object.skeleton.boneTexture, textureUnit );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( p_uniforms.boneTextureWidth !== null ) {\r\n\t\r\n\t\t\t\t\t\t_gl.uniform1i( p_uniforms.boneTextureWidth, object.skeleton.boneTextureWidth );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( p_uniforms.boneTextureHeight !== null ) {\r\n\t\r\n\t\t\t\t\t\t_gl.uniform1i( p_uniforms.boneTextureHeight, object.skeleton.boneTextureHeight );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else if ( object.skeleton && object.skeleton.boneMatrices ) {\r\n\t\r\n\t\t\t\t\tif ( p_uniforms.boneGlobalMatrices !== null ) {\r\n\t\r\n\t\t\t\t\t\t_gl.uniformMatrix4fv( p_uniforms.boneGlobalMatrices, false, object.skeleton.boneMatrices );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( refreshMaterial ) {\r\n\t\r\n\t\t\t\t// refresh uniforms common to several materials\r\n\t\r\n\t\t\t\tif ( fog && material.fog ) {\r\n\t\r\n\t\t\t\t\trefreshUniformsFog( m_uniforms, fog );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( material instanceof THREE.MeshPhongMaterial ||\r\n\t\t\t\t\t material instanceof THREE.MeshLambertMaterial ||\r\n\t\t\t\t\t material.lights ) {\r\n\t\r\n\t\t\t\t\tif ( _lightsNeedUpdate ) {\r\n\t\r\n\t\t\t\t\t\trefreshLights = true;\r\n\t\t\t\t\t\tsetupLights( lights );\r\n\t\t\t\t\t\t_lightsNeedUpdate = false;\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( refreshLights ) {\r\n\t\t\t\t\t\trefreshUniformsLights( m_uniforms, _lights );\r\n\t\t\t\t\t\tmarkUniformsLightsNeedsUpdate( m_uniforms, true );\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tmarkUniformsLightsNeedsUpdate( m_uniforms, false );\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( material instanceof THREE.MeshBasicMaterial ||\r\n\t\t\t\t\t material instanceof THREE.MeshLambertMaterial ||\r\n\t\t\t\t\t material instanceof THREE.MeshPhongMaterial ) {\r\n\t\r\n\t\t\t\t\trefreshUniformsCommon( m_uniforms, material );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// refresh single material specific uniforms\r\n\t\r\n\t\t\t\tif ( material instanceof THREE.LineBasicMaterial ) {\r\n\t\r\n\t\t\t\t\trefreshUniformsLine( m_uniforms, material );\r\n\t\r\n\t\t\t\t} else if ( material instanceof THREE.LineDashedMaterial ) {\r\n\t\r\n\t\t\t\t\trefreshUniformsLine( m_uniforms, material );\r\n\t\t\t\t\trefreshUniformsDash( m_uniforms, material );\r\n\t\r\n\t\t\t\t} else if ( material instanceof THREE.PointCloudMaterial ) {\r\n\t\r\n\t\t\t\t\trefreshUniformsParticle( m_uniforms, material );\r\n\t\r\n\t\t\t\t} else if ( material instanceof THREE.MeshPhongMaterial ) {\r\n\t\r\n\t\t\t\t\trefreshUniformsPhong( m_uniforms, material );\r\n\t\r\n\t\t\t\t} else if ( material instanceof THREE.MeshLambertMaterial ) {\r\n\t\r\n\t\t\t\t\trefreshUniformsLambert( m_uniforms, material );\r\n\t\r\n\t\t\t\t} else if ( material instanceof THREE.MeshDepthMaterial ) {\r\n\t\r\n\t\t\t\t\tm_uniforms.mNear.value = camera.near;\r\n\t\t\t\t\tm_uniforms.mFar.value = camera.far;\r\n\t\t\t\t\tm_uniforms.opacity.value = material.opacity;\r\n\t\r\n\t\t\t\t} else if ( material instanceof THREE.MeshNormalMaterial ) {\r\n\t\r\n\t\t\t\t\tm_uniforms.opacity.value = material.opacity;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( object.receiveShadow && ! material._shadowPass ) {\r\n\t\r\n\t\t\t\t\trefreshUniformsShadow( m_uniforms, lights );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// load common uniforms\r\n\t\r\n\t\t\t\tloadUniformsGeneric( material.uniformsList );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tloadUniformsMatrices( p_uniforms, object );\r\n\t\r\n\t\t\tif ( p_uniforms.modelMatrix !== null ) {\r\n\t\r\n\t\t\t\t_gl.uniformMatrix4fv( p_uniforms.modelMatrix, false, object.matrixWorld.elements );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn program;\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// Uniforms (refresh uniforms objects)\r\n\t\r\n\t\tfunction refreshUniformsCommon ( uniforms, material ) {\r\n\t\r\n\t\t\tuniforms.opacity.value = material.opacity;\r\n\t\r\n\t\t\tuniforms.diffuse.value = material.color;\r\n\t\r\n\t\t\tuniforms.map.value = material.map;\r\n\t\t\tuniforms.lightMap.value = material.lightMap;\r\n\t\t\tuniforms.specularMap.value = material.specularMap;\r\n\t\t\tuniforms.alphaMap.value = material.alphaMap;\r\n\t\r\n\t\t\tif ( material.bumpMap ) {\r\n\t\r\n\t\t\t\tuniforms.bumpMap.value = material.bumpMap;\r\n\t\t\t\tuniforms.bumpScale.value = material.bumpScale;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( material.normalMap ) {\r\n\t\r\n\t\t\t\tuniforms.normalMap.value = material.normalMap;\r\n\t\t\t\tuniforms.normalScale.value.copy( material.normalScale );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// uv repeat and offset setting priorities\r\n\t\t\t//  1. color map\r\n\t\t\t//  2. specular map\r\n\t\t\t//  3. normal map\r\n\t\t\t//  4. bump map\r\n\t\t\t//  5. alpha map\r\n\t\r\n\t\t\tvar uvScaleMap;\r\n\t\r\n\t\t\tif ( material.map ) {\r\n\t\r\n\t\t\t\tuvScaleMap = material.map;\r\n\t\r\n\t\t\t} else if ( material.specularMap ) {\r\n\t\r\n\t\t\t\tuvScaleMap = material.specularMap;\r\n\t\r\n\t\t\t} else if ( material.normalMap ) {\r\n\t\r\n\t\t\t\tuvScaleMap = material.normalMap;\r\n\t\r\n\t\t\t} else if ( material.bumpMap ) {\r\n\t\r\n\t\t\t\tuvScaleMap = material.bumpMap;\r\n\t\r\n\t\t\t} else if ( material.alphaMap ) {\r\n\t\r\n\t\t\t\tuvScaleMap = material.alphaMap;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( uvScaleMap !== undefined ) {\r\n\t\r\n\t\t\t\tvar offset = uvScaleMap.offset;\r\n\t\t\t\tvar repeat = uvScaleMap.repeat;\r\n\t\r\n\t\t\t\tuniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tuniforms.envMap.value = material.envMap;\r\n\t\t\tuniforms.flipEnvMap.value = ( material.envMap instanceof THREE.WebGLRenderTargetCube ) ? 1 : - 1;\r\n\t\r\n\t\t\tuniforms.reflectivity.value = material.reflectivity;\r\n\t\t\tuniforms.refractionRatio.value = material.refractionRatio;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction refreshUniformsLine ( uniforms, material ) {\r\n\t\r\n\t\t\tuniforms.diffuse.value = material.color;\r\n\t\t\tuniforms.opacity.value = material.opacity;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction refreshUniformsDash ( uniforms, material ) {\r\n\t\r\n\t\t\tuniforms.dashSize.value = material.dashSize;\r\n\t\t\tuniforms.totalSize.value = material.dashSize + material.gapSize;\r\n\t\t\tuniforms.scale.value = material.scale;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction refreshUniformsParticle ( uniforms, material ) {\r\n\t\r\n\t\t\tuniforms.psColor.value = material.color;\r\n\t\t\tuniforms.opacity.value = material.opacity;\r\n\t\t\tuniforms.size.value = material.size;\r\n\t\t\tuniforms.scale.value = _canvas.height / 2.0; // TODO: Cache this.\r\n\t\r\n\t\t\tuniforms.map.value = material.map;\r\n\t\r\n\t\t\tif ( material.map !== null ) {\r\n\t\r\n\t\t\t\tvar offset = material.map.offset;\r\n\t\t\t\tvar repeat = material.map.repeat;\r\n\t\r\n\t\t\t\tuniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction refreshUniformsFog ( uniforms, fog ) {\r\n\t\r\n\t\t\tuniforms.fogColor.value = fog.color;\r\n\t\r\n\t\t\tif ( fog instanceof THREE.Fog ) {\r\n\t\r\n\t\t\t\tuniforms.fogNear.value = fog.near;\r\n\t\t\t\tuniforms.fogFar.value = fog.far;\r\n\t\r\n\t\t\t} else if ( fog instanceof THREE.FogExp2 ) {\r\n\t\r\n\t\t\t\tuniforms.fogDensity.value = fog.density;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction refreshUniformsPhong ( uniforms, material ) {\r\n\t\r\n\t\t\tuniforms.shininess.value = material.shininess;\r\n\t\r\n\t\t\tuniforms.emissive.value = material.emissive;\r\n\t\t\tuniforms.specular.value = material.specular;\r\n\t\r\n\t\t\tif ( material.wrapAround ) {\r\n\t\r\n\t\t\t\tuniforms.wrapRGB.value.copy( material.wrapRGB );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction refreshUniformsLambert ( uniforms, material ) {\r\n\t\r\n\t\t\tuniforms.emissive.value = material.emissive;\r\n\t\r\n\t\t\tif ( material.wrapAround ) {\r\n\t\r\n\t\t\t\tuniforms.wrapRGB.value.copy( material.wrapRGB );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction refreshUniformsLights ( uniforms, lights ) {\r\n\t\r\n\t\t\tuniforms.ambientLightColor.value = lights.ambient;\r\n\t\r\n\t\t\tuniforms.directionalLightColor.value = lights.directional.colors;\r\n\t\t\tuniforms.directionalLightDirection.value = lights.directional.positions;\r\n\t\r\n\t\t\tuniforms.pointLightColor.value = lights.point.colors;\r\n\t\t\tuniforms.pointLightPosition.value = lights.point.positions;\r\n\t\t\tuniforms.pointLightDistance.value = lights.point.distances;\r\n\t\t\tuniforms.pointLightDecay.value = lights.point.decays;\r\n\t\r\n\t\t\tuniforms.spotLightColor.value = lights.spot.colors;\r\n\t\t\tuniforms.spotLightPosition.value = lights.spot.positions;\r\n\t\t\tuniforms.spotLightDistance.value = lights.spot.distances;\r\n\t\t\tuniforms.spotLightDirection.value = lights.spot.directions;\r\n\t\t\tuniforms.spotLightAngleCos.value = lights.spot.anglesCos;\r\n\t\t\tuniforms.spotLightExponent.value = lights.spot.exponents;\r\n\t\t\tuniforms.spotLightDecay.value = lights.spot.decays;\r\n\t\r\n\t\t\tuniforms.hemisphereLightSkyColor.value = lights.hemi.skyColors;\r\n\t\t\tuniforms.hemisphereLightGroundColor.value = lights.hemi.groundColors;\r\n\t\t\tuniforms.hemisphereLightDirection.value = lights.hemi.positions;\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// If uniforms are marked as clean, they don't need to be loaded to the GPU.\r\n\t\r\n\t\tfunction markUniformsLightsNeedsUpdate ( uniforms, value ) {\r\n\t\r\n\t\t\tuniforms.ambientLightColor.needsUpdate = value;\r\n\t\r\n\t\t\tuniforms.directionalLightColor.needsUpdate = value;\r\n\t\t\tuniforms.directionalLightDirection.needsUpdate = value;\r\n\t\r\n\t\t\tuniforms.pointLightColor.needsUpdate = value;\r\n\t\t\tuniforms.pointLightPosition.needsUpdate = value;\r\n\t\t\tuniforms.pointLightDistance.needsUpdate = value;\r\n\t\t\tuniforms.pointLightDecay.needsUpdate = value;\r\n\t\r\n\t\t\tuniforms.spotLightColor.needsUpdate = value;\r\n\t\t\tuniforms.spotLightPosition.needsUpdate = value;\r\n\t\t\tuniforms.spotLightDistance.needsUpdate = value;\r\n\t\t\tuniforms.spotLightDirection.needsUpdate = value;\r\n\t\t\tuniforms.spotLightAngleCos.needsUpdate = value;\r\n\t\t\tuniforms.spotLightExponent.needsUpdate = value;\r\n\t\t\tuniforms.spotLightDecay.needsUpdate = value;\r\n\t\r\n\t\t\tuniforms.hemisphereLightSkyColor.needsUpdate = value;\r\n\t\t\tuniforms.hemisphereLightGroundColor.needsUpdate = value;\r\n\t\t\tuniforms.hemisphereLightDirection.needsUpdate = value;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction refreshUniformsShadow ( uniforms, lights ) {\r\n\t\r\n\t\t\tif ( uniforms.shadowMatrix ) {\r\n\t\r\n\t\t\t\tvar j = 0;\r\n\t\r\n\t\t\t\tfor ( var i = 0, il = lights.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\tvar light = lights[ i ];\r\n\t\r\n\t\t\t\t\tif ( ! light.castShadow ) continue;\r\n\t\r\n\t\t\t\t\tif ( light instanceof THREE.SpotLight || ( light instanceof THREE.DirectionalLight && ! light.shadowCascade ) ) {\r\n\t\r\n\t\t\t\t\t\tuniforms.shadowMap.value[ j ] = light.shadowMap;\r\n\t\t\t\t\t\tuniforms.shadowMapSize.value[ j ] = light.shadowMapSize;\r\n\t\r\n\t\t\t\t\t\tuniforms.shadowMatrix.value[ j ] = light.shadowMatrix;\r\n\t\r\n\t\t\t\t\t\tuniforms.shadowDarkness.value[ j ] = light.shadowDarkness;\r\n\t\t\t\t\t\tuniforms.shadowBias.value[ j ] = light.shadowBias;\r\n\t\r\n\t\t\t\t\t\tj ++;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// Uniforms (load to GPU)\r\n\t\r\n\t\tfunction loadUniformsMatrices ( uniforms, object ) {\r\n\t\r\n\t\t\t_gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, object._modelViewMatrix.elements );\r\n\t\r\n\t\t\tif ( uniforms.normalMatrix ) {\r\n\t\r\n\t\t\t\t_gl.uniformMatrix3fv( uniforms.normalMatrix, false, object._normalMatrix.elements );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction getTextureUnit() {\r\n\t\r\n\t\t\tvar textureUnit = _usedTextureUnits;\r\n\t\r\n\t\t\tif ( textureUnit >= _maxTextures ) {\r\n\t\r\n\t\t\t\tTHREE.warn( 'WebGLRenderer: trying to use ' + textureUnit + ' texture units while this GPU supports only ' + _maxTextures );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t_usedTextureUnits += 1;\r\n\t\r\n\t\t\treturn textureUnit;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction loadUniformsGeneric ( uniforms ) {\r\n\t\r\n\t\t\tvar texture, textureUnit, offset;\r\n\t\r\n\t\t\tfor ( var j = 0, jl = uniforms.length; j < jl; j ++ ) {\r\n\t\r\n\t\t\t\tvar uniform = uniforms[ j ][ 0 ];\r\n\t\r\n\t\t\t\t// needsUpdate property is not added to all uniforms.\r\n\t\t\t\tif ( uniform.needsUpdate === false ) continue;\r\n\t\r\n\t\t\t\tvar type = uniform.type;\r\n\t\t\t\tvar value = uniform.value;\r\n\t\t\t\tvar location = uniforms[ j ][ 1 ];\r\n\t\r\n\t\t\t\tswitch ( type ) {\r\n\t\r\n\t\t\t\t\tcase '1i':\r\n\t\t\t\t\t\t_gl.uniform1i( location, value );\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase '1f':\r\n\t\t\t\t\t\t_gl.uniform1f( location, value );\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase '2f':\r\n\t\t\t\t\t\t_gl.uniform2f( location, value[ 0 ], value[ 1 ] );\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase '3f':\r\n\t\t\t\t\t\t_gl.uniform3f( location, value[ 0 ], value[ 1 ], value[ 2 ] );\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase '4f':\r\n\t\t\t\t\t\t_gl.uniform4f( location, value[ 0 ], value[ 1 ], value[ 2 ], value[ 3 ] );\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase '1iv':\r\n\t\t\t\t\t\t_gl.uniform1iv( location, value );\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase '3iv':\r\n\t\t\t\t\t\t_gl.uniform3iv( location, value );\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase '1fv':\r\n\t\t\t\t\t\t_gl.uniform1fv( location, value );\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase '2fv':\r\n\t\t\t\t\t\t_gl.uniform2fv( location, value );\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase '3fv':\r\n\t\t\t\t\t\t_gl.uniform3fv( location, value );\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase '4fv':\r\n\t\t\t\t\t\t_gl.uniform4fv( location, value );\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'Matrix3fv':\r\n\t\t\t\t\t\t_gl.uniformMatrix3fv( location, false, value );\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'Matrix4fv':\r\n\t\t\t\t\t\t_gl.uniformMatrix4fv( location, false, value );\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t//\r\n\t\r\n\t\t\t\t\tcase 'i':\r\n\t\r\n\t\t\t\t\t\t// single integer\r\n\t\t\t\t\t\t_gl.uniform1i( location, value );\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'f':\r\n\t\r\n\t\t\t\t\t\t// single float\r\n\t\t\t\t\t\t_gl.uniform1f( location, value );\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'v2':\r\n\t\r\n\t\t\t\t\t\t// single THREE.Vector2\r\n\t\t\t\t\t\t_gl.uniform2f( location, value.x, value.y );\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'v3':\r\n\t\r\n\t\t\t\t\t\t// single THREE.Vector3\r\n\t\t\t\t\t\t_gl.uniform3f( location, value.x, value.y, value.z );\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'v4':\r\n\t\r\n\t\t\t\t\t\t// single THREE.Vector4\r\n\t\t\t\t\t\t_gl.uniform4f( location, value.x, value.y, value.z, value.w );\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'c':\r\n\t\r\n\t\t\t\t\t\t// single THREE.Color\r\n\t\t\t\t\t\t_gl.uniform3f( location, value.r, value.g, value.b );\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'iv1':\r\n\t\r\n\t\t\t\t\t\t// flat array of integers (JS or typed array)\r\n\t\t\t\t\t\t_gl.uniform1iv( location, value );\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'iv':\r\n\t\r\n\t\t\t\t\t\t// flat array of integers with 3 x N size (JS or typed array)\r\n\t\t\t\t\t\t_gl.uniform3iv( location, value );\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'fv1':\r\n\t\r\n\t\t\t\t\t\t// flat array of floats (JS or typed array)\r\n\t\t\t\t\t\t_gl.uniform1fv( location, value );\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'fv':\r\n\t\r\n\t\t\t\t\t\t// flat array of floats with 3 x N size (JS or typed array)\r\n\t\t\t\t\t\t_gl.uniform3fv( location, value );\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'v2v':\r\n\t\r\n\t\t\t\t\t\t// array of THREE.Vector2\r\n\t\r\n\t\t\t\t\t\tif ( uniform._array === undefined ) {\r\n\t\r\n\t\t\t\t\t\t\tuniform._array = new Float32Array( 2 * value.length );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tfor ( var i = 0, il = value.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\t\t\toffset = i * 2;\r\n\t\r\n\t\t\t\t\t\t\tuniform._array[ offset ]   = value[ i ].x;\r\n\t\t\t\t\t\t\tuniform._array[ offset + 1 ] = value[ i ].y;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t_gl.uniform2fv( location, uniform._array );\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'v3v':\r\n\t\r\n\t\t\t\t\t\t// array of THREE.Vector3\r\n\t\r\n\t\t\t\t\t\tif ( uniform._array === undefined ) {\r\n\t\r\n\t\t\t\t\t\t\tuniform._array = new Float32Array( 3 * value.length );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tfor ( var i = 0, il = value.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\t\t\toffset = i * 3;\r\n\t\r\n\t\t\t\t\t\t\tuniform._array[ offset ]   = value[ i ].x;\r\n\t\t\t\t\t\t\tuniform._array[ offset + 1 ] = value[ i ].y;\r\n\t\t\t\t\t\t\tuniform._array[ offset + 2 ] = value[ i ].z;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t_gl.uniform3fv( location, uniform._array );\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'v4v':\r\n\t\r\n\t\t\t\t\t\t// array of THREE.Vector4\r\n\t\r\n\t\t\t\t\t\tif ( uniform._array === undefined ) {\r\n\t\r\n\t\t\t\t\t\t\tuniform._array = new Float32Array( 4 * value.length );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tfor ( var i = 0, il = value.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\t\t\toffset = i * 4;\r\n\t\r\n\t\t\t\t\t\t\tuniform._array[ offset ]   = value[ i ].x;\r\n\t\t\t\t\t\t\tuniform._array[ offset + 1 ] = value[ i ].y;\r\n\t\t\t\t\t\t\tuniform._array[ offset + 2 ] = value[ i ].z;\r\n\t\t\t\t\t\t\tuniform._array[ offset + 3 ] = value[ i ].w;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t_gl.uniform4fv( location, uniform._array );\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'm3':\r\n\t\r\n\t\t\t\t\t\t// single THREE.Matrix3\r\n\t\t\t\t\t\t_gl.uniformMatrix3fv( location, false, value.elements );\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'm3v':\r\n\t\r\n\t\t\t\t\t\t// array of THREE.Matrix3\r\n\t\r\n\t\t\t\t\t\tif ( uniform._array === undefined ) {\r\n\t\r\n\t\t\t\t\t\t\tuniform._array = new Float32Array( 9 * value.length );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tfor ( var i = 0, il = value.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\t\t\tvalue[ i ].flattenToArrayOffset( uniform._array, i * 9 );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t_gl.uniformMatrix3fv( location, false, uniform._array );\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'm4':\r\n\t\r\n\t\t\t\t\t\t// single THREE.Matrix4\r\n\t\t\t\t\t\t_gl.uniformMatrix4fv( location, false, value.elements );\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'm4v':\r\n\t\r\n\t\t\t\t\t\t// array of THREE.Matrix4\r\n\t\r\n\t\t\t\t\t\tif ( uniform._array === undefined ) {\r\n\t\r\n\t\t\t\t\t\t\tuniform._array = new Float32Array( 16 * value.length );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tfor ( var i = 0, il = value.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\t\t\tvalue[ i ].flattenToArrayOffset( uniform._array, i * 16 );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t_gl.uniformMatrix4fv( location, false, uniform._array );\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 't':\r\n\t\r\n\t\t\t\t\t\t// single THREE.Texture (2d or cube)\r\n\t\r\n\t\t\t\t\t\ttexture = value;\r\n\t\t\t\t\t\ttextureUnit = getTextureUnit();\r\n\t\r\n\t\t\t\t\t\t_gl.uniform1i( location, textureUnit );\r\n\t\r\n\t\t\t\t\t\tif ( ! texture ) continue;\r\n\t\r\n\t\t\t\t\t\tif ( texture instanceof THREE.CubeTexture ||\r\n\t\t\t\t\t\t   ( texture.image instanceof Array && texture.image.length === 6 ) ) { // CompressedTexture can have Array in image :/\r\n\t\r\n\t\t\t\t\t\t\tsetCubeTexture( texture, textureUnit );\r\n\t\r\n\t\t\t\t\t\t} else if ( texture instanceof THREE.WebGLRenderTargetCube ) {\r\n\t\r\n\t\t\t\t\t\t\tsetCubeTextureDynamic( texture, textureUnit );\r\n\t\r\n\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\t_this.setTexture( texture, textureUnit );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'tv':\r\n\t\r\n\t\t\t\t\t\t// array of THREE.Texture (2d)\r\n\t\r\n\t\t\t\t\t\tif ( uniform._array === undefined ) {\r\n\t\r\n\t\t\t\t\t\t\tuniform._array = [];\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tfor ( var i = 0, il = uniform.value.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\t\t\tuniform._array[ i ] = getTextureUnit();\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t_gl.uniform1iv( location, uniform._array );\r\n\t\r\n\t\t\t\t\t\tfor ( var i = 0, il = uniform.value.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\t\t\ttexture = uniform.value[ i ];\r\n\t\t\t\t\t\t\ttextureUnit = uniform._array[ i ];\r\n\t\r\n\t\t\t\t\t\t\tif ( ! texture ) continue;\r\n\t\r\n\t\t\t\t\t\t\t_this.setTexture( texture, textureUnit );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tdefault:\r\n\t\r\n\t\t\t\t\t\tTHREE.warn( 'THREE.WebGLRenderer: Unknown uniform type: ' + type );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction setupMatrices ( object, camera ) {\r\n\t\r\n\t\t\tobject._modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );\r\n\t\t\tobject._normalMatrix.getNormalMatrix( object._modelViewMatrix );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction setColorLinear( array, offset, color, intensity ) {\r\n\t\r\n\t\t\tarray[ offset ]     = color.r * intensity;\r\n\t\t\tarray[ offset + 1 ] = color.g * intensity;\r\n\t\t\tarray[ offset + 2 ] = color.b * intensity;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction setupLights ( lights ) {\r\n\t\r\n\t\t\tvar l, ll, light,\r\n\t\t\tr = 0, g = 0, b = 0,\r\n\t\t\tcolor, skyColor, groundColor,\r\n\t\t\tintensity,\r\n\t\t\tdistance,\r\n\t\r\n\t\t\tzlights = _lights,\r\n\t\r\n\t\t\tdirColors = zlights.directional.colors,\r\n\t\t\tdirPositions = zlights.directional.positions,\r\n\t\r\n\t\t\tpointColors = zlights.point.colors,\r\n\t\t\tpointPositions = zlights.point.positions,\r\n\t\t\tpointDistances = zlights.point.distances,\r\n\t\t\tpointDecays = zlights.point.decays,\r\n\t\r\n\t\t\tspotColors = zlights.spot.colors,\r\n\t\t\tspotPositions = zlights.spot.positions,\r\n\t\t\tspotDistances = zlights.spot.distances,\r\n\t\t\tspotDirections = zlights.spot.directions,\r\n\t\t\tspotAnglesCos = zlights.spot.anglesCos,\r\n\t\t\tspotExponents = zlights.spot.exponents,\r\n\t\t\tspotDecays = zlights.spot.decays,\r\n\t\r\n\t\t\themiSkyColors = zlights.hemi.skyColors,\r\n\t\t\themiGroundColors = zlights.hemi.groundColors,\r\n\t\t\themiPositions = zlights.hemi.positions,\r\n\t\r\n\t\t\tdirLength = 0,\r\n\t\t\tpointLength = 0,\r\n\t\t\tspotLength = 0,\r\n\t\t\themiLength = 0,\r\n\t\r\n\t\t\tdirCount = 0,\r\n\t\t\tpointCount = 0,\r\n\t\t\tspotCount = 0,\r\n\t\t\themiCount = 0,\r\n\t\r\n\t\t\tdirOffset = 0,\r\n\t\t\tpointOffset = 0,\r\n\t\t\tspotOffset = 0,\r\n\t\t\themiOffset = 0;\r\n\t\r\n\t\t\tfor ( l = 0, ll = lights.length; l < ll; l ++ ) {\r\n\t\r\n\t\t\t\tlight = lights[ l ];\r\n\t\r\n\t\t\t\tif ( light.onlyShadow ) continue;\r\n\t\r\n\t\t\t\tcolor = light.color;\r\n\t\t\t\tintensity = light.intensity;\r\n\t\t\t\tdistance = light.distance;\r\n\t\r\n\t\t\t\tif ( light instanceof THREE.AmbientLight ) {\r\n\t\r\n\t\t\t\t\tif ( ! light.visible ) continue;\r\n\t\r\n\t\t\t\t\tr += color.r;\r\n\t\t\t\t\tg += color.g;\r\n\t\t\t\t\tb += color.b;\r\n\t\r\n\t\t\t\t} else if ( light instanceof THREE.DirectionalLight ) {\r\n\t\r\n\t\t\t\t\tdirCount += 1;\r\n\t\r\n\t\t\t\t\tif ( ! light.visible ) continue;\r\n\t\r\n\t\t\t\t\t_direction.setFromMatrixPosition( light.matrixWorld );\r\n\t\t\t\t\t_vector3.setFromMatrixPosition( light.target.matrixWorld );\r\n\t\t\t\t\t_direction.sub( _vector3 );\r\n\t\t\t\t\t_direction.normalize();\r\n\t\r\n\t\t\t\t\tdirOffset = dirLength * 3;\r\n\t\r\n\t\t\t\t\tdirPositions[ dirOffset ]     = _direction.x;\r\n\t\t\t\t\tdirPositions[ dirOffset + 1 ] = _direction.y;\r\n\t\t\t\t\tdirPositions[ dirOffset + 2 ] = _direction.z;\r\n\t\r\n\t\t\t\t\tsetColorLinear( dirColors, dirOffset, color, intensity );\r\n\t\r\n\t\t\t\t\tdirLength += 1;\r\n\t\r\n\t\t\t\t} else if ( light instanceof THREE.PointLight ) {\r\n\t\r\n\t\t\t\t\tpointCount += 1;\r\n\t\r\n\t\t\t\t\tif ( ! light.visible ) continue;\r\n\t\r\n\t\t\t\t\tpointOffset = pointLength * 3;\r\n\t\r\n\t\t\t\t\tsetColorLinear( pointColors, pointOffset, color, intensity );\r\n\t\r\n\t\t\t\t\t_vector3.setFromMatrixPosition( light.matrixWorld );\r\n\t\r\n\t\t\t\t\tpointPositions[ pointOffset ]     = _vector3.x;\r\n\t\t\t\t\tpointPositions[ pointOffset + 1 ] = _vector3.y;\r\n\t\t\t\t\tpointPositions[ pointOffset + 2 ] = _vector3.z;\r\n\t\r\n\t\t\t\t\t// distance is 0 if decay is 0, because there is no attenuation at all.\r\n\t\t\t\t\tpointDistances[ pointLength ] = distance;\r\n\t\t\t\t\tpointDecays[ pointLength ] = ( light.distance === 0 ) ? 0.0 : light.decay;\r\n\t\r\n\t\t\t\t\tpointLength += 1;\r\n\t\r\n\t\t\t\t} else if ( light instanceof THREE.SpotLight ) {\r\n\t\r\n\t\t\t\t\tspotCount += 1;\r\n\t\r\n\t\t\t\t\tif ( ! light.visible ) continue;\r\n\t\r\n\t\t\t\t\tspotOffset = spotLength * 3;\r\n\t\r\n\t\t\t\t\tsetColorLinear( spotColors, spotOffset, color, intensity );\r\n\t\r\n\t\t\t\t\t_direction.setFromMatrixPosition( light.matrixWorld );\r\n\t\r\n\t\t\t\t\tspotPositions[ spotOffset ]     = _direction.x;\r\n\t\t\t\t\tspotPositions[ spotOffset + 1 ] = _direction.y;\r\n\t\t\t\t\tspotPositions[ spotOffset + 2 ] = _direction.z;\r\n\t\r\n\t\t\t\t\tspotDistances[ spotLength ] = distance;\r\n\t\r\n\t\t\t\t\t_vector3.setFromMatrixPosition( light.target.matrixWorld );\r\n\t\t\t\t\t_direction.sub( _vector3 );\r\n\t\t\t\t\t_direction.normalize();\r\n\t\r\n\t\t\t\t\tspotDirections[ spotOffset ]     = _direction.x;\r\n\t\t\t\t\tspotDirections[ spotOffset + 1 ] = _direction.y;\r\n\t\t\t\t\tspotDirections[ spotOffset + 2 ] = _direction.z;\r\n\t\r\n\t\t\t\t\tspotAnglesCos[ spotLength ] = Math.cos( light.angle );\r\n\t\t\t\t\tspotExponents[ spotLength ] = light.exponent;\r\n\t\t\t\t\tspotDecays[ spotLength ] = ( light.distance === 0 ) ? 0.0 : light.decay;\r\n\t\r\n\t\t\t\t\tspotLength += 1;\r\n\t\r\n\t\t\t\t} else if ( light instanceof THREE.HemisphereLight ) {\r\n\t\r\n\t\t\t\t\themiCount += 1;\r\n\t\r\n\t\t\t\t\tif ( ! light.visible ) continue;\r\n\t\r\n\t\t\t\t\t_direction.setFromMatrixPosition( light.matrixWorld );\r\n\t\t\t\t\t_direction.normalize();\r\n\t\r\n\t\t\t\t\themiOffset = hemiLength * 3;\r\n\t\r\n\t\t\t\t\themiPositions[ hemiOffset ]     = _direction.x;\r\n\t\t\t\t\themiPositions[ hemiOffset + 1 ] = _direction.y;\r\n\t\t\t\t\themiPositions[ hemiOffset + 2 ] = _direction.z;\r\n\t\r\n\t\t\t\t\tskyColor = light.color;\r\n\t\t\t\t\tgroundColor = light.groundColor;\r\n\t\r\n\t\t\t\t\tsetColorLinear( hemiSkyColors, hemiOffset, skyColor, intensity );\r\n\t\t\t\t\tsetColorLinear( hemiGroundColors, hemiOffset, groundColor, intensity );\r\n\t\r\n\t\t\t\t\themiLength += 1;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// null eventual remains from removed lights\r\n\t\t\t// (this is to avoid if in shader)\r\n\t\r\n\t\t\tfor ( l = dirLength * 3, ll = Math.max( dirColors.length, dirCount * 3 ); l < ll; l ++ ) dirColors[ l ] = 0.0;\r\n\t\t\tfor ( l = pointLength * 3, ll = Math.max( pointColors.length, pointCount * 3 ); l < ll; l ++ ) pointColors[ l ] = 0.0;\r\n\t\t\tfor ( l = spotLength * 3, ll = Math.max( spotColors.length, spotCount * 3 ); l < ll; l ++ ) spotColors[ l ] = 0.0;\r\n\t\t\tfor ( l = hemiLength * 3, ll = Math.max( hemiSkyColors.length, hemiCount * 3 ); l < ll; l ++ ) hemiSkyColors[ l ] = 0.0;\r\n\t\t\tfor ( l = hemiLength * 3, ll = Math.max( hemiGroundColors.length, hemiCount * 3 ); l < ll; l ++ ) hemiGroundColors[ l ] = 0.0;\r\n\t\r\n\t\t\tzlights.directional.length = dirLength;\r\n\t\t\tzlights.point.length = pointLength;\r\n\t\t\tzlights.spot.length = spotLength;\r\n\t\t\tzlights.hemi.length = hemiLength;\r\n\t\r\n\t\t\tzlights.ambient[ 0 ] = r;\r\n\t\t\tzlights.ambient[ 1 ] = g;\r\n\t\t\tzlights.ambient[ 2 ] = b;\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// GL state setting\r\n\t\r\n\t\tthis.setFaceCulling = function ( cullFace, frontFaceDirection ) {\r\n\t\r\n\t\t\tif ( cullFace === THREE.CullFaceNone ) {\r\n\t\r\n\t\t\t\t_gl.disable( _gl.CULL_FACE );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tif ( frontFaceDirection === THREE.FrontFaceDirectionCW ) {\r\n\t\r\n\t\t\t\t\t_gl.frontFace( _gl.CW );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t_gl.frontFace( _gl.CCW );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( cullFace === THREE.CullFaceBack ) {\r\n\t\r\n\t\t\t\t\t_gl.cullFace( _gl.BACK );\r\n\t\r\n\t\t\t\t} else if ( cullFace === THREE.CullFaceFront ) {\r\n\t\r\n\t\t\t\t\t_gl.cullFace( _gl.FRONT );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t_gl.cullFace( _gl.FRONT_AND_BACK );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t_gl.enable( _gl.CULL_FACE );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setMaterialFaces = function ( material ) {\r\n\t\r\n\t\t\tstate.setDoubleSided( material.side === THREE.DoubleSide );\r\n\t\t\tstate.setFlipSided( material.side === THREE.BackSide );\r\n\t\r\n\t\t};\r\n\t\r\n\t\t// Textures\r\n\t\r\n\t\tfunction setTextureParameters ( textureType, texture, isImagePowerOfTwo ) {\r\n\t\r\n\t\t\tvar extension;\r\n\t\r\n\t\t\tif ( isImagePowerOfTwo ) {\r\n\t\r\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL( texture.wrapS ) );\r\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL( texture.wrapT ) );\r\n\t\r\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL( texture.magFilter ) );\r\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL( texture.minFilter ) );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );\r\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );\r\n\t\r\n\t\t\t\tif ( texture.wrapS !== THREE.ClampToEdgeWrapping || texture.wrapT !== THREE.ClampToEdgeWrapping ) {\r\n\t\r\n\t\t\t\t\tTHREE.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping. ( ' + texture.sourceFile + ' )' );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );\r\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );\r\n\t\r\n\t\t\t\tif ( texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter ) {\r\n\t\r\n\t\t\t\t\tTHREE.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter. ( ' + texture.sourceFile + ' )' );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\textension = extensions.get( 'EXT_texture_filter_anisotropic' );\r\n\t\r\n\t\t\tif ( extension && texture.type !== THREE.FloatType && texture.type !== THREE.HalfFloatType ) {\r\n\t\r\n\t\t\t\tif ( texture.anisotropy > 1 || texture.__currentAnisotropy ) {\r\n\t\r\n\t\t\t\t\t_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, _this.getMaxAnisotropy() ) );\r\n\t\t\t\t\ttexture.__currentAnisotropy = texture.anisotropy;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.uploadTexture = function ( texture ) {\r\n\t\r\n\t\t\tif ( texture.__webglInit === undefined ) {\r\n\t\r\n\t\t\t\ttexture.__webglInit = true;\r\n\t\r\n\t\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\r\n\t\r\n\t\t\t\ttexture.__webglTexture = _gl.createTexture();\r\n\t\r\n\t\t\t\t_this.info.memory.textures ++;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t_gl.bindTexture( _gl.TEXTURE_2D, texture.__webglTexture );\r\n\t\r\n\t\t\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\r\n\t\t\t_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );\r\n\t\t\t_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );\r\n\t\r\n\t\t\ttexture.image = clampToMaxSize( texture.image, _maxTextureSize );\r\n\t\r\n\t\t\tvar image = texture.image,\r\n\t\t\tisImagePowerOfTwo = THREE.Math.isPowerOfTwo( image.width ) && THREE.Math.isPowerOfTwo( image.height ),\r\n\t\t\tglFormat = paramThreeToGL( texture.format ),\r\n\t\t\tglType = paramThreeToGL( texture.type );\r\n\t\r\n\t\t\tsetTextureParameters( _gl.TEXTURE_2D, texture, isImagePowerOfTwo );\r\n\t\r\n\t\t\tvar mipmap, mipmaps = texture.mipmaps;\r\n\t\r\n\t\t\tif ( texture instanceof THREE.DataTexture ) {\r\n\t\r\n\t\t\t\t// use manually created mipmaps if available\r\n\t\t\t\t// if there are no manual mipmaps\r\n\t\t\t\t// set 0 level mipmap and then use GL to generate other mipmap levels\r\n\t\r\n\t\t\t\tif ( mipmaps.length > 0 && isImagePowerOfTwo ) {\r\n\t\r\n\t\t\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\t\tmipmap = mipmaps[ i ];\r\n\t\t\t\t\t\t_gl.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\ttexture.generateMipmaps = false;\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t_gl.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else if ( texture instanceof THREE.CompressedTexture ) {\r\n\t\r\n\t\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\tmipmap = mipmaps[ i ];\r\n\t\r\n\t\t\t\t\tif ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {\r\n\t\r\n\t\t\t\t\t\tif ( getCompressedTextureFormats().indexOf( glFormat ) > -1 ) {\r\n\t\r\n\t\t\t\t\t\t\t_gl.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );\r\n\t\r\n\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\tTHREE.warn( \"THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()\" );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t_gl.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else { // regular Texture (image, video, canvas)\r\n\t\r\n\t\t\t\t// use manually created mipmaps if available\r\n\t\t\t\t// if there are no manual mipmaps\r\n\t\t\t\t// set 0 level mipmap and then use GL to generate other mipmap levels\r\n\t\r\n\t\t\t\tif ( mipmaps.length > 0 && isImagePowerOfTwo ) {\r\n\t\r\n\t\t\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\t\tmipmap = mipmaps[ i ];\r\n\t\t\t\t\t\t_gl.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\ttexture.generateMipmaps = false;\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t_gl.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, texture.image );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( texture.generateMipmaps && isImagePowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );\r\n\t\r\n\t\t\ttexture.needsUpdate = false;\r\n\t\r\n\t\t\tif ( texture.onUpdate ) texture.onUpdate();\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setTexture = function ( texture, slot ) {\r\n\t\r\n\t\t\t_gl.activeTexture( _gl.TEXTURE0 + slot );\r\n\t\r\n\t\t\tif ( texture.needsUpdate ) {\r\n\t\r\n\t\t\t\t_this.uploadTexture( texture );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\t_gl.bindTexture( _gl.TEXTURE_2D, texture.__webglTexture );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tfunction clampToMaxSize ( image, maxSize ) {\r\n\t\r\n\t\t\tif ( image.width > maxSize || image.height > maxSize ) {\r\n\t\r\n\t\t\t\t// Warning: Scaling through the canvas will only work with images that use\r\n\t\t\t\t// premultiplied alpha.\r\n\t\r\n\t\t\t\tvar scale = maxSize / Math.max( image.width, image.height );\r\n\t\r\n\t\t\t\tvar canvas = document.createElement( 'canvas' );\r\n\t\t\t\tcanvas.width = Math.floor( image.width * scale );\r\n\t\t\t\tcanvas.height = Math.floor( image.height * scale );\r\n\t\r\n\t\t\t\tvar context = canvas.getContext( '2d' );\r\n\t\t\t\tcontext.drawImage( image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height );\r\n\t\r\n\t\t\t\tTHREE.warn( 'THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );\r\n\t\r\n\t\t\t\treturn canvas;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn image;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction setCubeTexture ( texture, slot ) {\r\n\t\r\n\t\t\tif ( texture.image.length === 6 ) {\r\n\t\r\n\t\t\t\tif ( texture.needsUpdate ) {\r\n\t\r\n\t\t\t\t\tif ( ! texture.image.__webglTextureCube ) {\r\n\t\r\n\t\t\t\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\r\n\t\r\n\t\t\t\t\t\ttexture.image.__webglTextureCube = _gl.createTexture();\r\n\t\r\n\t\t\t\t\t\t_this.info.memory.textures ++;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t_gl.activeTexture( _gl.TEXTURE0 + slot );\r\n\t\t\t\t\t_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.image.__webglTextureCube );\r\n\t\r\n\t\t\t\t\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\r\n\t\r\n\t\t\t\t\tvar isCompressed = texture instanceof THREE.CompressedTexture;\r\n\t\t\t\t\tvar isDataTexture = texture.image[ 0 ] instanceof THREE.DataTexture;\r\n\t\r\n\t\t\t\t\tvar cubeImage = [];\r\n\t\r\n\t\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\t\r\n\t\t\t\t\t\tif ( _this.autoScaleCubemaps && ! isCompressed && ! isDataTexture ) {\r\n\t\r\n\t\t\t\t\t\t\tcubeImage[ i ] = clampToMaxSize( texture.image[ i ], _maxCubemapSize );\r\n\t\r\n\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\tcubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tvar image = cubeImage[ 0 ],\r\n\t\t\t\t\tisImagePowerOfTwo = THREE.Math.isPowerOfTwo( image.width ) && THREE.Math.isPowerOfTwo( image.height ),\r\n\t\t\t\t\tglFormat = paramThreeToGL( texture.format ),\r\n\t\t\t\t\tglType = paramThreeToGL( texture.type );\r\n\t\r\n\t\t\t\t\tsetTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isImagePowerOfTwo );\r\n\t\r\n\t\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\t\r\n\t\t\t\t\t\tif ( ! isCompressed ) {\r\n\t\r\n\t\t\t\t\t\t\tif ( isDataTexture ) {\r\n\t\r\n\t\t\t\t\t\t\t\t_gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );\r\n\t\r\n\t\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\t\t_gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\tvar mipmap, mipmaps = cubeImage[ i ].mipmaps;\r\n\t\r\n\t\t\t\t\t\t\tfor ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\tmipmap = mipmaps[ j ];\r\n\t\r\n\t\t\t\t\t\t\t\tif ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {\r\n\t\r\n\t\t\t\t\t\t\t\t\tif ( getCompressedTextureFormats().indexOf( glFormat ) > -1 ) {\r\n\t\r\n\t\t\t\t\t\t\t\t\t\t_gl.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );\r\n\t\r\n\t\t\t\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\t\t\t\tTHREE.warn( \"THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setCubeTexture()\" );\r\n\t\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\t\t\t_gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\r\n\t\r\n\t\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( texture.generateMipmaps && isImagePowerOfTwo ) {\r\n\t\r\n\t\t\t\t\t\t_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\ttexture.needsUpdate = false;\r\n\t\r\n\t\t\t\t\tif ( texture.onUpdate ) texture.onUpdate();\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t_gl.activeTexture( _gl.TEXTURE0 + slot );\r\n\t\t\t\t\t_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.image.__webglTextureCube );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction setCubeTextureDynamic ( texture, slot ) {\r\n\t\r\n\t\t\t_gl.activeTexture( _gl.TEXTURE0 + slot );\r\n\t\t\t_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.__webglTexture );\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// Render targets\r\n\t\r\n\t\tfunction setupFrameBuffer ( framebuffer, renderTarget, textureTarget ) {\r\n\t\r\n\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\r\n\t\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureTarget, renderTarget.__webglTexture, 0 );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction setupRenderBuffer ( renderbuffer, renderTarget  ) {\r\n\t\r\n\t\t\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );\r\n\t\r\n\t\t\tif ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {\r\n\t\r\n\t\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );\r\n\t\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\r\n\t\r\n\t\t\t/* For some reason this is not working. Defaulting to RGBA4.\r\n\t\t\t} else if ( ! renderTarget.depthBuffer && renderTarget.stencilBuffer ) {\r\n\t\r\n\t\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.STENCIL_INDEX8, renderTarget.width, renderTarget.height );\r\n\t\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\r\n\t\t\t*/\r\n\t\t\t} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {\r\n\t\r\n\t\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );\r\n\t\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.setRenderTarget = function ( renderTarget ) {\r\n\t\r\n\t\t\tvar isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );\r\n\t\r\n\t\t\tif ( renderTarget && renderTarget.__webglFramebuffer === undefined ) {\r\n\t\r\n\t\t\t\tif ( renderTarget.depthBuffer === undefined ) renderTarget.depthBuffer = true;\r\n\t\t\t\tif ( renderTarget.stencilBuffer === undefined ) renderTarget.stencilBuffer = true;\r\n\t\r\n\t\t\t\trenderTarget.addEventListener( 'dispose', onRenderTargetDispose );\r\n\t\r\n\t\t\t\trenderTarget.__webglTexture = _gl.createTexture();\r\n\t\r\n\t\t\t\t_this.info.memory.textures ++;\r\n\t\r\n\t\t\t\t// Setup texture, create render and frame buffers\r\n\t\r\n\t\t\t\tvar isTargetPowerOfTwo = THREE.Math.isPowerOfTwo( renderTarget.width ) && THREE.Math.isPowerOfTwo( renderTarget.height ),\r\n\t\t\t\t\tglFormat = paramThreeToGL( renderTarget.format ),\r\n\t\t\t\t\tglType = paramThreeToGL( renderTarget.type );\r\n\t\r\n\t\t\t\tif ( isCube ) {\r\n\t\r\n\t\t\t\t\trenderTarget.__webglFramebuffer = [];\r\n\t\t\t\t\trenderTarget.__webglRenderbuffer = [];\r\n\t\r\n\t\t\t\t\t_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, renderTarget.__webglTexture );\r\n\t\t\t\t\tsetTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget, isTargetPowerOfTwo );\r\n\t\r\n\t\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\t\r\n\t\t\t\t\t\trenderTarget.__webglFramebuffer[ i ] = _gl.createFramebuffer();\r\n\t\t\t\t\t\trenderTarget.__webglRenderbuffer[ i ] = _gl.createRenderbuffer();\r\n\t\r\n\t\t\t\t\t\t_gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );\r\n\t\r\n\t\t\t\t\t\tsetupFrameBuffer( renderTarget.__webglFramebuffer[ i ], renderTarget, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );\r\n\t\t\t\t\t\tsetupRenderBuffer( renderTarget.__webglRenderbuffer[ i ], renderTarget );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\trenderTarget.__webglFramebuffer = _gl.createFramebuffer();\r\n\t\r\n\t\t\t\t\tif ( renderTarget.shareDepthFrom ) {\r\n\t\r\n\t\t\t\t\t\trenderTarget.__webglRenderbuffer = renderTarget.shareDepthFrom.__webglRenderbuffer;\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\trenderTarget.__webglRenderbuffer = _gl.createRenderbuffer();\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t_gl.bindTexture( _gl.TEXTURE_2D, renderTarget.__webglTexture );\r\n\t\t\t\t\tsetTextureParameters( _gl.TEXTURE_2D, renderTarget, isTargetPowerOfTwo );\r\n\t\r\n\t\t\t\t\t_gl.texImage2D( _gl.TEXTURE_2D, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );\r\n\t\r\n\t\t\t\t\tsetupFrameBuffer( renderTarget.__webglFramebuffer, renderTarget, _gl.TEXTURE_2D );\r\n\t\r\n\t\t\t\t\tif ( renderTarget.shareDepthFrom ) {\r\n\t\r\n\t\t\t\t\t\tif ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {\r\n\t\r\n\t\t\t\t\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderTarget.__webglRenderbuffer );\r\n\t\r\n\t\t\t\t\t\t} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {\r\n\t\r\n\t\t\t\t\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderTarget.__webglRenderbuffer );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tsetupRenderBuffer( renderTarget.__webglRenderbuffer, renderTarget );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// Release everything\r\n\t\r\n\t\t\t\tif ( isCube ) {\r\n\t\r\n\t\t\t\t\t_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, null );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t_gl.bindTexture( _gl.TEXTURE_2D, null );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );\r\n\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar framebuffer, width, height, vx, vy;\r\n\t\r\n\t\t\tif ( renderTarget ) {\r\n\t\r\n\t\t\t\tif ( isCube ) {\r\n\t\r\n\t\t\t\t\tframebuffer = renderTarget.__webglFramebuffer[ renderTarget.activeCubeFace ];\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tframebuffer = renderTarget.__webglFramebuffer;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\twidth = renderTarget.width;\r\n\t\t\t\theight = renderTarget.height;\r\n\t\r\n\t\t\t\tvx = 0;\r\n\t\t\t\tvy = 0;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tframebuffer = null;\r\n\t\r\n\t\t\t\twidth = _viewportWidth;\r\n\t\t\t\theight = _viewportHeight;\r\n\t\r\n\t\t\t\tvx = _viewportX;\r\n\t\t\t\tvy = _viewportY;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( framebuffer !== _currentFramebuffer ) {\r\n\t\r\n\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\r\n\t\t\t\t_gl.viewport( vx, vy, width, height );\r\n\t\r\n\t\t\t\t_currentFramebuffer = framebuffer;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t_currentWidth = width;\r\n\t\t\t_currentHeight = height;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.readRenderTargetPixels = function( renderTarget, x, y, width, height, buffer ) {\r\n\t\r\n\t\t\tif ( ! ( renderTarget instanceof THREE.WebGLRenderTarget ) ) {\r\n\t\r\n\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );\r\n\t\t\t\treturn;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( renderTarget.__webglFramebuffer ) {\r\n\t\r\n\t\t\t\tif ( renderTarget.format !== THREE.RGBAFormat ) {\r\n\t\r\n\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA format. readPixels can read only RGBA format.' );\r\n\t\t\t\t\treturn;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar restore = false;\r\n\t\r\n\t\t\t\tif ( renderTarget.__webglFramebuffer !== _currentFramebuffer ) {\r\n\t\r\n\t\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTarget.__webglFramebuffer );\r\n\t\r\n\t\t\t\t\trestore = true;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( _gl.checkFramebufferStatus( _gl.FRAMEBUFFER ) === _gl.FRAMEBUFFER_COMPLETE ) {\r\n\t\r\n\t\t\t\t\t_gl.readPixels( x, y, width, height, _gl.RGBA, _gl.UNSIGNED_BYTE, buffer );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( restore ) {\r\n\t\r\n\t\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, _currentFramebuffer );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tfunction updateRenderTargetMipmap ( renderTarget ) {\r\n\t\r\n\t\t\tif ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {\r\n\t\r\n\t\t\t\t_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, renderTarget.__webglTexture );\r\n\t\t\t\t_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\r\n\t\t\t\t_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, null );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\t_gl.bindTexture( _gl.TEXTURE_2D, renderTarget.__webglTexture );\r\n\t\t\t\t_gl.generateMipmap( _gl.TEXTURE_2D );\r\n\t\t\t\t_gl.bindTexture( _gl.TEXTURE_2D, null );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// Fallback filters for non-power-of-2 textures\r\n\t\r\n\t\tfunction filterFallback ( f ) {\r\n\t\r\n\t\t\tif ( f === THREE.NearestFilter || f === THREE.NearestMipMapNearestFilter || f === THREE.NearestMipMapLinearFilter ) {\r\n\t\r\n\t\t\t\treturn _gl.NEAREST;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn _gl.LINEAR;\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// Map three.js constants to WebGL constants\r\n\t\r\n\t\tfunction paramThreeToGL ( p ) {\r\n\t\r\n\t\t\tvar extension;\r\n\t\r\n\t\t\tif ( p === THREE.RepeatWrapping ) return _gl.REPEAT;\r\n\t\t\tif ( p === THREE.ClampToEdgeWrapping ) return _gl.CLAMP_TO_EDGE;\r\n\t\t\tif ( p === THREE.MirroredRepeatWrapping ) return _gl.MIRRORED_REPEAT;\r\n\t\r\n\t\t\tif ( p === THREE.NearestFilter ) return _gl.NEAREST;\r\n\t\t\tif ( p === THREE.NearestMipMapNearestFilter ) return _gl.NEAREST_MIPMAP_NEAREST;\r\n\t\t\tif ( p === THREE.NearestMipMapLinearFilter ) return _gl.NEAREST_MIPMAP_LINEAR;\r\n\t\r\n\t\t\tif ( p === THREE.LinearFilter ) return _gl.LINEAR;\r\n\t\t\tif ( p === THREE.LinearMipMapNearestFilter ) return _gl.LINEAR_MIPMAP_NEAREST;\r\n\t\t\tif ( p === THREE.LinearMipMapLinearFilter ) return _gl.LINEAR_MIPMAP_LINEAR;\r\n\t\r\n\t\t\tif ( p === THREE.UnsignedByteType ) return _gl.UNSIGNED_BYTE;\r\n\t\t\tif ( p === THREE.UnsignedShort4444Type ) return _gl.UNSIGNED_SHORT_4_4_4_4;\r\n\t\t\tif ( p === THREE.UnsignedShort5551Type ) return _gl.UNSIGNED_SHORT_5_5_5_1;\r\n\t\t\tif ( p === THREE.UnsignedShort565Type ) return _gl.UNSIGNED_SHORT_5_6_5;\r\n\t\r\n\t\t\tif ( p === THREE.ByteType ) return _gl.BYTE;\r\n\t\t\tif ( p === THREE.ShortType ) return _gl.SHORT;\r\n\t\t\tif ( p === THREE.UnsignedShortType ) return _gl.UNSIGNED_SHORT;\r\n\t\t\tif ( p === THREE.IntType ) return _gl.INT;\r\n\t\t\tif ( p === THREE.UnsignedIntType ) return _gl.UNSIGNED_INT;\r\n\t\t\tif ( p === THREE.FloatType ) return _gl.FLOAT;\r\n\t\r\n\t\t\textension = extensions.get( 'OES_texture_half_float' );\r\n\t\r\n\t\t\tif ( extension !== null ) {\r\n\t\r\n\t\t\t\tif ( p === THREE.HalfFloatType ) return extension.HALF_FLOAT_OES;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( p === THREE.AlphaFormat ) return _gl.ALPHA;\r\n\t\t\tif ( p === THREE.RGBFormat ) return _gl.RGB;\r\n\t\t\tif ( p === THREE.RGBAFormat ) return _gl.RGBA;\r\n\t\t\tif ( p === THREE.LuminanceFormat ) return _gl.LUMINANCE;\r\n\t\t\tif ( p === THREE.LuminanceAlphaFormat ) return _gl.LUMINANCE_ALPHA;\r\n\t\r\n\t\t\tif ( p === THREE.AddEquation ) return _gl.FUNC_ADD;\r\n\t\t\tif ( p === THREE.SubtractEquation ) return _gl.FUNC_SUBTRACT;\r\n\t\t\tif ( p === THREE.ReverseSubtractEquation ) return _gl.FUNC_REVERSE_SUBTRACT;\r\n\t\r\n\t\t\tif ( p === THREE.ZeroFactor ) return _gl.ZERO;\r\n\t\t\tif ( p === THREE.OneFactor ) return _gl.ONE;\r\n\t\t\tif ( p === THREE.SrcColorFactor ) return _gl.SRC_COLOR;\r\n\t\t\tif ( p === THREE.OneMinusSrcColorFactor ) return _gl.ONE_MINUS_SRC_COLOR;\r\n\t\t\tif ( p === THREE.SrcAlphaFactor ) return _gl.SRC_ALPHA;\r\n\t\t\tif ( p === THREE.OneMinusSrcAlphaFactor ) return _gl.ONE_MINUS_SRC_ALPHA;\r\n\t\t\tif ( p === THREE.DstAlphaFactor ) return _gl.DST_ALPHA;\r\n\t\t\tif ( p === THREE.OneMinusDstAlphaFactor ) return _gl.ONE_MINUS_DST_ALPHA;\r\n\t\r\n\t\t\tif ( p === THREE.DstColorFactor ) return _gl.DST_COLOR;\r\n\t\t\tif ( p === THREE.OneMinusDstColorFactor ) return _gl.ONE_MINUS_DST_COLOR;\r\n\t\t\tif ( p === THREE.SrcAlphaSaturateFactor ) return _gl.SRC_ALPHA_SATURATE;\r\n\t\r\n\t\t\textension = extensions.get( 'WEBGL_compressed_texture_s3tc' );\r\n\t\r\n\t\t\tif ( extension !== null ) {\r\n\t\r\n\t\t\t\tif ( p === THREE.RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;\r\n\t\t\t\tif ( p === THREE.RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;\r\n\t\t\t\tif ( p === THREE.RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;\r\n\t\t\t\tif ( p === THREE.RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\textension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );\r\n\t\r\n\t\t\tif ( extension !== null ) {\r\n\t\r\n\t\t\t\tif ( p === THREE.RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;\r\n\t\t\t\tif ( p === THREE.RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;\r\n\t\t\t\tif ( p === THREE.RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;\r\n\t\t\t\tif ( p === THREE.RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\textension = extensions.get( 'EXT_blend_minmax' );\r\n\t\r\n\t\t\tif ( extension !== null ) {\r\n\t\r\n\t\t\t\tif ( p === THREE.MinEquation ) return extension.MIN_EXT;\r\n\t\t\t\tif ( p === THREE.MaxEquation ) return extension.MAX_EXT;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn 0;\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// Allocations\r\n\t\r\n\t\tfunction allocateBones ( object ) {\r\n\t\r\n\t\t\tif ( _supportsBoneTextures && object && object.skeleton && object.skeleton.useVertexTexture ) {\r\n\t\r\n\t\t\t\treturn 1024;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\t// default for when object is not specified\r\n\t\t\t\t// ( for example when prebuilding shader\r\n\t\t\t\t//   to be used with multiple objects )\r\n\t\t\t\t//\r\n\t\t\t\t//  - leave some extra space for other uniforms\r\n\t\t\t\t//  - limit here is ANGLE's 254 max uniform vectors\r\n\t\t\t\t//    (up to 54 should be safe)\r\n\t\r\n\t\t\t\tvar nVertexUniforms = _gl.getParameter( _gl.MAX_VERTEX_UNIFORM_VECTORS );\r\n\t\t\t\tvar nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );\r\n\t\r\n\t\t\t\tvar maxBones = nVertexMatrices;\r\n\t\r\n\t\t\t\tif ( object !== undefined && object instanceof THREE.SkinnedMesh ) {\r\n\t\r\n\t\t\t\t\tmaxBones = Math.min( object.skeleton.bones.length, maxBones );\r\n\t\r\n\t\t\t\t\tif ( maxBones < object.skeleton.bones.length ) {\r\n\t\r\n\t\t\t\t\t\tTHREE.warn( 'WebGLRenderer: too many bones - ' + object.skeleton.bones.length + ', this GPU supports just ' + maxBones + ' (try OpenGL instead of ANGLE)' );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn maxBones;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction allocateLights( lights ) {\r\n\t\r\n\t\t\tvar dirLights = 0;\r\n\t\t\tvar pointLights = 0;\r\n\t\t\tvar spotLights = 0;\r\n\t\t\tvar hemiLights = 0;\r\n\t\r\n\t\t\tfor ( var l = 0, ll = lights.length; l < ll; l ++ ) {\r\n\t\r\n\t\t\t\tvar light = lights[ l ];\r\n\t\r\n\t\t\t\tif ( light.onlyShadow || light.visible === false ) continue;\r\n\t\r\n\t\t\t\tif ( light instanceof THREE.DirectionalLight ) dirLights ++;\r\n\t\t\t\tif ( light instanceof THREE.PointLight ) pointLights ++;\r\n\t\t\t\tif ( light instanceof THREE.SpotLight ) spotLights ++;\r\n\t\t\t\tif ( light instanceof THREE.HemisphereLight ) hemiLights ++;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn { 'directional': dirLights, 'point': pointLights, 'spot': spotLights, 'hemi': hemiLights };\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction allocateShadows( lights ) {\r\n\t\r\n\t\t\tvar maxShadows = 0;\r\n\t\r\n\t\t\tfor ( var l = 0, ll = lights.length; l < ll; l ++ ) {\r\n\t\r\n\t\t\t\tvar light = lights[ l ];\r\n\t\r\n\t\t\t\tif ( ! light.castShadow ) continue;\r\n\t\r\n\t\t\t\tif ( light instanceof THREE.SpotLight ) maxShadows ++;\r\n\t\t\t\tif ( light instanceof THREE.DirectionalLight && ! light.shadowCascade ) maxShadows ++;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn maxShadows;\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// DEPRECATED\r\n\t\r\n\t\tthis.initMaterial = function () {\r\n\t\r\n\t\t\tTHREE.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.addPrePlugin = function () {\r\n\t\r\n\t\t\tTHREE.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.addPostPlugin = function () {\r\n\t\r\n\t\t\tTHREE.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.updateShadowMap = function () {\r\n\t\r\n\t\t\tTHREE.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );\r\n\t\r\n\t\t};\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/renderers/WebGLRenderTarget.js\r\n\t\r\n\t/**\r\n\t * @author szimek / https://github.com/szimek/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.WebGLRenderTarget = function ( width, height, options ) {\r\n\t\r\n\t\tthis.width = width;\r\n\t\tthis.height = height;\r\n\t\r\n\t\toptions = options || {};\r\n\t\r\n\t\tthis.wrapS = options.wrapS !== undefined ? options.wrapS : THREE.ClampToEdgeWrapping;\r\n\t\tthis.wrapT = options.wrapT !== undefined ? options.wrapT : THREE.ClampToEdgeWrapping;\r\n\t\r\n\t\tthis.magFilter = options.magFilter !== undefined ? options.magFilter : THREE.LinearFilter;\r\n\t\tthis.minFilter = options.minFilter !== undefined ? options.minFilter : THREE.LinearMipMapLinearFilter;\r\n\t\r\n\t\tthis.anisotropy = options.anisotropy !== undefined ? options.anisotropy : 1;\r\n\t\r\n\t\tthis.offset = new THREE.Vector2( 0, 0 );\r\n\t\tthis.repeat = new THREE.Vector2( 1, 1 );\r\n\t\r\n\t\tthis.format = options.format !== undefined ? options.format : THREE.RGBAFormat;\r\n\t\tthis.type = options.type !== undefined ? options.type : THREE.UnsignedByteType;\r\n\t\r\n\t\tthis.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;\r\n\t\tthis.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;\r\n\t\r\n\t\tthis.generateMipmaps = true;\r\n\t\r\n\t\tthis.shareDepthFrom = options.shareDepthFrom !== undefined ? options.shareDepthFrom : null;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.WebGLRenderTarget.prototype = {\r\n\t\r\n\t\tconstructor: THREE.WebGLRenderTarget,\r\n\t\r\n\t\tsetSize: function ( width, height ) {\r\n\t\r\n\t\t\tthis.width = width;\r\n\t\t\tthis.height = height;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\tvar tmp = new THREE.WebGLRenderTarget( this.width, this.height );\r\n\t\r\n\t\t\ttmp.wrapS = this.wrapS;\r\n\t\t\ttmp.wrapT = this.wrapT;\r\n\t\r\n\t\t\ttmp.magFilter = this.magFilter;\r\n\t\t\ttmp.minFilter = this.minFilter;\r\n\t\r\n\t\t\ttmp.anisotropy = this.anisotropy;\r\n\t\r\n\t\t\ttmp.offset.copy( this.offset );\r\n\t\t\ttmp.repeat.copy( this.repeat );\r\n\t\r\n\t\t\ttmp.format = this.format;\r\n\t\t\ttmp.type = this.type;\r\n\t\r\n\t\t\ttmp.depthBuffer = this.depthBuffer;\r\n\t\t\ttmp.stencilBuffer = this.stencilBuffer;\r\n\t\r\n\t\t\ttmp.generateMipmaps = this.generateMipmaps;\r\n\t\r\n\t\t\ttmp.shareDepthFrom = this.shareDepthFrom;\r\n\t\r\n\t\t\treturn tmp;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdispose: function () {\r\n\t\r\n\t\t\tthis.dispatchEvent( { type: 'dispose' } );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.EventDispatcher.prototype.apply( THREE.WebGLRenderTarget.prototype );\r\n\t\r\n\t// File:src/renderers/WebGLRenderTargetCube.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com\r\n\t */\r\n\t\r\n\tTHREE.WebGLRenderTargetCube = function ( width, height, options ) {\r\n\t\r\n\t\tTHREE.WebGLRenderTarget.call( this, width, height, options );\r\n\t\r\n\t\tthis.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.WebGLRenderTargetCube.prototype = Object.create( THREE.WebGLRenderTarget.prototype );\r\n\tTHREE.WebGLRenderTargetCube.prototype.constructor = THREE.WebGLRenderTargetCube;\r\n\t\r\n\t// File:src/renderers/webgl/WebGLExtensions.js\r\n\t\r\n\t/**\r\n\t* @author mrdoob / http://mrdoob.com/\r\n\t*/\r\n\t\r\n\tTHREE.WebGLExtensions = function ( gl ) {\r\n\t\r\n\t\tvar extensions = {};\r\n\t\r\n\t\tthis.get = function ( name ) {\r\n\t\r\n\t\t\tif ( extensions[ name ] !== undefined ) {\r\n\t\r\n\t\t\t\treturn extensions[ name ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar extension;\r\n\t\r\n\t\t\tswitch ( name ) {\r\n\t\r\n\t\t\t\tcase 'EXT_texture_filter_anisotropic':\r\n\t\t\t\t\textension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );\r\n\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\tcase 'WEBGL_compressed_texture_s3tc':\r\n\t\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );\r\n\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\tcase 'WEBGL_compressed_texture_pvrtc':\r\n\t\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );\r\n\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\tdefault:\r\n\t\t\t\t\textension = gl.getExtension( name );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( extension === null ) {\r\n\t\r\n\t\t\t\tTHREE.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\textensions[ name ] = extension;\r\n\t\r\n\t\t\treturn extension;\r\n\t\r\n\t\t};\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/renderers/webgl/WebGLProgram.js\r\n\t\r\n\tTHREE.WebGLProgram = ( function () {\r\n\t\r\n\t\tvar programIdCount = 0;\r\n\t\r\n\t\tvar generateDefines = function ( defines ) {\r\n\t\r\n\t\t\tvar value, chunk, chunks = [];\r\n\t\r\n\t\t\tfor ( var d in defines ) {\r\n\t\r\n\t\t\t\tvalue = defines[ d ];\r\n\t\t\t\tif ( value === false ) continue;\r\n\t\r\n\t\t\t\tchunk = '#define ' + d + ' ' + value;\r\n\t\t\t\tchunks.push( chunk );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn chunks.join( '\\n' );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tvar cacheUniformLocations = function ( gl, program, identifiers ) {\r\n\t\r\n\t\t\tvar uniforms = {};\r\n\t\r\n\t\t\tfor ( var i = 0, l = identifiers.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tvar id = identifiers[ i ];\r\n\t\t\t\tuniforms[ id ] = gl.getUniformLocation( program, id );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn uniforms;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tvar cacheAttributeLocations = function ( gl, program, identifiers ) {\r\n\t\r\n\t\t\tvar attributes = {};\r\n\t\r\n\t\t\tfor ( var i = 0, l = identifiers.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tvar id = identifiers[ i ];\r\n\t\t\t\tattributes[ id ] = gl.getAttribLocation( program, id );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn attributes;\r\n\t\r\n\t\t};\r\n\t\r\n\t\treturn function ( renderer, code, material, parameters ) {\r\n\t\r\n\t\t\tvar _this = renderer;\r\n\t\t\tvar _gl = _this.context;\r\n\t\r\n\t\t\tvar defines = material.defines;\r\n\t\t\tvar uniforms = material.__webglShader.uniforms;\r\n\t\t\tvar attributes = material.attributes;\r\n\t\r\n\t\t\tvar vertexShader = material.__webglShader.vertexShader;\r\n\t\t\tvar fragmentShader = material.__webglShader.fragmentShader;\r\n\t\r\n\t\t\tvar index0AttributeName = material.index0AttributeName;\r\n\t\r\n\t\t\tif ( index0AttributeName === undefined && parameters.morphTargets === true ) {\r\n\t\r\n\t\t\t\t// programs with morphTargets displace position out of attribute 0\r\n\t\r\n\t\t\t\tindex0AttributeName = 'position';\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';\r\n\t\r\n\t\t\tif ( parameters.shadowMapType === THREE.PCFShadowMap ) {\r\n\t\r\n\t\t\t\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';\r\n\t\r\n\t\t\t} else if ( parameters.shadowMapType === THREE.PCFSoftShadowMap ) {\r\n\t\r\n\t\t\t\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar envMapTypeDefine = 'ENVMAP_TYPE_CUBE';\r\n\t\t\tvar envMapModeDefine = 'ENVMAP_MODE_REFLECTION';\r\n\t\t\tvar envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';\r\n\t\r\n\t\t\tif ( parameters.envMap ) {\r\n\t\r\n\t\t\t\tswitch ( material.envMap.mapping ) {\r\n\t\r\n\t\t\t\t\tcase THREE.CubeReflectionMapping:\r\n\t\t\t\t\tcase THREE.CubeRefractionMapping:\r\n\t\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_CUBE';\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase THREE.EquirectangularReflectionMapping:\r\n\t\t\t\t\tcase THREE.EquirectangularRefractionMapping:\r\n\t\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase THREE.SphericalReflectionMapping:\r\n\t\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_SPHERE';\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tswitch ( material.envMap.mapping ) {\r\n\t\r\n\t\t\t\t\tcase THREE.CubeRefractionMapping:\r\n\t\t\t\t\tcase THREE.EquirectangularRefractionMapping:\r\n\t\t\t\t\t\tenvMapModeDefine = 'ENVMAP_MODE_REFRACTION';\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tswitch ( material.combine ) {\r\n\t\r\n\t\t\t\t\tcase THREE.MultiplyOperation:\r\n\t\t\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase THREE.MixOperation:\r\n\t\t\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_MIX';\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase THREE.AddOperation:\r\n\t\t\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_ADD';\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;\r\n\t\r\n\t\t\t// console.log( 'building new program ' );\r\n\t\r\n\t\t\t//\r\n\t\r\n\t\t\tvar customDefines = generateDefines( defines );\r\n\t\r\n\t\t\t//\r\n\t\r\n\t\t\tvar program = _gl.createProgram();\r\n\t\r\n\t\t\tvar prefix_vertex, prefix_fragment;\r\n\t\r\n\t\t\tif ( material instanceof THREE.RawShaderMaterial ) {\r\n\t\r\n\t\t\t\tprefix_vertex = '';\r\n\t\t\t\tprefix_fragment = '';\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tprefix_vertex = [\r\n\t\r\n\t\t\t\t\t'precision ' + parameters.precision + ' float;',\r\n\t\t\t\t\t'precision ' + parameters.precision + ' int;',\r\n\t\r\n\t\t\t\t\tcustomDefines,\r\n\t\r\n\t\t\t\t\tparameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',\r\n\t\r\n\t\t\t\t\t_this.gammaInput ? '#define GAMMA_INPUT' : '',\r\n\t\t\t\t\t_this.gammaOutput ? '#define GAMMA_OUTPUT' : '',\r\n\t\t\t\t\t'#define GAMMA_FACTOR ' + gammaFactorDefine,\r\n\t\r\n\t\t\t\t\t'#define MAX_DIR_LIGHTS ' + parameters.maxDirLights,\r\n\t\t\t\t\t'#define MAX_POINT_LIGHTS ' + parameters.maxPointLights,\r\n\t\t\t\t\t'#define MAX_SPOT_LIGHTS ' + parameters.maxSpotLights,\r\n\t\t\t\t\t'#define MAX_HEMI_LIGHTS ' + parameters.maxHemiLights,\r\n\t\r\n\t\t\t\t\t'#define MAX_SHADOWS ' + parameters.maxShadows,\r\n\t\r\n\t\t\t\t\t'#define MAX_BONES ' + parameters.maxBones,\r\n\t\r\n\t\t\t\t\tparameters.map ? '#define USE_MAP' : '',\r\n\t\t\t\t\tparameters.envMap ? '#define USE_ENVMAP' : '',\r\n\t\t\t\t\tparameters.envMap ? '#define ' + envMapModeDefine : '',\r\n\t\t\t\t\tparameters.lightMap ? '#define USE_LIGHTMAP' : '',\r\n\t\t\t\t\tparameters.bumpMap ? '#define USE_BUMPMAP' : '',\r\n\t\t\t\t\tparameters.normalMap ? '#define USE_NORMALMAP' : '',\r\n\t\t\t\t\tparameters.specularMap ? '#define USE_SPECULARMAP' : '',\r\n\t\t\t\t\tparameters.alphaMap ? '#define USE_ALPHAMAP' : '',\r\n\t\t\t\t\tparameters.vertexColors ? '#define USE_COLOR' : '',\r\n\t\r\n\t\t\t\t\tparameters.flatShading ? '#define FLAT_SHADED': '',\r\n\t\r\n\t\t\t\t\tparameters.skinning ? '#define USE_SKINNING' : '',\r\n\t\t\t\t\tparameters.useVertexTexture ? '#define BONE_TEXTURE' : '',\r\n\t\r\n\t\t\t\t\tparameters.morphTargets ? '#define USE_MORPHTARGETS' : '',\r\n\t\t\t\t\tparameters.morphNormals ? '#define USE_MORPHNORMALS' : '',\r\n\t\t\t\t\tparameters.wrapAround ? '#define WRAP_AROUND' : '',\r\n\t\t\t\t\tparameters.doubleSided ? '#define DOUBLE_SIDED' : '',\r\n\t\t\t\t\tparameters.flipSided ? '#define FLIP_SIDED' : '',\r\n\t\r\n\t\t\t\t\tparameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',\r\n\t\t\t\t\tparameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',\r\n\t\t\t\t\tparameters.shadowMapDebug ? '#define SHADOWMAP_DEBUG' : '',\r\n\t\t\t\t\tparameters.shadowMapCascade ? '#define SHADOWMAP_CASCADE' : '',\r\n\t\r\n\t\t\t\t\tparameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',\r\n\t\r\n\t\t\t\t\tparameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',\r\n\t\t\t\t\t//_this._glExtensionFragDepth ? '#define USE_LOGDEPTHBUF_EXT' : '',\r\n\t\r\n\t\r\n\t\t\t\t\t'uniform mat4 modelMatrix;',\r\n\t\t\t\t\t'uniform mat4 modelViewMatrix;',\r\n\t\t\t\t\t'uniform mat4 projectionMatrix;',\r\n\t\t\t\t\t'uniform mat4 viewMatrix;',\r\n\t\t\t\t\t'uniform mat3 normalMatrix;',\r\n\t\t\t\t\t'uniform vec3 cameraPosition;',\r\n\t\r\n\t\t\t\t\t'attribute vec3 position;',\r\n\t\t\t\t\t'attribute vec3 normal;',\r\n\t\t\t\t\t'attribute vec2 uv;',\r\n\t\t\t\t\t'attribute vec2 uv2;',\r\n\t\r\n\t\t\t\t\t'#ifdef USE_COLOR',\r\n\t\r\n\t\t\t\t\t'\tattribute vec3 color;',\r\n\t\r\n\t\t\t\t\t'#endif',\r\n\t\r\n\t\t\t\t\t'#ifdef USE_MORPHTARGETS',\r\n\t\r\n\t\t\t\t\t'\tattribute vec3 morphTarget0;',\r\n\t\t\t\t\t'\tattribute vec3 morphTarget1;',\r\n\t\t\t\t\t'\tattribute vec3 morphTarget2;',\r\n\t\t\t\t\t'\tattribute vec3 morphTarget3;',\r\n\t\r\n\t\t\t\t\t'\t#ifdef USE_MORPHNORMALS',\r\n\t\r\n\t\t\t\t\t'\t\tattribute vec3 morphNormal0;',\r\n\t\t\t\t\t'\t\tattribute vec3 morphNormal1;',\r\n\t\t\t\t\t'\t\tattribute vec3 morphNormal2;',\r\n\t\t\t\t\t'\t\tattribute vec3 morphNormal3;',\r\n\t\r\n\t\t\t\t\t'\t#else',\r\n\t\r\n\t\t\t\t\t'\t\tattribute vec3 morphTarget4;',\r\n\t\t\t\t\t'\t\tattribute vec3 morphTarget5;',\r\n\t\t\t\t\t'\t\tattribute vec3 morphTarget6;',\r\n\t\t\t\t\t'\t\tattribute vec3 morphTarget7;',\r\n\t\r\n\t\t\t\t\t'\t#endif',\r\n\t\r\n\t\t\t\t\t'#endif',\r\n\t\r\n\t\t\t\t\t'#ifdef USE_SKINNING',\r\n\t\r\n\t\t\t\t\t'\tattribute vec4 skinIndex;',\r\n\t\t\t\t\t'\tattribute vec4 skinWeight;',\r\n\t\r\n\t\t\t\t\t'#endif',\r\n\t\r\n\t\t\t\t\t''\r\n\t\r\n\t\t\t\t].join( '\\n' );\r\n\t\r\n\t\t\t\tprefix_fragment = [\r\n\t\r\n\t\t\t\t\t'precision ' + parameters.precision + ' float;',\r\n\t\t\t\t\t'precision ' + parameters.precision + ' int;',\r\n\t\r\n\t\t\t\t\t( parameters.bumpMap || parameters.normalMap || parameters.flatShading ) ? '#extension GL_OES_standard_derivatives : enable' : '',\r\n\t\r\n\t\t\t\t\tcustomDefines,\r\n\t\r\n\t\t\t\t\t'#define MAX_DIR_LIGHTS ' + parameters.maxDirLights,\r\n\t\t\t\t\t'#define MAX_POINT_LIGHTS ' + parameters.maxPointLights,\r\n\t\t\t\t\t'#define MAX_SPOT_LIGHTS ' + parameters.maxSpotLights,\r\n\t\t\t\t\t'#define MAX_HEMI_LIGHTS ' + parameters.maxHemiLights,\r\n\t\r\n\t\t\t\t\t'#define MAX_SHADOWS ' + parameters.maxShadows,\r\n\t\r\n\t\t\t\t\tparameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '',\r\n\t\r\n\t\t\t\t\t_this.gammaInput ? '#define GAMMA_INPUT' : '',\r\n\t\t\t\t\t_this.gammaOutput ? '#define GAMMA_OUTPUT' : '',\r\n\t\t\t\t\t'#define GAMMA_FACTOR ' + gammaFactorDefine,\r\n\t\r\n\t\t\t\t\t( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',\r\n\t\t\t\t\t( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',\r\n\t\r\n\t\t\t\t\tparameters.map ? '#define USE_MAP' : '',\r\n\t\t\t\t\tparameters.envMap ? '#define USE_ENVMAP' : '',\r\n\t\t\t\t\tparameters.envMap ? '#define ' + envMapTypeDefine : '',\r\n\t\t\t\t\tparameters.envMap ? '#define ' + envMapModeDefine : '',\r\n\t\t\t\t\tparameters.envMap ? '#define ' + envMapBlendingDefine : '',\r\n\t\t\t\t\tparameters.lightMap ? '#define USE_LIGHTMAP' : '',\r\n\t\t\t\t\tparameters.bumpMap ? '#define USE_BUMPMAP' : '',\r\n\t\t\t\t\tparameters.normalMap ? '#define USE_NORMALMAP' : '',\r\n\t\t\t\t\tparameters.specularMap ? '#define USE_SPECULARMAP' : '',\r\n\t\t\t\t\tparameters.alphaMap ? '#define USE_ALPHAMAP' : '',\r\n\t\t\t\t\tparameters.vertexColors ? '#define USE_COLOR' : '',\r\n\t\r\n\t\t\t\t\tparameters.flatShading ? '#define FLAT_SHADED': '',\r\n\t\r\n\t\t\t\t\tparameters.metal ? '#define METAL' : '',\r\n\t\t\t\t\tparameters.wrapAround ? '#define WRAP_AROUND' : '',\r\n\t\t\t\t\tparameters.doubleSided ? '#define DOUBLE_SIDED' : '',\r\n\t\t\t\t\tparameters.flipSided ? '#define FLIP_SIDED' : '',\r\n\t\r\n\t\t\t\t\tparameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',\r\n\t\t\t\t\tparameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',\r\n\t\t\t\t\tparameters.shadowMapDebug ? '#define SHADOWMAP_DEBUG' : '',\r\n\t\t\t\t\tparameters.shadowMapCascade ? '#define SHADOWMAP_CASCADE' : '',\r\n\t\r\n\t\t\t\t\tparameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',\r\n\t\t\t\t\t//_this._glExtensionFragDepth ? '#define USE_LOGDEPTHBUF_EXT' : '',\r\n\t\r\n\t\t\t\t\t'uniform mat4 viewMatrix;',\r\n\t\t\t\t\t'uniform vec3 cameraPosition;',\r\n\t\t\t\t\t''\r\n\t\r\n\t\t\t\t].join( '\\n' );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar glVertexShader = new THREE.WebGLShader( _gl, _gl.VERTEX_SHADER, prefix_vertex + vertexShader );\r\n\t\t\tvar glFragmentShader = new THREE.WebGLShader( _gl, _gl.FRAGMENT_SHADER, prefix_fragment + fragmentShader );\r\n\t\r\n\t\t\t_gl.attachShader( program, glVertexShader );\r\n\t\t\t_gl.attachShader( program, glFragmentShader );\r\n\t\r\n\t\t\tif ( index0AttributeName !== undefined ) {\r\n\t\r\n\t\t\t\t// Force a particular attribute to index 0.\r\n\t\t\t\t// because potentially expensive emulation is done by browser if attribute 0 is disabled.\r\n\t\t\t\t// And, color, for example is often automatically bound to index 0 so disabling it\r\n\t\r\n\t\t\t\t_gl.bindAttribLocation( program, 0, index0AttributeName );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t_gl.linkProgram( program );\r\n\t\r\n\t\t\tvar programLogInfo = _gl.getProgramInfoLog( program );\r\n\t\r\n\t\t\tif ( _gl.getProgramParameter( program, _gl.LINK_STATUS ) === false ) {\r\n\t\r\n\t\t\t\tTHREE.error( 'THREE.WebGLProgram: shader error: ' + _gl.getError(), 'gl.VALIDATE_STATUS', _gl.getProgramParameter( program, _gl.VALIDATE_STATUS ), 'gl.getPRogramInfoLog', programLogInfo );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( programLogInfo !== '' ) {\r\n\t\r\n\t\t\t\tTHREE.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()' + programLogInfo );\r\n\t\t\t\t// THREE.warn( _gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glVertexShader ) );\r\n\t\t\t\t// THREE.warn( _gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glFragmentShader ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// clean up\r\n\t\r\n\t\t\t_gl.deleteShader( glVertexShader );\r\n\t\t\t_gl.deleteShader( glFragmentShader );\r\n\t\r\n\t\t\t// cache uniform locations\r\n\t\r\n\t\t\tvar identifiers = [\r\n\t\r\n\t\t\t\t'viewMatrix',\r\n\t\t\t\t'modelViewMatrix',\r\n\t\t\t\t'projectionMatrix',\r\n\t\t\t\t'normalMatrix',\r\n\t\t\t\t'modelMatrix',\r\n\t\t\t\t'cameraPosition',\r\n\t\t\t\t'morphTargetInfluences',\r\n\t\t\t\t'bindMatrix',\r\n\t\t\t\t'bindMatrixInverse'\r\n\t\r\n\t\t\t];\r\n\t\r\n\t\t\tif ( parameters.useVertexTexture ) {\r\n\t\r\n\t\t\t\tidentifiers.push( 'boneTexture' );\r\n\t\t\t\tidentifiers.push( 'boneTextureWidth' );\r\n\t\t\t\tidentifiers.push( 'boneTextureHeight' );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tidentifiers.push( 'boneGlobalMatrices' );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( parameters.logarithmicDepthBuffer ) {\r\n\t\r\n\t\t\t\tidentifiers.push('logDepthBufFC');\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\r\n\t\t\tfor ( var u in uniforms ) {\r\n\t\r\n\t\t\t\tidentifiers.push( u );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.uniforms = cacheUniformLocations( _gl, program, identifiers );\r\n\t\r\n\t\t\t// cache attributes locations\r\n\t\r\n\t\t\tidentifiers = [\r\n\t\r\n\t\t\t\t'position',\r\n\t\t\t\t'normal',\r\n\t\t\t\t'uv',\r\n\t\t\t\t'uv2',\r\n\t\t\t\t'tangent',\r\n\t\t\t\t'color',\r\n\t\t\t\t'skinIndex',\r\n\t\t\t\t'skinWeight',\r\n\t\t\t\t'lineDistance'\r\n\t\r\n\t\t\t];\r\n\t\r\n\t\t\tfor ( var i = 0; i < parameters.maxMorphTargets; i ++ ) {\r\n\t\r\n\t\t\t\tidentifiers.push( 'morphTarget' + i );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfor ( var i = 0; i < parameters.maxMorphNormals; i ++ ) {\r\n\t\r\n\t\t\t\tidentifiers.push( 'morphNormal' + i );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfor ( var a in attributes ) {\r\n\t\r\n\t\t\t\tidentifiers.push( a );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.attributes = cacheAttributeLocations( _gl, program, identifiers );\r\n\t\t\tthis.attributesKeys = Object.keys( this.attributes );\r\n\t\r\n\t\t\t//\r\n\t\r\n\t\t\tthis.id = programIdCount ++;\r\n\t\t\tthis.code = code;\r\n\t\t\tthis.usedTimes = 1;\r\n\t\t\tthis.program = program;\r\n\t\t\tthis.vertexShader = glVertexShader;\r\n\t\t\tthis.fragmentShader = glFragmentShader;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t};\r\n\t\r\n\t} )();\r\n\t\r\n\t// File:src/renderers/webgl/WebGLShader.js\r\n\t\r\n\tTHREE.WebGLShader = ( function () {\r\n\t\r\n\t\tvar addLineNumbers = function ( string ) {\r\n\t\r\n\t\t\tvar lines = string.split( '\\n' );\r\n\t\r\n\t\t\tfor ( var i = 0; i < lines.length; i ++ ) {\r\n\t\r\n\t\t\t\tlines[ i ] = ( i + 1 ) + ': ' + lines[ i ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn lines.join( '\\n' );\r\n\t\r\n\t\t};\r\n\t\r\n\t\treturn function ( gl, type, string ) {\r\n\t\r\n\t\t\tvar shader = gl.createShader( type ); \r\n\t\r\n\t\t\tgl.shaderSource( shader, string );\r\n\t\t\tgl.compileShader( shader );\r\n\t\r\n\t\t\tif ( gl.getShaderParameter( shader, gl.COMPILE_STATUS ) === false ) {\r\n\t\r\n\t\t\t\tTHREE.error( 'THREE.WebGLShader: Shader couldn\\'t compile.' );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( gl.getShaderInfoLog( shader ) !== '' ) {\r\n\t\r\n\t\t\t\tTHREE.warn( 'THREE.WebGLShader: gl.getShaderInfoLog()', gl.getShaderInfoLog( shader ), addLineNumbers( string ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// --enable-privileged-webgl-extension\r\n\t\t\t// console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );\r\n\t\r\n\t\t\treturn shader;\r\n\t\r\n\t\t};\r\n\t\r\n\t} )();\r\n\t\r\n\t// File:src/renderers/webgl/WebGLState.js\r\n\t\r\n\t/**\r\n\t* @author mrdoob / http://mrdoob.com/\r\n\t*/\r\n\t\r\n\tTHREE.WebGLState = function ( gl, paramThreeToGL ) {\r\n\t\r\n\t\tvar newAttributes = new Uint8Array( 16 );\r\n\t\tvar enabledAttributes = new Uint8Array( 16 );\r\n\t\r\n\t\tvar currentBlending = null;\r\n\t\tvar currentBlendEquation = null;\r\n\t\tvar currentBlendSrc = null;\r\n\t\tvar currentBlendDst = null;\r\n\t\tvar currentBlendEquationAlpha = null;\r\n\t\tvar currentBlendSrcAlpha = null;\r\n\t\tvar currentBlendDstAlpha = null;\r\n\t\r\n\t\tvar currentDepthTest = null;\r\n\t\tvar currentDepthWrite = null;\r\n\t\r\n\t\tvar currentColorWrite = null;\r\n\t\r\n\t\tvar currentDoubleSided = null;\r\n\t\tvar currentFlipSided = null;\r\n\t\r\n\t\tvar currentLineWidth = null;\r\n\t\r\n\t\tvar currentPolygonOffset = null;\r\n\t\tvar currentPolygonOffsetFactor = null;\r\n\t\tvar currentPolygonOffsetUnits = null;\r\n\t\r\n\t\tthis.initAttributes = function () {\r\n\t\r\n\t\t\tfor ( var i = 0, l = newAttributes.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tnewAttributes[ i ] = 0;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.enableAttribute = function ( attribute ) {\r\n\t\r\n\t\t\tnewAttributes[ attribute ] = 1;\r\n\t\r\n\t\t\tif ( enabledAttributes[ attribute ] === 0 ) {\r\n\t\r\n\t\t\t\tgl.enableVertexAttribArray( attribute );\r\n\t\t\t\tenabledAttributes[ attribute ] = 1;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.disableUnusedAttributes = function () {\r\n\t\r\n\t\t\tfor ( var i = 0, l = enabledAttributes.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tif ( enabledAttributes[ i ] !== newAttributes[ i ] ) {\r\n\t\r\n\t\t\t\t\tgl.disableVertexAttribArray( i );\r\n\t\t\t\t\tenabledAttributes[ i ] = 0;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setBlending = function ( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha ) {\r\n\t\r\n\t\t\tif ( blending !== currentBlending ) {\r\n\t\r\n\t\t\t\tif ( blending === THREE.NoBlending ) {\r\n\t\r\n\t\t\t\t\tgl.disable( gl.BLEND );\r\n\t\r\n\t\t\t\t} else if ( blending === THREE.AdditiveBlending ) {\r\n\t\r\n\t\t\t\t\tgl.enable( gl.BLEND );\r\n\t\t\t\t\tgl.blendEquation( gl.FUNC_ADD );\r\n\t\t\t\t\tgl.blendFunc( gl.SRC_ALPHA, gl.ONE );\r\n\t\r\n\t\t\t\t} else if ( blending === THREE.SubtractiveBlending ) {\r\n\t\r\n\t\t\t\t\t// TODO: Find blendFuncSeparate() combination\r\n\t\t\t\t\tgl.enable( gl.BLEND );\r\n\t\t\t\t\tgl.blendEquation( gl.FUNC_ADD );\r\n\t\t\t\t\tgl.blendFunc( gl.ZERO, gl.ONE_MINUS_SRC_COLOR );\r\n\t\r\n\t\t\t\t} else if ( blending === THREE.MultiplyBlending ) {\r\n\t\r\n\t\t\t\t\t// TODO: Find blendFuncSeparate() combination\r\n\t\t\t\t\tgl.enable( gl.BLEND );\r\n\t\t\t\t\tgl.blendEquation( gl.FUNC_ADD );\r\n\t\t\t\t\tgl.blendFunc( gl.ZERO, gl.SRC_COLOR );\r\n\t\r\n\t\t\t\t} else if ( blending === THREE.CustomBlending ) {\r\n\t\r\n\t\t\t\t\tgl.enable( gl.BLEND );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tgl.enable( gl.BLEND );\r\n\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\r\n\t\t\t\t\tgl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tcurrentBlending = blending;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( blending === THREE.CustomBlending ) {\r\n\t\r\n\t\t\t\tblendEquationAlpha = blendEquationAlpha || blendEquation;\r\n\t\t\t\tblendSrcAlpha = blendSrcAlpha || blendSrc;\r\n\t\t\t\tblendDstAlpha = blendDstAlpha || blendDst;\r\n\t\r\n\t\t\t\tif ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {\r\n\t\r\n\t\t\t\t\tgl.blendEquationSeparate( paramThreeToGL( blendEquation ), paramThreeToGL( blendEquationAlpha ) );\r\n\t\r\n\t\t\t\t\tcurrentBlendEquation = blendEquation;\r\n\t\t\t\t\tcurrentBlendEquationAlpha = blendEquationAlpha;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {\r\n\t\r\n\t\t\t\t\tgl.blendFuncSeparate( paramThreeToGL( blendSrc ), paramThreeToGL( blendDst ), paramThreeToGL( blendSrcAlpha ), paramThreeToGL( blendDstAlpha ) );\r\n\t\r\n\t\t\t\t\tcurrentBlendSrc = blendSrc;\r\n\t\t\t\t\tcurrentBlendDst = blendDst;\r\n\t\t\t\t\tcurrentBlendSrcAlpha = blendSrcAlpha;\r\n\t\t\t\t\tcurrentBlendDstAlpha = blendDstAlpha;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tcurrentBlendEquation = null;\r\n\t\t\t\tcurrentBlendSrc = null;\r\n\t\t\t\tcurrentBlendDst = null;\r\n\t\t\t\tcurrentBlendEquationAlpha = null;\r\n\t\t\t\tcurrentBlendSrcAlpha = null;\r\n\t\t\t\tcurrentBlendDstAlpha = null;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setDepthTest = function ( depthTest ) {\r\n\t\r\n\t\t\tif ( currentDepthTest !== depthTest ) {\r\n\t\r\n\t\t\t\tif ( depthTest ) {\r\n\t\r\n\t\t\t\t\tgl.enable( gl.DEPTH_TEST );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tgl.disable( gl.DEPTH_TEST );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tcurrentDepthTest = depthTest;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setDepthWrite = function ( depthWrite ) {\r\n\t\r\n\t\t\tif ( currentDepthWrite !== depthWrite ) {\r\n\t\r\n\t\t\t\tgl.depthMask( depthWrite );\r\n\t\t\t\tcurrentDepthWrite = depthWrite;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setColorWrite = function ( colorWrite ) {\r\n\t\r\n\t\t\tif ( currentColorWrite !== colorWrite ) {\r\n\t\r\n\t\t\t\tgl.colorMask( colorWrite, colorWrite, colorWrite, colorWrite );\r\n\t\t\t\tcurrentColorWrite = colorWrite;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setDoubleSided = function ( doubleSided ) {\r\n\t\r\n\t\t\tif ( currentDoubleSided !== doubleSided ) {\r\n\t\r\n\t\t\t\tif ( doubleSided ) {\r\n\t\r\n\t\t\t\t\tgl.disable( gl.CULL_FACE );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tgl.enable( gl.CULL_FACE );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tcurrentDoubleSided = doubleSided;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setFlipSided = function ( flipSided ) {\r\n\t\r\n\t\t\tif ( currentFlipSided !== flipSided ) {\r\n\t\r\n\t\t\t\tif ( flipSided ) {\r\n\t\r\n\t\t\t\t\tgl.frontFace( gl.CW );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tgl.frontFace( gl.CCW );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tcurrentFlipSided = flipSided;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setLineWidth = function ( width ) {\r\n\t\r\n\t\t\tif ( width !== currentLineWidth ) {\r\n\t\r\n\t\t\t\tgl.lineWidth( width );\r\n\t\r\n\t\t\t\tcurrentLineWidth = width;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setPolygonOffset = function ( polygonoffset, factor, units ) {\r\n\t\r\n\t\t\tif ( currentPolygonOffset !== polygonoffset ) {\r\n\t\r\n\t\t\t\tif ( polygonoffset ) {\r\n\t\r\n\t\t\t\t\tgl.enable( gl.POLYGON_OFFSET_FILL );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tgl.disable( gl.POLYGON_OFFSET_FILL );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tcurrentPolygonOffset = polygonoffset;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( polygonoffset && ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) ) {\r\n\t\r\n\t\t\t\tgl.polygonOffset( factor, units );\r\n\t\r\n\t\t\t\tcurrentPolygonOffsetFactor = factor;\r\n\t\t\t\tcurrentPolygonOffsetUnits = units;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.reset = function () {\r\n\t\r\n\t\t\tfor ( var i = 0; i < enabledAttributes.length; i ++ ) {\r\n\t\r\n\t\t\t\tenabledAttributes[ i ] = 0;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tcurrentBlending = null;\r\n\t\t\tcurrentDepthTest = null;\r\n\t\t\tcurrentDepthWrite = null;\r\n\t\t\tcurrentColorWrite = null;\r\n\t\t\tcurrentDoubleSided = null;\r\n\t\t\tcurrentFlipSided = null;\r\n\t\r\n\t\t};\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/renderers/webgl/plugins/LensFlarePlugin.js\r\n\t\r\n\t/**\r\n\t * @author mikael emtinger / http://gomo.se/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.LensFlarePlugin = function ( renderer, flares ) {\r\n\t\r\n\t\tvar gl = renderer.context;\r\n\t\r\n\t\tvar vertexBuffer, elementBuffer;\r\n\t\tvar program, attributes, uniforms;\r\n\t\tvar hasVertexTexture;\r\n\t\r\n\t\tvar tempTexture, occlusionTexture;\r\n\t\r\n\t\tvar init = function () {\r\n\t\r\n\t\t\tvar vertices = new Float32Array( [\r\n\t\t\t\t-1, -1,  0, 0,\r\n\t\t\t\t 1, -1,  1, 0,\r\n\t\t\t\t 1,  1,  1, 1,\r\n\t\t\t\t-1,  1,  0, 1\r\n\t\t\t] );\r\n\t\r\n\t\t\tvar faces = new Uint16Array( [\r\n\t\t\t\t0, 1, 2,\r\n\t\t\t\t0, 2, 3\r\n\t\t\t] );\r\n\t\r\n\t\t\t// buffers\r\n\t\r\n\t\t\tvertexBuffer     = gl.createBuffer();\r\n\t\t\telementBuffer    = gl.createBuffer();\r\n\t\r\n\t\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\r\n\t\t\tgl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );\r\n\t\r\n\t\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\r\n\t\t\tgl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );\r\n\t\r\n\t\t\t// textures\r\n\t\r\n\t\t\ttempTexture      = gl.createTexture();\r\n\t\t\tocclusionTexture = gl.createTexture();\r\n\t\r\n\t\t\tgl.bindTexture( gl.TEXTURE_2D, tempTexture );\r\n\t\t\tgl.texImage2D( gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null );\r\n\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );\r\n\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );\r\n\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\r\n\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\r\n\t\r\n\t\t\tgl.bindTexture( gl.TEXTURE_2D, occlusionTexture );\r\n\t\t\tgl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null );\r\n\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );\r\n\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );\r\n\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\r\n\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\r\n\t\r\n\t\t\thasVertexTexture = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS ) > 0;\r\n\t\r\n\t\t\tvar shader;\r\n\t\r\n\t\t\tif ( hasVertexTexture ) {\r\n\t\r\n\t\t\t\tshader = {\r\n\t\r\n\t\t\t\t\tvertexShader: [\r\n\t\r\n\t\t\t\t\t\t\"uniform lowp int renderType;\",\r\n\t\r\n\t\t\t\t\t\t\"uniform vec3 screenPosition;\",\r\n\t\t\t\t\t\t\"uniform vec2 scale;\",\r\n\t\t\t\t\t\t\"uniform float rotation;\",\r\n\t\r\n\t\t\t\t\t\t\"uniform sampler2D occlusionMap;\",\r\n\t\r\n\t\t\t\t\t\t\"attribute vec2 position;\",\r\n\t\t\t\t\t\t\"attribute vec2 uv;\",\r\n\t\r\n\t\t\t\t\t\t\"varying vec2 vUV;\",\r\n\t\t\t\t\t\t\"varying float vVisibility;\",\r\n\t\r\n\t\t\t\t\t\t\"void main() {\",\r\n\t\r\n\t\t\t\t\t\t\t\"vUV = uv;\",\r\n\t\r\n\t\t\t\t\t\t\t\"vec2 pos = position;\",\r\n\t\r\n\t\t\t\t\t\t\t\"if( renderType == 2 ) {\",\r\n\t\r\n\t\t\t\t\t\t\t\t\"vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\",\r\n\t\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\",\r\n\t\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\",\r\n\t\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\",\r\n\t\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\",\r\n\t\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\",\r\n\t\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\",\r\n\t\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\",\r\n\t\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\",\r\n\t\r\n\t\t\t\t\t\t\t\t\"vVisibility =        visibility.r / 9.0;\",\r\n\t\t\t\t\t\t\t\t\"vVisibility *= 1.0 - visibility.g / 9.0;\",\r\n\t\t\t\t\t\t\t\t\"vVisibility *=       visibility.b / 9.0;\",\r\n\t\t\t\t\t\t\t\t\"vVisibility *= 1.0 - visibility.a / 9.0;\",\r\n\t\r\n\t\t\t\t\t\t\t\t\"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\",\r\n\t\t\t\t\t\t\t\t\"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\",\r\n\t\r\n\t\t\t\t\t\t\t\"}\",\r\n\t\r\n\t\t\t\t\t\t\t\"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\",\r\n\t\r\n\t\t\t\t\t\t\"}\"\r\n\t\r\n\t\t\t\t\t].join( \"\\n\" ),\r\n\t\r\n\t\t\t\t\tfragmentShader: [\r\n\t\r\n\t\t\t\t\t\t\"uniform lowp int renderType;\",\r\n\t\r\n\t\t\t\t\t\t\"uniform sampler2D map;\",\r\n\t\t\t\t\t\t\"uniform float opacity;\",\r\n\t\t\t\t\t\t\"uniform vec3 color;\",\r\n\t\r\n\t\t\t\t\t\t\"varying vec2 vUV;\",\r\n\t\t\t\t\t\t\"varying float vVisibility;\",\r\n\t\r\n\t\t\t\t\t\t\"void main() {\",\r\n\t\r\n\t\t\t\t\t\t\t// pink square\r\n\t\r\n\t\t\t\t\t\t\t\"if( renderType == 0 ) {\",\r\n\t\r\n\t\t\t\t\t\t\t\t\"gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );\",\r\n\t\r\n\t\t\t\t\t\t\t// restore\r\n\t\r\n\t\t\t\t\t\t\t\"} else if( renderType == 1 ) {\",\r\n\t\r\n\t\t\t\t\t\t\t\t\"gl_FragColor = texture2D( map, vUV );\",\r\n\t\r\n\t\t\t\t\t\t\t// flare\r\n\t\r\n\t\t\t\t\t\t\t\"} else {\",\r\n\t\r\n\t\t\t\t\t\t\t\t\"vec4 texture = texture2D( map, vUV );\",\r\n\t\t\t\t\t\t\t\t\"texture.a *= opacity * vVisibility;\",\r\n\t\t\t\t\t\t\t\t\"gl_FragColor = texture;\",\r\n\t\t\t\t\t\t\t\t\"gl_FragColor.rgb *= color;\",\r\n\t\r\n\t\t\t\t\t\t\t\"}\",\r\n\t\r\n\t\t\t\t\t\t\"}\"\r\n\t\r\n\t\t\t\t\t].join( \"\\n\" )\r\n\t\r\n\t\t\t\t};\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tshader = {\r\n\t\r\n\t\t\t\t\tvertexShader: [\r\n\t\r\n\t\t\t\t\t\t\"uniform lowp int renderType;\",\r\n\t\r\n\t\t\t\t\t\t\"uniform vec3 screenPosition;\",\r\n\t\t\t\t\t\t\"uniform vec2 scale;\",\r\n\t\t\t\t\t\t\"uniform float rotation;\",\r\n\t\r\n\t\t\t\t\t\t\"attribute vec2 position;\",\r\n\t\t\t\t\t\t\"attribute vec2 uv;\",\r\n\t\r\n\t\t\t\t\t\t\"varying vec2 vUV;\",\r\n\t\r\n\t\t\t\t\t\t\"void main() {\",\r\n\t\r\n\t\t\t\t\t\t\t\"vUV = uv;\",\r\n\t\r\n\t\t\t\t\t\t\t\"vec2 pos = position;\",\r\n\t\r\n\t\t\t\t\t\t\t\"if( renderType == 2 ) {\",\r\n\t\r\n\t\t\t\t\t\t\t\t\"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\",\r\n\t\t\t\t\t\t\t\t\"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\",\r\n\t\r\n\t\t\t\t\t\t\t\"}\",\r\n\t\r\n\t\t\t\t\t\t\t\"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\",\r\n\t\r\n\t\t\t\t\t\t\"}\"\r\n\t\r\n\t\t\t\t\t].join( \"\\n\" ),\r\n\t\r\n\t\t\t\t\tfragmentShader: [\r\n\t\r\n\t\t\t\t\t\t\"precision mediump float;\",\r\n\t\r\n\t\t\t\t\t\t\"uniform lowp int renderType;\",\r\n\t\r\n\t\t\t\t\t\t\"uniform sampler2D map;\",\r\n\t\t\t\t\t\t\"uniform sampler2D occlusionMap;\",\r\n\t\t\t\t\t\t\"uniform float opacity;\",\r\n\t\t\t\t\t\t\"uniform vec3 color;\",\r\n\t\r\n\t\t\t\t\t\t\"varying vec2 vUV;\",\r\n\t\r\n\t\t\t\t\t\t\"void main() {\",\r\n\t\r\n\t\t\t\t\t\t\t// pink square\r\n\t\r\n\t\t\t\t\t\t\t\"if( renderType == 0 ) {\",\r\n\t\r\n\t\t\t\t\t\t\t\t\"gl_FragColor = vec4( texture2D( map, vUV ).rgb, 0.0 );\",\r\n\t\r\n\t\t\t\t\t\t\t// restore\r\n\t\r\n\t\t\t\t\t\t\t\"} else if( renderType == 1 ) {\",\r\n\t\r\n\t\t\t\t\t\t\t\t\"gl_FragColor = texture2D( map, vUV );\",\r\n\t\r\n\t\t\t\t\t\t\t// flare\r\n\t\r\n\t\t\t\t\t\t\t\"} else {\",\r\n\t\r\n\t\t\t\t\t\t\t\t\"float visibility = texture2D( occlusionMap, vec2( 0.5, 0.1 ) ).a;\",\r\n\t\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) ).a;\",\r\n\t\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) ).a;\",\r\n\t\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) ).a;\",\r\n\t\t\t\t\t\t\t\t\"visibility = ( 1.0 - visibility / 4.0 );\",\r\n\t\r\n\t\t\t\t\t\t\t\t\"vec4 texture = texture2D( map, vUV );\",\r\n\t\t\t\t\t\t\t\t\"texture.a *= opacity * visibility;\",\r\n\t\t\t\t\t\t\t\t\"gl_FragColor = texture;\",\r\n\t\t\t\t\t\t\t\t\"gl_FragColor.rgb *= color;\",\r\n\t\r\n\t\t\t\t\t\t\t\"}\",\r\n\t\r\n\t\t\t\t\t\t\"}\"\r\n\t\r\n\t\t\t\t\t].join( \"\\n\" )\r\n\t\r\n\t\t\t\t};\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tprogram = createProgram( shader );\r\n\t\r\n\t\t\tattributes = {\r\n\t\t\t\tvertex: gl.getAttribLocation ( program, \"position\" ),\r\n\t\t\t\tuv:     gl.getAttribLocation ( program, \"uv\" )\r\n\t\t\t}\r\n\t\r\n\t\t\tuniforms = {\r\n\t\t\t\trenderType:     gl.getUniformLocation( program, \"renderType\" ),\r\n\t\t\t\tmap:            gl.getUniformLocation( program, \"map\" ),\r\n\t\t\t\tocclusionMap:   gl.getUniformLocation( program, \"occlusionMap\" ),\r\n\t\t\t\topacity:        gl.getUniformLocation( program, \"opacity\" ),\r\n\t\t\t\tcolor:          gl.getUniformLocation( program, \"color\" ),\r\n\t\t\t\tscale:          gl.getUniformLocation( program, \"scale\" ),\r\n\t\t\t\trotation:       gl.getUniformLocation( program, \"rotation\" ),\r\n\t\t\t\tscreenPosition: gl.getUniformLocation( program, \"screenPosition\" )\r\n\t\t\t};\r\n\t\r\n\t\t};\r\n\t\r\n\t\t/*\r\n\t\t * Render lens flares\r\n\t\t * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,\r\n\t\t *         reads these back and calculates occlusion.\r\n\t\t */\r\n\t\r\n\t\tthis.render = function ( scene, camera, viewportWidth, viewportHeight ) {\r\n\t\r\n\t\t\tif ( flares.length === 0 ) return;\r\n\t\r\n\t\t\tvar tempPosition = new THREE.Vector3();\r\n\t\r\n\t\t\tvar invAspect = viewportHeight / viewportWidth,\r\n\t\t\t\thalfViewportWidth = viewportWidth * 0.5,\r\n\t\t\t\thalfViewportHeight = viewportHeight * 0.5;\r\n\t\r\n\t\t\tvar size = 16 / viewportHeight,\r\n\t\t\t\tscale = new THREE.Vector2( size * invAspect, size );\r\n\t\r\n\t\t\tvar screenPosition = new THREE.Vector3( 1, 1, 0 ),\r\n\t\t\t\tscreenPositionPixels = new THREE.Vector2( 1, 1 );\r\n\t\r\n\t\t\tif ( program === undefined ) {\r\n\t\r\n\t\t\t\tinit();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tgl.useProgram( program );\r\n\t\r\n\t\t\tgl.enableVertexAttribArray( attributes.vertex );\r\n\t\t\tgl.enableVertexAttribArray( attributes.uv );\r\n\t\r\n\t\t\t// loop through all lens flares to update their occlusion and positions\r\n\t\t\t// setup gl and common used attribs/unforms\r\n\t\r\n\t\t\tgl.uniform1i( uniforms.occlusionMap, 0 );\r\n\t\t\tgl.uniform1i( uniforms.map, 1 );\r\n\t\r\n\t\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\r\n\t\t\tgl.vertexAttribPointer( attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0 );\r\n\t\t\tgl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );\r\n\t\r\n\t\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\r\n\t\r\n\t\t\tgl.disable( gl.CULL_FACE );\r\n\t\t\tgl.depthMask( false );\r\n\t\r\n\t\t\tfor ( var i = 0, l = flares.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tsize = 16 / viewportHeight;\r\n\t\t\t\tscale.set( size * invAspect, size );\r\n\t\r\n\t\t\t\t// calc object screen position\r\n\t\r\n\t\t\t\tvar flare = flares[ i ];\r\n\t\r\n\t\t\t\ttempPosition.set( flare.matrixWorld.elements[12], flare.matrixWorld.elements[13], flare.matrixWorld.elements[14] );\r\n\t\r\n\t\t\t\ttempPosition.applyMatrix4( camera.matrixWorldInverse );\r\n\t\t\t\ttempPosition.applyProjection( camera.projectionMatrix );\r\n\t\r\n\t\t\t\t// setup arrays for gl programs\r\n\t\r\n\t\t\t\tscreenPosition.copy( tempPosition )\r\n\t\r\n\t\t\t\tscreenPositionPixels.x = screenPosition.x * halfViewportWidth + halfViewportWidth;\r\n\t\t\t\tscreenPositionPixels.y = screenPosition.y * halfViewportHeight + halfViewportHeight;\r\n\t\r\n\t\t\t\t// screen cull\r\n\t\r\n\t\t\t\tif ( hasVertexTexture || (\r\n\t\t\t\t\tscreenPositionPixels.x > 0 &&\r\n\t\t\t\t\tscreenPositionPixels.x < viewportWidth &&\r\n\t\t\t\t\tscreenPositionPixels.y > 0 &&\r\n\t\t\t\t\tscreenPositionPixels.y < viewportHeight ) ) {\r\n\t\r\n\t\t\t\t\t// save current RGB to temp texture\r\n\t\r\n\t\t\t\t\tgl.activeTexture( gl.TEXTURE1 );\r\n\t\t\t\t\tgl.bindTexture( gl.TEXTURE_2D, tempTexture );\r\n\t\t\t\t\tgl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0 );\r\n\t\r\n\t\r\n\t\t\t\t\t// render pink quad\r\n\t\r\n\t\t\t\t\tgl.uniform1i( uniforms.renderType, 0 );\r\n\t\t\t\t\tgl.uniform2f( uniforms.scale, scale.x, scale.y );\r\n\t\t\t\t\tgl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );\r\n\t\r\n\t\t\t\t\tgl.disable( gl.BLEND );\r\n\t\t\t\t\tgl.enable( gl.DEPTH_TEST );\r\n\t\r\n\t\t\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\r\n\t\r\n\t\r\n\t\t\t\t\t// copy result to occlusionMap\r\n\t\r\n\t\t\t\t\tgl.activeTexture( gl.TEXTURE0 );\r\n\t\t\t\t\tgl.bindTexture( gl.TEXTURE_2D, occlusionTexture );\r\n\t\t\t\t\tgl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0 );\r\n\t\r\n\t\r\n\t\t\t\t\t// restore graphics\r\n\t\r\n\t\t\t\t\tgl.uniform1i( uniforms.renderType, 1 );\r\n\t\t\t\t\tgl.disable( gl.DEPTH_TEST );\r\n\t\r\n\t\t\t\t\tgl.activeTexture( gl.TEXTURE1 );\r\n\t\t\t\t\tgl.bindTexture( gl.TEXTURE_2D, tempTexture );\r\n\t\t\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\r\n\t\r\n\t\r\n\t\t\t\t\t// update object positions\r\n\t\r\n\t\t\t\t\tflare.positionScreen.copy( screenPosition )\r\n\t\r\n\t\t\t\t\tif ( flare.customUpdateCallback ) {\r\n\t\r\n\t\t\t\t\t\tflare.customUpdateCallback( flare );\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tflare.updateLensFlares();\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t// render flares\r\n\t\r\n\t\t\t\t\tgl.uniform1i( uniforms.renderType, 2 );\r\n\t\t\t\t\tgl.enable( gl.BLEND );\r\n\t\r\n\t\t\t\t\tfor ( var j = 0, jl = flare.lensFlares.length; j < jl; j ++ ) {\r\n\t\r\n\t\t\t\t\t\tvar sprite = flare.lensFlares[ j ];\r\n\t\r\n\t\t\t\t\t\tif ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {\r\n\t\r\n\t\t\t\t\t\t\tscreenPosition.x = sprite.x;\r\n\t\t\t\t\t\t\tscreenPosition.y = sprite.y;\r\n\t\t\t\t\t\t\tscreenPosition.z = sprite.z;\r\n\t\r\n\t\t\t\t\t\t\tsize = sprite.size * sprite.scale / viewportHeight;\r\n\t\r\n\t\t\t\t\t\t\tscale.x = size * invAspect;\r\n\t\t\t\t\t\t\tscale.y = size;\r\n\t\r\n\t\t\t\t\t\t\tgl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );\r\n\t\t\t\t\t\t\tgl.uniform2f( uniforms.scale, scale.x, scale.y );\r\n\t\t\t\t\t\t\tgl.uniform1f( uniforms.rotation, sprite.rotation );\r\n\t\r\n\t\t\t\t\t\t\tgl.uniform1f( uniforms.opacity, sprite.opacity );\r\n\t\t\t\t\t\t\tgl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );\r\n\t\r\n\t\t\t\t\t\t\trenderer.state.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );\r\n\t\t\t\t\t\t\trenderer.setTexture( sprite.texture, 1 );\r\n\t\r\n\t\t\t\t\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// restore gl\r\n\t\r\n\t\t\tgl.enable( gl.CULL_FACE );\r\n\t\t\tgl.enable( gl.DEPTH_TEST );\r\n\t\t\tgl.depthMask( true );\r\n\t\r\n\t\t\trenderer.resetGLState();\r\n\t\r\n\t\t};\r\n\t\r\n\t\tfunction createProgram ( shader ) {\r\n\t\r\n\t\t\tvar program = gl.createProgram();\r\n\t\r\n\t\t\tvar fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );\r\n\t\t\tvar vertexShader = gl.createShader( gl.VERTEX_SHADER );\r\n\t\r\n\t\t\tvar prefix = \"precision \" + renderer.getPrecision() + \" float;\\n\";\r\n\t\r\n\t\t\tgl.shaderSource( fragmentShader, prefix + shader.fragmentShader );\r\n\t\t\tgl.shaderSource( vertexShader, prefix + shader.vertexShader );\r\n\t\r\n\t\t\tgl.compileShader( fragmentShader );\r\n\t\t\tgl.compileShader( vertexShader );\r\n\t\r\n\t\t\tgl.attachShader( program, fragmentShader );\r\n\t\t\tgl.attachShader( program, vertexShader );\r\n\t\r\n\t\t\tgl.linkProgram( program );\r\n\t\r\n\t\t\treturn program;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/renderers/webgl/plugins/ShadowMapPlugin.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.ShadowMapPlugin = function ( _renderer, _lights, _webglObjects, _webglObjectsImmediate ) {\r\n\t\r\n\t\tvar _gl = _renderer.context;\r\n\t\r\n\t\tvar _depthMaterial, _depthMaterialMorph, _depthMaterialSkin, _depthMaterialMorphSkin,\r\n\t\r\n\t\t_frustum = new THREE.Frustum(),\r\n\t\t_projScreenMatrix = new THREE.Matrix4(),\r\n\t\r\n\t\t_min = new THREE.Vector3(),\r\n\t\t_max = new THREE.Vector3(),\r\n\t\r\n\t\t_matrixPosition = new THREE.Vector3(),\r\n\t\r\n\t\t_renderList = [];\r\n\t\r\n\t\t// init\r\n\t\r\n\t\tvar depthShader = THREE.ShaderLib[ \"depthRGBA\" ];\r\n\t\tvar depthUniforms = THREE.UniformsUtils.clone( depthShader.uniforms );\r\n\t\r\n\t\t_depthMaterial = new THREE.ShaderMaterial( {\r\n\t\t\tuniforms: depthUniforms,\r\n\t\t\tvertexShader: depthShader.vertexShader,\r\n\t\t\tfragmentShader: depthShader.fragmentShader\r\n\t\t } );\r\n\t\r\n\t\t_depthMaterialMorph = new THREE.ShaderMaterial( {\r\n\t\t\tuniforms: depthUniforms,\r\n\t\t\tvertexShader: depthShader.vertexShader,\r\n\t\t\tfragmentShader: depthShader.fragmentShader,\r\n\t\t\tmorphTargets: true\r\n\t\t} );\r\n\t\r\n\t\t_depthMaterialSkin = new THREE.ShaderMaterial( {\r\n\t\t\tuniforms: depthUniforms,\r\n\t\t\tvertexShader: depthShader.vertexShader,\r\n\t\t\tfragmentShader: depthShader.fragmentShader,\r\n\t\t\tskinning: true\r\n\t\t} );\r\n\t\r\n\t\t_depthMaterialMorphSkin = new THREE.ShaderMaterial( {\r\n\t\t\tuniforms: depthUniforms,\r\n\t\t\tvertexShader: depthShader.vertexShader,\r\n\t\t\tfragmentShader: depthShader.fragmentShader,\r\n\t\t\tmorphTargets: true,\r\n\t\t\tskinning: true\r\n\t\t} );\r\n\t\r\n\t\t_depthMaterial._shadowPass = true;\r\n\t\t_depthMaterialMorph._shadowPass = true;\r\n\t\t_depthMaterialSkin._shadowPass = true;\r\n\t\t_depthMaterialMorphSkin._shadowPass = true;\r\n\t\r\n\t\tthis.render = function ( scene, camera ) {\r\n\t\r\n\t\t\tif ( _renderer.shadowMapEnabled === false ) return;\r\n\t\r\n\t\t\tvar i, il, j, jl, n,\r\n\t\r\n\t\t\tshadowMap, shadowMatrix, shadowCamera,\r\n\t\t\tbuffer, material,\r\n\t\t\twebglObject, object, light,\r\n\t\r\n\t\t\tlights = [],\r\n\t\t\tk = 0,\r\n\t\r\n\t\t\tfog = null;\r\n\t\r\n\t\t\t// set GL state for depth map\r\n\t\r\n\t\t\t_gl.clearColor( 1, 1, 1, 1 );\r\n\t\t\t_gl.disable( _gl.BLEND );\r\n\t\r\n\t\t\t_gl.enable( _gl.CULL_FACE );\r\n\t\t\t_gl.frontFace( _gl.CCW );\r\n\t\r\n\t\t\tif ( _renderer.shadowMapCullFace === THREE.CullFaceFront ) {\r\n\t\r\n\t\t\t\t_gl.cullFace( _gl.FRONT );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\t_gl.cullFace( _gl.BACK );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t_renderer.state.setDepthTest( true );\r\n\t\r\n\t\t\t// preprocess lights\r\n\t\t\t// \t- skip lights that are not casting shadows\r\n\t\t\t//\t- create virtual lights for cascaded shadow maps\r\n\t\r\n\t\t\tfor ( i = 0, il = _lights.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tlight = _lights[ i ];\r\n\t\r\n\t\t\t\tif ( ! light.castShadow ) continue;\r\n\t\r\n\t\t\t\tif ( ( light instanceof THREE.DirectionalLight ) && light.shadowCascade ) {\r\n\t\r\n\t\t\t\t\tfor ( n = 0; n < light.shadowCascadeCount; n ++ ) {\r\n\t\r\n\t\t\t\t\t\tvar virtualLight;\r\n\t\r\n\t\t\t\t\t\tif ( ! light.shadowCascadeArray[ n ] ) {\r\n\t\r\n\t\t\t\t\t\t\tvirtualLight = createVirtualLight( light, n );\r\n\t\t\t\t\t\t\tvirtualLight.originalCamera = camera;\r\n\t\r\n\t\t\t\t\t\t\tvar gyro = new THREE.Gyroscope();\r\n\t\t\t\t\t\t\tgyro.position.copy( light.shadowCascadeOffset );\r\n\t\r\n\t\t\t\t\t\t\tgyro.add( virtualLight );\r\n\t\t\t\t\t\t\tgyro.add( virtualLight.target );\r\n\t\r\n\t\t\t\t\t\t\tcamera.add( gyro );\r\n\t\r\n\t\t\t\t\t\t\tlight.shadowCascadeArray[ n ] = virtualLight;\r\n\t\r\n\t\t\t\t\t\t\t//console.log( \"Created virtualLight\", virtualLight );\r\n\t\r\n\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\tvirtualLight = light.shadowCascadeArray[ n ];\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tupdateVirtualLight( light, n );\r\n\t\r\n\t\t\t\t\t\tlights[ k ] = virtualLight;\r\n\t\t\t\t\t\tk ++;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tlights[ k ] = light;\r\n\t\t\t\t\tk ++;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// render depth map\r\n\t\r\n\t\t\tfor ( i = 0, il = lights.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tlight = lights[ i ];\r\n\t\r\n\t\t\t\tif ( ! light.shadowMap ) {\r\n\t\r\n\t\t\t\t\tvar shadowFilter = THREE.LinearFilter;\r\n\t\r\n\t\t\t\t\tif ( _renderer.shadowMapType === THREE.PCFSoftShadowMap ) {\r\n\t\r\n\t\t\t\t\t\tshadowFilter = THREE.NearestFilter;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tvar pars = { minFilter: shadowFilter, magFilter: shadowFilter, format: THREE.RGBAFormat };\r\n\t\r\n\t\t\t\t\tlight.shadowMap = new THREE.WebGLRenderTarget( light.shadowMapWidth, light.shadowMapHeight, pars );\r\n\t\t\t\t\tlight.shadowMapSize = new THREE.Vector2( light.shadowMapWidth, light.shadowMapHeight );\r\n\t\r\n\t\t\t\t\tlight.shadowMatrix = new THREE.Matrix4();\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( ! light.shadowCamera ) {\r\n\t\r\n\t\t\t\t\tif ( light instanceof THREE.SpotLight ) {\r\n\t\r\n\t\t\t\t\t\tlight.shadowCamera = new THREE.PerspectiveCamera( light.shadowCameraFov, light.shadowMapWidth / light.shadowMapHeight, light.shadowCameraNear, light.shadowCameraFar );\r\n\t\r\n\t\t\t\t\t} else if ( light instanceof THREE.DirectionalLight ) {\r\n\t\r\n\t\t\t\t\t\tlight.shadowCamera = new THREE.OrthographicCamera( light.shadowCameraLeft, light.shadowCameraRight, light.shadowCameraTop, light.shadowCameraBottom, light.shadowCameraNear, light.shadowCameraFar );\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tTHREE.error( \"THREE.ShadowMapPlugin: Unsupported light type for shadow\", light );\r\n\t\t\t\t\t\tcontinue;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tscene.add( light.shadowCamera );\r\n\t\r\n\t\t\t\t\tif ( scene.autoUpdate === true ) scene.updateMatrixWorld();\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( light.shadowCameraVisible && ! light.cameraHelper ) {\r\n\t\r\n\t\t\t\t\tlight.cameraHelper = new THREE.CameraHelper( light.shadowCamera );\r\n\t\t\t\t\tscene.add( light.cameraHelper );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( light.isVirtual && virtualLight.originalCamera == camera ) {\r\n\t\r\n\t\t\t\t\tupdateShadowCamera( camera, light );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tshadowMap = light.shadowMap;\r\n\t\t\t\tshadowMatrix = light.shadowMatrix;\r\n\t\t\t\tshadowCamera = light.shadowCamera;\r\n\t\r\n\t\t\t\t//\r\n\t\r\n\t\t\t\tshadowCamera.position.setFromMatrixPosition( light.matrixWorld );\r\n\t\t\t\t_matrixPosition.setFromMatrixPosition( light.target.matrixWorld );\r\n\t\t\t\tshadowCamera.lookAt( _matrixPosition );\r\n\t\t\t\tshadowCamera.updateMatrixWorld();\r\n\t\r\n\t\t\t\tshadowCamera.matrixWorldInverse.getInverse( shadowCamera.matrixWorld );\r\n\t\r\n\t\t\t\t//\r\n\t\r\n\t\t\t\tif ( light.cameraHelper ) light.cameraHelper.visible = light.shadowCameraVisible;\r\n\t\t\t\tif ( light.shadowCameraVisible ) light.cameraHelper.update();\r\n\t\r\n\t\t\t\t// compute shadow matrix\r\n\t\r\n\t\t\t\tshadowMatrix.set(\r\n\t\t\t\t\t0.5, 0.0, 0.0, 0.5,\r\n\t\t\t\t\t0.0, 0.5, 0.0, 0.5,\r\n\t\t\t\t\t0.0, 0.0, 0.5, 0.5,\r\n\t\t\t\t\t0.0, 0.0, 0.0, 1.0\r\n\t\t\t\t);\r\n\t\r\n\t\t\t\tshadowMatrix.multiply( shadowCamera.projectionMatrix );\r\n\t\t\t\tshadowMatrix.multiply( shadowCamera.matrixWorldInverse );\r\n\t\r\n\t\t\t\t// update camera matrices and frustum\r\n\t\r\n\t\t\t\t_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );\r\n\t\t\t\t_frustum.setFromMatrix( _projScreenMatrix );\r\n\t\r\n\t\t\t\t// render shadow map\r\n\t\r\n\t\t\t\t_renderer.setRenderTarget( shadowMap );\r\n\t\t\t\t_renderer.clear();\r\n\t\r\n\t\t\t\t// set object matrices & frustum culling\r\n\t\r\n\t\t\t\t_renderList.length = 0;\r\n\t\r\n\t\t\t\tprojectObject( scene, scene, shadowCamera );\r\n\t\r\n\t\r\n\t\t\t\t// render regular objects\r\n\t\r\n\t\t\t\tvar objectMaterial, useMorphing, useSkinning;\r\n\t\r\n\t\t\t\tfor ( j = 0, jl = _renderList.length; j < jl; j ++ ) {\r\n\t\r\n\t\t\t\t\twebglObject = _renderList[ j ];\r\n\t\r\n\t\t\t\t\tobject = webglObject.object;\r\n\t\t\t\t\tbuffer = webglObject.buffer;\r\n\t\r\n\t\t\t\t\t// culling is overriden globally for all objects\r\n\t\t\t\t\t// while rendering depth map\r\n\t\r\n\t\t\t\t\t// need to deal with MeshFaceMaterial somehow\r\n\t\t\t\t\t// in that case just use the first of material.materials for now\r\n\t\t\t\t\t// (proper solution would require to break objects by materials\r\n\t\t\t\t\t//  similarly to regular rendering and then set corresponding\r\n\t\t\t\t\t//  depth materials per each chunk instead of just once per object)\r\n\t\r\n\t\t\t\t\tobjectMaterial = getObjectMaterial( object );\r\n\t\r\n\t\t\t\t\tuseMorphing = object.geometry.morphTargets !== undefined && object.geometry.morphTargets.length > 0 && objectMaterial.morphTargets;\r\n\t\t\t\t\tuseSkinning = object instanceof THREE.SkinnedMesh && objectMaterial.skinning;\r\n\t\r\n\t\t\t\t\tif ( object.customDepthMaterial ) {\r\n\t\r\n\t\t\t\t\t\tmaterial = object.customDepthMaterial;\r\n\t\r\n\t\t\t\t\t} else if ( useSkinning ) {\r\n\t\r\n\t\t\t\t\t\tmaterial = useMorphing ? _depthMaterialMorphSkin : _depthMaterialSkin;\r\n\t\r\n\t\t\t\t\t} else if ( useMorphing ) {\r\n\t\r\n\t\t\t\t\t\tmaterial = _depthMaterialMorph;\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tmaterial = _depthMaterial;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t_renderer.setMaterialFaces( objectMaterial );\r\n\t\r\n\t\t\t\t\tif ( buffer instanceof THREE.BufferGeometry ) {\r\n\t\r\n\t\t\t\t\t\t_renderer.renderBufferDirect( shadowCamera, _lights, fog, material, buffer, object );\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t_renderer.renderBuffer( shadowCamera, _lights, fog, material, buffer, object );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// set matrices and render immediate objects\r\n\t\r\n\t\t\t\tfor ( j = 0, jl = _webglObjectsImmediate.length; j < jl; j ++ ) {\r\n\t\r\n\t\t\t\t\twebglObject = _webglObjectsImmediate[ j ];\r\n\t\t\t\t\tobject = webglObject.object;\r\n\t\r\n\t\t\t\t\tif ( object.visible && object.castShadow ) {\r\n\t\r\n\t\t\t\t\t\tobject._modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );\r\n\t\r\n\t\t\t\t\t\t_renderer.renderImmediateObject( shadowCamera, _lights, fog, _depthMaterial, object );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// restore GL state\r\n\t\r\n\t\t\tvar clearColor = _renderer.getClearColor(),\r\n\t\t\tclearAlpha = _renderer.getClearAlpha();\r\n\t\r\n\t\t\t_gl.clearColor( clearColor.r, clearColor.g, clearColor.b, clearAlpha );\r\n\t\t\t_gl.enable( _gl.BLEND );\r\n\t\r\n\t\t\tif ( _renderer.shadowMapCullFace === THREE.CullFaceFront ) {\r\n\t\r\n\t\t\t\t_gl.cullFace( _gl.BACK );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t_renderer.resetGLState();\r\n\t\r\n\t\t};\r\n\t\r\n\t\tfunction projectObject( scene, object, shadowCamera ) {\r\n\t\r\n\t\t\tif ( object.visible ) {\r\n\t\r\n\t\t\t\tvar webglObjects = _webglObjects[ object.id ];\r\n\t\r\n\t\t\t\tif ( webglObjects && object.castShadow && (object.frustumCulled === false || _frustum.intersectsObject( object ) === true) ) {\r\n\t\r\n\t\t\t\t\tfor ( var i = 0, l = webglObjects.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\t\tvar webglObject = webglObjects[ i ];\r\n\t\r\n\t\t\t\t\t\tobject._modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );\r\n\t\t\t\t\t\t_renderList.push( webglObject );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tfor ( var i = 0, l = object.children.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\tprojectObject( scene, object.children[ i ], shadowCamera );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction createVirtualLight( light, cascade ) {\r\n\t\r\n\t\t\tvar virtualLight = new THREE.DirectionalLight();\r\n\t\r\n\t\t\tvirtualLight.isVirtual = true;\r\n\t\r\n\t\t\tvirtualLight.onlyShadow = true;\r\n\t\t\tvirtualLight.castShadow = true;\r\n\t\r\n\t\t\tvirtualLight.shadowCameraNear = light.shadowCameraNear;\r\n\t\t\tvirtualLight.shadowCameraFar = light.shadowCameraFar;\r\n\t\r\n\t\t\tvirtualLight.shadowCameraLeft = light.shadowCameraLeft;\r\n\t\t\tvirtualLight.shadowCameraRight = light.shadowCameraRight;\r\n\t\t\tvirtualLight.shadowCameraBottom = light.shadowCameraBottom;\r\n\t\t\tvirtualLight.shadowCameraTop = light.shadowCameraTop;\r\n\t\r\n\t\t\tvirtualLight.shadowCameraVisible = light.shadowCameraVisible;\r\n\t\r\n\t\t\tvirtualLight.shadowDarkness = light.shadowDarkness;\r\n\t\r\n\t\t\tvirtualLight.shadowBias = light.shadowCascadeBias[ cascade ];\r\n\t\t\tvirtualLight.shadowMapWidth = light.shadowCascadeWidth[ cascade ];\r\n\t\t\tvirtualLight.shadowMapHeight = light.shadowCascadeHeight[ cascade ];\r\n\t\r\n\t\t\tvirtualLight.pointsWorld = [];\r\n\t\t\tvirtualLight.pointsFrustum = [];\r\n\t\r\n\t\t\tvar pointsWorld = virtualLight.pointsWorld,\r\n\t\t\t\tpointsFrustum = virtualLight.pointsFrustum;\r\n\t\r\n\t\t\tfor ( var i = 0; i < 8; i ++ ) {\r\n\t\r\n\t\t\t\tpointsWorld[ i ] = new THREE.Vector3();\r\n\t\t\t\tpointsFrustum[ i ] = new THREE.Vector3();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar nearZ = light.shadowCascadeNearZ[ cascade ];\r\n\t\t\tvar farZ = light.shadowCascadeFarZ[ cascade ];\r\n\t\r\n\t\t\tpointsFrustum[ 0 ].set( - 1, - 1, nearZ );\r\n\t\t\tpointsFrustum[ 1 ].set(  1, - 1, nearZ );\r\n\t\t\tpointsFrustum[ 2 ].set( - 1,  1, nearZ );\r\n\t\t\tpointsFrustum[ 3 ].set(  1,  1, nearZ );\r\n\t\r\n\t\t\tpointsFrustum[ 4 ].set( - 1, - 1, farZ );\r\n\t\t\tpointsFrustum[ 5 ].set(  1, - 1, farZ );\r\n\t\t\tpointsFrustum[ 6 ].set( - 1,  1, farZ );\r\n\t\t\tpointsFrustum[ 7 ].set(  1,  1, farZ );\r\n\t\r\n\t\t\treturn virtualLight;\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// Synchronize virtual light with the original light\r\n\t\r\n\t\tfunction updateVirtualLight( light, cascade ) {\r\n\t\r\n\t\t\tvar virtualLight = light.shadowCascadeArray[ cascade ];\r\n\t\r\n\t\t\tvirtualLight.position.copy( light.position );\r\n\t\t\tvirtualLight.target.position.copy( light.target.position );\r\n\t\t\tvirtualLight.lookAt( virtualLight.target );\r\n\t\r\n\t\t\tvirtualLight.shadowCameraVisible = light.shadowCameraVisible;\r\n\t\t\tvirtualLight.shadowDarkness = light.shadowDarkness;\r\n\t\r\n\t\t\tvirtualLight.shadowBias = light.shadowCascadeBias[ cascade ];\r\n\t\r\n\t\t\tvar nearZ = light.shadowCascadeNearZ[ cascade ];\r\n\t\t\tvar farZ = light.shadowCascadeFarZ[ cascade ];\r\n\t\r\n\t\t\tvar pointsFrustum = virtualLight.pointsFrustum;\r\n\t\r\n\t\t\tpointsFrustum[ 0 ].z = nearZ;\r\n\t\t\tpointsFrustum[ 1 ].z = nearZ;\r\n\t\t\tpointsFrustum[ 2 ].z = nearZ;\r\n\t\t\tpointsFrustum[ 3 ].z = nearZ;\r\n\t\r\n\t\t\tpointsFrustum[ 4 ].z = farZ;\r\n\t\t\tpointsFrustum[ 5 ].z = farZ;\r\n\t\t\tpointsFrustum[ 6 ].z = farZ;\r\n\t\t\tpointsFrustum[ 7 ].z = farZ;\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// Fit shadow camera's ortho frustum to camera frustum\r\n\t\r\n\t\tfunction updateShadowCamera( camera, light ) {\r\n\t\r\n\t\t\tvar shadowCamera = light.shadowCamera,\r\n\t\t\t\tpointsFrustum = light.pointsFrustum,\r\n\t\t\t\tpointsWorld = light.pointsWorld;\r\n\t\r\n\t\t\t_min.set( Infinity, Infinity, Infinity );\r\n\t\t\t_max.set( - Infinity, - Infinity, - Infinity );\r\n\t\r\n\t\t\tfor ( var i = 0; i < 8; i ++ ) {\r\n\t\r\n\t\t\t\tvar p = pointsWorld[ i ];\r\n\t\r\n\t\t\t\tp.copy( pointsFrustum[ i ] );\r\n\t\t\t\tp.unproject( camera );\r\n\t\r\n\t\t\t\tp.applyMatrix4( shadowCamera.matrixWorldInverse );\r\n\t\r\n\t\t\t\tif ( p.x < _min.x ) _min.x = p.x;\r\n\t\t\t\tif ( p.x > _max.x ) _max.x = p.x;\r\n\t\r\n\t\t\t\tif ( p.y < _min.y ) _min.y = p.y;\r\n\t\t\t\tif ( p.y > _max.y ) _max.y = p.y;\r\n\t\r\n\t\t\t\tif ( p.z < _min.z ) _min.z = p.z;\r\n\t\t\t\tif ( p.z > _max.z ) _max.z = p.z;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tshadowCamera.left = _min.x;\r\n\t\t\tshadowCamera.right = _max.x;\r\n\t\t\tshadowCamera.top = _max.y;\r\n\t\t\tshadowCamera.bottom = _min.y;\r\n\t\r\n\t\t\t// can't really fit near/far\r\n\t\t\t//shadowCamera.near = _min.z;\r\n\t\t\t//shadowCamera.far = _max.z;\r\n\t\r\n\t\t\tshadowCamera.updateProjectionMatrix();\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// For the moment just ignore objects that have multiple materials with different animation methods\r\n\t\t// Only the first material will be taken into account for deciding which depth material to use for shadow maps\r\n\t\r\n\t\tfunction getObjectMaterial( object ) {\r\n\t\r\n\t\t\treturn object.material instanceof THREE.MeshFaceMaterial\r\n\t\t\t\t? object.material.materials[ 0 ]\r\n\t\t\t\t: object.material;\r\n\t\r\n\t\t};\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/renderers/webgl/plugins/SpritePlugin.js\r\n\t\r\n\t/**\r\n\t * @author mikael emtinger / http://gomo.se/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.SpritePlugin = function ( renderer, sprites ) {\r\n\t\r\n\t\tvar gl = renderer.context;\r\n\t\r\n\t\tvar vertexBuffer, elementBuffer;\r\n\t\tvar program, attributes, uniforms;\r\n\t\r\n\t\tvar texture;\r\n\t\r\n\t\t// decompose matrixWorld\r\n\t\r\n\t\tvar spritePosition = new THREE.Vector3();\r\n\t\tvar spriteRotation = new THREE.Quaternion();\r\n\t\tvar spriteScale = new THREE.Vector3();\r\n\t\r\n\t\tvar init = function () {\r\n\t\r\n\t\t\tvar vertices = new Float32Array( [\r\n\t\t\t\t- 0.5, - 0.5,  0, 0,\r\n\t\t\t\t  0.5, - 0.5,  1, 0,\r\n\t\t\t\t  0.5,   0.5,  1, 1,\r\n\t\t\t\t- 0.5,   0.5,  0, 1\r\n\t\t\t] );\r\n\t\r\n\t\t\tvar faces = new Uint16Array( [\r\n\t\t\t\t0, 1, 2,\r\n\t\t\t\t0, 2, 3\r\n\t\t\t] );\r\n\t\r\n\t\t\tvertexBuffer  = gl.createBuffer();\r\n\t\t\telementBuffer = gl.createBuffer();\r\n\t\r\n\t\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\r\n\t\t\tgl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );\r\n\t\r\n\t\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\r\n\t\t\tgl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );\r\n\t\r\n\t\t\tprogram = createProgram();\r\n\t\r\n\t\t\tattributes = {\r\n\t\t\t\tposition:\t\t\tgl.getAttribLocation ( program, 'position' ),\r\n\t\t\t\tuv:\t\t\t\t\tgl.getAttribLocation ( program, 'uv' )\r\n\t\t\t};\r\n\t\r\n\t\t\tuniforms = {\r\n\t\t\t\tuvOffset:\t\t\tgl.getUniformLocation( program, 'uvOffset' ),\r\n\t\t\t\tuvScale:\t\t\tgl.getUniformLocation( program, 'uvScale' ),\r\n\t\r\n\t\t\t\trotation:\t\t\tgl.getUniformLocation( program, 'rotation' ),\r\n\t\t\t\tscale:\t\t\t\tgl.getUniformLocation( program, 'scale' ),\r\n\t\r\n\t\t\t\tcolor:\t\t\t\tgl.getUniformLocation( program, 'color' ),\r\n\t\t\t\tmap:\t\t\t\tgl.getUniformLocation( program, 'map' ),\r\n\t\t\t\topacity:\t\t\tgl.getUniformLocation( program, 'opacity' ),\r\n\t\r\n\t\t\t\tmodelViewMatrix: \tgl.getUniformLocation( program, 'modelViewMatrix' ),\r\n\t\t\t\tprojectionMatrix:\tgl.getUniformLocation( program, 'projectionMatrix' ),\r\n\t\r\n\t\t\t\tfogType:\t\t\tgl.getUniformLocation( program, 'fogType' ),\r\n\t\t\t\tfogDensity:\t\t\tgl.getUniformLocation( program, 'fogDensity' ),\r\n\t\t\t\tfogNear:\t\t\tgl.getUniformLocation( program, 'fogNear' ),\r\n\t\t\t\tfogFar:\t\t\t\tgl.getUniformLocation( program, 'fogFar' ),\r\n\t\t\t\tfogColor:\t\t\tgl.getUniformLocation( program, 'fogColor' ),\r\n\t\r\n\t\t\t\talphaTest:\t\t\tgl.getUniformLocation( program, 'alphaTest' )\r\n\t\t\t};\r\n\t\r\n\t\t\tvar canvas = document.createElement( 'canvas' );\r\n\t\t\tcanvas.width = 8;\r\n\t\t\tcanvas.height = 8;\r\n\t\r\n\t\t\tvar context = canvas.getContext( '2d' );\r\n\t\t\tcontext.fillStyle = 'white';\r\n\t\t\tcontext.fillRect( 0, 0, 8, 8 );\r\n\t\r\n\t\t\ttexture = new THREE.Texture( canvas );\r\n\t\t\ttexture.needsUpdate = true;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.render = function ( scene, camera ) {\r\n\t\r\n\t\t\tif ( sprites.length === 0 ) return;\r\n\t\r\n\t\t\t// setup gl\r\n\t\r\n\t\t\tif ( program === undefined ) {\r\n\t\r\n\t\t\t\tinit();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tgl.useProgram( program );\r\n\t\r\n\t\t\tgl.enableVertexAttribArray( attributes.position );\r\n\t\t\tgl.enableVertexAttribArray( attributes.uv );\r\n\t\r\n\t\t\tgl.disable( gl.CULL_FACE );\r\n\t\t\tgl.enable( gl.BLEND );\r\n\t\r\n\t\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\r\n\t\t\tgl.vertexAttribPointer( attributes.position, 2, gl.FLOAT, false, 2 * 8, 0 );\r\n\t\t\tgl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );\r\n\t\r\n\t\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\r\n\t\r\n\t\t\tgl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );\r\n\t\r\n\t\t\tgl.activeTexture( gl.TEXTURE0 );\r\n\t\t\tgl.uniform1i( uniforms.map, 0 );\r\n\t\r\n\t\t\tvar oldFogType = 0;\r\n\t\t\tvar sceneFogType = 0;\r\n\t\t\tvar fog = scene.fog;\r\n\t\r\n\t\t\tif ( fog ) {\r\n\t\r\n\t\t\t\tgl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );\r\n\t\r\n\t\t\t\tif ( fog instanceof THREE.Fog ) {\r\n\t\r\n\t\t\t\t\tgl.uniform1f( uniforms.fogNear, fog.near );\r\n\t\t\t\t\tgl.uniform1f( uniforms.fogFar, fog.far );\r\n\t\r\n\t\t\t\t\tgl.uniform1i( uniforms.fogType, 1 );\r\n\t\t\t\t\toldFogType = 1;\r\n\t\t\t\t\tsceneFogType = 1;\r\n\t\r\n\t\t\t\t} else if ( fog instanceof THREE.FogExp2 ) {\r\n\t\r\n\t\t\t\t\tgl.uniform1f( uniforms.fogDensity, fog.density );\r\n\t\r\n\t\t\t\t\tgl.uniform1i( uniforms.fogType, 2 );\r\n\t\t\t\t\toldFogType = 2;\r\n\t\t\t\t\tsceneFogType = 2;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tgl.uniform1i( uniforms.fogType, 0 );\r\n\t\t\t\toldFogType = 0;\r\n\t\t\t\tsceneFogType = 0;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\r\n\t\t\t// update positions and sort\r\n\t\r\n\t\t\tfor ( var i = 0, l = sprites.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tvar sprite = sprites[ i ];\r\n\t\r\n\t\t\t\tsprite._modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );\r\n\t\t\t\tsprite.z = - sprite._modelViewMatrix.elements[ 14 ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tsprites.sort( painterSortStable );\r\n\t\r\n\t\t\t// render all sprites\r\n\t\r\n\t\t\tvar scale = [];\r\n\t\r\n\t\t\tfor ( var i = 0, l = sprites.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tvar sprite = sprites[ i ];\r\n\t\t\t\tvar material = sprite.material;\r\n\t\r\n\t\t\t\tgl.uniform1f( uniforms.alphaTest, material.alphaTest );\r\n\t\t\t\tgl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite._modelViewMatrix.elements );\r\n\t\r\n\t\t\t\tsprite.matrixWorld.decompose( spritePosition, spriteRotation, spriteScale );\r\n\t\r\n\t\t\t\tscale[ 0 ] = spriteScale.x;\r\n\t\t\t\tscale[ 1 ] = spriteScale.y;\r\n\t\r\n\t\t\t\tvar fogType = 0;\r\n\t\r\n\t\t\t\tif ( scene.fog && material.fog ) {\r\n\t\r\n\t\t\t\t\tfogType = sceneFogType;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( oldFogType !== fogType ) {\r\n\t\r\n\t\t\t\t\tgl.uniform1i( uniforms.fogType, fogType );\r\n\t\t\t\t\toldFogType = fogType;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( material.map !== null ) {\r\n\t\r\n\t\t\t\t\tgl.uniform2f( uniforms.uvOffset, material.map.offset.x, material.map.offset.y );\r\n\t\t\t\t\tgl.uniform2f( uniforms.uvScale, material.map.repeat.x, material.map.repeat.y );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tgl.uniform2f( uniforms.uvOffset, 0, 0 );\r\n\t\t\t\t\tgl.uniform2f( uniforms.uvScale, 1, 1 );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tgl.uniform1f( uniforms.opacity, material.opacity );\r\n\t\t\t\tgl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );\r\n\t\r\n\t\t\t\tgl.uniform1f( uniforms.rotation, material.rotation );\r\n\t\t\t\tgl.uniform2fv( uniforms.scale, scale );\r\n\t\r\n\t\t\t\trenderer.state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );\r\n\t\t\t\trenderer.state.setDepthTest( material.depthTest );\r\n\t\t\t\trenderer.state.setDepthWrite( material.depthWrite );\r\n\t\r\n\t\t\t\tif ( material.map && material.map.image && material.map.image.width ) {\r\n\t\r\n\t\t\t\t\trenderer.setTexture( material.map, 0 );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\trenderer.setTexture( texture, 0 );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// restore gl\r\n\t\r\n\t\t\tgl.enable( gl.CULL_FACE );\r\n\t\r\n\t\t\trenderer.resetGLState();\r\n\t\r\n\t\t};\r\n\t\r\n\t\tfunction createProgram () {\r\n\t\r\n\t\t\tvar program = gl.createProgram();\r\n\t\r\n\t\t\tvar vertexShader = gl.createShader( gl.VERTEX_SHADER );\r\n\t\t\tvar fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );\r\n\t\r\n\t\t\tgl.shaderSource( vertexShader, [\r\n\t\r\n\t\t\t\t'precision ' + renderer.getPrecision() + ' float;',\r\n\t\r\n\t\t\t\t'uniform mat4 modelViewMatrix;',\r\n\t\t\t\t'uniform mat4 projectionMatrix;',\r\n\t\t\t\t'uniform float rotation;',\r\n\t\t\t\t'uniform vec2 scale;',\r\n\t\t\t\t'uniform vec2 uvOffset;',\r\n\t\t\t\t'uniform vec2 uvScale;',\r\n\t\r\n\t\t\t\t'attribute vec2 position;',\r\n\t\t\t\t'attribute vec2 uv;',\r\n\t\r\n\t\t\t\t'varying vec2 vUV;',\r\n\t\r\n\t\t\t\t'void main() {',\r\n\t\r\n\t\t\t\t\t'vUV = uvOffset + uv * uvScale;',\r\n\t\r\n\t\t\t\t\t'vec2 alignedPosition = position * scale;',\r\n\t\r\n\t\t\t\t\t'vec2 rotatedPosition;',\r\n\t\t\t\t\t'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',\r\n\t\t\t\t\t'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',\r\n\t\r\n\t\t\t\t\t'vec4 finalPosition;',\r\n\t\r\n\t\t\t\t\t'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',\r\n\t\t\t\t\t'finalPosition.xy += rotatedPosition;',\r\n\t\t\t\t\t'finalPosition = projectionMatrix * finalPosition;',\r\n\t\r\n\t\t\t\t\t'gl_Position = finalPosition;',\r\n\t\r\n\t\t\t\t'}'\r\n\t\r\n\t\t\t].join( '\\n' ) );\r\n\t\r\n\t\t\tgl.shaderSource( fragmentShader, [\r\n\t\r\n\t\t\t\t'precision ' + renderer.getPrecision() + ' float;',\r\n\t\r\n\t\t\t\t'uniform vec3 color;',\r\n\t\t\t\t'uniform sampler2D map;',\r\n\t\t\t\t'uniform float opacity;',\r\n\t\r\n\t\t\t\t'uniform int fogType;',\r\n\t\t\t\t'uniform vec3 fogColor;',\r\n\t\t\t\t'uniform float fogDensity;',\r\n\t\t\t\t'uniform float fogNear;',\r\n\t\t\t\t'uniform float fogFar;',\r\n\t\t\t\t'uniform float alphaTest;',\r\n\t\r\n\t\t\t\t'varying vec2 vUV;',\r\n\t\r\n\t\t\t\t'void main() {',\r\n\t\r\n\t\t\t\t\t'vec4 texture = texture2D( map, vUV );',\r\n\t\r\n\t\t\t\t\t'if ( texture.a < alphaTest ) discard;',\r\n\t\r\n\t\t\t\t\t'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',\r\n\t\r\n\t\t\t\t\t'if ( fogType > 0 ) {',\r\n\t\r\n\t\t\t\t\t\t'float depth = gl_FragCoord.z / gl_FragCoord.w;',\r\n\t\t\t\t\t\t'float fogFactor = 0.0;',\r\n\t\r\n\t\t\t\t\t\t'if ( fogType == 1 ) {',\r\n\t\r\n\t\t\t\t\t\t\t'fogFactor = smoothstep( fogNear, fogFar, depth );',\r\n\t\r\n\t\t\t\t\t\t'} else {',\r\n\t\r\n\t\t\t\t\t\t\t'const float LOG2 = 1.442695;',\r\n\t\t\t\t\t\t\t'float fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',\r\n\t\t\t\t\t\t\t'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',\r\n\t\r\n\t\t\t\t\t\t'}',\r\n\t\r\n\t\t\t\t\t\t'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',\r\n\t\r\n\t\t\t\t\t'}',\r\n\t\r\n\t\t\t\t'}'\r\n\t\r\n\t\t\t].join( '\\n' ) );\r\n\t\r\n\t\t\tgl.compileShader( vertexShader );\r\n\t\t\tgl.compileShader( fragmentShader );\r\n\t\r\n\t\t\tgl.attachShader( program, vertexShader );\r\n\t\t\tgl.attachShader( program, fragmentShader );\r\n\t\r\n\t\t\tgl.linkProgram( program );\r\n\t\r\n\t\t\treturn program;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tfunction painterSortStable ( a, b ) {\r\n\t\r\n\t\t\tif ( a.z !== b.z ) {\r\n\t\r\n\t\t\t\treturn b.z - a.z;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\treturn b.id - a.id;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/GeometryUtils.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.GeometryUtils = {\r\n\t\r\n\t\tmerge: function ( geometry1, geometry2, materialIndexOffset ) {\r\n\t\r\n\t\t\tTHREE.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );\r\n\t\r\n\t\t\tvar matrix;\r\n\t\r\n\t\t\tif ( geometry2 instanceof THREE.Mesh ) {\r\n\t\r\n\t\t\t\tgeometry2.matrixAutoUpdate && geometry2.updateMatrix();\r\n\t\r\n\t\t\t\tmatrix = geometry2.matrix;\r\n\t\t\t\tgeometry2 = geometry2.geometry;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tgeometry1.merge( geometry2, matrix, materialIndexOffset );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcenter: function ( geometry ) {\r\n\t\r\n\t\t\tTHREE.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );\r\n\t\t\treturn geometry.center();\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/ImageUtils.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author Daosheng Mu / https://github.com/DaoshengMu/\r\n\t */\r\n\t\r\n\tTHREE.ImageUtils = {\r\n\t\r\n\t\tcrossOrigin: undefined,\r\n\t\r\n\t\tloadTexture: function ( url, mapping, onLoad, onError ) {\r\n\t\r\n\t\t\tvar loader = new THREE.ImageLoader();\r\n\t\t\tloader.crossOrigin = this.crossOrigin;\r\n\t\r\n\t\t\tvar texture = new THREE.Texture( undefined, mapping );\r\n\t\r\n\t\t\tloader.load( url, function ( image ) {\r\n\t\r\n\t\t\t\ttexture.image = image;\r\n\t\t\t\ttexture.needsUpdate = true;\r\n\t\r\n\t\t\t\tif ( onLoad ) onLoad( texture );\r\n\t\r\n\t\t\t}, undefined, function ( event ) {\r\n\t\r\n\t\t\t\tif ( onError ) onError( event );\r\n\t\r\n\t\t\t} );\r\n\t\r\n\t\t\ttexture.sourceFile = url;\r\n\t\r\n\t\t\treturn texture;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tloadTextureCube: function ( array, mapping, onLoad, onError ) {\r\n\t\r\n\t\t\tvar images = [];\r\n\t\r\n\t\t\tvar loader = new THREE.ImageLoader();\r\n\t\t\tloader.crossOrigin = this.crossOrigin;\r\n\t\r\n\t\t\tvar texture = new THREE.CubeTexture( images, mapping );\r\n\t\r\n\t\t\t// no flipping needed for cube textures\r\n\t\r\n\t\t\ttexture.flipY = false;\r\n\t\r\n\t\t\tvar loaded = 0;\r\n\t\r\n\t\t\tvar loadTexture = function ( i ) {\r\n\t\r\n\t\t\t\tloader.load( array[ i ], function ( image ) {\r\n\t\r\n\t\t\t\t\ttexture.images[ i ] = image;\r\n\t\r\n\t\t\t\t\tloaded += 1;\r\n\t\r\n\t\t\t\t\tif ( loaded === 6 ) {\r\n\t\r\n\t\t\t\t\t\ttexture.needsUpdate = true;\r\n\t\r\n\t\t\t\t\t\tif ( onLoad ) onLoad( texture );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}, undefined, onError );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfor ( var i = 0, il = array.length; i < il; ++ i ) {\r\n\t\r\n\t\t\t\tloadTexture( i );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn texture;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tloadCompressedTexture: function () {\r\n\t\r\n\t\t\tTHREE.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' )\r\n\t\r\n\t\t},\r\n\t\r\n\t\tloadCompressedTextureCube: function () {\r\n\t\r\n\t\t\tTHREE.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' )\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetNormalMap: function ( image, depth ) {\r\n\t\r\n\t\t\t// Adapted from http://www.paulbrunt.co.uk/lab/heightnormal/\r\n\t\r\n\t\t\tvar cross = function ( a, b ) {\r\n\t\r\n\t\t\t\treturn [ a[ 1 ] * b[ 2 ] - a[ 2 ] * b[ 1 ], a[ 2 ] * b[ 0 ] - a[ 0 ] * b[ 2 ], a[ 0 ] * b[ 1 ] - a[ 1 ] * b[ 0 ] ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar subtract = function ( a, b ) {\r\n\t\r\n\t\t\t\treturn [ a[ 0 ] - b[ 0 ], a[ 1 ] - b[ 1 ], a[ 2 ] - b[ 2 ] ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar normalize = function ( a ) {\r\n\t\r\n\t\t\t\tvar l = Math.sqrt( a[ 0 ] * a[ 0 ] + a[ 1 ] * a[ 1 ] + a[ 2 ] * a[ 2 ] );\r\n\t\t\t\treturn [ a[ 0 ] / l, a[ 1 ] / l, a[ 2 ] / l ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tdepth = depth | 1;\r\n\t\r\n\t\t\tvar width = image.width;\r\n\t\t\tvar height = image.height;\r\n\t\r\n\t\t\tvar canvas = document.createElement( 'canvas' );\r\n\t\t\tcanvas.width = width;\r\n\t\t\tcanvas.height = height;\r\n\t\r\n\t\t\tvar context = canvas.getContext( '2d' );\r\n\t\t\tcontext.drawImage( image, 0, 0 );\r\n\t\r\n\t\t\tvar data = context.getImageData( 0, 0, width, height ).data;\r\n\t\t\tvar imageData = context.createImageData( width, height );\r\n\t\t\tvar output = imageData.data;\r\n\t\r\n\t\t\tfor ( var x = 0; x < width; x ++ ) {\r\n\t\r\n\t\t\t\tfor ( var y = 0; y < height; y ++ ) {\r\n\t\r\n\t\t\t\t\tvar ly = y - 1 < 0 ? 0 : y - 1;\r\n\t\t\t\t\tvar uy = y + 1 > height - 1 ? height - 1 : y + 1;\r\n\t\t\t\t\tvar lx = x - 1 < 0 ? 0 : x - 1;\r\n\t\t\t\t\tvar ux = x + 1 > width - 1 ? width - 1 : x + 1;\r\n\t\r\n\t\t\t\t\tvar points = [];\r\n\t\t\t\t\tvar origin = [ 0, 0, data[ ( y * width + x ) * 4 ] / 255 * depth ];\r\n\t\t\t\t\tpoints.push( [ - 1, 0, data[ ( y * width + lx ) * 4 ] / 255 * depth ] );\r\n\t\t\t\t\tpoints.push( [ - 1, - 1, data[ ( ly * width + lx ) * 4 ] / 255 * depth ] );\r\n\t\t\t\t\tpoints.push( [ 0, - 1, data[ ( ly * width + x ) * 4 ] / 255 * depth ] );\r\n\t\t\t\t\tpoints.push( [ 1, - 1, data[ ( ly * width + ux ) * 4 ] / 255 * depth ] );\r\n\t\t\t\t\tpoints.push( [ 1, 0, data[ ( y * width + ux ) * 4 ] / 255 * depth ] );\r\n\t\t\t\t\tpoints.push( [ 1, 1, data[ ( uy * width + ux ) * 4 ] / 255 * depth ] );\r\n\t\t\t\t\tpoints.push( [ 0, 1, data[ ( uy * width + x ) * 4 ] / 255 * depth ] );\r\n\t\t\t\t\tpoints.push( [ - 1, 1, data[ ( uy * width + lx ) * 4 ] / 255 * depth ] );\r\n\t\r\n\t\t\t\t\tvar normals = [];\r\n\t\t\t\t\tvar num_points = points.length;\r\n\t\r\n\t\t\t\t\tfor ( var i = 0; i < num_points; i ++ ) {\r\n\t\r\n\t\t\t\t\t\tvar v1 = points[ i ];\r\n\t\t\t\t\t\tvar v2 = points[ ( i + 1 ) % num_points ];\r\n\t\t\t\t\t\tv1 = subtract( v1, origin );\r\n\t\t\t\t\t\tv2 = subtract( v2, origin );\r\n\t\t\t\t\t\tnormals.push( normalize( cross( v1, v2 ) ) );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tvar normal = [ 0, 0, 0 ];\r\n\t\r\n\t\t\t\t\tfor ( var i = 0; i < normals.length; i ++ ) {\r\n\t\r\n\t\t\t\t\t\tnormal[ 0 ] += normals[ i ][ 0 ];\r\n\t\t\t\t\t\tnormal[ 1 ] += normals[ i ][ 1 ];\r\n\t\t\t\t\t\tnormal[ 2 ] += normals[ i ][ 2 ];\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tnormal[ 0 ] /= normals.length;\r\n\t\t\t\t\tnormal[ 1 ] /= normals.length;\r\n\t\t\t\t\tnormal[ 2 ] /= normals.length;\r\n\t\r\n\t\t\t\t\tvar idx = ( y * width + x ) * 4;\r\n\t\r\n\t\t\t\t\toutput[ idx ] = ( ( normal[ 0 ] + 1.0 ) / 2.0 * 255 ) | 0;\r\n\t\t\t\t\toutput[ idx + 1 ] = ( ( normal[ 1 ] + 1.0 ) / 2.0 * 255 ) | 0;\r\n\t\t\t\t\toutput[ idx + 2 ] = ( normal[ 2 ] * 255 ) | 0;\r\n\t\t\t\t\toutput[ idx + 3 ] = 255;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tcontext.putImageData( imageData, 0, 0 );\r\n\t\r\n\t\t\treturn canvas;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgenerateDataTexture: function ( width, height, color ) {\r\n\t\r\n\t\t\tvar size = width * height;\r\n\t\t\tvar data = new Uint8Array( 3 * size );\r\n\t\r\n\t\t\tvar r = Math.floor( color.r * 255 );\r\n\t\t\tvar g = Math.floor( color.g * 255 );\r\n\t\t\tvar b = Math.floor( color.b * 255 );\r\n\t\r\n\t\t\tfor ( var i = 0; i < size; i ++ ) {\r\n\t\r\n\t\t\t\tdata[ i * 3 ] \t   = r;\r\n\t\t\t\tdata[ i * 3 + 1 ] = g;\r\n\t\t\t\tdata[ i * 3 + 2 ] = b;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar texture = new THREE.DataTexture( data, width, height, THREE.RGBFormat );\r\n\t\t\ttexture.needsUpdate = true;\r\n\t\r\n\t\t\treturn texture;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/SceneUtils.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.SceneUtils = {\r\n\t\r\n\t\tcreateMultiMaterialObject: function ( geometry, materials ) {\r\n\t\r\n\t\t\tvar group = new THREE.Object3D();\r\n\t\r\n\t\t\tfor ( var i = 0, l = materials.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tgroup.add( new THREE.Mesh( geometry, materials[ i ] ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn group;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdetach: function ( child, parent, scene ) {\r\n\t\r\n\t\t\tchild.applyMatrix( parent.matrixWorld );\r\n\t\t\tparent.remove( child );\r\n\t\t\tscene.add( child );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tattach: function ( child, scene, parent ) {\r\n\t\r\n\t\t\tvar matrixWorldInverse = new THREE.Matrix4();\r\n\t\t\tmatrixWorldInverse.getInverse( parent.matrixWorld );\r\n\t\t\tchild.applyMatrix( matrixWorldInverse );\r\n\t\r\n\t\t\tscene.remove( child );\r\n\t\t\tparent.add( child );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/FontUtils.js\r\n\t\r\n\t/**\r\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t *\r\n\t * For Text operations in three.js (See TextGeometry)\r\n\t *\r\n\t * It uses techniques used in:\r\n\t *\r\n\t * \ttypeface.js and canvastext\r\n\t * \t\tFor converting fonts and rendering with javascript\r\n\t *\t\thttp://typeface.neocracy.org\r\n\t *\r\n\t *\tTriangulation ported from AS3\r\n\t *\t\tSimple Polygon Triangulation\r\n\t *\t\thttp://actionsnippet.com/?p=1462\r\n\t *\r\n\t * \tA Method to triangulate shapes with holes\r\n\t *\t\thttp://www.sakri.net/blog/2009/06/12/an-approach-to-triangulating-polygons-with-holes/\r\n\t *\r\n\t */\r\n\t\r\n\tTHREE.FontUtils = {\r\n\t\r\n\t\tfaces: {},\r\n\t\r\n\t\t// Just for now. face[weight][style]\r\n\t\r\n\t\tface: 'helvetiker',\r\n\t\tweight: 'normal',\r\n\t\tstyle: 'normal',\r\n\t\tsize: 150,\r\n\t\tdivisions: 10,\r\n\t\r\n\t\tgetFace: function () {\r\n\t\r\n\t\t\ttry {\r\n\t\r\n\t\t\t\treturn this.faces[ this.face ][ this.weight ][ this.style ];\r\n\t\r\n\t\t\t} catch (e) {\r\n\t\r\n\t\t\t\tthrow \"The font \" + this.face + \" with \" + this.weight + \" weight and \" + this.style + \" style is missing.\"\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t},\r\n\t\r\n\t\tloadFace: function ( data ) {\r\n\t\r\n\t\t\tvar family = data.familyName.toLowerCase();\r\n\t\r\n\t\t\tvar ThreeFont = this;\r\n\t\r\n\t\t\tThreeFont.faces[ family ] = ThreeFont.faces[ family ] || {};\r\n\t\r\n\t\t\tThreeFont.faces[ family ][ data.cssFontWeight ] = ThreeFont.faces[ family ][ data.cssFontWeight ] || {};\r\n\t\t\tThreeFont.faces[ family ][ data.cssFontWeight ][ data.cssFontStyle ] = data;\r\n\t\r\n\t\t\tThreeFont.faces[ family ][ data.cssFontWeight ][ data.cssFontStyle ] = data;\r\n\t\r\n\t\t\treturn data;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdrawText: function ( text ) {\r\n\t\r\n\t\t\t// RenderText\r\n\t\r\n\t\t\tvar i,\r\n\t\t\t\tface = this.getFace(),\r\n\t\t\t\tscale = this.size / face.resolution,\r\n\t\t\t\toffset = 0,\r\n\t\t\t\tchars = String( text ).split( '' ),\r\n\t\t\t\tlength = chars.length;\r\n\t\r\n\t\t\tvar fontPaths = [];\r\n\t\r\n\t\t\tfor ( i = 0; i < length; i ++ ) {\r\n\t\r\n\t\t\t\tvar path = new THREE.Path();\r\n\t\r\n\t\t\t\tvar ret = this.extractGlyphPoints( chars[ i ], face, scale, offset, path );\r\n\t\t\t\toffset += ret.offset;\r\n\t\r\n\t\t\t\tfontPaths.push( ret.path );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// get the width\r\n\t\r\n\t\t\tvar width = offset / 2;\r\n\t\t\t//\r\n\t\t\t// for ( p = 0; p < allPts.length; p++ ) {\r\n\t\t\t//\r\n\t\t\t// \tallPts[ p ].x -= width;\r\n\t\t\t//\r\n\t\t\t// }\r\n\t\r\n\t\t\t//var extract = this.extractPoints( allPts, characterPts );\r\n\t\t\t//extract.contour = allPts;\r\n\t\r\n\t\t\t//extract.paths = fontPaths;\r\n\t\t\t//extract.offset = width;\r\n\t\r\n\t\t\treturn { paths: fontPaths, offset: width };\r\n\t\r\n\t\t},\r\n\t\r\n\t\r\n\t\r\n\t\r\n\t\textractGlyphPoints: function ( c, face, scale, offset, path ) {\r\n\t\r\n\t\t\tvar pts = [];\r\n\t\r\n\t\t\tvar i, i2, divisions,\r\n\t\t\t\toutline, action, length,\r\n\t\t\t\tscaleX, scaleY,\r\n\t\t\t\tx, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2,\r\n\t\t\t\tlaste,\r\n\t\t\t\tglyph = face.glyphs[ c ] || face.glyphs[ '?' ];\r\n\t\r\n\t\t\tif ( ! glyph ) return;\r\n\t\r\n\t\t\tif ( glyph.o ) {\r\n\t\r\n\t\t\t\toutline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );\r\n\t\t\t\tlength = outline.length;\r\n\t\r\n\t\t\t\tscaleX = scale;\r\n\t\t\t\tscaleY = scale;\r\n\t\r\n\t\t\t\tfor ( i = 0; i < length; ) {\r\n\t\r\n\t\t\t\t\taction = outline[ i ++ ];\r\n\t\r\n\t\t\t\t\t//console.log( action );\r\n\t\r\n\t\t\t\t\tswitch ( action ) {\r\n\t\r\n\t\t\t\t\tcase 'm':\r\n\t\r\n\t\t\t\t\t\t// Move To\r\n\t\r\n\t\t\t\t\t\tx = outline[ i ++ ] * scaleX + offset;\r\n\t\t\t\t\t\ty = outline[ i ++ ] * scaleY;\r\n\t\r\n\t\t\t\t\t\tpath.moveTo( x, y );\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'l':\r\n\t\r\n\t\t\t\t\t\t// Line To\r\n\t\r\n\t\t\t\t\t\tx = outline[ i ++ ] * scaleX + offset;\r\n\t\t\t\t\t\ty = outline[ i ++ ] * scaleY;\r\n\t\t\t\t\t\tpath.lineTo( x, y );\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'q':\r\n\t\r\n\t\t\t\t\t\t// QuadraticCurveTo\r\n\t\r\n\t\t\t\t\t\tcpx  = outline[ i ++ ] * scaleX + offset;\r\n\t\t\t\t\t\tcpy  = outline[ i ++ ] * scaleY;\r\n\t\t\t\t\t\tcpx1 = outline[ i ++ ] * scaleX + offset;\r\n\t\t\t\t\t\tcpy1 = outline[ i ++ ] * scaleY;\r\n\t\r\n\t\t\t\t\t\tpath.quadraticCurveTo( cpx1, cpy1, cpx, cpy );\r\n\t\r\n\t\t\t\t\t\tlaste = pts[ pts.length - 1 ];\r\n\t\r\n\t\t\t\t\t\tif ( laste ) {\r\n\t\r\n\t\t\t\t\t\t\tcpx0 = laste.x;\r\n\t\t\t\t\t\t\tcpy0 = laste.y;\r\n\t\r\n\t\t\t\t\t\t\tfor ( i2 = 1, divisions = this.divisions; i2 <= divisions; i2 ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\tvar t = i2 / divisions;\r\n\t\t\t\t\t\t\t\tTHREE.Shape.Utils.b2( t, cpx0, cpx1, cpx );\r\n\t\t\t\t\t\t\t\tTHREE.Shape.Utils.b2( t, cpy0, cpy1, cpy );\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'b':\r\n\t\r\n\t\t\t\t\t\t// Cubic Bezier Curve\r\n\t\r\n\t\t\t\t\t\tcpx  = outline[ i ++ ] *  scaleX + offset;\r\n\t\t\t\t\t\tcpy  = outline[ i ++ ] *  scaleY;\r\n\t\t\t\t\t\tcpx1 = outline[ i ++ ] *  scaleX + offset;\r\n\t\t\t\t\t\tcpy1 = outline[ i ++ ] *  scaleY;\r\n\t\t\t\t\t\tcpx2 = outline[ i ++ ] *  scaleX + offset;\r\n\t\t\t\t\t\tcpy2 = outline[ i ++ ] *  scaleY;\r\n\t\r\n\t\t\t\t\t\tpath.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );\r\n\t\r\n\t\t\t\t\t\tlaste = pts[ pts.length - 1 ];\r\n\t\r\n\t\t\t\t\t\tif ( laste ) {\r\n\t\r\n\t\t\t\t\t\t\tcpx0 = laste.x;\r\n\t\t\t\t\t\t\tcpy0 = laste.y;\r\n\t\r\n\t\t\t\t\t\t\tfor ( i2 = 1, divisions = this.divisions; i2 <= divisions; i2 ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\tvar t = i2 / divisions;\r\n\t\t\t\t\t\t\t\tTHREE.Shape.Utils.b3( t, cpx0, cpx1, cpx2, cpx );\r\n\t\t\t\t\t\t\t\tTHREE.Shape.Utils.b3( t, cpy0, cpy1, cpy2, cpy );\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\r\n\t\r\n\t\r\n\t\t\treturn { offset: glyph.ha * scale, path:path };\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\tTHREE.FontUtils.generateShapes = function ( text, parameters ) {\r\n\t\r\n\t\t// Parameters \r\n\t\r\n\t\tparameters = parameters || {};\r\n\t\r\n\t\tvar size = parameters.size !== undefined ? parameters.size : 100;\r\n\t\tvar curveSegments = parameters.curveSegments !== undefined ? parameters.curveSegments : 4;\r\n\t\r\n\t\tvar font = parameters.font !== undefined ? parameters.font : 'helvetiker';\r\n\t\tvar weight = parameters.weight !== undefined ? parameters.weight : 'normal';\r\n\t\tvar style = parameters.style !== undefined ? parameters.style : 'normal';\r\n\t\r\n\t\tTHREE.FontUtils.size = size;\r\n\t\tTHREE.FontUtils.divisions = curveSegments;\r\n\t\r\n\t\tTHREE.FontUtils.face = font;\r\n\t\tTHREE.FontUtils.weight = weight;\r\n\t\tTHREE.FontUtils.style = style;\r\n\t\r\n\t\t// Get a Font data json object\r\n\t\r\n\t\tvar data = THREE.FontUtils.drawText( text );\r\n\t\r\n\t\tvar paths = data.paths;\r\n\t\tvar shapes = [];\r\n\t\r\n\t\tfor ( var p = 0, pl = paths.length; p < pl; p ++ ) {\r\n\t\r\n\t\t\tArray.prototype.push.apply( shapes, paths[ p ].toShapes() );\r\n\t\r\n\t\t}\r\n\t\r\n\t\treturn shapes;\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\t/**\r\n\t * This code is a quick port of code written in C++ which was submitted to\r\n\t * flipcode.com by John W. Ratcliff  // July 22, 2000\r\n\t * See original code and more information here:\r\n\t * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml\r\n\t *\r\n\t * ported to actionscript by Zevan Rosser\r\n\t * www.actionsnippet.com\r\n\t *\r\n\t * ported to javascript by Joshua Koo\r\n\t * http://www.lab4games.net/zz85/blog\r\n\t *\r\n\t */\r\n\t\r\n\t\r\n\t( function ( namespace ) {\r\n\t\r\n\t\tvar EPSILON = 0.0000000001;\r\n\t\r\n\t\t// takes in an contour array and returns\r\n\t\r\n\t\tvar process = function ( contour, indices ) {\r\n\t\r\n\t\t\tvar n = contour.length;\r\n\t\r\n\t\t\tif ( n < 3 ) return null;\r\n\t\r\n\t\t\tvar result = [],\r\n\t\t\t\tverts = [],\r\n\t\t\t\tvertIndices = [];\r\n\t\r\n\t\t\t/* we want a counter-clockwise polygon in verts */\r\n\t\r\n\t\t\tvar u, v, w;\r\n\t\r\n\t\t\tif ( area( contour ) > 0.0 ) {\r\n\t\r\n\t\t\t\tfor ( v = 0; v < n; v ++ ) verts[ v ] = v;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tfor ( v = 0; v < n; v ++ ) verts[ v ] = ( n - 1 ) - v;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar nv = n;\r\n\t\r\n\t\t\t/*  remove nv - 2 vertices, creating 1 triangle every time */\r\n\t\r\n\t\t\tvar count = 2 * nv;   /* error detection */\r\n\t\r\n\t\t\tfor ( v = nv - 1; nv > 2; ) {\r\n\t\r\n\t\t\t\t/* if we loop, it is probably a non-simple polygon */\r\n\t\r\n\t\t\t\tif ( ( count -- ) <= 0 ) {\r\n\t\r\n\t\t\t\t\t//** Triangulate: ERROR - probable bad polygon!\r\n\t\r\n\t\t\t\t\t//throw ( \"Warning, unable to triangulate polygon!\" );\r\n\t\t\t\t\t//return null;\r\n\t\t\t\t\t// Sometimes warning is fine, especially polygons are triangulated in reverse.\r\n\t\t\t\t\tTHREE.warn( 'THREE.FontUtils: Warning, unable to triangulate polygon! in Triangulate.process()' );\r\n\t\r\n\t\t\t\t\tif ( indices ) return vertIndices;\r\n\t\t\t\t\treturn result;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t/* three consecutive vertices in current polygon, <u,v,w> */\r\n\t\r\n\t\t\t\tu = v; \t \tif ( nv <= u ) u = 0;     /* previous */\r\n\t\t\t\tv = u + 1;  if ( nv <= v ) v = 0;     /* new v    */\r\n\t\t\t\tw = v + 1;  if ( nv <= w ) w = 0;     /* next     */\r\n\t\r\n\t\t\t\tif ( snip( contour, u, v, w, nv, verts ) ) {\r\n\t\r\n\t\t\t\t\tvar a, b, c, s, t;\r\n\t\r\n\t\t\t\t\t/* true names of the vertices */\r\n\t\r\n\t\t\t\t\ta = verts[ u ];\r\n\t\t\t\t\tb = verts[ v ];\r\n\t\t\t\t\tc = verts[ w ];\r\n\t\r\n\t\t\t\t\t/* output Triangle */\r\n\t\r\n\t\t\t\t\tresult.push( [ contour[ a ],\r\n\t\t\t\t\t\tcontour[ b ],\r\n\t\t\t\t\t\tcontour[ c ] ] );\r\n\t\r\n\t\r\n\t\t\t\t\tvertIndices.push( [ verts[ u ], verts[ v ], verts[ w ] ] );\r\n\t\r\n\t\t\t\t\t/* remove v from the remaining polygon */\r\n\t\r\n\t\t\t\t\tfor ( s = v, t = v + 1; t < nv; s ++, t ++ ) {\r\n\t\r\n\t\t\t\t\t\tverts[ s ] = verts[ t ];\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tnv --;\r\n\t\r\n\t\t\t\t\t/* reset error detection counter */\r\n\t\r\n\t\t\t\t\tcount = 2 * nv;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( indices ) return vertIndices;\r\n\t\t\treturn result;\r\n\t\r\n\t\t};\r\n\t\r\n\t\t// calculate area of the contour polygon\r\n\t\r\n\t\tvar area = function ( contour ) {\r\n\t\r\n\t\t\tvar n = contour.length;\r\n\t\t\tvar a = 0.0;\r\n\t\r\n\t\t\tfor ( var p = n - 1, q = 0; q < n; p = q ++ ) {\r\n\t\r\n\t\t\t\ta += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn a * 0.5;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tvar snip = function ( contour, u, v, w, n, verts ) {\r\n\t\r\n\t\t\tvar p;\r\n\t\t\tvar ax, ay, bx, by;\r\n\t\t\tvar cx, cy, px, py;\r\n\t\r\n\t\t\tax = contour[ verts[ u ] ].x;\r\n\t\t\tay = contour[ verts[ u ] ].y;\r\n\t\r\n\t\t\tbx = contour[ verts[ v ] ].x;\r\n\t\t\tby = contour[ verts[ v ] ].y;\r\n\t\r\n\t\t\tcx = contour[ verts[ w ] ].x;\r\n\t\t\tcy = contour[ verts[ w ] ].y;\r\n\t\r\n\t\t\tif ( EPSILON > ( ( ( bx - ax ) * ( cy - ay ) ) - ( ( by - ay ) * ( cx - ax ) ) ) ) return false;\r\n\t\r\n\t\t\tvar aX, aY, bX, bY, cX, cY;\r\n\t\t\tvar apx, apy, bpx, bpy, cpx, cpy;\r\n\t\t\tvar cCROSSap, bCROSScp, aCROSSbp;\r\n\t\r\n\t\t\taX = cx - bx;  aY = cy - by;\r\n\t\t\tbX = ax - cx;  bY = ay - cy;\r\n\t\t\tcX = bx - ax;  cY = by - ay;\r\n\t\r\n\t\t\tfor ( p = 0; p < n; p ++ ) {\r\n\t\r\n\t\t\t\tpx = contour[ verts[ p ] ].x\r\n\t\t\t\tpy = contour[ verts[ p ] ].y\r\n\t\r\n\t\t\t\tif ( ( ( px === ax ) && ( py === ay ) ) ||\r\n\t\t\t\t\t ( ( px === bx ) && ( py === by ) ) ||\r\n\t\t\t\t\t ( ( px === cx ) && ( py === cy ) ) )\tcontinue;\r\n\t\r\n\t\t\t\tapx = px - ax;  apy = py - ay;\r\n\t\t\t\tbpx = px - bx;  bpy = py - by;\r\n\t\t\t\tcpx = px - cx;  cpy = py - cy;\r\n\t\r\n\t\t\t\t// see if p is inside triangle abc\r\n\t\r\n\t\t\t\taCROSSbp = aX * bpy - aY * bpx;\r\n\t\t\t\tcCROSSap = cX * apy - cY * apx;\r\n\t\t\t\tbCROSScp = bX * cpy - bY * cpx;\r\n\t\r\n\t\t\t\tif ( ( aCROSSbp >= - EPSILON ) && ( bCROSScp >= - EPSILON ) && ( cCROSSap >= - EPSILON ) ) return false;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn true;\r\n\t\r\n\t\t};\r\n\t\r\n\t\r\n\t\tnamespace.Triangulate = process;\r\n\t\tnamespace.Triangulate.area = area;\r\n\t\r\n\t\treturn namespace;\r\n\t\r\n\t} )( THREE.FontUtils );\r\n\t\r\n\t// To use the typeface.js face files, hook up the API\r\n\tself._typeface_js = { faces: THREE.FontUtils.faces, loadFace: THREE.FontUtils.loadFace };\r\n\tTHREE.typeface_js = self._typeface_js;\r\n\t\r\n\t// File:src/extras/audio/Audio.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.Audio = function ( listener ) {\r\n\t\r\n\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t\tthis.type = 'Audio';\r\n\t\r\n\t\tthis.context = listener.context;\r\n\t\tthis.source = this.context.createBufferSource();\r\n\t\tthis.source.onended = this.onEnded.bind(this);\r\n\t\r\n\t\tthis.gain = this.context.createGain();\r\n\t\tthis.gain.connect( this.context.destination );\r\n\t\r\n\t\tthis.panner = this.context.createPanner();\r\n\t\tthis.panner.connect( this.gain );\r\n\t\r\n\t\tthis.autoplay = false;\r\n\t\r\n\t\tthis.startTime = 0;\r\n\t\tthis.isPlaying = false;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Audio.prototype = Object.create( THREE.Object3D.prototype );\r\n\tTHREE.Audio.prototype.constructor = THREE.Audio;\r\n\t\r\n\tTHREE.Audio.prototype.load = function ( file ) {\r\n\t\r\n\t\tvar scope = this;\r\n\t\r\n\t\tvar request = new XMLHttpRequest();\r\n\t\trequest.open( 'GET', file, true );\r\n\t\trequest.responseType = 'arraybuffer';\r\n\t\trequest.onload = function ( e ) {\r\n\t\r\n\t\t\tscope.context.decodeAudioData( this.response, function ( buffer ) {\r\n\t\r\n\t\t\t\tscope.source.buffer = buffer;\r\n\t\r\n\t\t\t\tif( scope.autoplay ) scope.play();\r\n\t\r\n\t\t\t} );\r\n\t\r\n\t\t};\r\n\t\trequest.send();\r\n\t\r\n\t\treturn this;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Audio.prototype.play = function () {\r\n\t\r\n\t\tif ( this.isPlaying === true ) {\r\n\t\r\n\t\t\tTHREE.warn( 'THREE.Audio: Audio is already playing.' );\r\n\t\t\treturn;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar source = this.context.createBufferSource();\r\n\t\r\n\t\tsource.buffer = this.source.buffer;\r\n\t\tsource.loop = this.source.loop;\r\n\t\tsource.onended = this.source.onended;\r\n\t\tsource.connect( this.panner );\r\n\t\tsource.start( 0, this.startTime );\r\n\t\r\n\t\tthis.isPlaying = true;\r\n\t\r\n\t\tthis.source = source;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Audio.prototype.pause = function () {\r\n\t\r\n\t\tthis.source.stop();\r\n\t\tthis.startTime = this.context.currentTime;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Audio.prototype.stop = function () {\r\n\t\r\n\t\tthis.source.stop();\r\n\t\tthis.startTime = 0;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Audio.prototype.onEnded = function() {\r\n\t\r\n\t\tthis.isPlaying = false;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Audio.prototype.setLoop = function ( value ) {\r\n\t\r\n\t\tthis.source.loop = value;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Audio.prototype.setRefDistance = function ( value ) {\r\n\t\r\n\t\tthis.panner.refDistance = value;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Audio.prototype.setRolloffFactor = function ( value ) {\r\n\t\r\n\t\tthis.panner.rolloffFactor = value;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Audio.prototype.setVolume = function ( value ) {\r\n\t\r\n\t\tthis.gain.gain.value = value;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Audio.prototype.updateMatrixWorld = ( function () {\r\n\t\r\n\t\tvar position = new THREE.Vector3();\r\n\t\r\n\t\treturn function ( force ) {\r\n\t\r\n\t\t\tTHREE.Object3D.prototype.updateMatrixWorld.call( this, force );\r\n\t\r\n\t\t\tposition.setFromMatrixPosition( this.matrixWorld );\r\n\t\r\n\t\t\tthis.panner.setPosition( position.x, position.y, position.z );\r\n\t\r\n\t\t};\r\n\t\r\n\t} )();\r\n\t\r\n\t// File:src/extras/audio/AudioListener.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.AudioListener = function () {\r\n\t\r\n\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t\tthis.type = 'AudioListener';\r\n\t\r\n\t\tthis.context = new ( window.AudioContext || window.webkitAudioContext )();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.AudioListener.prototype = Object.create( THREE.Object3D.prototype );\r\n\tTHREE.AudioListener.prototype.constructor = THREE.AudioListener;\r\n\t\r\n\tTHREE.AudioListener.prototype.updateMatrixWorld = ( function () {\r\n\t\r\n\t\tvar position = new THREE.Vector3();\r\n\t\tvar quaternion = new THREE.Quaternion();\r\n\t\tvar scale = new THREE.Vector3();\r\n\t\r\n\t\tvar orientation = new THREE.Vector3();\r\n\t\tvar velocity = new THREE.Vector3();\r\n\t\r\n\t\tvar positionPrev = new THREE.Vector3();\r\n\t\r\n\t\treturn function ( force ) {\r\n\t\r\n\t\t\tTHREE.Object3D.prototype.updateMatrixWorld.call( this, force );\r\n\t\r\n\t\t\tvar listener = this.context.listener;\r\n\t\t\tvar up = this.up;\r\n\t\r\n\t\t\tthis.matrixWorld.decompose( position, quaternion, scale );\r\n\t\r\n\t\t\torientation.set( 0, 0, -1 ).applyQuaternion( quaternion );\r\n\t\t\tvelocity.subVectors( position, positionPrev );\r\n\t\r\n\t\t\tlistener.setPosition( position.x, position.y, position.z );\r\n\t\t\tlistener.setOrientation( orientation.x, orientation.y, orientation.z, up.x, up.y, up.z );\r\n\t\t\tlistener.setVelocity( velocity.x, velocity.y, velocity.z );\r\n\t\r\n\t\t\tpositionPrev.copy( position );\r\n\t\r\n\t\t};\r\n\t\r\n\t} )();\r\n\t\r\n\t// File:src/extras/core/Curve.js\r\n\t\r\n\t/**\r\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\r\n\t * Extensible curve object\r\n\t *\r\n\t * Some common of Curve methods\r\n\t * .getPoint(t), getTangent(t)\r\n\t * .getPointAt(u), getTagentAt(u)\r\n\t * .getPoints(), .getSpacedPoints()\r\n\t * .getLength()\r\n\t * .updateArcLengths()\r\n\t *\r\n\t * This following classes subclasses THREE.Curve:\r\n\t *\r\n\t * -- 2d classes --\r\n\t * THREE.LineCurve\r\n\t * THREE.QuadraticBezierCurve\r\n\t * THREE.CubicBezierCurve\r\n\t * THREE.SplineCurve\r\n\t * THREE.ArcCurve\r\n\t * THREE.EllipseCurve\r\n\t *\r\n\t * -- 3d classes --\r\n\t * THREE.LineCurve3\r\n\t * THREE.QuadraticBezierCurve3\r\n\t * THREE.CubicBezierCurve3\r\n\t * THREE.SplineCurve3\r\n\t * THREE.ClosedSplineCurve3\r\n\t *\r\n\t * A series of curves can be represented as a THREE.CurvePath\r\n\t *\r\n\t **/\r\n\t\r\n\t/**************************************************************\r\n\t *\tAbstract Curve base class\r\n\t **************************************************************/\r\n\t\r\n\tTHREE.Curve = function () {\r\n\t\r\n\t};\r\n\t\r\n\t// Virtual base class method to overwrite and implement in subclasses\r\n\t//\t- t [0 .. 1]\r\n\t\r\n\tTHREE.Curve.prototype.getPoint = function ( t ) {\r\n\t\r\n\t\tTHREE.warn( \"THREE.Curve: Warning, getPoint() not implemented!\" );\r\n\t\treturn null;\r\n\t\r\n\t};\r\n\t\r\n\t// Get point at relative position in curve according to arc length\r\n\t// - u [0 .. 1]\r\n\t\r\n\tTHREE.Curve.prototype.getPointAt = function ( u ) {\r\n\t\r\n\t\tvar t = this.getUtoTmapping( u );\r\n\t\treturn this.getPoint( t );\r\n\t\r\n\t};\r\n\t\r\n\t// Get sequence of points using getPoint( t )\r\n\t\r\n\tTHREE.Curve.prototype.getPoints = function ( divisions ) {\r\n\t\r\n\t\tif ( ! divisions ) divisions = 5;\r\n\t\r\n\t\tvar d, pts = [];\r\n\t\r\n\t\tfor ( d = 0; d <= divisions; d ++ ) {\r\n\t\r\n\t\t\tpts.push( this.getPoint( d / divisions ) );\r\n\t\r\n\t\t}\r\n\t\r\n\t\treturn pts;\r\n\t\r\n\t};\r\n\t\r\n\t// Get sequence of points using getPointAt( u )\r\n\t\r\n\tTHREE.Curve.prototype.getSpacedPoints = function ( divisions ) {\r\n\t\r\n\t\tif ( ! divisions ) divisions = 5;\r\n\t\r\n\t\tvar d, pts = [];\r\n\t\r\n\t\tfor ( d = 0; d <= divisions; d ++ ) {\r\n\t\r\n\t\t\tpts.push( this.getPointAt( d / divisions ) );\r\n\t\r\n\t\t}\r\n\t\r\n\t\treturn pts;\r\n\t\r\n\t};\r\n\t\r\n\t// Get total curve arc length\r\n\t\r\n\tTHREE.Curve.prototype.getLength = function () {\r\n\t\r\n\t\tvar lengths = this.getLengths();\r\n\t\treturn lengths[ lengths.length - 1 ];\r\n\t\r\n\t};\r\n\t\r\n\t// Get list of cumulative segment lengths\r\n\t\r\n\tTHREE.Curve.prototype.getLengths = function ( divisions ) {\r\n\t\r\n\t\tif ( ! divisions ) divisions = (this.__arcLengthDivisions) ? (this.__arcLengthDivisions) : 200;\r\n\t\r\n\t\tif ( this.cacheArcLengths\r\n\t\t\t&& ( this.cacheArcLengths.length == divisions + 1 )\r\n\t\t\t&& ! this.needsUpdate) {\r\n\t\r\n\t\t\t//console.log( \"cached\", this.cacheArcLengths );\r\n\t\t\treturn this.cacheArcLengths;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.needsUpdate = false;\r\n\t\r\n\t\tvar cache = [];\r\n\t\tvar current, last = this.getPoint( 0 );\r\n\t\tvar p, sum = 0;\r\n\t\r\n\t\tcache.push( 0 );\r\n\t\r\n\t\tfor ( p = 1; p <= divisions; p ++ ) {\r\n\t\r\n\t\t\tcurrent = this.getPoint ( p / divisions );\r\n\t\t\tsum += current.distanceTo( last );\r\n\t\t\tcache.push( sum );\r\n\t\t\tlast = current;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.cacheArcLengths = cache;\r\n\t\r\n\t\treturn cache; // { sums: cache, sum:sum }; Sum is in the last element.\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\tTHREE.Curve.prototype.updateArcLengths = function() {\r\n\t\tthis.needsUpdate = true;\r\n\t\tthis.getLengths();\r\n\t};\r\n\t\r\n\t// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equi distance\r\n\t\r\n\tTHREE.Curve.prototype.getUtoTmapping = function ( u, distance ) {\r\n\t\r\n\t\tvar arcLengths = this.getLengths();\r\n\t\r\n\t\tvar i = 0, il = arcLengths.length;\r\n\t\r\n\t\tvar targetArcLength; // The targeted u distance value to get\r\n\t\r\n\t\tif ( distance ) {\r\n\t\r\n\t\t\ttargetArcLength = distance;\r\n\t\r\n\t\t} else {\r\n\t\r\n\t\t\ttargetArcLength = u * arcLengths[ il - 1 ];\r\n\t\r\n\t\t}\r\n\t\r\n\t\t//var time = Date.now();\r\n\t\r\n\t\t// binary search for the index with largest value smaller than target u distance\r\n\t\r\n\t\tvar low = 0, high = il - 1, comparison;\r\n\t\r\n\t\twhile ( low <= high ) {\r\n\t\r\n\t\t\ti = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats\r\n\t\r\n\t\t\tcomparison = arcLengths[ i ] - targetArcLength;\r\n\t\r\n\t\t\tif ( comparison < 0 ) {\r\n\t\r\n\t\t\t\tlow = i + 1;\r\n\t\r\n\t\t\t} else if ( comparison > 0 ) {\r\n\t\r\n\t\t\t\thigh = i - 1;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\thigh = i;\r\n\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t// DONE\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\ti = high;\r\n\t\r\n\t\t//console.log('b' , i, low, high, Date.now()- time);\r\n\t\r\n\t\tif ( arcLengths[ i ] == targetArcLength ) {\r\n\t\r\n\t\t\tvar t = i / ( il - 1 );\r\n\t\t\treturn t;\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// we could get finer grain at lengths, or use simple interpolatation between two points\r\n\t\r\n\t\tvar lengthBefore = arcLengths[ i ];\r\n\t\tvar lengthAfter = arcLengths[ i + 1 ];\r\n\t\r\n\t\tvar segmentLength = lengthAfter - lengthBefore;\r\n\t\r\n\t    // determine where we are between the 'before' and 'after' points\r\n\t\r\n\t\tvar segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;\r\n\t\r\n\t    // add that fractional amount to t\r\n\t\r\n\t\tvar t = ( i + segmentFraction ) / ( il - 1 );\r\n\t\r\n\t\treturn t;\r\n\t\r\n\t};\r\n\t\r\n\t// Returns a unit vector tangent at t\r\n\t// In case any sub curve does not implement its tangent derivation,\r\n\t// 2 points a small delta apart will be used to find its gradient\r\n\t// which seems to give a reasonable approximation\r\n\t\r\n\tTHREE.Curve.prototype.getTangent = function( t ) {\r\n\t\r\n\t\tvar delta = 0.0001;\r\n\t\tvar t1 = t - delta;\r\n\t\tvar t2 = t + delta;\r\n\t\r\n\t\t// Capping in case of danger\r\n\t\r\n\t\tif ( t1 < 0 ) t1 = 0;\r\n\t\tif ( t2 > 1 ) t2 = 1;\r\n\t\r\n\t\tvar pt1 = this.getPoint( t1 );\r\n\t\tvar pt2 = this.getPoint( t2 );\r\n\t\r\n\t\tvar vec = pt2.clone().sub(pt1);\r\n\t\treturn vec.normalize();\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\tTHREE.Curve.prototype.getTangentAt = function ( u ) {\r\n\t\r\n\t\tvar t = this.getUtoTmapping( u );\r\n\t\treturn this.getTangent( t );\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\t\r\n\t\r\n\t\r\n\t/**************************************************************\r\n\t *\tUtils\r\n\t **************************************************************/\r\n\t\r\n\tTHREE.Curve.Utils = {\r\n\t\r\n\t\ttangentQuadraticBezier: function ( t, p0, p1, p2 ) {\r\n\t\r\n\t\t\treturn 2 * ( 1 - t ) * ( p1 - p0 ) + 2 * t * ( p2 - p1 );\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// Puay Bing, thanks for helping with this derivative!\r\n\t\r\n\t\ttangentCubicBezier: function (t, p0, p1, p2, p3 ) {\r\n\t\r\n\t\t\treturn - 3 * p0 * (1 - t) * (1 - t)  +\r\n\t\t\t\t3 * p1 * (1 - t) * (1 - t) - 6 * t * p1 * (1 - t) +\r\n\t\t\t\t6 * t *  p2 * (1 - t) - 3 * t * t * p2 +\r\n\t\t\t\t3 * t * t * p3;\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttangentSpline: function ( t, p0, p1, p2, p3 ) {\r\n\t\r\n\t\t\t// To check if my formulas are correct\r\n\t\r\n\t\t\tvar h00 = 6 * t * t - 6 * t; \t// derived from 2t^3 â 3t^2 + 1\r\n\t\t\tvar h10 = 3 * t * t - 4 * t + 1; // t^3 â 2t^2 + t\r\n\t\t\tvar h01 = - 6 * t * t + 6 * t; \t// â 2t3 + 3t2\r\n\t\t\tvar h11 = 3 * t * t - 2 * t;\t// t3 â t2\r\n\t\r\n\t\t\treturn h00 + h10 + h01 + h11;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// Catmull-Rom\r\n\t\r\n\t\tinterpolate: function( p0, p1, p2, p3, t ) {\r\n\t\r\n\t\t\tvar v0 = ( p2 - p0 ) * 0.5;\r\n\t\t\tvar v1 = ( p3 - p1 ) * 0.5;\r\n\t\t\tvar t2 = t * t;\r\n\t\t\tvar t3 = t * t2;\r\n\t\t\treturn ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\t// TODO: Transformation for Curves?\r\n\t\r\n\t/**************************************************************\r\n\t *\t3D Curves\r\n\t **************************************************************/\r\n\t\r\n\t// A Factory method for creating new curve subclasses\r\n\t\r\n\tTHREE.Curve.create = function ( constructor, getPointFunc ) {\r\n\t\r\n\t\tconstructor.prototype = Object.create( THREE.Curve.prototype );\r\n\t\tconstructor.prototype.constructor = constructor;\r\n\t\tconstructor.prototype.getPoint = getPointFunc;\r\n\t\r\n\t\treturn constructor;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/core/CurvePath.js\r\n\t\r\n\t/**\r\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\r\n\t *\r\n\t **/\r\n\t\r\n\t/**************************************************************\r\n\t *\tCurved Path - a curve path is simply a array of connected\r\n\t *  curves, but retains the api of a curve\r\n\t **************************************************************/\r\n\t\r\n\tTHREE.CurvePath = function () {\r\n\t\r\n\t\tthis.curves = [];\r\n\t\tthis.bends = [];\r\n\t\t\r\n\t\tthis.autoClose = false; // Automatically closes the path\r\n\t};\r\n\t\r\n\tTHREE.CurvePath.prototype = Object.create( THREE.Curve.prototype );\r\n\tTHREE.CurvePath.prototype.constructor = THREE.CurvePath;\r\n\t\r\n\tTHREE.CurvePath.prototype.add = function ( curve ) {\r\n\t\r\n\t\tthis.curves.push( curve );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.CurvePath.prototype.checkConnection = function() {\r\n\t\t// TODO\r\n\t\t// If the ending of curve is not connected to the starting\r\n\t\t// or the next curve, then, this is not a real path\r\n\t};\r\n\t\r\n\tTHREE.CurvePath.prototype.closePath = function() {\r\n\t\t// TODO Test\r\n\t\t// and verify for vector3 (needs to implement equals)\r\n\t\t// Add a line curve if start and end of lines are not connected\r\n\t\tvar startPoint = this.curves[0].getPoint(0);\r\n\t\tvar endPoint = this.curves[this.curves.length - 1].getPoint(1);\r\n\t\t\r\n\t\tif (! startPoint.equals(endPoint)) {\r\n\t\t\tthis.curves.push( new THREE.LineCurve(endPoint, startPoint) );\r\n\t\t}\r\n\t\t\r\n\t};\r\n\t\r\n\t// To get accurate point with reference to\r\n\t// entire path distance at time t,\r\n\t// following has to be done:\r\n\t\r\n\t// 1. Length of each sub path have to be known\r\n\t// 2. Locate and identify type of curve\r\n\t// 3. Get t for the curve\r\n\t// 4. Return curve.getPointAt(t')\r\n\t\r\n\tTHREE.CurvePath.prototype.getPoint = function( t ) {\r\n\t\r\n\t\tvar d = t * this.getLength();\r\n\t\tvar curveLengths = this.getCurveLengths();\r\n\t\tvar i = 0, diff, curve;\r\n\t\r\n\t\t// To think about boundaries points.\r\n\t\r\n\t\twhile ( i < curveLengths.length ) {\r\n\t\r\n\t\t\tif ( curveLengths[ i ] >= d ) {\r\n\t\r\n\t\t\t\tdiff = curveLengths[ i ] - d;\r\n\t\t\t\tcurve = this.curves[ i ];\r\n\t\r\n\t\t\t\tvar u = 1 - diff / curve.getLength();\r\n\t\r\n\t\t\t\treturn curve.getPointAt( u );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\ti ++;\r\n\t\r\n\t\t}\r\n\t\r\n\t\treturn null;\r\n\t\r\n\t\t// loop where sum != 0, sum > d , sum+1 <d\r\n\t\r\n\t};\r\n\t\r\n\t/*\r\n\tTHREE.CurvePath.prototype.getTangent = function( t ) {\r\n\t};*/\r\n\t\r\n\t\r\n\t// We cannot use the default THREE.Curve getPoint() with getLength() because in\r\n\t// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath\r\n\t// getPoint() depends on getLength\r\n\t\r\n\tTHREE.CurvePath.prototype.getLength = function() {\r\n\t\r\n\t\tvar lens = this.getCurveLengths();\r\n\t\treturn lens[ lens.length - 1 ];\r\n\t\r\n\t};\r\n\t\r\n\t// Compute lengths and cache them\r\n\t// We cannot overwrite getLengths() because UtoT mapping uses it.\r\n\t\r\n\tTHREE.CurvePath.prototype.getCurveLengths = function() {\r\n\t\r\n\t\t// We use cache values if curves and cache array are same length\r\n\t\r\n\t\tif ( this.cacheLengths && this.cacheLengths.length == this.curves.length ) {\r\n\t\r\n\t\t\treturn this.cacheLengths;\r\n\t\r\n\t\t};\r\n\t\r\n\t\t// Get length of subsurve\r\n\t\t// Push sums into cached array\r\n\t\r\n\t\tvar lengths = [], sums = 0;\r\n\t\tvar i, il = this.curves.length;\r\n\t\r\n\t\tfor ( i = 0; i < il; i ++ ) {\r\n\t\r\n\t\t\tsums += this.curves[ i ].getLength();\r\n\t\t\tlengths.push( sums );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.cacheLengths = lengths;\r\n\t\r\n\t\treturn lengths;\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\t\r\n\t// Returns min and max coordinates\r\n\t\r\n\tTHREE.CurvePath.prototype.getBoundingBox = function () {\r\n\t\r\n\t\tvar points = this.getPoints();\r\n\t\r\n\t\tvar maxX, maxY, maxZ;\r\n\t\tvar minX, minY, minZ;\r\n\t\r\n\t\tmaxX = maxY = Number.NEGATIVE_INFINITY;\r\n\t\tminX = minY = Number.POSITIVE_INFINITY;\r\n\t\r\n\t\tvar p, i, il, sum;\r\n\t\r\n\t\tvar v3 = points[0] instanceof THREE.Vector3;\r\n\t\r\n\t\tsum = v3 ? new THREE.Vector3() : new THREE.Vector2();\r\n\t\r\n\t\tfor ( i = 0, il = points.length; i < il; i ++ ) {\r\n\t\r\n\t\t\tp = points[ i ];\r\n\t\r\n\t\t\tif ( p.x > maxX ) maxX = p.x;\r\n\t\t\telse if ( p.x < minX ) minX = p.x;\r\n\t\r\n\t\t\tif ( p.y > maxY ) maxY = p.y;\r\n\t\t\telse if ( p.y < minY ) minY = p.y;\r\n\t\r\n\t\t\tif ( v3 ) {\r\n\t\r\n\t\t\t\tif ( p.z > maxZ ) maxZ = p.z;\r\n\t\t\t\telse if ( p.z < minZ ) minZ = p.z;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tsum.add( p );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar ret = {\r\n\t\r\n\t\t\tminX: minX,\r\n\t\t\tminY: minY,\r\n\t\t\tmaxX: maxX,\r\n\t\t\tmaxY: maxY\r\n\t\r\n\t\t};\r\n\t\r\n\t\tif ( v3 ) {\r\n\t\r\n\t\t\tret.maxZ = maxZ;\r\n\t\t\tret.minZ = minZ;\r\n\t\r\n\t\t}\r\n\t\r\n\t\treturn ret;\r\n\t\r\n\t};\r\n\t\r\n\t/**************************************************************\r\n\t *\tCreate Geometries Helpers\r\n\t **************************************************************/\r\n\t\r\n\t/// Generate geometry from path points (for Line or Points objects)\r\n\t\r\n\tTHREE.CurvePath.prototype.createPointsGeometry = function( divisions ) {\r\n\t\r\n\t\tvar pts = this.getPoints( divisions, true );\r\n\t\treturn this.createGeometry( pts );\r\n\t\r\n\t};\r\n\t\r\n\t// Generate geometry from equidistance sampling along the path\r\n\t\r\n\tTHREE.CurvePath.prototype.createSpacedPointsGeometry = function( divisions ) {\r\n\t\r\n\t\tvar pts = this.getSpacedPoints( divisions, true );\r\n\t\treturn this.createGeometry( pts );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.CurvePath.prototype.createGeometry = function( points ) {\r\n\t\r\n\t\tvar geometry = new THREE.Geometry();\r\n\t\r\n\t\tfor ( var i = 0; i < points.length; i ++ ) {\r\n\t\r\n\t\t\tgeometry.vertices.push( new THREE.Vector3( points[ i ].x, points[ i ].y, points[ i ].z || 0) );\r\n\t\r\n\t\t}\r\n\t\r\n\t\treturn geometry;\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\t/**************************************************************\r\n\t *\tBend / Wrap Helper Methods\r\n\t **************************************************************/\r\n\t\r\n\t// Wrap path / Bend modifiers?\r\n\t\r\n\tTHREE.CurvePath.prototype.addWrapPath = function ( bendpath ) {\r\n\t\r\n\t\tthis.bends.push( bendpath );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.CurvePath.prototype.getTransformedPoints = function( segments, bends ) {\r\n\t\r\n\t\tvar oldPts = this.getPoints( segments ); // getPoints getSpacedPoints\r\n\t\tvar i, il;\r\n\t\r\n\t\tif ( ! bends ) {\r\n\t\r\n\t\t\tbends = this.bends;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfor ( i = 0, il = bends.length; i < il; i ++ ) {\r\n\t\r\n\t\t\toldPts = this.getWrapPoints( oldPts, bends[ i ] );\r\n\t\r\n\t\t}\r\n\t\r\n\t\treturn oldPts;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.CurvePath.prototype.getTransformedSpacedPoints = function( segments, bends ) {\r\n\t\r\n\t\tvar oldPts = this.getSpacedPoints( segments );\r\n\t\r\n\t\tvar i, il;\r\n\t\r\n\t\tif ( ! bends ) {\r\n\t\r\n\t\t\tbends = this.bends;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfor ( i = 0, il = bends.length; i < il; i ++ ) {\r\n\t\r\n\t\t\toldPts = this.getWrapPoints( oldPts, bends[ i ] );\r\n\t\r\n\t\t}\r\n\t\r\n\t\treturn oldPts;\r\n\t\r\n\t};\r\n\t\r\n\t// This returns getPoints() bend/wrapped around the contour of a path.\r\n\t// Read http://www.planetclegg.com/projects/WarpingTextToSplines.html\r\n\t\r\n\tTHREE.CurvePath.prototype.getWrapPoints = function ( oldPts, path ) {\r\n\t\r\n\t\tvar bounds = this.getBoundingBox();\r\n\t\r\n\t\tvar i, il, p, oldX, oldY, xNorm;\r\n\t\r\n\t\tfor ( i = 0, il = oldPts.length; i < il; i ++ ) {\r\n\t\r\n\t\t\tp = oldPts[ i ];\r\n\t\r\n\t\t\toldX = p.x;\r\n\t\t\toldY = p.y;\r\n\t\r\n\t\t\txNorm = oldX / bounds.maxX;\r\n\t\r\n\t\t\t// If using actual distance, for length > path, requires line extrusions\r\n\t\t\t//xNorm = path.getUtoTmapping(xNorm, oldX); // 3 styles. 1) wrap stretched. 2) wrap stretch by arc length 3) warp by actual distance\r\n\t\r\n\t\t\txNorm = path.getUtoTmapping( xNorm, oldX );\r\n\t\r\n\t\t\t// check for out of bounds?\r\n\t\r\n\t\t\tvar pathPt = path.getPoint( xNorm );\r\n\t\t\tvar normal = path.getTangent( xNorm );\r\n\t\t\tnormal.set( - normal.y, normal.x ).multiplyScalar( oldY );\r\n\t\r\n\t\t\tp.x = pathPt.x + normal.x;\r\n\t\t\tp.y = pathPt.y + normal.y;\r\n\t\r\n\t\t}\r\n\t\r\n\t\treturn oldPts;\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\t// File:src/extras/core/Gyroscope.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.Gyroscope = function () {\r\n\t\r\n\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Gyroscope.prototype = Object.create( THREE.Object3D.prototype );\r\n\tTHREE.Gyroscope.prototype.constructor = THREE.Gyroscope;\r\n\t\r\n\tTHREE.Gyroscope.prototype.updateMatrixWorld = ( function () {\r\n\t\r\n\t\tvar translationObject = new THREE.Vector3();\r\n\t\tvar quaternionObject = new THREE.Quaternion();\r\n\t\tvar scaleObject = new THREE.Vector3();\r\n\t\r\n\t\tvar translationWorld = new THREE.Vector3();\r\n\t\tvar quaternionWorld = new THREE.Quaternion();\r\n\t\tvar scaleWorld = new THREE.Vector3();\r\n\t\r\n\t\treturn function ( force ) {\r\n\t\r\n\t\t\tthis.matrixAutoUpdate && this.updateMatrix();\r\n\t\r\n\t\t\t// update matrixWorld\r\n\t\r\n\t\t\tif ( this.matrixWorldNeedsUpdate || force ) {\r\n\t\r\n\t\t\t\tif ( this.parent ) {\r\n\t\r\n\t\t\t\t\tthis.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\r\n\t\r\n\t\t\t\t\tthis.matrixWorld.decompose( translationWorld, quaternionWorld, scaleWorld );\r\n\t\t\t\t\tthis.matrix.decompose( translationObject, quaternionObject, scaleObject );\r\n\t\r\n\t\t\t\t\tthis.matrixWorld.compose( translationWorld, quaternionObject, scaleWorld );\r\n\t\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tthis.matrixWorld.copy( this.matrix );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\r\n\t\t\t\tthis.matrixWorldNeedsUpdate = false;\r\n\t\r\n\t\t\t\tforce = true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// update children\r\n\t\r\n\t\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tthis.children[ i ].updateMatrixWorld( force );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\t\r\n\t}() );\r\n\t\r\n\t// File:src/extras/core/Path.js\r\n\t\r\n\t/**\r\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\r\n\t * Creates free form 2d path using series of points, lines or curves.\r\n\t *\r\n\t **/\r\n\t\r\n\tTHREE.Path = function ( points ) {\r\n\t\r\n\t\tTHREE.CurvePath.call(this);\r\n\t\r\n\t\tthis.actions = [];\r\n\t\r\n\t\tif ( points ) {\r\n\t\r\n\t\t\tthis.fromPoints( points );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Path.prototype = Object.create( THREE.CurvePath.prototype );\r\n\tTHREE.Path.prototype.constructor = THREE.Path;\r\n\t\r\n\tTHREE.PathActions = {\r\n\t\r\n\t\tMOVE_TO: 'moveTo',\r\n\t\tLINE_TO: 'lineTo',\r\n\t\tQUADRATIC_CURVE_TO: 'quadraticCurveTo', // Bezier quadratic curve\r\n\t\tBEZIER_CURVE_TO: 'bezierCurveTo', \t\t// Bezier cubic curve\r\n\t\tCSPLINE_THRU: 'splineThru',\t\t\t\t// Catmull-rom spline\r\n\t\tARC: 'arc',\t\t\t\t\t\t\t\t// Circle\r\n\t\tELLIPSE: 'ellipse'\r\n\t};\r\n\t\r\n\t// TODO Clean up PATH API\r\n\t\r\n\t// Create path using straight lines to connect all points\r\n\t// - vectors: array of Vector2\r\n\t\r\n\tTHREE.Path.prototype.fromPoints = function ( vectors ) {\r\n\t\r\n\t\tthis.moveTo( vectors[ 0 ].x, vectors[ 0 ].y );\r\n\t\r\n\t\tfor ( var v = 1, vlen = vectors.length; v < vlen; v ++ ) {\r\n\t\r\n\t\t\tthis.lineTo( vectors[ v ].x, vectors[ v ].y );\r\n\t\r\n\t\t};\r\n\t\r\n\t};\r\n\t\r\n\t// startPath() endPath()?\r\n\t\r\n\tTHREE.Path.prototype.moveTo = function ( x, y ) {\r\n\t\r\n\t\tvar args = Array.prototype.slice.call( arguments );\r\n\t\tthis.actions.push( { action: THREE.PathActions.MOVE_TO, args: args } );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Path.prototype.lineTo = function ( x, y ) {\r\n\t\r\n\t\tvar args = Array.prototype.slice.call( arguments );\r\n\t\r\n\t\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\r\n\t\r\n\t\tvar x0 = lastargs[ lastargs.length - 2 ];\r\n\t\tvar y0 = lastargs[ lastargs.length - 1 ];\r\n\t\r\n\t\tvar curve = new THREE.LineCurve( new THREE.Vector2( x0, y0 ), new THREE.Vector2( x, y ) );\r\n\t\tthis.curves.push( curve );\r\n\t\r\n\t\tthis.actions.push( { action: THREE.PathActions.LINE_TO, args: args } );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Path.prototype.quadraticCurveTo = function( aCPx, aCPy, aX, aY ) {\r\n\t\r\n\t\tvar args = Array.prototype.slice.call( arguments );\r\n\t\r\n\t\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\r\n\t\r\n\t\tvar x0 = lastargs[ lastargs.length - 2 ];\r\n\t\tvar y0 = lastargs[ lastargs.length - 1 ];\r\n\t\r\n\t\tvar curve = new THREE.QuadraticBezierCurve( new THREE.Vector2( x0, y0 ),\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tnew THREE.Vector2( aCPx, aCPy ),\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tnew THREE.Vector2( aX, aY ) );\r\n\t\tthis.curves.push( curve );\r\n\t\r\n\t\tthis.actions.push( { action: THREE.PathActions.QUADRATIC_CURVE_TO, args: args } );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Path.prototype.bezierCurveTo = function( aCP1x, aCP1y,\r\n\t\t\t\t\t\t\t\t\t\t\t\t   aCP2x, aCP2y,\r\n\t\t\t\t\t\t\t\t\t\t\t\t   aX, aY ) {\r\n\t\r\n\t\tvar args = Array.prototype.slice.call( arguments );\r\n\t\r\n\t\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\r\n\t\r\n\t\tvar x0 = lastargs[ lastargs.length - 2 ];\r\n\t\tvar y0 = lastargs[ lastargs.length - 1 ];\r\n\t\r\n\t\tvar curve = new THREE.CubicBezierCurve( new THREE.Vector2( x0, y0 ),\r\n\t\t\t\t\t\t\t\t\t\t\t\tnew THREE.Vector2( aCP1x, aCP1y ),\r\n\t\t\t\t\t\t\t\t\t\t\t\tnew THREE.Vector2( aCP2x, aCP2y ),\r\n\t\t\t\t\t\t\t\t\t\t\t\tnew THREE.Vector2( aX, aY ) );\r\n\t\tthis.curves.push( curve );\r\n\t\r\n\t\tthis.actions.push( { action: THREE.PathActions.BEZIER_CURVE_TO, args: args } );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Path.prototype.splineThru = function( pts /*Array of Vector*/ ) {\r\n\t\r\n\t\tvar args = Array.prototype.slice.call( arguments );\r\n\t\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\r\n\t\r\n\t\tvar x0 = lastargs[ lastargs.length - 2 ];\r\n\t\tvar y0 = lastargs[ lastargs.length - 1 ];\r\n\t//---\r\n\t\tvar npts = [ new THREE.Vector2( x0, y0 ) ];\r\n\t\tArray.prototype.push.apply( npts, pts );\r\n\t\r\n\t\tvar curve = new THREE.SplineCurve( npts );\r\n\t\tthis.curves.push( curve );\r\n\t\r\n\t\tthis.actions.push( { action: THREE.PathActions.CSPLINE_THRU, args: args } );\r\n\t\r\n\t};\r\n\t\r\n\t// FUTURE: Change the API or follow canvas API?\r\n\t\r\n\tTHREE.Path.prototype.arc = function ( aX, aY, aRadius,\r\n\t\t\t\t\t\t\t\t\t\t  aStartAngle, aEndAngle, aClockwise ) {\r\n\t\r\n\t\tvar lastargs = this.actions[ this.actions.length - 1].args;\r\n\t\tvar x0 = lastargs[ lastargs.length - 2 ];\r\n\t\tvar y0 = lastargs[ lastargs.length - 1 ];\r\n\t\r\n\t\tthis.absarc(aX + x0, aY + y0, aRadius,\r\n\t\t\taStartAngle, aEndAngle, aClockwise );\r\n\t\r\n\t };\r\n\t\r\n\t THREE.Path.prototype.absarc = function ( aX, aY, aRadius,\r\n\t\t\t\t\t\t\t\t\t\t  aStartAngle, aEndAngle, aClockwise ) {\r\n\t\tthis.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);\r\n\t };\r\n\t\r\n\tTHREE.Path.prototype.ellipse = function ( aX, aY, xRadius, yRadius,\r\n\t\t\t\t\t\t\t\t\t\t  aStartAngle, aEndAngle, aClockwise ) {\r\n\t\r\n\t\tvar lastargs = this.actions[ this.actions.length - 1].args;\r\n\t\tvar x0 = lastargs[ lastargs.length - 2 ];\r\n\t\tvar y0 = lastargs[ lastargs.length - 1 ];\r\n\t\r\n\t\tthis.absellipse(aX + x0, aY + y0, xRadius, yRadius,\r\n\t\t\taStartAngle, aEndAngle, aClockwise );\r\n\t\r\n\t };\r\n\t\r\n\t\r\n\tTHREE.Path.prototype.absellipse = function ( aX, aY, xRadius, yRadius,\r\n\t\t\t\t\t\t\t\t\t\t  aStartAngle, aEndAngle, aClockwise ) {\r\n\t\r\n\t\tvar args = Array.prototype.slice.call( arguments );\r\n\t\tvar curve = new THREE.EllipseCurve( aX, aY, xRadius, yRadius,\r\n\t\t\t\t\t\t\t\t\t\taStartAngle, aEndAngle, aClockwise );\r\n\t\tthis.curves.push( curve );\r\n\t\r\n\t\tvar lastPoint = curve.getPoint(1);\r\n\t\targs.push(lastPoint.x);\r\n\t\targs.push(lastPoint.y);\r\n\t\r\n\t\tthis.actions.push( { action: THREE.PathActions.ELLIPSE, args: args } );\r\n\t\r\n\t };\r\n\t\r\n\tTHREE.Path.prototype.getSpacedPoints = function ( divisions, closedPath ) {\r\n\t\r\n\t\tif ( ! divisions ) divisions = 40;\r\n\t\r\n\t\tvar points = [];\r\n\t\r\n\t\tfor ( var i = 0; i < divisions; i ++ ) {\r\n\t\r\n\t\t\tpoints.push( this.getPoint( i / divisions ) );\r\n\t\r\n\t\t\t//if( !this.getPoint( i / divisions ) ) throw \"DIE\";\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// if ( closedPath ) {\r\n\t\t//\r\n\t\t// \tpoints.push( points[ 0 ] );\r\n\t\t//\r\n\t\t// }\r\n\t\r\n\t\treturn points;\r\n\t\r\n\t};\r\n\t\r\n\t/* Return an array of vectors based on contour of the path */\r\n\t\r\n\tTHREE.Path.prototype.getPoints = function( divisions, closedPath ) {\r\n\t\r\n\t\tif (this.useSpacedPoints) {\r\n\t\t\tconsole.log('tata');\r\n\t\t\treturn this.getSpacedPoints( divisions, closedPath );\r\n\t\t}\r\n\t\r\n\t\tdivisions = divisions || 12;\r\n\t\r\n\t\tvar points = [];\r\n\t\r\n\t\tvar i, il, item, action, args;\r\n\t\tvar cpx, cpy, cpx2, cpy2, cpx1, cpy1, cpx0, cpy0,\r\n\t\t\tlaste, j,\r\n\t\t\tt, tx, ty;\r\n\t\r\n\t\tfor ( i = 0, il = this.actions.length; i < il; i ++ ) {\r\n\t\r\n\t\t\titem = this.actions[ i ];\r\n\t\r\n\t\t\taction = item.action;\r\n\t\t\targs = item.args;\r\n\t\r\n\t\t\tswitch ( action ) {\r\n\t\r\n\t\t\tcase THREE.PathActions.MOVE_TO:\r\n\t\r\n\t\t\t\tpoints.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );\r\n\t\r\n\t\t\t\tbreak;\r\n\t\r\n\t\t\tcase THREE.PathActions.LINE_TO:\r\n\t\r\n\t\t\t\tpoints.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );\r\n\t\r\n\t\t\t\tbreak;\r\n\t\r\n\t\t\tcase THREE.PathActions.QUADRATIC_CURVE_TO:\r\n\t\r\n\t\t\t\tcpx  = args[ 2 ];\r\n\t\t\t\tcpy  = args[ 3 ];\r\n\t\r\n\t\t\t\tcpx1 = args[ 0 ];\r\n\t\t\t\tcpy1 = args[ 1 ];\r\n\t\r\n\t\t\t\tif ( points.length > 0 ) {\r\n\t\r\n\t\t\t\t\tlaste = points[ points.length - 1 ];\r\n\t\r\n\t\t\t\t\tcpx0 = laste.x;\r\n\t\t\t\t\tcpy0 = laste.y;\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tlaste = this.actions[ i - 1 ].args;\r\n\t\r\n\t\t\t\t\tcpx0 = laste[ laste.length - 2 ];\r\n\t\t\t\t\tcpy0 = laste[ laste.length - 1 ];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tfor ( j = 1; j <= divisions; j ++ ) {\r\n\t\r\n\t\t\t\t\tt = j / divisions;\r\n\t\r\n\t\t\t\t\ttx = THREE.Shape.Utils.b2( t, cpx0, cpx1, cpx );\r\n\t\t\t\t\tty = THREE.Shape.Utils.b2( t, cpy0, cpy1, cpy );\r\n\t\r\n\t\t\t\t\tpoints.push( new THREE.Vector2( tx, ty ) );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tbreak;\r\n\t\r\n\t\t\tcase THREE.PathActions.BEZIER_CURVE_TO:\r\n\t\r\n\t\t\t\tcpx  = args[ 4 ];\r\n\t\t\t\tcpy  = args[ 5 ];\r\n\t\r\n\t\t\t\tcpx1 = args[ 0 ];\r\n\t\t\t\tcpy1 = args[ 1 ];\r\n\t\r\n\t\t\t\tcpx2 = args[ 2 ];\r\n\t\t\t\tcpy2 = args[ 3 ];\r\n\t\r\n\t\t\t\tif ( points.length > 0 ) {\r\n\t\r\n\t\t\t\t\tlaste = points[ points.length - 1 ];\r\n\t\r\n\t\t\t\t\tcpx0 = laste.x;\r\n\t\t\t\t\tcpy0 = laste.y;\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tlaste = this.actions[ i - 1 ].args;\r\n\t\r\n\t\t\t\t\tcpx0 = laste[ laste.length - 2 ];\r\n\t\t\t\t\tcpy0 = laste[ laste.length - 1 ];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\r\n\t\t\t\tfor ( j = 1; j <= divisions; j ++ ) {\r\n\t\r\n\t\t\t\t\tt = j / divisions;\r\n\t\r\n\t\t\t\t\ttx = THREE.Shape.Utils.b3( t, cpx0, cpx1, cpx2, cpx );\r\n\t\t\t\t\tty = THREE.Shape.Utils.b3( t, cpy0, cpy1, cpy2, cpy );\r\n\t\r\n\t\t\t\t\tpoints.push( new THREE.Vector2( tx, ty ) );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tbreak;\r\n\t\r\n\t\t\tcase THREE.PathActions.CSPLINE_THRU:\r\n\t\r\n\t\t\t\tlaste = this.actions[ i - 1 ].args;\r\n\t\r\n\t\t\t\tvar last = new THREE.Vector2( laste[ laste.length - 2 ], laste[ laste.length - 1 ] );\r\n\t\t\t\tvar spts = [ last ];\r\n\t\r\n\t\t\t\tvar n = divisions * args[ 0 ].length;\r\n\t\r\n\t\t\t\tspts = spts.concat( args[ 0 ] );\r\n\t\r\n\t\t\t\tvar spline = new THREE.SplineCurve( spts );\r\n\t\r\n\t\t\t\tfor ( j = 1; j <= n; j ++ ) {\r\n\t\r\n\t\t\t\t\tpoints.push( spline.getPointAt( j / n ) ) ;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tbreak;\r\n\t\r\n\t\t\tcase THREE.PathActions.ARC:\r\n\t\r\n\t\t\t\tvar aX = args[ 0 ], aY = args[ 1 ],\r\n\t\t\t\t\taRadius = args[ 2 ],\r\n\t\t\t\t\taStartAngle = args[ 3 ], aEndAngle = args[ 4 ],\r\n\t\t\t\t\taClockwise = !! args[ 5 ];\r\n\t\r\n\t\t\t\tvar deltaAngle = aEndAngle - aStartAngle;\r\n\t\t\t\tvar angle;\r\n\t\t\t\tvar tdivisions = divisions * 2;\r\n\t\r\n\t\t\t\tfor ( j = 1; j <= tdivisions; j ++ ) {\r\n\t\r\n\t\t\t\t\tt = j / tdivisions;\r\n\t\r\n\t\t\t\t\tif ( ! aClockwise ) {\r\n\t\r\n\t\t\t\t\t\tt = 1 - t;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tangle = aStartAngle + t * deltaAngle;\r\n\t\r\n\t\t\t\t\ttx = aX + aRadius * Math.cos( angle );\r\n\t\t\t\t\tty = aY + aRadius * Math.sin( angle );\r\n\t\r\n\t\t\t\t\t//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);\r\n\t\r\n\t\t\t\t\tpoints.push( new THREE.Vector2( tx, ty ) );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t//console.log(points);\r\n\t\r\n\t\t\t\tbreak;\r\n\t\t\t  \r\n\t\t\tcase THREE.PathActions.ELLIPSE:\r\n\t\r\n\t\t\t\tvar aX = args[ 0 ], aY = args[ 1 ],\r\n\t\t\t\t\txRadius = args[ 2 ],\r\n\t\t\t\t\tyRadius = args[ 3 ],\r\n\t\t\t\t\taStartAngle = args[ 4 ], aEndAngle = args[ 5 ],\r\n\t\t\t\t\taClockwise = !! args[ 6 ];\r\n\t\r\n\t\r\n\t\t\t\tvar deltaAngle = aEndAngle - aStartAngle;\r\n\t\t\t\tvar angle;\r\n\t\t\t\tvar tdivisions = divisions * 2;\r\n\t\r\n\t\t\t\tfor ( j = 1; j <= tdivisions; j ++ ) {\r\n\t\r\n\t\t\t\t\tt = j / tdivisions;\r\n\t\r\n\t\t\t\t\tif ( ! aClockwise ) {\r\n\t\r\n\t\t\t\t\t\tt = 1 - t;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tangle = aStartAngle + t * deltaAngle;\r\n\t\r\n\t\t\t\t\ttx = aX + xRadius * Math.cos( angle );\r\n\t\t\t\t\tty = aY + yRadius * Math.sin( angle );\r\n\t\r\n\t\t\t\t\t//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);\r\n\t\r\n\t\t\t\t\tpoints.push( new THREE.Vector2( tx, ty ) );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t//console.log(points);\r\n\t\r\n\t\t\t\tbreak;\r\n\t\r\n\t\t\t} // end switch\r\n\t\r\n\t\t}\r\n\t\r\n\t\r\n\t\r\n\t\t// Normalize to remove the closing point by default.\r\n\t\tvar lastPoint = points[ points.length - 1];\r\n\t\tvar EPSILON = 0.0000000001;\r\n\t\tif ( Math.abs(lastPoint.x - points[ 0 ].x) < EPSILON &&\r\n\t\t\t\t Math.abs(lastPoint.y - points[ 0 ].y) < EPSILON)\r\n\t\t\tpoints.splice( points.length - 1, 1);\r\n\t\tif ( closedPath ) {\r\n\t\r\n\t\t\tpoints.push( points[ 0 ] );\r\n\t\r\n\t\t}\r\n\t\r\n\t\treturn points;\r\n\t\r\n\t};\r\n\t\r\n\t//\r\n\t// Breaks path into shapes\r\n\t//\r\n\t//\tAssumptions (if parameter isCCW==true the opposite holds):\r\n\t//\t- solid shapes are defined clockwise (CW)\r\n\t//\t- holes are defined counterclockwise (CCW)\r\n\t//\r\n\t//\tIf parameter noHoles==true:\r\n\t//  - all subPaths are regarded as solid shapes\r\n\t//  - definition order CW/CCW has no relevance\r\n\t//\r\n\t\r\n\tTHREE.Path.prototype.toShapes = function( isCCW, noHoles ) {\r\n\t\r\n\t\tfunction extractSubpaths( inActions ) {\r\n\t\r\n\t\t\tvar i, il, item, action, args;\r\n\t\r\n\t\t\tvar subPaths = [], lastPath = new THREE.Path();\r\n\t\r\n\t\t\tfor ( i = 0, il = inActions.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\titem = inActions[ i ];\r\n\t\r\n\t\t\t\targs = item.args;\r\n\t\t\t\taction = item.action;\r\n\t\r\n\t\t\t\tif ( action == THREE.PathActions.MOVE_TO ) {\r\n\t\r\n\t\t\t\t\tif ( lastPath.actions.length != 0 ) {\r\n\t\r\n\t\t\t\t\t\tsubPaths.push( lastPath );\r\n\t\t\t\t\t\tlastPath = new THREE.Path();\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tlastPath[ action ].apply( lastPath, args );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( lastPath.actions.length != 0 ) {\r\n\t\r\n\t\t\t\tsubPaths.push( lastPath );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// console.log(subPaths);\r\n\t\r\n\t\t\treturn\tsubPaths;\r\n\t\t}\r\n\t\r\n\t\tfunction toShapesNoHoles( inSubpaths ) {\r\n\t\r\n\t\t\tvar shapes = [];\r\n\t\r\n\t\t\tfor ( var i = 0, il = inSubpaths.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tvar tmpPath = inSubpaths[ i ];\r\n\t\r\n\t\t\t\tvar tmpShape = new THREE.Shape();\r\n\t\t\t\ttmpShape.actions = tmpPath.actions;\r\n\t\t\t\ttmpShape.curves = tmpPath.curves;\r\n\t\r\n\t\t\t\tshapes.push( tmpShape );\r\n\t\t\t}\r\n\t\r\n\t\t\t//console.log(\"shape\", shapes);\r\n\t\r\n\t\t\treturn shapes;\r\n\t\t};\r\n\t\r\n\t\tfunction isPointInsidePolygon( inPt, inPolygon ) {\r\n\t\t\tvar EPSILON = 0.0000000001;\r\n\t\r\n\t\t\tvar polyLen = inPolygon.length;\r\n\t\r\n\t\t\t// inPt on polygon contour => immediate success    or\r\n\t\t\t// toggling of inside/outside at every single! intersection point of an edge\r\n\t\t\t//  with the horizontal line through inPt, left of inPt\r\n\t\t\t//  not counting lowerY endpoints of edges and whole edges on that line\r\n\t\t\tvar inside = false;\r\n\t\t\tfor ( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {\r\n\t\t\t\tvar edgeLowPt  = inPolygon[ p ];\r\n\t\t\t\tvar edgeHighPt = inPolygon[ q ];\r\n\t\r\n\t\t\t\tvar edgeDx = edgeHighPt.x - edgeLowPt.x;\r\n\t\t\t\tvar edgeDy = edgeHighPt.y - edgeLowPt.y;\r\n\t\r\n\t\t\t\tif ( Math.abs(edgeDy) > EPSILON ) {\t\t\t// not parallel\r\n\t\t\t\t\tif ( edgeDy < 0 ) {\r\n\t\t\t\t\t\tedgeLowPt  = inPolygon[ q ]; edgeDx = - edgeDx;\r\n\t\t\t\t\t\tedgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) \t\tcontinue;\r\n\t\r\n\t\t\t\t\tif ( inPt.y == edgeLowPt.y ) {\r\n\t\t\t\t\t\tif ( inPt.x == edgeLowPt.x )\t\treturn\ttrue;\t\t// inPt is on contour ?\r\n\t\t\t\t\t\t// continue;\t\t\t\t// no intersection or edgeLowPt => doesn't count !!!\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tvar perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);\r\n\t\t\t\t\t\tif ( perpEdge == 0 )\t\t\t\treturn\ttrue;\t\t// inPt is on contour ?\r\n\t\t\t\t\t\tif ( perpEdge < 0 ) \t\t\t\tcontinue;\r\n\t\t\t\t\t\tinside = ! inside;\t\t// true intersection left of inPt\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\t\t// parallel or colinear\r\n\t\t\t\t\tif ( inPt.y != edgeLowPt.y ) \t\tcontinue;\t\t\t// parallel\r\n\t\t\t\t\t// egde lies on the same horizontal line as inPt\r\n\t\t\t\t\tif ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||\r\n\t\t\t\t\t\t ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )\t\treturn\ttrue;\t// inPt: Point on contour !\r\n\t\t\t\t\t// continue;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\r\n\t\t\treturn\tinside;\r\n\t\t}\r\n\t\r\n\t\r\n\t\tvar subPaths = extractSubpaths( this.actions );\r\n\t\tif ( subPaths.length == 0 ) return [];\r\n\t\r\n\t\tif ( noHoles === true )\treturn\ttoShapesNoHoles( subPaths );\r\n\t\r\n\t\r\n\t\tvar solid, tmpPath, tmpShape, shapes = [];\r\n\t\r\n\t\tif ( subPaths.length == 1) {\r\n\t\r\n\t\t\ttmpPath = subPaths[0];\r\n\t\t\ttmpShape = new THREE.Shape();\r\n\t\t\ttmpShape.actions = tmpPath.actions;\r\n\t\t\ttmpShape.curves = tmpPath.curves;\r\n\t\t\tshapes.push( tmpShape );\r\n\t\t\treturn shapes;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar holesFirst = ! THREE.Shape.Utils.isClockWise( subPaths[ 0 ].getPoints() );\r\n\t\tholesFirst = isCCW ? ! holesFirst : holesFirst;\r\n\t\r\n\t\t// console.log(\"Holes first\", holesFirst);\r\n\t\t\r\n\t\tvar betterShapeHoles = [];\r\n\t\tvar newShapes = [];\r\n\t\tvar newShapeHoles = [];\r\n\t\tvar mainIdx = 0;\r\n\t\tvar tmpPoints;\r\n\t\r\n\t\tnewShapes[mainIdx] = undefined;\r\n\t\tnewShapeHoles[mainIdx] = [];\r\n\t\r\n\t\tvar i, il;\r\n\t\r\n\t\tfor ( i = 0, il = subPaths.length; i < il; i ++ ) {\r\n\t\r\n\t\t\ttmpPath = subPaths[ i ];\r\n\t\t\ttmpPoints = tmpPath.getPoints();\r\n\t\t\tsolid = THREE.Shape.Utils.isClockWise( tmpPoints );\r\n\t\t\tsolid = isCCW ? ! solid : solid;\r\n\t\r\n\t\t\tif ( solid ) {\r\n\t\r\n\t\t\t\tif ( (! holesFirst ) && ( newShapes[mainIdx] ) )\tmainIdx ++;\r\n\t\r\n\t\t\t\tnewShapes[mainIdx] = { s: new THREE.Shape(), p: tmpPoints };\r\n\t\t\t\tnewShapes[mainIdx].s.actions = tmpPath.actions;\r\n\t\t\t\tnewShapes[mainIdx].s.curves = tmpPath.curves;\r\n\t\t\t\t\r\n\t\t\t\tif ( holesFirst )\tmainIdx ++;\r\n\t\t\t\tnewShapeHoles[mainIdx] = [];\r\n\t\r\n\t\t\t\t//console.log('cw', i);\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tnewShapeHoles[mainIdx].push( { h: tmpPath, p: tmpPoints[0] } );\r\n\t\r\n\t\t\t\t//console.log('ccw', i);\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// only Holes? -> probably all Shapes with wrong orientation\r\n\t\tif ( ! newShapes[0] )\treturn\ttoShapesNoHoles( subPaths );\r\n\t\r\n\t\r\n\t\tif ( newShapes.length > 1 ) {\r\n\t\t\tvar ambigious = false;\r\n\t\t\tvar toChange = [];\r\n\t\r\n\t\t\tfor (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\r\n\t\t\t\tbetterShapeHoles[sIdx] = [];\r\n\t\t\t}\r\n\t\t\tfor (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\r\n\t\t\t\tvar sho = newShapeHoles[sIdx];\r\n\t\t\t\tfor (var hIdx = 0; hIdx < sho.length; hIdx ++ ) {\r\n\t\t\t\t\tvar ho = sho[hIdx];\r\n\t\t\t\t\tvar hole_unassigned = true;\r\n\t\t\t\t\tfor (var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {\r\n\t\t\t\t\t\tif ( isPointInsidePolygon( ho.p, newShapes[s2Idx].p ) ) {\r\n\t\t\t\t\t\t\tif ( sIdx != s2Idx )\t\ttoChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );\r\n\t\t\t\t\t\t\tif ( hole_unassigned ) {\r\n\t\t\t\t\t\t\t\thole_unassigned = false;\r\n\t\t\t\t\t\t\t\tbetterShapeHoles[s2Idx].push( ho );\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tambigious = true;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ( hole_unassigned ) { betterShapeHoles[sIdx].push( ho ); }\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// console.log(\"ambigious: \", ambigious);\r\n\t\t\tif ( toChange.length > 0 ) {\r\n\t\t\t\t// console.log(\"to change: \", toChange);\r\n\t\t\t\tif (! ambigious)\tnewShapeHoles = betterShapeHoles;\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tvar tmpHoles, j, jl;\r\n\t\tfor ( i = 0, il = newShapes.length; i < il; i ++ ) {\r\n\t\t\ttmpShape = newShapes[i].s;\r\n\t\t\tshapes.push( tmpShape );\r\n\t\t\ttmpHoles = newShapeHoles[i];\r\n\t\t\tfor ( j = 0, jl = tmpHoles.length; j < jl; j ++ ) {\r\n\t\t\t\ttmpShape.holes.push( tmpHoles[j].h );\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\t//console.log(\"shape\", shapes);\r\n\t\r\n\t\treturn shapes;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/core/Shape.js\r\n\t\r\n\t/**\r\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\r\n\t * Defines a 2d shape plane using paths.\r\n\t **/\r\n\t\r\n\t// STEP 1 Create a path.\r\n\t// STEP 2 Turn path into shape.\r\n\t// STEP 3 ExtrudeGeometry takes in Shape/Shapes\r\n\t// STEP 3a - Extract points from each shape, turn to vertices\r\n\t// STEP 3b - Triangulate each shape, add faces.\r\n\t\r\n\tTHREE.Shape = function () {\r\n\t\r\n\t\tTHREE.Path.apply( this, arguments );\r\n\t\tthis.holes = [];\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Shape.prototype = Object.create( THREE.Path.prototype );\r\n\tTHREE.Shape.prototype.constructor = THREE.Shape;\r\n\t\r\n\t// Convenience method to return ExtrudeGeometry\r\n\t\r\n\tTHREE.Shape.prototype.extrude = function ( options ) {\r\n\t\r\n\t\tvar extruded = new THREE.ExtrudeGeometry( this, options );\r\n\t\treturn extruded;\r\n\t\r\n\t};\r\n\t\r\n\t// Convenience method to return ShapeGeometry\r\n\t\r\n\tTHREE.Shape.prototype.makeGeometry = function ( options ) {\r\n\t\r\n\t\tvar geometry = new THREE.ShapeGeometry( this, options );\r\n\t\treturn geometry;\r\n\t\r\n\t};\r\n\t\r\n\t// Get points of holes\r\n\t\r\n\tTHREE.Shape.prototype.getPointsHoles = function ( divisions ) {\r\n\t\r\n\t\tvar i, il = this.holes.length, holesPts = [];\r\n\t\r\n\t\tfor ( i = 0; i < il; i ++ ) {\r\n\t\r\n\t\t\tholesPts[ i ] = this.holes[ i ].getTransformedPoints( divisions, this.bends );\r\n\t\r\n\t\t}\r\n\t\r\n\t\treturn holesPts;\r\n\t\r\n\t};\r\n\t\r\n\t// Get points of holes (spaced by regular distance)\r\n\t\r\n\tTHREE.Shape.prototype.getSpacedPointsHoles = function ( divisions ) {\r\n\t\r\n\t\tvar i, il = this.holes.length, holesPts = [];\r\n\t\r\n\t\tfor ( i = 0; i < il; i ++ ) {\r\n\t\r\n\t\t\tholesPts[ i ] = this.holes[ i ].getTransformedSpacedPoints( divisions, this.bends );\r\n\t\r\n\t\t}\r\n\t\r\n\t\treturn holesPts;\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\t// Get points of shape and holes (keypoints based on segments parameter)\r\n\t\r\n\tTHREE.Shape.prototype.extractAllPoints = function ( divisions ) {\r\n\t\r\n\t\treturn {\r\n\t\r\n\t\t\tshape: this.getTransformedPoints( divisions ),\r\n\t\t\tholes: this.getPointsHoles( divisions )\r\n\t\r\n\t\t};\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Shape.prototype.extractPoints = function ( divisions ) {\r\n\t\r\n\t\tif (this.useSpacedPoints) {\r\n\t\t\treturn this.extractAllSpacedPoints(divisions);\r\n\t\t}\r\n\t\r\n\t\treturn this.extractAllPoints(divisions);\r\n\t\r\n\t};\r\n\t\r\n\t//\r\n\t// THREE.Shape.prototype.extractAllPointsWithBend = function ( divisions, bend ) {\r\n\t//\r\n\t// \treturn {\r\n\t//\r\n\t// \t\tshape: this.transform( bend, divisions ),\r\n\t// \t\tholes: this.getPointsHoles( divisions, bend )\r\n\t//\r\n\t// \t};\r\n\t//\r\n\t// };\r\n\t\r\n\t// Get points of shape and holes (spaced by regular distance)\r\n\t\r\n\tTHREE.Shape.prototype.extractAllSpacedPoints = function ( divisions ) {\r\n\t\r\n\t\treturn {\r\n\t\r\n\t\t\tshape: this.getTransformedSpacedPoints( divisions ),\r\n\t\t\tholes: this.getSpacedPointsHoles( divisions )\r\n\t\r\n\t\t};\r\n\t\r\n\t};\r\n\t\r\n\t/**************************************************************\r\n\t *\tUtils\r\n\t **************************************************************/\r\n\t\r\n\tTHREE.Shape.Utils = {\r\n\t\r\n\t\ttriangulateShape: function ( contour, holes ) {\r\n\t\r\n\t\t\tfunction point_in_segment_2D_colin( inSegPt1, inSegPt2, inOtherPt ) {\r\n\t\t\t\t// inOtherPt needs to be colinear to the inSegment\r\n\t\t\t\tif ( inSegPt1.x != inSegPt2.x ) {\r\n\t\t\t\t\tif ( inSegPt1.x < inSegPt2.x ) {\r\n\t\t\t\t\t\treturn\t( ( inSegPt1.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt2.x ) );\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\treturn\t( ( inSegPt2.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt1.x ) );\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif ( inSegPt1.y < inSegPt2.y ) {\r\n\t\t\t\t\t\treturn\t( ( inSegPt1.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt2.y ) );\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\treturn\t( ( inSegPt2.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt1.y ) );\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\r\n\t\t\tfunction intersect_segments_2D( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs ) {\r\n\t\t\t\tvar EPSILON = 0.0000000001;\r\n\t\r\n\t\t\t\tvar seg1dx = inSeg1Pt2.x - inSeg1Pt1.x,   seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;\r\n\t\t\t\tvar seg2dx = inSeg2Pt2.x - inSeg2Pt1.x,   seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;\r\n\t\r\n\t\t\t\tvar seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;\r\n\t\t\t\tvar seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;\r\n\t\r\n\t\t\t\tvar limit\t\t= seg1dy * seg2dx - seg1dx * seg2dy;\r\n\t\t\t\tvar perpSeg1\t= seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;\r\n\t\r\n\t\t\t\tif ( Math.abs(limit) > EPSILON ) {\t\t\t// not parallel\r\n\t\r\n\t\t\t\t\tvar perpSeg2;\r\n\t\t\t\t\tif ( limit > 0 ) {\r\n\t\t\t\t\t\tif ( ( perpSeg1 < 0 ) || ( perpSeg1 > limit ) ) \t\treturn [];\r\n\t\t\t\t\t\tperpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;\r\n\t\t\t\t\t\tif ( ( perpSeg2 < 0 ) || ( perpSeg2 > limit ) ) \t\treturn [];\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tif ( ( perpSeg1 > 0 ) || ( perpSeg1 < limit ) ) \t\treturn [];\r\n\t\t\t\t\t\tperpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;\r\n\t\t\t\t\t\tif ( ( perpSeg2 > 0 ) || ( perpSeg2 < limit ) ) \t\treturn [];\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t// i.e. to reduce rounding errors\r\n\t\t\t\t\t// intersection at endpoint of segment#1?\r\n\t\t\t\t\tif ( perpSeg2 == 0 ) {\r\n\t\t\t\t\t\tif ( ( inExcludeAdjacentSegs ) &&\r\n\t\t\t\t\t\t\t ( ( perpSeg1 == 0 ) || ( perpSeg1 == limit ) ) )\t\treturn [];\r\n\t\t\t\t\t\treturn [ inSeg1Pt1 ];\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ( perpSeg2 == limit ) {\r\n\t\t\t\t\t\tif ( ( inExcludeAdjacentSegs ) &&\r\n\t\t\t\t\t\t\t ( ( perpSeg1 == 0 ) || ( perpSeg1 == limit ) ) )\t\treturn [];\r\n\t\t\t\t\t\treturn [ inSeg1Pt2 ];\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// intersection at endpoint of segment#2?\r\n\t\t\t\t\tif ( perpSeg1 == 0 )\t\treturn [ inSeg2Pt1 ];\r\n\t\t\t\t\tif ( perpSeg1 == limit )\treturn [ inSeg2Pt2 ];\r\n\t\r\n\t\t\t\t\t// return real intersection point\r\n\t\t\t\t\tvar factorSeg1 = perpSeg2 / limit;\r\n\t\t\t\t\treturn\t[ { x: inSeg1Pt1.x + factorSeg1 * seg1dx,\r\n\t\t\t\t\t\t\t\ty: inSeg1Pt1.y + factorSeg1 * seg1dy } ];\r\n\t\r\n\t\t\t\t} else {\t\t// parallel or colinear\r\n\t\t\t\t\tif ( ( perpSeg1 != 0 ) ||\r\n\t\t\t\t\t\t ( seg2dy * seg1seg2dx != seg2dx * seg1seg2dy ) ) \t\t\treturn [];\r\n\t\r\n\t\t\t\t\t// they are collinear or degenerate\r\n\t\t\t\t\tvar seg1Pt = ( (seg1dx == 0) && (seg1dy == 0) );\t// segment1 ist just a point?\r\n\t\t\t\t\tvar seg2Pt = ( (seg2dx == 0) && (seg2dy == 0) );\t// segment2 ist just a point?\r\n\t\t\t\t\t// both segments are points\r\n\t\t\t\t\tif ( seg1Pt && seg2Pt ) {\r\n\t\t\t\t\t\tif ( (inSeg1Pt1.x != inSeg2Pt1.x) ||\r\n\t\t\t\t\t\t\t (inSeg1Pt1.y != inSeg2Pt1.y) )\t\treturn [];   \t// they are distinct  points\r\n\t\t\t\t\t\treturn [ inSeg1Pt1 ];                 \t\t\t\t\t// they are the same point\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// segment#1  is a single point\r\n\t\t\t\t\tif ( seg1Pt ) {\r\n\t\t\t\t\t\tif (! point_in_segment_2D_colin( inSeg2Pt1, inSeg2Pt2, inSeg1Pt1 ) )\t\treturn [];\t\t// but not in segment#2\r\n\t\t\t\t\t\treturn [ inSeg1Pt1 ];\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// segment#2  is a single point\r\n\t\t\t\t\tif ( seg2Pt ) {\r\n\t\t\t\t\t\tif (! point_in_segment_2D_colin( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1 ) )\t\treturn [];\t\t// but not in segment#1\r\n\t\t\t\t\t\treturn [ inSeg2Pt1 ];\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t// they are collinear segments, which might overlap\r\n\t\t\t\t\tvar seg1min, seg1max, seg1minVal, seg1maxVal;\r\n\t\t\t\t\tvar seg2min, seg2max, seg2minVal, seg2maxVal;\r\n\t\t\t\t\tif (seg1dx != 0) {\t\t// the segments are NOT on a vertical line\r\n\t\t\t\t\t\tif ( inSeg1Pt1.x < inSeg1Pt2.x ) {\r\n\t\t\t\t\t\t\tseg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.x;\r\n\t\t\t\t\t\t\tseg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.x;\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tseg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.x;\r\n\t\t\t\t\t\t\tseg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.x;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif ( inSeg2Pt1.x < inSeg2Pt2.x ) {\r\n\t\t\t\t\t\t\tseg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.x;\r\n\t\t\t\t\t\t\tseg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.x;\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tseg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.x;\r\n\t\t\t\t\t\t\tseg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.x;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\t\t\t\t// the segments are on a vertical line\r\n\t\t\t\t\t\tif ( inSeg1Pt1.y < inSeg1Pt2.y ) {\r\n\t\t\t\t\t\t\tseg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.y;\r\n\t\t\t\t\t\t\tseg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.y;\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tseg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.y;\r\n\t\t\t\t\t\t\tseg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.y;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif ( inSeg2Pt1.y < inSeg2Pt2.y ) {\r\n\t\t\t\t\t\t\tseg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.y;\r\n\t\t\t\t\t\t\tseg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.y;\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tseg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.y;\r\n\t\t\t\t\t\t\tseg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.y;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ( seg1minVal <= seg2minVal ) {\r\n\t\t\t\t\t\tif ( seg1maxVal <  seg2minVal )\treturn [];\r\n\t\t\t\t\t\tif ( seg1maxVal == seg2minVal )\t{\r\n\t\t\t\t\t\t\tif ( inExcludeAdjacentSegs )\t\treturn [];\r\n\t\t\t\t\t\t\treturn [ seg2min ];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif ( seg1maxVal <= seg2maxVal )\treturn [ seg2min, seg1max ];\r\n\t\t\t\t\t\treturn\t[ seg2min, seg2max ];\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tif ( seg1minVal >  seg2maxVal )\treturn [];\r\n\t\t\t\t\t\tif ( seg1minVal == seg2maxVal )\t{\r\n\t\t\t\t\t\t\tif ( inExcludeAdjacentSegs )\t\treturn [];\r\n\t\t\t\t\t\t\treturn [ seg1min ];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif ( seg1maxVal <= seg2maxVal )\treturn [ seg1min, seg1max ];\r\n\t\t\t\t\t\treturn\t[ seg1min, seg2max ];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\r\n\t\t\tfunction isPointInsideAngle( inVertex, inLegFromPt, inLegToPt, inOtherPt ) {\r\n\t\t\t\t// The order of legs is important\r\n\t\r\n\t\t\t\tvar EPSILON = 0.0000000001;\r\n\t\r\n\t\t\t\t// translation of all points, so that Vertex is at (0,0)\r\n\t\t\t\tvar legFromPtX\t= inLegFromPt.x - inVertex.x,  legFromPtY\t= inLegFromPt.y - inVertex.y;\r\n\t\t\t\tvar legToPtX\t= inLegToPt.x\t- inVertex.x,  legToPtY\t\t= inLegToPt.y\t- inVertex.y;\r\n\t\t\t\tvar otherPtX\t= inOtherPt.x\t- inVertex.x,  otherPtY\t\t= inOtherPt.y\t- inVertex.y;\r\n\t\r\n\t\t\t\t// main angle >0: < 180 deg.; 0: 180 deg.; <0: > 180 deg.\r\n\t\t\t\tvar from2toAngle\t= legFromPtX * legToPtY - legFromPtY * legToPtX;\r\n\t\t\t\tvar from2otherAngle\t= legFromPtX * otherPtY - legFromPtY * otherPtX;\r\n\t\r\n\t\t\t\tif ( Math.abs(from2toAngle) > EPSILON ) {\t\t\t// angle != 180 deg.\r\n\t\r\n\t\t\t\t\tvar other2toAngle\t\t= otherPtX * legToPtY - otherPtY * legToPtX;\r\n\t\t\t\t\t// console.log( \"from2to: \" + from2toAngle + \", from2other: \" + from2otherAngle + \", other2to: \" + other2toAngle );\r\n\t\r\n\t\t\t\t\tif ( from2toAngle > 0 ) {\t\t\t\t// main angle < 180 deg.\r\n\t\t\t\t\t\treturn\t( ( from2otherAngle >= 0 ) && ( other2toAngle >= 0 ) );\r\n\t\t\t\t\t} else {\t\t\t\t\t\t\t\t// main angle > 180 deg.\r\n\t\t\t\t\t\treturn\t( ( from2otherAngle >= 0 ) || ( other2toAngle >= 0 ) );\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\t\t\t\t\t\t\t\t\t\t// angle == 180 deg.\r\n\t\t\t\t\t// console.log( \"from2to: 180 deg., from2other: \" + from2otherAngle  );\r\n\t\t\t\t\treturn\t( from2otherAngle > 0 );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\r\n\t\r\n\t\t\tfunction removeHoles( contour, holes ) {\r\n\t\r\n\t\t\t\tvar shape = contour.concat(); // work on this shape\r\n\t\t\t\tvar hole;\r\n\t\r\n\t\t\t\tfunction isCutLineInsideAngles( inShapeIdx, inHoleIdx ) {\r\n\t\t\t\t\t// Check if hole point lies within angle around shape point\r\n\t\t\t\t\tvar lastShapeIdx = shape.length - 1;\r\n\t\r\n\t\t\t\t\tvar prevShapeIdx = inShapeIdx - 1;\r\n\t\t\t\t\tif ( prevShapeIdx < 0 )\t\t\tprevShapeIdx = lastShapeIdx;\r\n\t\r\n\t\t\t\t\tvar nextShapeIdx = inShapeIdx + 1;\r\n\t\t\t\t\tif ( nextShapeIdx > lastShapeIdx )\tnextShapeIdx = 0;\r\n\t\r\n\t\t\t\t\tvar insideAngle = isPointInsideAngle( shape[inShapeIdx], shape[ prevShapeIdx ], shape[ nextShapeIdx ], hole[inHoleIdx] );\r\n\t\t\t\t\tif (! insideAngle ) {\r\n\t\t\t\t\t\t// console.log( \"Vertex (Shape): \" + inShapeIdx + \", Point: \" + hole[inHoleIdx].x + \"/\" + hole[inHoleIdx].y );\r\n\t\t\t\t\t\treturn\tfalse;\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t// Check if shape point lies within angle around hole point\r\n\t\t\t\t\tvar lastHoleIdx = hole.length - 1;\r\n\t\r\n\t\t\t\t\tvar prevHoleIdx = inHoleIdx - 1;\r\n\t\t\t\t\tif ( prevHoleIdx < 0 )\t\t\tprevHoleIdx = lastHoleIdx;\r\n\t\r\n\t\t\t\t\tvar nextHoleIdx = inHoleIdx + 1;\r\n\t\t\t\t\tif ( nextHoleIdx > lastHoleIdx )\tnextHoleIdx = 0;\r\n\t\r\n\t\t\t\t\tinsideAngle = isPointInsideAngle( hole[inHoleIdx], hole[ prevHoleIdx ], hole[ nextHoleIdx ], shape[inShapeIdx] );\r\n\t\t\t\t\tif (! insideAngle ) {\r\n\t\t\t\t\t\t// console.log( \"Vertex (Hole): \" + inHoleIdx + \", Point: \" + shape[inShapeIdx].x + \"/\" + shape[inShapeIdx].y );\r\n\t\t\t\t\t\treturn\tfalse;\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\treturn\ttrue;\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tfunction intersectsShapeEdge( inShapePt, inHolePt ) {\r\n\t\t\t\t\t// checks for intersections with shape edges\r\n\t\t\t\t\tvar sIdx, nextIdx, intersection;\r\n\t\t\t\t\tfor ( sIdx = 0; sIdx < shape.length; sIdx ++ ) {\r\n\t\t\t\t\t\tnextIdx = sIdx + 1; nextIdx %= shape.length;\r\n\t\t\t\t\t\tintersection = intersect_segments_2D( inShapePt, inHolePt, shape[sIdx], shape[nextIdx], true );\r\n\t\t\t\t\t\tif ( intersection.length > 0 )\t\treturn\ttrue;\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\treturn\tfalse;\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar indepHoles = [];\r\n\t\r\n\t\t\t\tfunction intersectsHoleEdge( inShapePt, inHolePt ) {\r\n\t\t\t\t\t// checks for intersections with hole edges\r\n\t\t\t\t\tvar ihIdx, chkHole,\r\n\t\t\t\t\t\thIdx, nextIdx, intersection;\r\n\t\t\t\t\tfor ( ihIdx = 0; ihIdx < indepHoles.length; ihIdx ++ ) {\r\n\t\t\t\t\t\tchkHole = holes[indepHoles[ihIdx]];\r\n\t\t\t\t\t\tfor ( hIdx = 0; hIdx < chkHole.length; hIdx ++ ) {\r\n\t\t\t\t\t\t\tnextIdx = hIdx + 1; nextIdx %= chkHole.length;\r\n\t\t\t\t\t\t\tintersection = intersect_segments_2D( inShapePt, inHolePt, chkHole[hIdx], chkHole[nextIdx], true );\r\n\t\t\t\t\t\t\tif ( intersection.length > 0 )\t\treturn\ttrue;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn\tfalse;\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar holeIndex, shapeIndex,\r\n\t\t\t\t\tshapePt, holePt,\r\n\t\t\t\t\tholeIdx, cutKey, failedCuts = [],\r\n\t\t\t\t\ttmpShape1, tmpShape2,\r\n\t\t\t\t\ttmpHole1, tmpHole2;\r\n\t\r\n\t\t\t\tfor ( var h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\t\r\n\t\t\t\t\tindepHoles.push( h );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar minShapeIndex = 0;\r\n\t\t\t\tvar counter = indepHoles.length * 2;\r\n\t\t\t\twhile ( indepHoles.length > 0 ) {\r\n\t\t\t\t\tcounter --;\r\n\t\t\t\t\tif ( counter < 0 ) {\r\n\t\t\t\t\t\tconsole.log( \"Infinite Loop! Holes left:\" + indepHoles.length + \", Probably Hole outside Shape!\" );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t// search for shape-vertex and hole-vertex,\r\n\t\t\t\t\t// which can be connected without intersections\r\n\t\t\t\t\tfor ( shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex ++ ) {\r\n\t\r\n\t\t\t\t\t\tshapePt = shape[ shapeIndex ];\r\n\t\t\t\t\t\tholeIndex\t= - 1;\r\n\t\r\n\t\t\t\t\t\t// search for hole which can be reached without intersections\r\n\t\t\t\t\t\tfor ( var h = 0; h < indepHoles.length; h ++ ) {\r\n\t\t\t\t\t\t\tholeIdx = indepHoles[h];\r\n\t\r\n\t\t\t\t\t\t\t// prevent multiple checks\r\n\t\t\t\t\t\t\tcutKey = shapePt.x + \":\" + shapePt.y + \":\" + holeIdx;\r\n\t\t\t\t\t\t\tif ( failedCuts[cutKey] !== undefined )\t\t\tcontinue;\r\n\t\r\n\t\t\t\t\t\t\thole = holes[holeIdx];\r\n\t\t\t\t\t\t\tfor ( var h2 = 0; h2 < hole.length; h2 ++ ) {\r\n\t\t\t\t\t\t\t\tholePt = hole[ h2 ];\r\n\t\t\t\t\t\t\t\tif (! isCutLineInsideAngles( shapeIndex, h2 ) )\t\tcontinue;\r\n\t\t\t\t\t\t\t\tif ( intersectsShapeEdge( shapePt, holePt ) )\t\tcontinue;\r\n\t\t\t\t\t\t\t\tif ( intersectsHoleEdge( shapePt, holePt ) )\t\tcontinue;\r\n\t\r\n\t\t\t\t\t\t\t\tholeIndex = h2;\r\n\t\t\t\t\t\t\t\tindepHoles.splice(h, 1);\r\n\t\r\n\t\t\t\t\t\t\t\ttmpShape1 = shape.slice( 0, shapeIndex + 1 );\r\n\t\t\t\t\t\t\t\ttmpShape2 = shape.slice( shapeIndex );\r\n\t\t\t\t\t\t\t\ttmpHole1 = hole.slice( holeIndex );\r\n\t\t\t\t\t\t\t\ttmpHole2 = hole.slice( 0, holeIndex + 1 );\r\n\t\r\n\t\t\t\t\t\t\t\tshape = tmpShape1.concat( tmpHole1 ).concat( tmpHole2 ).concat( tmpShape2 );\r\n\t\r\n\t\t\t\t\t\t\t\tminShapeIndex = shapeIndex;\r\n\t\r\n\t\t\t\t\t\t\t\t// Debug only, to show the selected cuts\r\n\t\t\t\t\t\t\t\t// glob_CutLines.push( [ shapePt, holePt ] );\r\n\t\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif ( holeIndex >= 0 )\tbreak;\t\t// hole-vertex found\r\n\t\r\n\t\t\t\t\t\t\tfailedCuts[cutKey] = true;\t\t\t// remember failure\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif ( holeIndex >= 0 )\tbreak;\t\t// hole-vertex found\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn shape; \t\t\t/* shape with no holes */\r\n\t\t\t}\r\n\t\r\n\t\r\n\t\t\tvar i, il, f, face,\r\n\t\t\t\tkey, index,\r\n\t\t\t\tallPointsMap = {};\r\n\t\r\n\t\t\t// To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.\r\n\t\r\n\t\t\tvar allpoints = contour.concat();\r\n\t\r\n\t\t\tfor ( var h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\t\r\n\t\t\t\tArray.prototype.push.apply( allpoints, holes[h] );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t//console.log( \"allpoints\",allpoints, allpoints.length );\r\n\t\r\n\t\t\t// prepare all points map\r\n\t\r\n\t\t\tfor ( i = 0, il = allpoints.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tkey = allpoints[ i ].x + \":\" + allpoints[ i ].y;\r\n\t\r\n\t\t\t\tif ( allPointsMap[ key ] !== undefined ) {\r\n\t\r\n\t\t\t\t\tTHREE.warn( \"THREE.Shape: Duplicate point\", key );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tallPointsMap[ key ] = i;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// remove holes by cutting paths to holes and adding them to the shape\r\n\t\t\tvar shapeWithoutHoles = removeHoles( contour, holes );\r\n\t\r\n\t\t\tvar triangles = THREE.FontUtils.Triangulate( shapeWithoutHoles, false ); // True returns indices for points of spooled shape\r\n\t\t\t//console.log( \"triangles\",triangles, triangles.length );\r\n\t\r\n\t\t\t// check all face vertices against all points map\r\n\t\r\n\t\t\tfor ( i = 0, il = triangles.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tface = triangles[ i ];\r\n\t\r\n\t\t\t\tfor ( f = 0; f < 3; f ++ ) {\r\n\t\r\n\t\t\t\t\tkey = face[ f ].x + \":\" + face[ f ].y;\r\n\t\r\n\t\t\t\t\tindex = allPointsMap[ key ];\r\n\t\r\n\t\t\t\t\tif ( index !== undefined ) {\r\n\t\r\n\t\t\t\t\t\tface[ f ] = index;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn triangles.concat();\r\n\t\r\n\t\t},\r\n\t\r\n\t\tisClockWise: function ( pts ) {\r\n\t\r\n\t\t\treturn THREE.FontUtils.Triangulate.area( pts ) < 0;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// Bezier Curves formulas obtained from\r\n\t\t// http://en.wikipedia.org/wiki/B%C3%A9zier_curve\r\n\t\r\n\t\t// Quad Bezier Functions\r\n\t\r\n\t\tb2p0: function ( t, p ) {\r\n\t\r\n\t\t\tvar k = 1 - t;\r\n\t\t\treturn k * k * p;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tb2p1: function ( t, p ) {\r\n\t\r\n\t\t\treturn 2 * ( 1 - t ) * t * p;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tb2p2: function ( t, p ) {\r\n\t\r\n\t\t\treturn t * t * p;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tb2: function ( t, p0, p1, p2 ) {\r\n\t\r\n\t\t\treturn this.b2p0( t, p0 ) + this.b2p1( t, p1 ) + this.b2p2( t, p2 );\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// Cubic Bezier Functions\r\n\t\r\n\t\tb3p0: function ( t, p ) {\r\n\t\r\n\t\t\tvar k = 1 - t;\r\n\t\t\treturn k * k * k * p;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tb3p1: function ( t, p ) {\r\n\t\r\n\t\t\tvar k = 1 - t;\r\n\t\t\treturn 3 * k * k * t * p;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tb3p2: function ( t, p ) {\r\n\t\r\n\t\t\tvar k = 1 - t;\r\n\t\t\treturn 3 * k * t * t * p;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tb3p3: function ( t, p ) {\r\n\t\r\n\t\t\treturn t * t * t * p;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tb3: function ( t, p0, p1, p2, p3 ) {\r\n\t\r\n\t\t\treturn this.b3p0( t, p0 ) + this.b3p1( t, p1 ) + this.b3p2( t, p2 ) +  this.b3p3( t, p3 );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\t// File:src/extras/curves/LineCurve.js\r\n\t\r\n\t/**************************************************************\r\n\t *\tLine\r\n\t **************************************************************/\r\n\t\r\n\tTHREE.LineCurve = function ( v1, v2 ) {\r\n\t\r\n\t\tthis.v1 = v1;\r\n\t\tthis.v2 = v2;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.LineCurve.prototype = Object.create( THREE.Curve.prototype );\r\n\tTHREE.LineCurve.prototype.constructor = THREE.LineCurve;\r\n\t\r\n\tTHREE.LineCurve.prototype.getPoint = function ( t ) {\r\n\t\r\n\t\tvar point = this.v2.clone().sub(this.v1);\r\n\t\tpoint.multiplyScalar( t ).add( this.v1 );\r\n\t\r\n\t\treturn point;\r\n\t\r\n\t};\r\n\t\r\n\t// Line curve is linear, so we can overwrite default getPointAt\r\n\t\r\n\tTHREE.LineCurve.prototype.getPointAt = function ( u ) {\r\n\t\r\n\t\treturn this.getPoint( u );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.LineCurve.prototype.getTangent = function( t ) {\r\n\t\r\n\t\tvar tangent = this.v2.clone().sub(this.v1);\r\n\t\r\n\t\treturn tangent.normalize();\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/curves/QuadraticBezierCurve.js\r\n\t\r\n\t/**************************************************************\r\n\t *\tQuadratic Bezier curve\r\n\t **************************************************************/\r\n\t\r\n\t\r\n\tTHREE.QuadraticBezierCurve = function ( v0, v1, v2 ) {\r\n\t\r\n\t\tthis.v0 = v0;\r\n\t\tthis.v1 = v1;\r\n\t\tthis.v2 = v2;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.QuadraticBezierCurve.prototype = Object.create( THREE.Curve.prototype );\r\n\tTHREE.QuadraticBezierCurve.prototype.constructor = THREE.QuadraticBezierCurve;\r\n\t\r\n\t\r\n\tTHREE.QuadraticBezierCurve.prototype.getPoint = function ( t ) {\r\n\t\r\n\t\tvar vector = new THREE.Vector2();\r\n\t\r\n\t\tvector.x = THREE.Shape.Utils.b2( t, this.v0.x, this.v1.x, this.v2.x );\r\n\t\tvector.y = THREE.Shape.Utils.b2( t, this.v0.y, this.v1.y, this.v2.y );\r\n\t\r\n\t\treturn vector;\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\tTHREE.QuadraticBezierCurve.prototype.getTangent = function( t ) {\r\n\t\r\n\t\tvar vector = new THREE.Vector2();\r\n\t\r\n\t\tvector.x = THREE.Curve.Utils.tangentQuadraticBezier( t, this.v0.x, this.v1.x, this.v2.x );\r\n\t\tvector.y = THREE.Curve.Utils.tangentQuadraticBezier( t, this.v0.y, this.v1.y, this.v2.y );\r\n\t\r\n\t\t// returns unit vector\r\n\t\r\n\t\treturn vector.normalize();\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/curves/CubicBezierCurve.js\r\n\t\r\n\t/**************************************************************\r\n\t *\tCubic Bezier curve\r\n\t **************************************************************/\r\n\t\r\n\tTHREE.CubicBezierCurve = function ( v0, v1, v2, v3 ) {\r\n\t\r\n\t\tthis.v0 = v0;\r\n\t\tthis.v1 = v1;\r\n\t\tthis.v2 = v2;\r\n\t\tthis.v3 = v3;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.CubicBezierCurve.prototype = Object.create( THREE.Curve.prototype );\r\n\tTHREE.CubicBezierCurve.prototype.constructor = THREE.CubicBezierCurve;\r\n\t\r\n\tTHREE.CubicBezierCurve.prototype.getPoint = function ( t ) {\r\n\t\r\n\t\tvar tx, ty;\r\n\t\r\n\t\ttx = THREE.Shape.Utils.b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );\r\n\t\tty = THREE.Shape.Utils.b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );\r\n\t\r\n\t\treturn new THREE.Vector2( tx, ty );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.CubicBezierCurve.prototype.getTangent = function( t ) {\r\n\t\r\n\t\tvar tx, ty;\r\n\t\r\n\t\ttx = THREE.Curve.Utils.tangentCubicBezier( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );\r\n\t\tty = THREE.Curve.Utils.tangentCubicBezier( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );\r\n\t\r\n\t\tvar tangent = new THREE.Vector2( tx, ty );\r\n\t\ttangent.normalize();\r\n\t\r\n\t\treturn tangent;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/curves/SplineCurve.js\r\n\t\r\n\t/**************************************************************\r\n\t *\tSpline curve\r\n\t **************************************************************/\r\n\t\r\n\tTHREE.SplineCurve = function ( points /* array of Vector2 */ ) {\r\n\t\r\n\t\tthis.points = ( points == undefined ) ? [] : points;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.SplineCurve.prototype = Object.create( THREE.Curve.prototype );\r\n\tTHREE.SplineCurve.prototype.constructor = THREE.SplineCurve;\r\n\t\r\n\tTHREE.SplineCurve.prototype.getPoint = function ( t ) {\r\n\t\r\n\t\tvar points = this.points;\r\n\t\tvar point = ( points.length - 1 ) * t;\r\n\t\r\n\t\tvar intPoint = Math.floor( point );\r\n\t\tvar weight = point - intPoint;\r\n\t\r\n\t\tvar point0 = points[ intPoint == 0 ? intPoint : intPoint - 1 ]\r\n\t\tvar point1 = points[ intPoint ]\r\n\t\tvar point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ]\r\n\t\tvar point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ]\r\n\t\r\n\t\tvar vector = new THREE.Vector2();\r\n\t\r\n\t\tvector.x = THREE.Curve.Utils.interpolate( point0.x, point1.x, point2.x, point3.x, weight );\r\n\t\tvector.y = THREE.Curve.Utils.interpolate( point0.y, point1.y, point2.y, point3.y, weight );\r\n\t\r\n\t\treturn vector;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/curves/EllipseCurve.js\r\n\t\r\n\t/**************************************************************\r\n\t *\tEllipse curve\r\n\t **************************************************************/\r\n\t\r\n\tTHREE.EllipseCurve = function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise ) {\r\n\t\r\n\t\tthis.aX = aX;\r\n\t\tthis.aY = aY;\r\n\t\r\n\t\tthis.xRadius = xRadius;\r\n\t\tthis.yRadius = yRadius;\r\n\t\r\n\t\tthis.aStartAngle = aStartAngle;\r\n\t\tthis.aEndAngle = aEndAngle;\r\n\t\r\n\t\tthis.aClockwise = aClockwise;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.EllipseCurve.prototype = Object.create( THREE.Curve.prototype );\r\n\tTHREE.EllipseCurve.prototype.constructor = THREE.EllipseCurve;\r\n\t\r\n\tTHREE.EllipseCurve.prototype.getPoint = function ( t ) {\r\n\t\r\n\t\tvar deltaAngle = this.aEndAngle - this.aStartAngle;\r\n\t\r\n\t\tif ( deltaAngle < 0 ) deltaAngle += Math.PI * 2;\r\n\t\tif ( deltaAngle > Math.PI * 2 ) deltaAngle -= Math.PI * 2;\r\n\t\r\n\t\tvar angle;\r\n\t\r\n\t\tif ( this.aClockwise === true ) {\r\n\t\r\n\t\t\tangle = this.aEndAngle + ( 1 - t ) * ( Math.PI * 2 - deltaAngle );\r\n\t\r\n\t\t} else {\r\n\t\r\n\t\t\tangle = this.aStartAngle + t * deltaAngle;\r\n\t\r\n\t\t}\r\n\t\t\r\n\t\tvar vector = new THREE.Vector2();\r\n\t\r\n\t\tvector.x = this.aX + this.xRadius * Math.cos( angle );\r\n\t\tvector.y = this.aY + this.yRadius * Math.sin( angle );\r\n\t\r\n\t\treturn vector;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/curves/ArcCurve.js\r\n\t\r\n\t/**************************************************************\r\n\t *\tArc curve\r\n\t **************************************************************/\r\n\t\r\n\tTHREE.ArcCurve = function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\r\n\t\r\n\t\tTHREE.EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\r\n\t};\r\n\t\r\n\tTHREE.ArcCurve.prototype = Object.create( THREE.EllipseCurve.prototype );\r\n\tTHREE.ArcCurve.prototype.constructor = THREE.ArcCurve;\r\n\t\r\n\t// File:src/extras/curves/LineCurve3.js\r\n\t\r\n\t/**************************************************************\r\n\t *\tLine3D\r\n\t **************************************************************/\r\n\t\r\n\tTHREE.LineCurve3 = THREE.Curve.create(\r\n\t\r\n\t\tfunction ( v1, v2 ) {\r\n\t\r\n\t\t\tthis.v1 = v1;\r\n\t\t\tthis.v2 = v2;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfunction ( t ) {\r\n\t\r\n\t\t\tvar vector = new THREE.Vector3();\r\n\t\r\n\t\t\tvector.subVectors( this.v2, this.v1 ); // diff\r\n\t\t\tvector.multiplyScalar( t );\r\n\t\t\tvector.add( this.v1 );\r\n\t\r\n\t\t\treturn vector;\r\n\t\r\n\t\t}\r\n\t\r\n\t);\r\n\t\r\n\t// File:src/extras/curves/QuadraticBezierCurve3.js\r\n\t\r\n\t/**************************************************************\r\n\t *\tQuadratic Bezier 3D curve\r\n\t **************************************************************/\r\n\t\r\n\tTHREE.QuadraticBezierCurve3 = THREE.Curve.create(\r\n\t\r\n\t\tfunction ( v0, v1, v2 ) {\r\n\t\r\n\t\t\tthis.v0 = v0;\r\n\t\t\tthis.v1 = v1;\r\n\t\t\tthis.v2 = v2;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfunction ( t ) {\r\n\t\r\n\t\t\tvar vector = new THREE.Vector3();\r\n\t\r\n\t\t\tvector.x = THREE.Shape.Utils.b2( t, this.v0.x, this.v1.x, this.v2.x );\r\n\t\t\tvector.y = THREE.Shape.Utils.b2( t, this.v0.y, this.v1.y, this.v2.y );\r\n\t\t\tvector.z = THREE.Shape.Utils.b2( t, this.v0.z, this.v1.z, this.v2.z );\r\n\t\r\n\t\t\treturn vector;\r\n\t\r\n\t\t}\r\n\t\r\n\t);\r\n\t\r\n\t// File:src/extras/curves/CubicBezierCurve3.js\r\n\t\r\n\t/**************************************************************\r\n\t *\tCubic Bezier 3D curve\r\n\t **************************************************************/\r\n\t\r\n\tTHREE.CubicBezierCurve3 = THREE.Curve.create(\r\n\t\r\n\t\tfunction ( v0, v1, v2, v3 ) {\r\n\t\r\n\t\t\tthis.v0 = v0;\r\n\t\t\tthis.v1 = v1;\r\n\t\t\tthis.v2 = v2;\r\n\t\t\tthis.v3 = v3;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfunction ( t ) {\r\n\t\r\n\t\t\tvar vector = new THREE.Vector3();\r\n\t\r\n\t\t\tvector.x = THREE.Shape.Utils.b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );\r\n\t\t\tvector.y = THREE.Shape.Utils.b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );\r\n\t\t\tvector.z = THREE.Shape.Utils.b3( t, this.v0.z, this.v1.z, this.v2.z, this.v3.z );\r\n\t\r\n\t\t\treturn vector;\r\n\t\r\n\t\t}\r\n\t\r\n\t);\r\n\t\r\n\t// File:src/extras/curves/SplineCurve3.js\r\n\t\r\n\t/**************************************************************\r\n\t *\tSpline 3D curve\r\n\t **************************************************************/\r\n\t\r\n\t\r\n\tTHREE.SplineCurve3 = THREE.Curve.create(\r\n\t\r\n\t\tfunction ( points /* array of Vector3 */) {\r\n\t\r\n\t\t\tthis.points = ( points == undefined ) ? [] : points;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfunction ( t ) {\r\n\t\r\n\t\t\tvar points = this.points;\r\n\t\t\tvar point = ( points.length - 1 ) * t;\r\n\t\r\n\t\t\tvar intPoint = Math.floor( point );\r\n\t\t\tvar weight = point - intPoint;\r\n\t\r\n\t\t\tvar point0 = points[ intPoint == 0 ? intPoint : intPoint - 1 ];\r\n\t\t\tvar point1 = points[ intPoint ];\r\n\t\t\tvar point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];\r\n\t\t\tvar point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];\r\n\t\r\n\t\t\tvar vector = new THREE.Vector3();\r\n\t\r\n\t\t\tvector.x = THREE.Curve.Utils.interpolate( point0.x, point1.x, point2.x, point3.x, weight );\r\n\t\t\tvector.y = THREE.Curve.Utils.interpolate( point0.y, point1.y, point2.y, point3.y, weight );\r\n\t\t\tvector.z = THREE.Curve.Utils.interpolate( point0.z, point1.z, point2.z, point3.z, weight );\r\n\t\r\n\t\t\treturn vector;\r\n\t\r\n\t\t}\r\n\t\r\n\t);\r\n\t\r\n\t// File:src/extras/curves/ClosedSplineCurve3.js\r\n\t\r\n\t/**************************************************************\r\n\t *\tClosed Spline 3D curve\r\n\t **************************************************************/\r\n\t\r\n\t\r\n\tTHREE.ClosedSplineCurve3 = THREE.Curve.create(\r\n\t\r\n\t\tfunction ( points /* array of Vector3 */) {\r\n\t\r\n\t\t\tthis.points = ( points == undefined ) ? [] : points;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfunction ( t ) {\r\n\t\r\n\t\t\tvar points = this.points;\r\n\t\t\tvar point = ( points.length - 0 ) * t; // This needs to be from 0-length +1\r\n\t\r\n\t\t\tvar intPoint = Math.floor( point );\r\n\t\t\tvar weight = point - intPoint;\r\n\t\r\n\t\t\tintPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;\r\n\t\r\n\t\t\tvar point0 = points[ ( intPoint - 1 ) % points.length ];\r\n\t\t\tvar point1 = points[ ( intPoint     ) % points.length ];\r\n\t\t\tvar point2 = points[ ( intPoint + 1 ) % points.length ];\r\n\t\t\tvar point3 = points[ ( intPoint + 2 ) % points.length ];\r\n\t\r\n\t\t\tvar vector = new THREE.Vector3();\r\n\t\r\n\t\t\tvector.x = THREE.Curve.Utils.interpolate( point0.x, point1.x, point2.x, point3.x, weight );\r\n\t\t\tvector.y = THREE.Curve.Utils.interpolate( point0.y, point1.y, point2.y, point3.y, weight );\r\n\t\t\tvector.z = THREE.Curve.Utils.interpolate( point0.z, point1.z, point2.z, point3.z, weight );\r\n\t\r\n\t\t\treturn vector;\r\n\t\r\n\t\t}\r\n\t\r\n\t);\r\n\t\r\n\t// File:src/extras/animation/AnimationHandler.js\r\n\t\r\n\t/**\r\n\t * @author mikael emtinger / http://gomo.se/\r\n\t */\r\n\t\r\n\tTHREE.AnimationHandler = {\r\n\t\r\n\t\tLINEAR: 0,\r\n\t\tCATMULLROM: 1,\r\n\t\tCATMULLROM_FORWARD: 2,\r\n\t\r\n\t\t//\r\n\t\r\n\t\tadd: function () { THREE.warn( 'THREE.AnimationHandler.add() has been deprecated.' ); },\r\n\t\tget: function () { THREE.warn( 'THREE.AnimationHandler.get() has been deprecated.' ); },\r\n\t\tremove: function () { THREE.warn( 'THREE.AnimationHandler.remove() has been deprecated.' ); },\r\n\t\r\n\t\t//\r\n\t\r\n\t\tanimations: [],\r\n\t\r\n\t\tinit: function ( data ) {\r\n\t\r\n\t\t\tif ( data.initialized === true ) return data;\r\n\t\r\n\t\t\t// loop through all keys\r\n\t\r\n\t\t\tfor ( var h = 0; h < data.hierarchy.length; h ++ ) {\r\n\t\r\n\t\t\t\tfor ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {\r\n\t\r\n\t\t\t\t\t// remove minus times\r\n\t\r\n\t\t\t\t\tif ( data.hierarchy[ h ].keys[ k ].time < 0 ) {\r\n\t\r\n\t\t\t\t\t\t data.hierarchy[ h ].keys[ k ].time = 0;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t// create quaternions\r\n\t\r\n\t\t\t\t\tif ( data.hierarchy[ h ].keys[ k ].rot !== undefined &&\r\n\t\t\t\t\t  ! ( data.hierarchy[ h ].keys[ k ].rot instanceof THREE.Quaternion ) ) {\r\n\t\r\n\t\t\t\t\t\tvar quat = data.hierarchy[ h ].keys[ k ].rot;\r\n\t\t\t\t\t\tdata.hierarchy[ h ].keys[ k ].rot = new THREE.Quaternion().fromArray( quat );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// prepare morph target keys\r\n\t\r\n\t\t\t\tif ( data.hierarchy[ h ].keys.length && data.hierarchy[ h ].keys[ 0 ].morphTargets !== undefined ) {\r\n\t\r\n\t\t\t\t\t// get all used\r\n\t\r\n\t\t\t\t\tvar usedMorphTargets = {};\r\n\t\r\n\t\t\t\t\tfor ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {\r\n\t\r\n\t\t\t\t\t\tfor ( var m = 0; m < data.hierarchy[ h ].keys[ k ].morphTargets.length; m ++ ) {\r\n\t\r\n\t\t\t\t\t\t\tvar morphTargetName = data.hierarchy[ h ].keys[ k ].morphTargets[ m ];\r\n\t\t\t\t\t\t\tusedMorphTargets[ morphTargetName ] = - 1;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tdata.hierarchy[ h ].usedMorphTargets = usedMorphTargets;\r\n\t\r\n\t\r\n\t\t\t\t\t// set all used on all frames\r\n\t\r\n\t\t\t\t\tfor ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {\r\n\t\r\n\t\t\t\t\t\tvar influences = {};\r\n\t\r\n\t\t\t\t\t\tfor ( var morphTargetName in usedMorphTargets ) {\r\n\t\r\n\t\t\t\t\t\t\tfor ( var m = 0; m < data.hierarchy[ h ].keys[ k ].morphTargets.length; m ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\tif ( data.hierarchy[ h ].keys[ k ].morphTargets[ m ] === morphTargetName ) {\r\n\t\r\n\t\t\t\t\t\t\t\t\tinfluences[ morphTargetName ] = data.hierarchy[ h ].keys[ k ].morphTargetsInfluences[ m ];\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\tif ( m === data.hierarchy[ h ].keys[ k ].morphTargets.length ) {\r\n\t\r\n\t\t\t\t\t\t\t\tinfluences[ morphTargetName ] = 0;\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tdata.hierarchy[ h ].keys[ k ].morphTargetsInfluences = influences;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\r\n\t\t\t\t// remove all keys that are on the same time\r\n\t\r\n\t\t\t\tfor ( var k = 1; k < data.hierarchy[ h ].keys.length; k ++ ) {\r\n\t\r\n\t\t\t\t\tif ( data.hierarchy[ h ].keys[ k ].time === data.hierarchy[ h ].keys[ k - 1 ].time ) {\r\n\t\r\n\t\t\t\t\t\tdata.hierarchy[ h ].keys.splice( k, 1 );\r\n\t\t\t\t\t\tk --;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\r\n\t\t\t\t// set index\r\n\t\r\n\t\t\t\tfor ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {\r\n\t\r\n\t\t\t\t\tdata.hierarchy[ h ].keys[ k ].index = k;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tdata.initialized = true;\r\n\t\r\n\t\t\treturn data;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tparse: function ( root ) {\r\n\t\r\n\t\t\tvar parseRecurseHierarchy = function ( root, hierarchy ) {\r\n\t\r\n\t\t\t\thierarchy.push( root );\r\n\t\r\n\t\t\t\tfor ( var c = 0; c < root.children.length; c ++ )\r\n\t\t\t\t\tparseRecurseHierarchy( root.children[ c ], hierarchy );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t\t// setup hierarchy\r\n\t\r\n\t\t\tvar hierarchy = [];\r\n\t\r\n\t\t\tif ( root instanceof THREE.SkinnedMesh ) {\r\n\t\r\n\t\t\t\tfor ( var b = 0; b < root.skeleton.bones.length; b ++ ) {\r\n\t\r\n\t\t\t\t\thierarchy.push( root.skeleton.bones[ b ] );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tparseRecurseHierarchy( root, hierarchy );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn hierarchy;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tplay: function ( animation ) {\r\n\t\r\n\t\t\tif ( this.animations.indexOf( animation ) === - 1 ) {\r\n\t\r\n\t\t\t\tthis.animations.push( animation );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tstop: function ( animation ) {\r\n\t\r\n\t\t\tvar index = this.animations.indexOf( animation );\r\n\t\r\n\t\t\tif ( index !== - 1 ) {\r\n\t\r\n\t\t\t\tthis.animations.splice( index, 1 );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tupdate: function ( deltaTimeMS ) {\r\n\t\r\n\t\t\tfor ( var i = 0; i < this.animations.length; i ++ ) {\r\n\t\r\n\t\t\t\tthis.animations[ i ].resetBlendWeights( );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfor ( var i = 0; i < this.animations.length; i ++ ) {\r\n\t\r\n\t\t\t\tthis.animations[ i ].update( deltaTimeMS );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/animation/Animation.js\r\n\t\r\n\t/**\r\n\t * @author mikael emtinger / http://gomo.se/\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.Animation = function ( root, data ) {\r\n\t\r\n\t\tthis.root = root;\r\n\t\tthis.data = THREE.AnimationHandler.init( data );\r\n\t\tthis.hierarchy = THREE.AnimationHandler.parse( root );\r\n\t\r\n\t\tthis.currentTime = 0;\r\n\t\tthis.timeScale = 1;\r\n\t\r\n\t\tthis.isPlaying = false;\r\n\t\tthis.loop = true;\r\n\t\tthis.weight = 0;\r\n\t\r\n\t\tthis.interpolationType = THREE.AnimationHandler.LINEAR;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Animation.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Animation,\r\n\t\r\n\t\tkeyTypes:  [ \"pos\", \"rot\", \"scl\" ],\r\n\t\r\n\t\tplay: function ( startTime, weight ) {\r\n\t\r\n\t\t\tthis.currentTime = startTime !== undefined ? startTime : 0;\r\n\t\t\tthis.weight = weight !== undefined ? weight : 1;\r\n\t\r\n\t\t\tthis.isPlaying = true;\r\n\t\r\n\t\t\tthis.reset();\r\n\t\r\n\t\t\tTHREE.AnimationHandler.play( this );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tstop: function() {\r\n\t\r\n\t\t\tthis.isPlaying = false;\r\n\t\r\n\t\t\tTHREE.AnimationHandler.stop( this );\r\n\t\r\n\t\t},\r\n\t\r\n\t\treset: function () {\r\n\t\r\n\t\t\tfor ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {\r\n\t\r\n\t\t\t\tvar object = this.hierarchy[ h ];\r\n\t\r\n\t\t\t\tif ( object.animationCache === undefined ) {\r\n\t\r\n\t\t\t\t\tobject.animationCache = {\r\n\t\t\t\t\t\tanimations: {},\r\n\t\t\t\t\t\tblending: {\r\n\t\t\t\t\t\t\tpositionWeight: 0.0,\r\n\t\t\t\t\t\t\tquaternionWeight: 0.0,\r\n\t\t\t\t\t\t\tscaleWeight: 0.0\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar name = this.data.name;\r\n\t\t\t\tvar animations = object.animationCache.animations;\r\n\t\t\t\tvar animationCache = animations[ name ];\r\n\t\r\n\t\t\t\tif ( animationCache === undefined ) {\r\n\t\r\n\t\t\t\t\tanimationCache = {\r\n\t\t\t\t\t\tprevKey: { pos: 0, rot: 0, scl: 0 },\r\n\t\t\t\t\t\tnextKey: { pos: 0, rot: 0, scl: 0 },\r\n\t\t\t\t\t\toriginalMatrix: object.matrix\r\n\t\t\t\t\t};\r\n\t\r\n\t\t\t\t\tanimations[ name ] = animationCache;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// Get keys to match our current time\r\n\t\r\n\t\t\t\tfor ( var t = 0; t < 3; t ++ ) {\r\n\t\r\n\t\t\t\t\tvar type = this.keyTypes[ t ];\r\n\t\r\n\t\t\t\t\tvar prevKey = this.data.hierarchy[ h ].keys[ 0 ];\r\n\t\t\t\t\tvar nextKey = this.getNextKeyWith( type, h, 1 );\r\n\t\r\n\t\t\t\t\twhile ( nextKey.time < this.currentTime && nextKey.index > prevKey.index ) {\r\n\t\r\n\t\t\t\t\t\tprevKey = nextKey;\r\n\t\t\t\t\t\tnextKey = this.getNextKeyWith( type, h, nextKey.index + 1 );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tanimationCache.prevKey[ type ] = prevKey;\r\n\t\t\t\t\tanimationCache.nextKey[ type ] = nextKey;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tresetBlendWeights: function () {\r\n\t\r\n\t\t\tfor ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {\r\n\t\r\n\t\t\t\tvar object = this.hierarchy[ h ];\r\n\t\t\t\tvar animationCache = object.animationCache;\r\n\t\r\n\t\t\t\tif ( animationCache !== undefined ) {\r\n\t\r\n\t\t\t\t\tvar blending = animationCache.blending;\r\n\t\r\n\t\t\t\t\tblending.positionWeight = 0.0;\r\n\t\t\t\t\tblending.quaternionWeight = 0.0;\r\n\t\t\t\t\tblending.scaleWeight = 0.0;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tupdate: ( function() {\r\n\t\r\n\t\t\tvar points = [];\r\n\t\t\tvar target = new THREE.Vector3();\r\n\t\t\tvar newVector = new THREE.Vector3();\r\n\t\t\tvar newQuat = new THREE.Quaternion();\r\n\t\r\n\t\t\t// Catmull-Rom spline\r\n\t\r\n\t\t\tvar interpolateCatmullRom = function ( points, scale ) {\r\n\t\r\n\t\t\t\tvar c = [], v3 = [],\r\n\t\t\t\tpoint, intPoint, weight, w2, w3,\r\n\t\t\t\tpa, pb, pc, pd;\r\n\t\r\n\t\t\t\tpoint = ( points.length - 1 ) * scale;\r\n\t\t\t\tintPoint = Math.floor( point );\r\n\t\t\t\tweight = point - intPoint;\r\n\t\r\n\t\t\t\tc[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;\r\n\t\t\t\tc[ 1 ] = intPoint;\r\n\t\t\t\tc[ 2 ] = intPoint > points.length - 2 ? intPoint : intPoint + 1;\r\n\t\t\t\tc[ 3 ] = intPoint > points.length - 3 ? intPoint : intPoint + 2;\r\n\t\r\n\t\t\t\tpa = points[ c[ 0 ] ];\r\n\t\t\t\tpb = points[ c[ 1 ] ];\r\n\t\t\t\tpc = points[ c[ 2 ] ];\r\n\t\t\t\tpd = points[ c[ 3 ] ];\r\n\t\r\n\t\t\t\tw2 = weight * weight;\r\n\t\t\t\tw3 = weight * w2;\r\n\t\r\n\t\t\t\tv3[ 0 ] = interpolate( pa[ 0 ], pb[ 0 ], pc[ 0 ], pd[ 0 ], weight, w2, w3 );\r\n\t\t\t\tv3[ 1 ] = interpolate( pa[ 1 ], pb[ 1 ], pc[ 1 ], pd[ 1 ], weight, w2, w3 );\r\n\t\t\t\tv3[ 2 ] = interpolate( pa[ 2 ], pb[ 2 ], pc[ 2 ], pd[ 2 ], weight, w2, w3 );\r\n\t\r\n\t\t\t\treturn v3;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t\tvar interpolate = function ( p0, p1, p2, p3, t, t2, t3 ) {\r\n\t\r\n\t\t\t\tvar v0 = ( p2 - p0 ) * 0.5,\r\n\t\t\t\t\tv1 = ( p3 - p1 ) * 0.5;\r\n\t\r\n\t\t\t\treturn ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t\treturn function ( delta ) {\r\n\t\r\n\t\t\t\tif ( this.isPlaying === false ) return;\r\n\t\r\n\t\t\t\tthis.currentTime += delta * this.timeScale;\r\n\t\r\n\t\t\t\tif ( this.weight === 0 )\r\n\t\t\t\t\treturn;\r\n\t\r\n\t\t\t\t//\r\n\t\r\n\t\t\t\tvar duration = this.data.length;\r\n\t\r\n\t\t\t\tif ( this.currentTime > duration || this.currentTime < 0 ) {\r\n\t\r\n\t\t\t\t\tif ( this.loop ) {\r\n\t\r\n\t\t\t\t\t\tthis.currentTime %= duration;\r\n\t\r\n\t\t\t\t\t\tif ( this.currentTime < 0 )\r\n\t\t\t\t\t\t\tthis.currentTime += duration;\r\n\t\r\n\t\t\t\t\t\tthis.reset();\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tthis.stop();\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tfor ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {\r\n\t\r\n\t\t\t\t\tvar object = this.hierarchy[ h ];\r\n\t\t\t\t\tvar animationCache = object.animationCache.animations[this.data.name];\r\n\t\t\t\t\tvar blending = object.animationCache.blending;\r\n\t\r\n\t\t\t\t\t// loop through pos/rot/scl\r\n\t\r\n\t\t\t\t\tfor ( var t = 0; t < 3; t ++ ) {\r\n\t\r\n\t\t\t\t\t\t// get keys\r\n\t\r\n\t\t\t\t\t\tvar type    = this.keyTypes[ t ];\r\n\t\t\t\t\t\tvar prevKey = animationCache.prevKey[ type ];\r\n\t\t\t\t\t\tvar nextKey = animationCache.nextKey[ type ];\r\n\t\r\n\t\t\t\t\t\tif ( ( this.timeScale > 0 && nextKey.time <= this.currentTime ) ||\r\n\t\t\t\t\t\t\t( this.timeScale < 0 && prevKey.time >= this.currentTime ) ) {\r\n\t\r\n\t\t\t\t\t\t\tprevKey = this.data.hierarchy[ h ].keys[ 0 ];\r\n\t\t\t\t\t\t\tnextKey = this.getNextKeyWith( type, h, 1 );\r\n\t\r\n\t\t\t\t\t\t\twhile ( nextKey.time < this.currentTime && nextKey.index > prevKey.index ) {\r\n\t\r\n\t\t\t\t\t\t\t\tprevKey = nextKey;\r\n\t\t\t\t\t\t\t\tnextKey = this.getNextKeyWith( type, h, nextKey.index + 1 );\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\tanimationCache.prevKey[ type ] = prevKey;\r\n\t\t\t\t\t\t\tanimationCache.nextKey[ type ] = nextKey;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tvar scale = ( this.currentTime - prevKey.time ) / ( nextKey.time - prevKey.time );\r\n\t\r\n\t\t\t\t\t\tvar prevXYZ = prevKey[ type ];\r\n\t\t\t\t\t\tvar nextXYZ = nextKey[ type ];\r\n\t\r\n\t\t\t\t\t\tif ( scale < 0 ) scale = 0;\r\n\t\t\t\t\t\tif ( scale > 1 ) scale = 1;\r\n\t\r\n\t\t\t\t\t\t// interpolate\r\n\t\r\n\t\t\t\t\t\tif ( type === \"pos\" ) {\r\n\t\r\n\t\t\t\t\t\t\tif ( this.interpolationType === THREE.AnimationHandler.LINEAR ) {\r\n\t\r\n\t\t\t\t\t\t\t\tnewVector.x = prevXYZ[ 0 ] + ( nextXYZ[ 0 ] - prevXYZ[ 0 ] ) * scale;\r\n\t\t\t\t\t\t\t\tnewVector.y = prevXYZ[ 1 ] + ( nextXYZ[ 1 ] - prevXYZ[ 1 ] ) * scale;\r\n\t\t\t\t\t\t\t\tnewVector.z = prevXYZ[ 2 ] + ( nextXYZ[ 2 ] - prevXYZ[ 2 ] ) * scale;\r\n\t\r\n\t\t\t\t\t\t\t\t// blend\r\n\t\t\t\t\t\t\t\tvar proportionalWeight = this.weight / ( this.weight + blending.positionWeight );\r\n\t\t\t\t\t\t\t\tobject.position.lerp( newVector, proportionalWeight );\r\n\t\t\t\t\t\t\t\tblending.positionWeight += this.weight;\r\n\t\r\n\t\t\t\t\t\t\t} else if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||\r\n\t\t\t\t\t\t\t\t\t\tthis.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {\r\n\t\r\n\t\t\t\t\t\t\t\tpoints[ 0 ] = this.getPrevKeyWith( \"pos\", h, prevKey.index - 1 )[ \"pos\" ];\r\n\t\t\t\t\t\t\t\tpoints[ 1 ] = prevXYZ;\r\n\t\t\t\t\t\t\t\tpoints[ 2 ] = nextXYZ;\r\n\t\t\t\t\t\t\t\tpoints[ 3 ] = this.getNextKeyWith( \"pos\", h, nextKey.index + 1 )[ \"pos\" ];\r\n\t\r\n\t\t\t\t\t\t\t\tscale = scale * 0.33 + 0.33;\r\n\t\r\n\t\t\t\t\t\t\t\tvar currentPoint = interpolateCatmullRom( points, scale );\r\n\t\t\t\t\t\t\t\tvar proportionalWeight = this.weight / ( this.weight + blending.positionWeight );\r\n\t\t\t\t\t\t\t\tblending.positionWeight += this.weight;\r\n\t\r\n\t\t\t\t\t\t\t\t// blend\r\n\t\r\n\t\t\t\t\t\t\t\tvar vector = object.position;\r\n\t\r\n\t\t\t\t\t\t\t\tvector.x = vector.x + ( currentPoint[ 0 ] - vector.x ) * proportionalWeight;\r\n\t\t\t\t\t\t\t\tvector.y = vector.y + ( currentPoint[ 1 ] - vector.y ) * proportionalWeight;\r\n\t\t\t\t\t\t\t\tvector.z = vector.z + ( currentPoint[ 2 ] - vector.z ) * proportionalWeight;\r\n\t\r\n\t\t\t\t\t\t\t\tif ( this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {\r\n\t\r\n\t\t\t\t\t\t\t\t\tvar forwardPoint = interpolateCatmullRom( points, scale * 1.01 );\r\n\t\r\n\t\t\t\t\t\t\t\t\ttarget.set( forwardPoint[ 0 ], forwardPoint[ 1 ], forwardPoint[ 2 ] );\r\n\t\t\t\t\t\t\t\t\ttarget.sub( vector );\r\n\t\t\t\t\t\t\t\t\ttarget.y = 0;\r\n\t\t\t\t\t\t\t\t\ttarget.normalize();\r\n\t\r\n\t\t\t\t\t\t\t\t\tvar angle = Math.atan2( target.x, target.z );\r\n\t\t\t\t\t\t\t\t\tobject.rotation.set( 0, angle, 0 );\r\n\t\r\n\t\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t} else if ( type === \"rot\" ) {\r\n\t\r\n\t\t\t\t\t\t\tTHREE.Quaternion.slerp( prevXYZ, nextXYZ, newQuat, scale );\r\n\t\r\n\t\t\t\t\t\t\t// Avoid paying the cost of an additional slerp if we don't have to\r\n\t\t\t\t\t\t\tif ( blending.quaternionWeight === 0 ) {\r\n\t\r\n\t\t\t\t\t\t\t\tobject.quaternion.copy(newQuat);\r\n\t\t\t\t\t\t\t\tblending.quaternionWeight = this.weight;\r\n\t\r\n\t\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\t\tvar proportionalWeight = this.weight / ( this.weight + blending.quaternionWeight );\r\n\t\t\t\t\t\t\t\tTHREE.Quaternion.slerp( object.quaternion, newQuat, object.quaternion, proportionalWeight );\r\n\t\t\t\t\t\t\t\tblending.quaternionWeight += this.weight;\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t} else if ( type === \"scl\" ) {\r\n\t\r\n\t\t\t\t\t\t\tnewVector.x = prevXYZ[ 0 ] + ( nextXYZ[ 0 ] - prevXYZ[ 0 ] ) * scale;\r\n\t\t\t\t\t\t\tnewVector.y = prevXYZ[ 1 ] + ( nextXYZ[ 1 ] - prevXYZ[ 1 ] ) * scale;\r\n\t\t\t\t\t\t\tnewVector.z = prevXYZ[ 2 ] + ( nextXYZ[ 2 ] - prevXYZ[ 2 ] ) * scale;\r\n\t\r\n\t\t\t\t\t\t\tvar proportionalWeight = this.weight / ( this.weight + blending.scaleWeight );\r\n\t\t\t\t\t\t\tobject.scale.lerp( newVector, proportionalWeight );\r\n\t\t\t\t\t\t\tblending.scaleWeight += this.weight;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn true;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t} )(),\r\n\t\r\n\t\tgetNextKeyWith: function ( type, h, key ) {\r\n\t\r\n\t\t\tvar keys = this.data.hierarchy[ h ].keys;\r\n\t\r\n\t\t\tif ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||\r\n\t\t\t\t this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {\r\n\t\r\n\t\t\t\tkey = key < keys.length - 1 ? key : keys.length - 1;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tkey = key % keys.length;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfor ( ; key < keys.length; key ++ ) {\r\n\t\r\n\t\t\t\tif ( keys[ key ][ type ] !== undefined ) {\r\n\t\r\n\t\t\t\t\treturn keys[ key ];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this.data.hierarchy[ h ].keys[ 0 ];\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetPrevKeyWith: function ( type, h, key ) {\r\n\t\r\n\t\t\tvar keys = this.data.hierarchy[ h ].keys;\r\n\t\r\n\t\t\tif ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||\r\n\t\t\t\tthis.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {\r\n\t\r\n\t\t\t\tkey = key > 0 ? key : 0;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tkey = key >= 0 ? key : key + keys.length;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\r\n\t\t\tfor ( ; key >= 0; key -- ) {\r\n\t\r\n\t\t\t\tif ( keys[ key ][ type ] !== undefined ) {\r\n\t\r\n\t\t\t\t\treturn keys[ key ];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this.data.hierarchy[ h ].keys[ keys.length - 1 ];\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/animation/KeyFrameAnimation.js\r\n\t\r\n\t/**\r\n\t * @author mikael emtinger / http://gomo.se/\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author khang duong\r\n\t * @author erik kitson\r\n\t */\r\n\t\r\n\tTHREE.KeyFrameAnimation = function ( data ) {\r\n\t\r\n\t\tthis.root = data.node;\r\n\t\tthis.data = THREE.AnimationHandler.init( data );\r\n\t\tthis.hierarchy = THREE.AnimationHandler.parse( this.root );\r\n\t\tthis.currentTime = 0;\r\n\t\tthis.timeScale = 0.001;\r\n\t\tthis.isPlaying = false;\r\n\t\tthis.isPaused = true;\r\n\t\tthis.loop = true;\r\n\t\r\n\t\t// initialize to first keyframes\r\n\t\r\n\t\tfor ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {\r\n\t\r\n\t\t\tvar keys = this.data.hierarchy[h].keys,\r\n\t\t\t\tsids = this.data.hierarchy[h].sids,\r\n\t\t\t\tobj = this.hierarchy[h];\r\n\t\r\n\t\t\tif ( keys.length && sids ) {\r\n\t\r\n\t\t\t\tfor ( var s = 0; s < sids.length; s ++ ) {\r\n\t\r\n\t\t\t\t\tvar sid = sids[ s ],\r\n\t\t\t\t\t\tnext = this.getNextKeyWith( sid, h, 0 );\r\n\t\r\n\t\t\t\t\tif ( next ) {\r\n\t\r\n\t\t\t\t\t\tnext.apply( sid );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tobj.matrixAutoUpdate = false;\r\n\t\t\t\tthis.data.hierarchy[h].node.updateMatrix();\r\n\t\t\t\tobj.matrixWorldNeedsUpdate = true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.KeyFrameAnimation.prototype = {\r\n\t\r\n\t\tconstructor: THREE.KeyFrameAnimation,\r\n\t\r\n\t\tplay: function ( startTime ) {\r\n\t\r\n\t\t\tthis.currentTime = startTime !== undefined ? startTime : 0;\r\n\t\r\n\t\t\tif ( this.isPlaying === false ) {\r\n\t\r\n\t\t\t\tthis.isPlaying = true;\r\n\t\r\n\t\t\t\t// reset key cache\r\n\t\r\n\t\t\t\tvar h, hl = this.hierarchy.length,\r\n\t\t\t\t\tobject,\r\n\t\t\t\t\tnode;\r\n\t\r\n\t\t\t\tfor ( h = 0; h < hl; h ++ ) {\r\n\t\r\n\t\t\t\t\tobject = this.hierarchy[ h ];\r\n\t\t\t\t\tnode = this.data.hierarchy[ h ];\r\n\t\r\n\t\t\t\t\tif ( node.animationCache === undefined ) {\r\n\t\r\n\t\t\t\t\t\tnode.animationCache = {};\r\n\t\t\t\t\t\tnode.animationCache.prevKey = null;\r\n\t\t\t\t\t\tnode.animationCache.nextKey = null;\r\n\t\t\t\t\t\tnode.animationCache.originalMatrix = object.matrix;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tvar keys = this.data.hierarchy[h].keys;\r\n\t\r\n\t\t\t\t\tif (keys.length) {\r\n\t\r\n\t\t\t\t\t\tnode.animationCache.prevKey = keys[ 0 ];\r\n\t\t\t\t\t\tnode.animationCache.nextKey = keys[ 1 ];\r\n\t\r\n\t\t\t\t\t\tthis.startTime = Math.min( keys[0].time, this.startTime );\r\n\t\t\t\t\t\tthis.endTime = Math.max( keys[keys.length - 1].time, this.endTime );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tthis.update( 0 );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.isPaused = false;\r\n\t\r\n\t\t\tTHREE.AnimationHandler.play( this );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tstop: function () {\r\n\t\r\n\t\t\tthis.isPlaying = false;\r\n\t\t\tthis.isPaused  = false;\r\n\t\r\n\t\t\tTHREE.AnimationHandler.stop( this );\r\n\t\r\n\t\t\t// reset JIT matrix and remove cache\r\n\t\r\n\t\t\tfor ( var h = 0; h < this.data.hierarchy.length; h ++ ) {\r\n\t\r\n\t\t\t\tvar obj = this.hierarchy[ h ];\r\n\t\t\t\tvar node = this.data.hierarchy[ h ];\r\n\t\r\n\t\t\t\tif ( node.animationCache !== undefined ) {\r\n\t\r\n\t\t\t\t\tvar original = node.animationCache.originalMatrix;\r\n\t\r\n\t\t\t\t\toriginal.copy( obj.matrix );\r\n\t\t\t\t\tobj.matrix = original;\r\n\t\r\n\t\t\t\t\tdelete node.animationCache;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tupdate: function ( delta ) {\r\n\t\r\n\t\t\tif ( this.isPlaying === false ) return;\r\n\t\r\n\t\t\tthis.currentTime += delta * this.timeScale;\r\n\t\r\n\t\t\t//\r\n\t\r\n\t\t\tvar duration = this.data.length;\r\n\t\r\n\t\t\tif ( this.loop === true && this.currentTime > duration ) {\r\n\t\r\n\t\t\t\tthis.currentTime %= duration;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.currentTime = Math.min( this.currentTime, duration );\r\n\t\r\n\t\t\tfor ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {\r\n\t\r\n\t\t\t\tvar object = this.hierarchy[ h ];\r\n\t\t\t\tvar node = this.data.hierarchy[ h ];\r\n\t\r\n\t\t\t\tvar keys = node.keys,\r\n\t\t\t\t\tanimationCache = node.animationCache;\r\n\t\r\n\t\r\n\t\t\t\tif ( keys.length ) {\r\n\t\r\n\t\t\t\t\tvar prevKey = animationCache.prevKey;\r\n\t\t\t\t\tvar nextKey = animationCache.nextKey;\r\n\t\r\n\t\t\t\t\tif ( nextKey.time <= this.currentTime ) {\r\n\t\r\n\t\t\t\t\t\twhile ( nextKey.time < this.currentTime && nextKey.index > prevKey.index ) {\r\n\t\r\n\t\t\t\t\t\t\tprevKey = nextKey;\r\n\t\t\t\t\t\t\tnextKey = keys[ prevKey.index + 1 ];\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tanimationCache.prevKey = prevKey;\r\n\t\t\t\t\t\tanimationCache.nextKey = nextKey;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( nextKey.time >= this.currentTime ) {\r\n\t\r\n\t\t\t\t\t\tprevKey.interpolate( nextKey, this.currentTime );\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tprevKey.interpolate( nextKey, nextKey.time );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tthis.data.hierarchy[ h ].node.updateMatrix();\r\n\t\t\t\t\tobject.matrixWorldNeedsUpdate = true;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetNextKeyWith: function ( sid, h, key ) {\r\n\t\r\n\t\t\tvar keys = this.data.hierarchy[ h ].keys;\r\n\t\t\tkey = key % keys.length;\r\n\t\r\n\t\t\tfor ( ; key < keys.length; key ++ ) {\r\n\t\r\n\t\t\t\tif ( keys[ key ].hasTarget( sid ) ) {\r\n\t\r\n\t\t\t\t\treturn keys[ key ];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn keys[ 0 ];\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetPrevKeyWith: function ( sid, h, key ) {\r\n\t\r\n\t\t\tvar keys = this.data.hierarchy[ h ].keys;\r\n\t\t\tkey = key >= 0 ? key : key + keys.length;\r\n\t\r\n\t\t\tfor ( ; key >= 0; key -- ) {\r\n\t\r\n\t\t\t\tif ( keys[ key ].hasTarget( sid ) ) {\r\n\t\r\n\t\t\t\t\treturn keys[ key ];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn keys[ keys.length - 1 ];\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/animation/MorphAnimation.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com\r\n\t * @author willy-vvu / http://willy-vvu.github.io\r\n\t */\r\n\t\r\n\tTHREE.MorphAnimation = function ( mesh ) {\r\n\t\r\n\t\tthis.mesh = mesh;\r\n\t\tthis.frames = mesh.morphTargetInfluences.length;\r\n\t\tthis.currentTime = 0;\r\n\t\tthis.duration = 1000;\r\n\t\tthis.loop = true;\r\n\t\tthis.lastFrame = 0;\r\n\t\tthis.currentFrame = 0;\r\n\t\r\n\t\tthis.isPlaying = false;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MorphAnimation.prototype = {\r\n\t\r\n\t\tconstructor: THREE.MorphAnimation,\r\n\t\r\n\t\tplay: function () {\r\n\t\r\n\t\t\tthis.isPlaying = true;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tpause: function () {\r\n\t\r\n\t\t\tthis.isPlaying = false;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tupdate: function ( delta ) {\r\n\t\r\n\t\t\tif ( this.isPlaying === false ) return;\r\n\t\r\n\t\t\tthis.currentTime += delta;\r\n\t\r\n\t\t\tif ( this.loop === true && this.currentTime > this.duration ) {\r\n\t\r\n\t\t\t\tthis.currentTime %= this.duration;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.currentTime = Math.min( this.currentTime, this.duration );\r\n\t\r\n\t\t\tvar interpolation = this.duration / this.frames;\r\n\t\t\tvar frame = Math.floor( this.currentTime / interpolation );\r\n\t\r\n\t\t\tvar influences = this.mesh.morphTargetInfluences;\r\n\t\r\n\t\t\tif ( frame != this.currentFrame ) {\r\n\t\r\n\t\t\t\tinfluences[ this.lastFrame ] = 0;\r\n\t\t\t\tinfluences[ this.currentFrame ] = 1;\r\n\t\t\t\tinfluences[ frame ] = 0;\r\n\t\r\n\t\t\t\tthis.lastFrame = this.currentFrame;\r\n\t\t\t\tthis.currentFrame = frame;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tinfluences[ frame ] = ( this.currentTime % interpolation ) / interpolation;\r\n\t\t\tinfluences[ this.lastFrame ] = 1 - influences[ frame ];\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/geometries/BoxGeometry.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as\r\n\t */\r\n\t\r\n\tTHREE.BoxGeometry = function ( width, height, depth, widthSegments, heightSegments, depthSegments ) {\r\n\t\r\n\t\tTHREE.Geometry.call( this );\r\n\t\r\n\t\tthis.type = 'BoxGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\twidth: width,\r\n\t\t\theight: height,\r\n\t\t\tdepth: depth,\r\n\t\t\twidthSegments: widthSegments,\r\n\t\t\theightSegments: heightSegments,\r\n\t\t\tdepthSegments: depthSegments\r\n\t\t};\r\n\t\r\n\t\tthis.widthSegments = widthSegments || 1;\r\n\t\tthis.heightSegments = heightSegments || 1;\r\n\t\tthis.depthSegments = depthSegments || 1;\r\n\t\r\n\t\tvar scope = this;\r\n\t\r\n\t\tvar width_half = width / 2;\r\n\t\tvar height_half = height / 2;\r\n\t\tvar depth_half = depth / 2;\r\n\t\r\n\t\tbuildPlane( 'z', 'y', - 1, - 1, depth, height, width_half, 0 ); // px\r\n\t\tbuildPlane( 'z', 'y',   1, - 1, depth, height, - width_half, 1 ); // nx\r\n\t\tbuildPlane( 'x', 'z',   1,   1, width, depth, height_half, 2 ); // py\r\n\t\tbuildPlane( 'x', 'z',   1, - 1, width, depth, - height_half, 3 ); // ny\r\n\t\tbuildPlane( 'x', 'y',   1, - 1, width, height, depth_half, 4 ); // pz\r\n\t\tbuildPlane( 'x', 'y', - 1, - 1, width, height, - depth_half, 5 ); // nz\r\n\t\r\n\t\tfunction buildPlane( u, v, udir, vdir, width, height, depth, materialIndex ) {\r\n\t\r\n\t\t\tvar w, ix, iy,\r\n\t\t\tgridX = scope.widthSegments,\r\n\t\t\tgridY = scope.heightSegments,\r\n\t\t\twidth_half = width / 2,\r\n\t\t\theight_half = height / 2,\r\n\t\t\toffset = scope.vertices.length;\r\n\t\r\n\t\t\tif ( ( u === 'x' && v === 'y' ) || ( u === 'y' && v === 'x' ) ) {\r\n\t\r\n\t\t\t\tw = 'z';\r\n\t\r\n\t\t\t} else if ( ( u === 'x' && v === 'z' ) || ( u === 'z' && v === 'x' ) ) {\r\n\t\r\n\t\t\t\tw = 'y';\r\n\t\t\t\tgridY = scope.depthSegments;\r\n\t\r\n\t\t\t} else if ( ( u === 'z' && v === 'y' ) || ( u === 'y' && v === 'z' ) ) {\r\n\t\r\n\t\t\t\tw = 'x';\r\n\t\t\t\tgridX = scope.depthSegments;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar gridX1 = gridX + 1,\r\n\t\t\tgridY1 = gridY + 1,\r\n\t\t\tsegment_width = width / gridX,\r\n\t\t\tsegment_height = height / gridY,\r\n\t\t\tnormal = new THREE.Vector3();\r\n\t\r\n\t\t\tnormal[ w ] = depth > 0 ? 1 : - 1;\r\n\t\r\n\t\t\tfor ( iy = 0; iy < gridY1; iy ++ ) {\r\n\t\r\n\t\t\t\tfor ( ix = 0; ix < gridX1; ix ++ ) {\r\n\t\r\n\t\t\t\t\tvar vector = new THREE.Vector3();\r\n\t\t\t\t\tvector[ u ] = ( ix * segment_width - width_half ) * udir;\r\n\t\t\t\t\tvector[ v ] = ( iy * segment_height - height_half ) * vdir;\r\n\t\t\t\t\tvector[ w ] = depth;\r\n\t\r\n\t\t\t\t\tscope.vertices.push( vector );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfor ( iy = 0; iy < gridY; iy ++ ) {\r\n\t\r\n\t\t\t\tfor ( ix = 0; ix < gridX; ix ++ ) {\r\n\t\r\n\t\t\t\t\tvar a = ix + gridX1 * iy;\r\n\t\t\t\t\tvar b = ix + gridX1 * ( iy + 1 );\r\n\t\t\t\t\tvar c = ( ix + 1 ) + gridX1 * ( iy + 1 );\r\n\t\t\t\t\tvar d = ( ix + 1 ) + gridX1 * iy;\r\n\t\r\n\t\t\t\t\tvar uva = new THREE.Vector2( ix / gridX, 1 - iy / gridY );\r\n\t\t\t\t\tvar uvb = new THREE.Vector2( ix / gridX, 1 - ( iy + 1 ) / gridY );\r\n\t\t\t\t\tvar uvc = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - ( iy + 1 ) / gridY );\r\n\t\t\t\t\tvar uvd = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - iy / gridY );\r\n\t\r\n\t\t\t\t\tvar face = new THREE.Face3( a + offset, b + offset, d + offset );\r\n\t\t\t\t\tface.normal.copy( normal );\r\n\t\t\t\t\tface.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );\r\n\t\t\t\t\tface.materialIndex = materialIndex;\r\n\t\r\n\t\t\t\t\tscope.faces.push( face );\r\n\t\t\t\t\tscope.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );\r\n\t\r\n\t\t\t\t\tface = new THREE.Face3( b + offset, c + offset, d + offset );\r\n\t\t\t\t\tface.normal.copy( normal );\r\n\t\t\t\t\tface.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );\r\n\t\t\t\t\tface.materialIndex = materialIndex;\r\n\t\r\n\t\t\t\t\tscope.faces.push( face );\r\n\t\t\t\t\tscope.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.mergeVertices();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.BoxGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\tTHREE.BoxGeometry.prototype.constructor = THREE.BoxGeometry;\r\n\t\r\n\t// File:src/extras/geometries/CircleGeometry.js\r\n\t\r\n\t/**\r\n\t * @author hughes\r\n\t */\r\n\t\r\n\tTHREE.CircleGeometry = function ( radius, segments, thetaStart, thetaLength ) {\r\n\t\r\n\t\tTHREE.Geometry.call( this );\r\n\t\r\n\t\tthis.type = 'CircleGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\tradius: radius,\r\n\t\t\tsegments: segments,\r\n\t\t\tthetaStart: thetaStart,\r\n\t\t\tthetaLength: thetaLength\r\n\t\t};\r\n\t\r\n\t\tradius = radius || 50;\r\n\t\tsegments = segments !== undefined ? Math.max( 3, segments ) : 8;\r\n\t\r\n\t\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\r\n\t\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\r\n\t\r\n\t\tvar i, uvs = [],\r\n\t\tcenter = new THREE.Vector3(), centerUV = new THREE.Vector2( 0.5, 0.5 );\r\n\t\r\n\t\tthis.vertices.push(center);\r\n\t\tuvs.push( centerUV );\r\n\t\r\n\t\tfor ( i = 0; i <= segments; i ++ ) {\r\n\t\r\n\t\t\tvar vertex = new THREE.Vector3();\r\n\t\t\tvar segment = thetaStart + i / segments * thetaLength;\r\n\t\r\n\t\t\tvertex.x = radius * Math.cos( segment );\r\n\t\t\tvertex.y = radius * Math.sin( segment );\r\n\t\r\n\t\t\tthis.vertices.push( vertex );\r\n\t\t\tuvs.push( new THREE.Vector2( ( vertex.x / radius + 1 ) / 2, ( vertex.y / radius + 1 ) / 2 ) );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar n = new THREE.Vector3( 0, 0, 1 );\r\n\t\r\n\t\tfor ( i = 1; i <= segments; i ++ ) {\r\n\t\r\n\t\t\tthis.faces.push( new THREE.Face3( i, i + 1, 0, [ n.clone(), n.clone(), n.clone() ] ) );\r\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uvs[ i ].clone(), uvs[ i + 1 ].clone(), centerUV.clone() ] );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.computeFaceNormals();\r\n\t\r\n\t\tthis.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.CircleGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\tTHREE.CircleGeometry.prototype.constructor = THREE.CircleGeometry;\r\n\t\r\n\t// File:src/extras/geometries/CubeGeometry.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\t\r\n\tTHREE.CubeGeometry = function ( width, height, depth, widthSegments, heightSegments, depthSegments ) {\r\n\t\r\n\t\tTHREE.warn( 'THREE.CubeGeometry has been renamed to THREE.BoxGeometry.' );\r\n\t\treturn new THREE.BoxGeometry( width, height, depth, widthSegments, heightSegments, depthSegments );\r\n\t\r\n\t };\r\n\t\r\n\t// File:src/extras/geometries/CylinderGeometry.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.CylinderGeometry = function ( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\r\n\t\r\n\t\tTHREE.Geometry.call( this );\r\n\t\r\n\t\tthis.type = 'CylinderGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\tradiusTop: radiusTop,\r\n\t\t\tradiusBottom: radiusBottom,\r\n\t\t\theight: height,\r\n\t\t\tradialSegments: radialSegments,\r\n\t\t\theightSegments: heightSegments,\r\n\t\t\topenEnded: openEnded,\r\n\t\t\tthetaStart: thetaStart,\r\n\t\t\tthetaLength: thetaLength\r\n\t\t};\r\n\t\r\n\t\tradiusTop = radiusTop !== undefined ? radiusTop : 20;\r\n\t\tradiusBottom = radiusBottom !== undefined ? radiusBottom : 20;\r\n\t\theight = height !== undefined ? height : 100;\r\n\t\r\n\t\tradialSegments = radialSegments || 8;\r\n\t\theightSegments = heightSegments || 1;\r\n\t\r\n\t\topenEnded = openEnded !== undefined ? openEnded : false;\r\n\t\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\r\n\t\tthetaLength = thetaLength !== undefined ? thetaLength : 2 * Math.PI;\r\n\t\r\n\t\tvar heightHalf = height / 2;\r\n\t\r\n\t\tvar x, y, vertices = [], uvs = [];\r\n\t\r\n\t\tfor ( y = 0; y <= heightSegments; y ++ ) {\r\n\t\r\n\t\t\tvar verticesRow = [];\r\n\t\t\tvar uvsRow = [];\r\n\t\r\n\t\t\tvar v = y / heightSegments;\r\n\t\t\tvar radius = v * ( radiusBottom - radiusTop ) + radiusTop;\r\n\t\r\n\t\t\tfor ( x = 0; x <= radialSegments; x ++ ) {\r\n\t\r\n\t\t\t\tvar u = x / radialSegments;\r\n\t\r\n\t\t\t\tvar vertex = new THREE.Vector3();\r\n\t\t\t\tvertex.x = radius * Math.sin( u * thetaLength + thetaStart );\r\n\t\t\t\tvertex.y = - v * height + heightHalf;\r\n\t\t\t\tvertex.z = radius * Math.cos( u * thetaLength + thetaStart );\r\n\t\r\n\t\t\t\tthis.vertices.push( vertex );\r\n\t\r\n\t\t\t\tverticesRow.push( this.vertices.length - 1 );\r\n\t\t\t\tuvsRow.push( new THREE.Vector2( u, 1 - v ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvertices.push( verticesRow );\r\n\t\t\tuvs.push( uvsRow );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar tanTheta = ( radiusBottom - radiusTop ) / height;\r\n\t\tvar na, nb;\r\n\t\r\n\t\tfor ( x = 0; x < radialSegments; x ++ ) {\r\n\t\r\n\t\t\tif ( radiusTop !== 0 ) {\r\n\t\r\n\t\t\t\tna = this.vertices[ vertices[ 0 ][ x ] ].clone();\r\n\t\t\t\tnb = this.vertices[ vertices[ 0 ][ x + 1 ] ].clone();\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tna = this.vertices[ vertices[ 1 ][ x ] ].clone();\r\n\t\t\t\tnb = this.vertices[ vertices[ 1 ][ x + 1 ] ].clone();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tna.setY( Math.sqrt( na.x * na.x + na.z * na.z ) * tanTheta ).normalize();\r\n\t\t\tnb.setY( Math.sqrt( nb.x * nb.x + nb.z * nb.z ) * tanTheta ).normalize();\r\n\t\r\n\t\t\tfor ( y = 0; y < heightSegments; y ++ ) {\r\n\t\r\n\t\t\t\tvar v1 = vertices[ y ][ x ];\r\n\t\t\t\tvar v2 = vertices[ y + 1 ][ x ];\r\n\t\t\t\tvar v3 = vertices[ y + 1 ][ x + 1 ];\r\n\t\t\t\tvar v4 = vertices[ y ][ x + 1 ];\r\n\t\r\n\t\t\t\tvar n1 = na.clone();\r\n\t\t\t\tvar n2 = na.clone();\r\n\t\t\t\tvar n3 = nb.clone();\r\n\t\t\t\tvar n4 = nb.clone();\r\n\t\r\n\t\t\t\tvar uv1 = uvs[ y ][ x ].clone();\r\n\t\t\t\tvar uv2 = uvs[ y + 1 ][ x ].clone();\r\n\t\t\t\tvar uv3 = uvs[ y + 1 ][ x + 1 ].clone();\r\n\t\t\t\tvar uv4 = uvs[ y ][ x + 1 ].clone();\r\n\t\r\n\t\t\t\tthis.faces.push( new THREE.Face3( v1, v2, v4, [ n1, n2, n4 ] ) );\r\n\t\t\t\tthis.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv4 ] );\r\n\t\r\n\t\t\t\tthis.faces.push( new THREE.Face3( v2, v3, v4, [ n2.clone(), n3, n4.clone() ] ) );\r\n\t\t\t\tthis.faceVertexUvs[ 0 ].push( [ uv2.clone(), uv3, uv4.clone() ] );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// top cap\r\n\t\r\n\t\tif ( openEnded === false && radiusTop > 0 ) {\r\n\t\r\n\t\t\tthis.vertices.push( new THREE.Vector3( 0, heightHalf, 0 ) );\r\n\t\r\n\t\t\tfor ( x = 0; x < radialSegments; x ++ ) {\r\n\t\r\n\t\t\t\tvar v1 = vertices[ 0 ][ x ];\r\n\t\t\t\tvar v2 = vertices[ 0 ][ x + 1 ];\r\n\t\t\t\tvar v3 = this.vertices.length - 1;\r\n\t\r\n\t\t\t\tvar n1 = new THREE.Vector3( 0, 1, 0 );\r\n\t\t\t\tvar n2 = new THREE.Vector3( 0, 1, 0 );\r\n\t\t\t\tvar n3 = new THREE.Vector3( 0, 1, 0 );\r\n\t\r\n\t\t\t\tvar uv1 = uvs[ 0 ][ x ].clone();\r\n\t\t\t\tvar uv2 = uvs[ 0 ][ x + 1 ].clone();\r\n\t\t\t\tvar uv3 = new THREE.Vector2( uv2.x, 0 );\r\n\t\r\n\t\t\t\tthis.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );\r\n\t\t\t\tthis.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// bottom cap\r\n\t\r\n\t\tif ( openEnded === false && radiusBottom > 0 ) {\r\n\t\r\n\t\t\tthis.vertices.push( new THREE.Vector3( 0, - heightHalf, 0 ) );\r\n\t\r\n\t\t\tfor ( x = 0; x < radialSegments; x ++ ) {\r\n\t\r\n\t\t\t\tvar v1 = vertices[ heightSegments ][ x + 1 ];\r\n\t\t\t\tvar v2 = vertices[ heightSegments ][ x ];\r\n\t\t\t\tvar v3 = this.vertices.length - 1;\r\n\t\r\n\t\t\t\tvar n1 = new THREE.Vector3( 0, - 1, 0 );\r\n\t\t\t\tvar n2 = new THREE.Vector3( 0, - 1, 0 );\r\n\t\t\t\tvar n3 = new THREE.Vector3( 0, - 1, 0 );\r\n\t\r\n\t\t\t\tvar uv1 = uvs[ heightSegments ][ x + 1 ].clone();\r\n\t\t\t\tvar uv2 = uvs[ heightSegments ][ x ].clone();\r\n\t\t\t\tvar uv3 = new THREE.Vector2( uv2.x, 1 );\r\n\t\r\n\t\t\t\tthis.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );\r\n\t\t\t\tthis.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.computeFaceNormals();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.CylinderGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\tTHREE.CylinderGeometry.prototype.constructor = THREE.CylinderGeometry;\r\n\t\r\n\t// File:src/extras/geometries/ExtrudeGeometry.js\r\n\t\r\n\t/**\r\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\r\n\t *\r\n\t * Creates extruded geometry from a path shape.\r\n\t *\r\n\t * parameters = {\r\n\t *\r\n\t *  curveSegments: <int>, // number of points on the curves\r\n\t *  steps: <int>, // number of points for z-side extrusions / used for subdividing segements of extrude spline too\r\n\t *  amount: <int>, // Depth to extrude the shape\r\n\t *\r\n\t *  bevelEnabled: <bool>, // turn on bevel\r\n\t *  bevelThickness: <float>, // how deep into the original shape bevel goes\r\n\t *  bevelSize: <float>, // how far from shape outline is bevel\r\n\t *  bevelSegments: <int>, // number of bevel layers\r\n\t *\r\n\t *  extrudePath: <THREE.CurvePath> // 3d spline path to extrude shape along. (creates Frames if .frames aren't defined)\r\n\t *  frames: <THREE.TubeGeometry.FrenetFrames> // containing arrays of tangents, normals, binormals\r\n\t *\r\n\t *  material: <int> // material index for front and back faces\r\n\t *  extrudeMaterial: <int> // material index for extrusion and beveled faces\r\n\t *  uvGenerator: <Object> // object that provides UV generator functions\r\n\t *\r\n\t * }\r\n\t **/\r\n\t\r\n\tTHREE.ExtrudeGeometry = function ( shapes, options ) {\r\n\t\r\n\t\tif ( typeof( shapes ) === \"undefined\" ) {\r\n\t\t\tshapes = [];\r\n\t\t\treturn;\r\n\t\t}\r\n\t\r\n\t\tTHREE.Geometry.call( this );\r\n\t\r\n\t\tthis.type = 'ExtrudeGeometry';\r\n\t\r\n\t\tshapes = shapes instanceof Array ? shapes : [ shapes ];\r\n\t\r\n\t\tthis.addShapeList( shapes, options );\r\n\t\r\n\t\tthis.computeFaceNormals();\r\n\t\r\n\t\t// can't really use automatic vertex normals\r\n\t\t// as then front and back sides get smoothed too\r\n\t\t// should do separate smoothing just for sides\r\n\t\r\n\t\t//this.computeVertexNormals();\r\n\t\r\n\t\t//console.log( \"took\", ( Date.now() - startTime ) );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.ExtrudeGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\tTHREE.ExtrudeGeometry.prototype.constructor = THREE.ExtrudeGeometry;\r\n\t\r\n\tTHREE.ExtrudeGeometry.prototype.addShapeList = function ( shapes, options ) {\r\n\t\tvar sl = shapes.length;\r\n\t\r\n\t\tfor ( var s = 0; s < sl; s ++ ) {\r\n\t\t\tvar shape = shapes[ s ];\r\n\t\t\tthis.addShape( shape, options );\r\n\t\t}\r\n\t};\r\n\t\r\n\tTHREE.ExtrudeGeometry.prototype.addShape = function ( shape, options ) {\r\n\t\r\n\t\tvar amount = options.amount !== undefined ? options.amount : 100;\r\n\t\r\n\t\tvar bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10\r\n\t\tvar bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8\r\n\t\tvar bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;\r\n\t\r\n\t\tvar bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false\r\n\t\r\n\t\tvar curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\r\n\t\r\n\t\tvar steps = options.steps !== undefined ? options.steps : 1;\r\n\t\r\n\t\tvar extrudePath = options.extrudePath;\r\n\t\tvar extrudePts, extrudeByPath = false;\r\n\t\r\n\t\tvar material = options.material;\r\n\t\tvar extrudeMaterial = options.extrudeMaterial;\r\n\t\r\n\t\t// Use default WorldUVGenerator if no UV generators are specified.\r\n\t\tvar uvgen = options.UVGenerator !== undefined ? options.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator;\r\n\t\r\n\t\tvar splineTube, binormal, normal, position2;\r\n\t\tif ( extrudePath ) {\r\n\t\r\n\t\t\textrudePts = extrudePath.getSpacedPoints( steps );\r\n\t\r\n\t\t\textrudeByPath = true;\r\n\t\t\tbevelEnabled = false; // bevels not supported for path extrusion\r\n\t\r\n\t\t\t// SETUP TNB variables\r\n\t\r\n\t\t\t// Reuse TNB from TubeGeomtry for now.\r\n\t\t\t// TODO1 - have a .isClosed in spline?\r\n\t\r\n\t\t\tsplineTube = options.frames !== undefined ? options.frames : new THREE.TubeGeometry.FrenetFrames(extrudePath, steps, false);\r\n\t\r\n\t\t\t// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);\r\n\t\r\n\t\t\tbinormal = new THREE.Vector3();\r\n\t\t\tnormal = new THREE.Vector3();\r\n\t\t\tposition2 = new THREE.Vector3();\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// Safeguards if bevels are not enabled\r\n\t\r\n\t\tif ( ! bevelEnabled ) {\r\n\t\r\n\t\t\tbevelSegments = 0;\r\n\t\t\tbevelThickness = 0;\r\n\t\t\tbevelSize = 0;\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// Variables initalization\r\n\t\r\n\t\tvar ahole, h, hl; // looping of holes\r\n\t\tvar scope = this;\r\n\t\r\n\t\tvar shapesOffset = this.vertices.length;\r\n\t\r\n\t\tvar shapePoints = shape.extractPoints( curveSegments );\r\n\t\r\n\t\tvar vertices = shapePoints.shape;\r\n\t\tvar holes = shapePoints.holes;\r\n\t\r\n\t\tvar reverse = ! THREE.Shape.Utils.isClockWise( vertices ) ;\r\n\t\r\n\t\tif ( reverse ) {\r\n\t\r\n\t\t\tvertices = vertices.reverse();\r\n\t\r\n\t\t\t// Maybe we should also check if holes are in the opposite direction, just to be safe ...\r\n\t\r\n\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\t\r\n\t\t\t\tahole = holes[ h ];\r\n\t\r\n\t\t\t\tif ( THREE.Shape.Utils.isClockWise( ahole ) ) {\r\n\t\r\n\t\t\t\t\tholes[ h ] = ahole.reverse();\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treverse = false; // If vertices are in order now, we shouldn't need to worry about them again (hopefully)!\r\n\t\r\n\t\t}\r\n\t\r\n\t\r\n\t\tvar faces = THREE.Shape.Utils.triangulateShape ( vertices, holes );\r\n\t\r\n\t\t/* Vertices */\r\n\t\r\n\t\tvar contour = vertices; // vertices has all points but contour has only points of circumference\r\n\t\r\n\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\t\r\n\t\t\tahole = holes[ h ];\r\n\t\r\n\t\t\tvertices = vertices.concat( ahole );\r\n\t\r\n\t\t}\r\n\t\r\n\t\r\n\t\tfunction scalePt2 ( pt, vec, size ) {\r\n\t\r\n\t\t\tif ( ! vec ) THREE.error( \"THREE.ExtrudeGeometry: vec does not exist\" );\r\n\t\r\n\t\t\treturn vec.clone().multiplyScalar( size ).add( pt );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar b, bs, t, z,\r\n\t\t\tvert, vlen = vertices.length,\r\n\t\t\tface, flen = faces.length;\r\n\t\r\n\t\r\n\t\t// Find directions for point movement\r\n\t\r\n\t\r\n\t\tfunction getBevelVec( inPt, inPrev, inNext ) {\r\n\t\r\n\t\t\tvar EPSILON = 0.0000000001;\r\n\t\t\t\r\n\t\t\t// computes for inPt the corresponding point inPt' on a new contour\r\n\t\t\t//   shiftet by 1 unit (length of normalized vector) to the left\r\n\t\t\t// if we walk along contour clockwise, this new contour is outside the old one\r\n\t\t\t//\r\n\t\t\t// inPt' is the intersection of the two lines parallel to the two\r\n\t\t\t//  adjacent edges of inPt at a distance of 1 unit on the left side.\r\n\t\t\t\r\n\t\t\tvar v_trans_x, v_trans_y, shrink_by = 1;\t\t// resulting translation vector for inPt\r\n\t\r\n\t\t\t// good reading for geometry algorithms (here: line-line intersection)\r\n\t\t\t// http://geomalgorithms.com/a05-_intersect-1.html\r\n\t\r\n\t\t\tvar v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;\r\n\t\t\tvar v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;\r\n\t\t\t\r\n\t\t\tvar v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );\r\n\t\t\t\r\n\t\t\t// check for colinear edges\r\n\t\t\tvar colinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );\r\n\t\t\t\r\n\t\t\tif ( Math.abs( colinear0 ) > EPSILON ) {\t\t// not colinear\r\n\t\t\t\t\r\n\t\t\t\t// length of vectors for normalizing\r\n\t\t\r\n\t\t\t\tvar v_prev_len = Math.sqrt( v_prev_lensq );\r\n\t\t\t\tvar v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );\r\n\t\t\t\t\r\n\t\t\t\t// shift adjacent points by unit vectors to the left\r\n\t\t\r\n\t\t\t\tvar ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );\r\n\t\t\t\tvar ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );\r\n\t\t\t\t\r\n\t\t\t\tvar ptNextShift_x = ( inNext.x - v_next_y / v_next_len );\r\n\t\t\t\tvar ptNextShift_y = ( inNext.y + v_next_x / v_next_len );\r\n\t\t\r\n\t\t\t\t// scaling factor for v_prev to intersection point\r\n\t\t\r\n\t\t\t\tvar sf = (  ( ptNextShift_x - ptPrevShift_x ) * v_next_y -\r\n\t\t\t\t\t\t\t( ptNextShift_y - ptPrevShift_y ) * v_next_x    ) /\r\n\t\t\t\t\t\t  ( v_prev_x * v_next_y - v_prev_y * v_next_x );\r\n\t\t\r\n\t\t\t\t// vector from inPt to intersection point\r\n\t\t\r\n\t\t\t\tv_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );\r\n\t\t\t\tv_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );\r\n\t\t\r\n\t\t\t\t// Don't normalize!, otherwise sharp corners become ugly\r\n\t\t\t\t//  but prevent crazy spikes\r\n\t\t\t\tvar v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y )\r\n\t\t\t\tif ( v_trans_lensq <= 2 ) {\r\n\t\t\t\t\treturn\tnew THREE.Vector2( v_trans_x, v_trans_y );\r\n\t\t\t\t} else {\r\n\t\t\t\t\tshrink_by = Math.sqrt( v_trans_lensq / 2 );\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t} else {\t\t// handle special case of colinear edges\r\n\t\r\n\t\t\t\tvar direction_eq = false;\t\t// assumes: opposite\r\n\t\t\t\tif ( v_prev_x > EPSILON ) {\r\n\t\t\t\t\tif ( v_next_x > EPSILON ) { direction_eq = true; }\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif ( v_prev_x < - EPSILON ) {\r\n\t\t\t\t\t\tif ( v_next_x < - EPSILON ) { direction_eq = true; }\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tif ( Math.sign(v_prev_y) == Math.sign(v_next_y) ) { direction_eq = true; }\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( direction_eq ) {\r\n\t\t\t\t\t// console.log(\"Warning: lines are a straight sequence\");\r\n\t\t\t\t\tv_trans_x = - v_prev_y;\r\n\t\t\t\t\tv_trans_y =  v_prev_x;\r\n\t\t\t\t\tshrink_by = Math.sqrt( v_prev_lensq );\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// console.log(\"Warning: lines are a straight spike\");\r\n\t\t\t\t\tv_trans_x = v_prev_x;\r\n\t\t\t\t\tv_trans_y = v_prev_y;\r\n\t\t\t\t\tshrink_by = Math.sqrt( v_prev_lensq / 2 );\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn\tnew THREE.Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );\r\n\t\r\n\t\t}\r\n\t\r\n\t\r\n\t\tvar contourMovements = [];\r\n\t\r\n\t\tfor ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\r\n\t\r\n\t\t\tif ( j === il ) j = 0;\r\n\t\t\tif ( k === il ) k = 0;\r\n\t\r\n\t\t\t//  (j)---(i)---(k)\r\n\t\t\t// console.log('i,j,k', i, j , k)\r\n\t\r\n\t\t\tcontourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();\r\n\t\r\n\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\t\r\n\t\t\tahole = holes[ h ];\r\n\t\r\n\t\t\toneHoleMovements = [];\r\n\t\r\n\t\t\tfor ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\r\n\t\r\n\t\t\t\tif ( j === il ) j = 0;\r\n\t\t\t\tif ( k === il ) k = 0;\r\n\t\r\n\t\t\t\t//  (j)---(i)---(k)\r\n\t\t\t\toneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tholesMovements.push( oneHoleMovements );\r\n\t\t\tverticesMovements = verticesMovements.concat( oneHoleMovements );\r\n\t\r\n\t\t}\r\n\t\r\n\t\r\n\t\t// Loop bevelSegments, 1 for the front, 1 for the back\r\n\t\r\n\t\tfor ( b = 0; b < bevelSegments; b ++ ) {\r\n\t\t//for ( b = bevelSegments; b > 0; b -- ) {\r\n\t\r\n\t\t\tt = b / bevelSegments;\r\n\t\t\tz = bevelThickness * ( 1 - t );\r\n\t\r\n\t\t\t//z = bevelThickness * t;\r\n\t\t\tbs = bevelSize * ( Math.sin ( t * Math.PI / 2 ) ) ; // curved\r\n\t\t\t//bs = bevelSize * t ; // linear\r\n\t\r\n\t\t\t// contract shape\r\n\t\r\n\t\t\tfor ( i = 0, il = contour.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tvert = scalePt2( contour[ i ], contourMovements[ i ], bs );\r\n\t\r\n\t\t\t\tv( vert.x, vert.y,  - z );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// expand holes\r\n\t\r\n\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\t\r\n\t\t\t\tahole = holes[ h ];\r\n\t\t\t\toneHoleMovements = holesMovements[ h ];\r\n\t\r\n\t\t\t\tfor ( i = 0, il = ahole.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\tvert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\r\n\t\r\n\t\t\t\t\tv( vert.x, vert.y,  - z );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tbs = bevelSize;\r\n\t\r\n\t\t// Back facing vertices\r\n\t\r\n\t\tfor ( i = 0; i < vlen; i ++ ) {\r\n\t\r\n\t\t\tvert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\r\n\t\r\n\t\t\tif ( ! extrudeByPath ) {\r\n\t\r\n\t\t\t\tv( vert.x, vert.y, 0 );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\t// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );\r\n\t\r\n\t\t\t\tnormal.copy( splineTube.normals[0] ).multiplyScalar(vert.x);\r\n\t\t\t\tbinormal.copy( splineTube.binormals[0] ).multiplyScalar(vert.y);\r\n\t\r\n\t\t\t\tposition2.copy( extrudePts[0] ).add(normal).add(binormal);\r\n\t\r\n\t\t\t\tv( position2.x, position2.y, position2.z );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// Add stepped vertices...\r\n\t\t// Including front facing vertices\r\n\t\r\n\t\tvar s;\r\n\t\r\n\t\tfor ( s = 1; s <= steps; s ++ ) {\r\n\t\r\n\t\t\tfor ( i = 0; i < vlen; i ++ ) {\r\n\t\r\n\t\t\t\tvert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\r\n\t\r\n\t\t\t\tif ( ! extrudeByPath ) {\r\n\t\r\n\t\t\t\t\tv( vert.x, vert.y, amount / steps * s );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );\r\n\t\r\n\t\t\t\t\tnormal.copy( splineTube.normals[s] ).multiplyScalar( vert.x );\r\n\t\t\t\t\tbinormal.copy( splineTube.binormals[s] ).multiplyScalar( vert.y );\r\n\t\r\n\t\t\t\t\tposition2.copy( extrudePts[s] ).add( normal ).add( binormal );\r\n\t\r\n\t\t\t\t\tv( position2.x, position2.y, position2.z );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\r\n\t\t// Add bevel segments planes\r\n\t\r\n\t\t//for ( b = 1; b <= bevelSegments; b ++ ) {\r\n\t\tfor ( b = bevelSegments - 1; b >= 0; b -- ) {\r\n\t\r\n\t\t\tt = b / bevelSegments;\r\n\t\t\tz = bevelThickness * ( 1 - t );\r\n\t\t\t//bs = bevelSize * ( 1-Math.sin ( ( 1 - t ) * Math.PI/2 ) );\r\n\t\t\tbs = bevelSize * Math.sin ( t * Math.PI / 2 ) ;\r\n\t\r\n\t\t\t// contract shape\r\n\t\r\n\t\t\tfor ( i = 0, il = contour.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tvert = scalePt2( contour[ i ], contourMovements[ i ], bs );\r\n\t\t\t\tv( vert.x, vert.y,  amount + z );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// expand holes\r\n\t\r\n\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\t\r\n\t\t\t\tahole = holes[ h ];\r\n\t\t\t\toneHoleMovements = holesMovements[ h ];\r\n\t\r\n\t\t\t\tfor ( i = 0, il = ahole.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\tvert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\r\n\t\r\n\t\t\t\t\tif ( ! extrudeByPath ) {\r\n\t\r\n\t\t\t\t\t\tv( vert.x, vert.y,  amount + z );\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tv( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\t/* Faces */\r\n\t\r\n\t\t// Top and bottom faces\r\n\t\r\n\t\tbuildLidFaces();\r\n\t\r\n\t\t// Sides faces\r\n\t\r\n\t\tbuildSideFaces();\r\n\t\r\n\t\r\n\t\t/////  Internal functions\r\n\t\r\n\t\tfunction buildLidFaces() {\r\n\t\r\n\t\t\tif ( bevelEnabled ) {\r\n\t\r\n\t\t\t\tvar layer = 0 ; // steps + 1\r\n\t\t\t\tvar offset = vlen * layer;\r\n\t\r\n\t\t\t\t// Bottom faces\r\n\t\r\n\t\t\t\tfor ( i = 0; i < flen; i ++ ) {\r\n\t\r\n\t\t\t\t\tface = faces[ i ];\r\n\t\t\t\t\tf3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tlayer = steps + bevelSegments * 2;\r\n\t\t\t\toffset = vlen * layer;\r\n\t\r\n\t\t\t\t// Top faces\r\n\t\r\n\t\t\t\tfor ( i = 0; i < flen; i ++ ) {\r\n\t\r\n\t\t\t\t\tface = faces[ i ];\r\n\t\t\t\t\tf3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\t// Bottom faces\r\n\t\r\n\t\t\t\tfor ( i = 0; i < flen; i ++ ) {\r\n\t\r\n\t\t\t\t\tface = faces[ i ];\r\n\t\t\t\t\tf3( face[ 2 ], face[ 1 ], face[ 0 ] );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// Top faces\r\n\t\r\n\t\t\t\tfor ( i = 0; i < flen; i ++ ) {\r\n\t\r\n\t\t\t\t\tface = faces[ i ];\r\n\t\t\t\t\tf3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );\r\n\t\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// Create faces for the z-sides of the shape\r\n\t\r\n\t\tfunction buildSideFaces() {\r\n\t\r\n\t\t\tvar layeroffset = 0;\r\n\t\t\tsidewalls( contour, layeroffset );\r\n\t\t\tlayeroffset += contour.length;\r\n\t\r\n\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\t\r\n\t\t\t\tahole = holes[ h ];\r\n\t\t\t\tsidewalls( ahole, layeroffset );\r\n\t\r\n\t\t\t\t//, true\r\n\t\t\t\tlayeroffset += ahole.length;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction sidewalls( contour, layeroffset ) {\r\n\t\r\n\t\t\tvar j, k;\r\n\t\t\ti = contour.length;\r\n\t\r\n\t\t\twhile ( -- i >= 0 ) {\r\n\t\r\n\t\t\t\tj = i;\r\n\t\t\t\tk = i - 1;\r\n\t\t\t\tif ( k < 0 ) k = contour.length - 1;\r\n\t\r\n\t\t\t\t//console.log('b', i,j, i-1, k,vertices.length);\r\n\t\r\n\t\t\t\tvar s = 0, sl = steps  + bevelSegments * 2;\r\n\t\r\n\t\t\t\tfor ( s = 0; s < sl; s ++ ) {\r\n\t\r\n\t\t\t\t\tvar slen1 = vlen * s;\r\n\t\t\t\t\tvar slen2 = vlen * ( s + 1 );\r\n\t\r\n\t\t\t\t\tvar a = layeroffset + j + slen1,\r\n\t\t\t\t\t\tb = layeroffset + k + slen1,\r\n\t\t\t\t\t\tc = layeroffset + k + slen2,\r\n\t\t\t\t\t\td = layeroffset + j + slen2;\r\n\t\r\n\t\t\t\t\tf4( a, b, c, d, contour, s, sl, j, k );\r\n\t\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\r\n\t\tfunction v( x, y, z ) {\r\n\t\r\n\t\t\tscope.vertices.push( new THREE.Vector3( x, y, z ) );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction f3( a, b, c ) {\r\n\t\r\n\t\t\ta += shapesOffset;\r\n\t\t\tb += shapesOffset;\r\n\t\t\tc += shapesOffset;\r\n\t\r\n\t\t\t// normal, color, material\r\n\t\t\tscope.faces.push( new THREE.Face3( a, b, c, null, null, material ) );\r\n\t\r\n\t\t\tvar uvs = uvgen.generateTopUV( scope, a, b, c );\r\n\t\r\n\t\t\tscope.faceVertexUvs[ 0 ].push( uvs );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction f4( a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2 ) {\r\n\t\r\n\t\t\ta += shapesOffset;\r\n\t\t\tb += shapesOffset;\r\n\t\t\tc += shapesOffset;\r\n\t\t\td += shapesOffset;\r\n\t\r\n\t\t\tscope.faces.push( new THREE.Face3( a, b, d, null, null, extrudeMaterial ) );\r\n\t\t\tscope.faces.push( new THREE.Face3( b, c, d, null, null, extrudeMaterial ) );\r\n\t\r\n\t\t\tvar uvs = uvgen.generateSideWallUV( scope, a, b, c, d );\r\n\t\r\n\t\t\tscope.faceVertexUvs[ 0 ].push( [ uvs[ 0 ], uvs[ 1 ], uvs[ 3 ] ] );\r\n\t\t\tscope.faceVertexUvs[ 0 ].push( [ uvs[ 1 ], uvs[ 2 ], uvs[ 3 ] ] );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.ExtrudeGeometry.WorldUVGenerator = {\r\n\t\r\n\t\tgenerateTopUV: function ( geometry, indexA, indexB, indexC ) {\r\n\t\r\n\t\t\tvar vertices = geometry.vertices;\r\n\t\r\n\t\t\tvar a = vertices[ indexA ];\r\n\t\t\tvar b = vertices[ indexB ];\r\n\t\t\tvar c = vertices[ indexC ];\r\n\t\r\n\t\t\treturn [\r\n\t\t\t\tnew THREE.Vector2( a.x, a.y ),\r\n\t\t\t\tnew THREE.Vector2( b.x, b.y ),\r\n\t\t\t\tnew THREE.Vector2( c.x, c.y )\r\n\t\t\t];\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgenerateSideWallUV: function ( geometry, indexA, indexB, indexC, indexD ) {\r\n\t\r\n\t\t\tvar vertices = geometry.vertices;\r\n\t\r\n\t\t\tvar a = vertices[ indexA ];\r\n\t\t\tvar b = vertices[ indexB ];\r\n\t\t\tvar c = vertices[ indexC ];\r\n\t\t\tvar d = vertices[ indexD ];\r\n\t\r\n\t\t\tif ( Math.abs( a.y - b.y ) < 0.01 ) {\r\n\t\t\t\treturn [\r\n\t\t\t\t\tnew THREE.Vector2( a.x, 1 - a.z ),\r\n\t\t\t\t\tnew THREE.Vector2( b.x, 1 - b.z ),\r\n\t\t\t\t\tnew THREE.Vector2( c.x, 1 - c.z ),\r\n\t\t\t\t\tnew THREE.Vector2( d.x, 1 - d.z )\r\n\t\t\t\t];\r\n\t\t\t} else {\r\n\t\t\t\treturn [\r\n\t\t\t\t\tnew THREE.Vector2( a.y, 1 - a.z ),\r\n\t\t\t\t\tnew THREE.Vector2( b.y, 1 - b.z ),\r\n\t\t\t\t\tnew THREE.Vector2( c.y, 1 - c.z ),\r\n\t\t\t\t\tnew THREE.Vector2( d.y, 1 - d.z )\r\n\t\t\t\t];\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\t\r\n\t// File:src/extras/geometries/ShapeGeometry.js\r\n\t\r\n\t/**\r\n\t * @author jonobr1 / http://jonobr1.com\r\n\t *\r\n\t * Creates a one-sided polygonal geometry from a path shape. Similar to\r\n\t * ExtrudeGeometry.\r\n\t *\r\n\t * parameters = {\r\n\t *\r\n\t *\tcurveSegments: <int>, // number of points on the curves. NOT USED AT THE MOMENT.\r\n\t *\r\n\t *\tmaterial: <int> // material index for front and back faces\r\n\t *\tuvGenerator: <Object> // object that provides UV generator functions\r\n\t *\r\n\t * }\r\n\t **/\r\n\t\r\n\tTHREE.ShapeGeometry = function ( shapes, options ) {\r\n\t\r\n\t\tTHREE.Geometry.call( this );\r\n\t\r\n\t\tthis.type = 'ShapeGeometry';\r\n\t\r\n\t\tif ( shapes instanceof Array === false ) shapes = [ shapes ];\r\n\t\r\n\t\tthis.addShapeList( shapes, options );\r\n\t\r\n\t\tthis.computeFaceNormals();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.ShapeGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\tTHREE.ShapeGeometry.prototype.constructor = THREE.ShapeGeometry;\r\n\t\r\n\t/**\r\n\t * Add an array of shapes to THREE.ShapeGeometry.\r\n\t */\r\n\tTHREE.ShapeGeometry.prototype.addShapeList = function ( shapes, options ) {\r\n\t\r\n\t\tfor ( var i = 0, l = shapes.length; i < l; i ++ ) {\r\n\t\r\n\t\t\tthis.addShape( shapes[ i ], options );\r\n\t\r\n\t\t}\r\n\t\r\n\t\treturn this;\r\n\t\r\n\t};\r\n\t\r\n\t/**\r\n\t * Adds a shape to THREE.ShapeGeometry, based on THREE.ExtrudeGeometry.\r\n\t */\r\n\tTHREE.ShapeGeometry.prototype.addShape = function ( shape, options ) {\r\n\t\r\n\t\tif ( options === undefined ) options = {};\r\n\t\tvar curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\r\n\t\r\n\t\tvar material = options.material;\r\n\t\tvar uvgen = options.UVGenerator === undefined ? THREE.ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;\r\n\t\r\n\t\t//\r\n\t\r\n\t\tvar i, l, hole;\r\n\t\r\n\t\tvar shapesOffset = this.vertices.length;\r\n\t\tvar shapePoints = shape.extractPoints( curveSegments );\r\n\t\r\n\t\tvar vertices = shapePoints.shape;\r\n\t\tvar holes = shapePoints.holes;\r\n\t\r\n\t\tvar reverse = ! THREE.Shape.Utils.isClockWise( vertices );\r\n\t\r\n\t\tif ( reverse ) {\r\n\t\r\n\t\t\tvertices = vertices.reverse();\r\n\t\r\n\t\t\t// Maybe we should also check if holes are in the opposite direction, just to be safe...\r\n\t\r\n\t\t\tfor ( i = 0, l = holes.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\thole = holes[ i ];\r\n\t\r\n\t\t\t\tif ( THREE.Shape.Utils.isClockWise( hole ) ) {\r\n\t\r\n\t\t\t\t\tholes[ i ] = hole.reverse();\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treverse = false;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar faces = THREE.Shape.Utils.triangulateShape( vertices, holes );\r\n\t\r\n\t\t// Vertices\r\n\t\r\n\t\tvar contour = vertices;\r\n\t\r\n\t\tfor ( i = 0, l = holes.length; i < l; i ++ ) {\r\n\t\r\n\t\t\thole = holes[ i ];\r\n\t\t\tvertices = vertices.concat( hole );\r\n\t\r\n\t\t}\r\n\t\r\n\t\t//\r\n\t\r\n\t\tvar vert, vlen = vertices.length;\r\n\t\tvar face, flen = faces.length;\r\n\t\r\n\t\tfor ( i = 0; i < vlen; i ++ ) {\r\n\t\r\n\t\t\tvert = vertices[ i ];\r\n\t\r\n\t\t\tthis.vertices.push( new THREE.Vector3( vert.x, vert.y, 0 ) );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfor ( i = 0; i < flen; i ++ ) {\r\n\t\r\n\t\t\tface = faces[ i ];\r\n\t\r\n\t\t\tvar a = face[ 0 ] + shapesOffset;\r\n\t\t\tvar b = face[ 1 ] + shapesOffset;\r\n\t\t\tvar c = face[ 2 ] + shapesOffset;\r\n\t\r\n\t\t\tthis.faces.push( new THREE.Face3( a, b, c, null, null, material ) );\r\n\t\t\tthis.faceVertexUvs[ 0 ].push( uvgen.generateTopUV( this, a, b, c ) );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/geometries/LatheGeometry.js\r\n\t\r\n\t/**\r\n\t * @author astrodud / http://astrodud.isgreat.org/\r\n\t * @author zz85 / https://github.com/zz85\r\n\t * @author bhouston / http://exocortex.com\r\n\t */\r\n\t\r\n\t// points - to create a closed torus, one must use a set of points \r\n\t//    like so: [ a, b, c, d, a ], see first is the same as last.\r\n\t// segments - the number of circumference segments to create\r\n\t// phiStart - the starting radian\r\n\t// phiLength - the radian (0 to 2*PI) range of the lathed section\r\n\t//    2*pi is a closed lathe, less than 2PI is a portion.\r\n\t\r\n\tTHREE.LatheGeometry = function ( points, segments, phiStart, phiLength ) {\r\n\t\r\n\t\tTHREE.Geometry.call( this );\r\n\t\r\n\t\tthis.type = 'LatheGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\tpoints: points,\r\n\t\t\tsegments: segments,\r\n\t\t\tphiStart: phiStart,\r\n\t\t\tphiLength: phiLength\r\n\t\t};\r\n\t\r\n\t\tsegments = segments || 12;\r\n\t\tphiStart = phiStart || 0;\r\n\t\tphiLength = phiLength || 2 * Math.PI;\r\n\t\r\n\t\tvar inversePointLength = 1.0 / ( points.length - 1 );\r\n\t\tvar inverseSegments = 1.0 / segments;\r\n\t\r\n\t\tfor ( var i = 0, il = segments; i <= il; i ++ ) {\r\n\t\r\n\t\t\tvar phi = phiStart + i * inverseSegments * phiLength;\r\n\t\r\n\t\t\tvar c = Math.cos( phi ),\r\n\t\t\t\ts = Math.sin( phi );\r\n\t\r\n\t\t\tfor ( var j = 0, jl = points.length; j < jl; j ++ ) {\r\n\t\r\n\t\t\t\tvar pt = points[ j ];\r\n\t\r\n\t\t\t\tvar vertex = new THREE.Vector3();\r\n\t\r\n\t\t\t\tvertex.x = c * pt.x - s * pt.y;\r\n\t\t\t\tvertex.y = s * pt.x + c * pt.y;\r\n\t\t\t\tvertex.z = pt.z;\r\n\t\r\n\t\t\t\tthis.vertices.push( vertex );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar np = points.length;\r\n\t\r\n\t\tfor ( var i = 0, il = segments; i < il; i ++ ) {\r\n\t\r\n\t\t\tfor ( var j = 0, jl = points.length - 1; j < jl; j ++ ) {\r\n\t\r\n\t\t\t\tvar base = j + np * i;\r\n\t\t\t\tvar a = base;\r\n\t\t\t\tvar b = base + np;\r\n\t\t\t\tvar c = base + 1 + np;\r\n\t\t\t\tvar d = base + 1;\r\n\t\r\n\t\t\t\tvar u0 = i * inverseSegments;\r\n\t\t\t\tvar v0 = j * inversePointLength;\r\n\t\t\t\tvar u1 = u0 + inverseSegments;\r\n\t\t\t\tvar v1 = v0 + inversePointLength;\r\n\t\r\n\t\t\t\tthis.faces.push( new THREE.Face3( a, b, d ) );\r\n\t\r\n\t\t\t\tthis.faceVertexUvs[ 0 ].push( [\r\n\t\r\n\t\t\t\t\tnew THREE.Vector2( u0, v0 ),\r\n\t\t\t\t\tnew THREE.Vector2( u1, v0 ),\r\n\t\t\t\t\tnew THREE.Vector2( u0, v1 )\r\n\t\r\n\t\t\t\t] );\r\n\t\r\n\t\t\t\tthis.faces.push( new THREE.Face3( b, c, d ) );\r\n\t\r\n\t\t\t\tthis.faceVertexUvs[ 0 ].push( [\r\n\t\r\n\t\t\t\t\tnew THREE.Vector2( u1, v0 ),\r\n\t\t\t\t\tnew THREE.Vector2( u1, v1 ),\r\n\t\t\t\t\tnew THREE.Vector2( u0, v1 )\r\n\t\r\n\t\t\t\t] );\r\n\t\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.mergeVertices();\r\n\t\tthis.computeFaceNormals();\r\n\t\tthis.computeVertexNormals();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.LatheGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\tTHREE.LatheGeometry.prototype.constructor = THREE.LatheGeometry;\r\n\t\r\n\t// File:src/extras/geometries/PlaneGeometry.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as\r\n\t */\r\n\t\r\n\tTHREE.PlaneGeometry = function ( width, height, widthSegments, heightSegments ) {\r\n\t\r\n\t\tconsole.info( 'THREE.PlaneGeometry: Consider using THREE.PlaneBufferGeometry for lower memory footprint.' );\r\n\t\r\n\t\tTHREE.Geometry.call( this );\r\n\t\r\n\t\tthis.type = 'PlaneGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\twidth: width,\r\n\t\t\theight: height,\r\n\t\t\twidthSegments: widthSegments,\r\n\t\t\theightSegments: heightSegments\r\n\t\t};\r\n\t\r\n\t\tthis.fromBufferGeometry( new THREE.PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.PlaneGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\tTHREE.PlaneGeometry.prototype.constructor = THREE.PlaneGeometry;\r\n\t\r\n\t// File:src/extras/geometries/PlaneBufferGeometry.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as\r\n\t */\r\n\t\r\n\tTHREE.PlaneBufferGeometry = function ( width, height, widthSegments, heightSegments ) {\r\n\t\r\n\t\tTHREE.BufferGeometry.call( this );\r\n\t\r\n\t\tthis.type = 'PlaneBufferGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\twidth: width,\r\n\t\t\theight: height,\r\n\t\t\twidthSegments: widthSegments,\r\n\t\t\theightSegments: heightSegments\r\n\t\t};\r\n\t\r\n\t\tvar width_half = width / 2;\r\n\t\tvar height_half = height / 2;\r\n\t\r\n\t\tvar gridX = widthSegments || 1;\r\n\t\tvar gridY = heightSegments || 1;\r\n\t\r\n\t\tvar gridX1 = gridX + 1;\r\n\t\tvar gridY1 = gridY + 1;\r\n\t\r\n\t\tvar segment_width = width / gridX;\r\n\t\tvar segment_height = height / gridY;\r\n\t\r\n\t\tvar vertices = new Float32Array( gridX1 * gridY1 * 3 );\r\n\t\tvar normals = new Float32Array( gridX1 * gridY1 * 3 );\r\n\t\tvar uvs = new Float32Array( gridX1 * gridY1 * 2 );\r\n\t\r\n\t\tvar offset = 0;\r\n\t\tvar offset2 = 0;\r\n\t\r\n\t\tfor ( var iy = 0; iy < gridY1; iy ++ ) {\r\n\t\r\n\t\t\tvar y = iy * segment_height - height_half;\r\n\t\r\n\t\t\tfor ( var ix = 0; ix < gridX1; ix ++ ) {\r\n\t\r\n\t\t\t\tvar x = ix * segment_width - width_half;\r\n\t\r\n\t\t\t\tvertices[ offset     ] = x;\r\n\t\t\t\tvertices[ offset + 1 ] = - y;\r\n\t\r\n\t\t\t\tnormals[ offset + 2 ] = 1;\r\n\t\r\n\t\t\t\tuvs[ offset2     ] = ix / gridX;\r\n\t\t\t\tuvs[ offset2 + 1 ] = 1 - ( iy / gridY );\r\n\t\r\n\t\t\t\toffset += 3;\r\n\t\t\t\toffset2 += 2;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\toffset = 0;\r\n\t\r\n\t\tvar indices = new ( ( vertices.length / 3 ) > 65535 ? Uint32Array : Uint16Array )( gridX * gridY * 6 );\r\n\t\r\n\t\tfor ( var iy = 0; iy < gridY; iy ++ ) {\r\n\t\r\n\t\t\tfor ( var ix = 0; ix < gridX; ix ++ ) {\r\n\t\r\n\t\t\t\tvar a = ix + gridX1 * iy;\r\n\t\t\t\tvar b = ix + gridX1 * ( iy + 1 );\r\n\t\t\t\tvar c = ( ix + 1 ) + gridX1 * ( iy + 1 );\r\n\t\t\t\tvar d = ( ix + 1 ) + gridX1 * iy;\r\n\t\r\n\t\t\t\tindices[ offset     ] = a;\r\n\t\t\t\tindices[ offset + 1 ] = b;\r\n\t\t\t\tindices[ offset + 2 ] = d;\r\n\t\r\n\t\t\t\tindices[ offset + 3 ] = b;\r\n\t\t\t\tindices[ offset + 4 ] = c;\r\n\t\t\t\tindices[ offset + 5 ] = d;\r\n\t\r\n\t\t\t\toffset += 6;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.addAttribute( 'index', new THREE.BufferAttribute( indices, 1 ) );\r\n\t\tthis.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\r\n\t\tthis.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );\r\n\t\tthis.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.PlaneBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\r\n\tTHREE.PlaneBufferGeometry.prototype.constructor = THREE.PlaneBufferGeometry;\r\n\t\r\n\t// File:src/extras/geometries/RingGeometry.js\r\n\t\r\n\t/**\r\n\t * @author Kaleb Murphy\r\n\t */\r\n\t\r\n\tTHREE.RingGeometry = function ( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {\r\n\t\r\n\t\tTHREE.Geometry.call( this );\r\n\t\r\n\t\tthis.type = 'RingGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\tinnerRadius: innerRadius,\r\n\t\t\touterRadius: outerRadius,\r\n\t\t\tthetaSegments: thetaSegments,\r\n\t\t\tphiSegments: phiSegments,\r\n\t\t\tthetaStart: thetaStart,\r\n\t\t\tthetaLength: thetaLength\r\n\t\t};\r\n\t\r\n\t\tinnerRadius = innerRadius || 0;\r\n\t\touterRadius = outerRadius || 50;\r\n\t\r\n\t\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\r\n\t\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\r\n\t\r\n\t\tthetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;\r\n\t\tphiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 8;\r\n\t\r\n\t\tvar i, o, uvs = [], radius = innerRadius, radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );\r\n\t\r\n\t\tfor ( i = 0; i < phiSegments + 1; i ++ ) { // concentric circles inside ring\r\n\t\r\n\t\t\tfor ( o = 0; o < thetaSegments + 1; o ++ ) { // number of segments per circle\r\n\t\r\n\t\t\t\tvar vertex = new THREE.Vector3();\r\n\t\t\t\tvar segment = thetaStart + o / thetaSegments * thetaLength;\r\n\t\t\t\tvertex.x = radius * Math.cos( segment );\r\n\t\t\t\tvertex.y = radius * Math.sin( segment );\r\n\t\r\n\t\t\t\tthis.vertices.push( vertex );\r\n\t\t\t\tuvs.push( new THREE.Vector2( ( vertex.x / outerRadius + 1 ) / 2, ( vertex.y / outerRadius + 1 ) / 2 ) );\r\n\t\t\t}\r\n\t\r\n\t\t\tradius += radiusStep;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar n = new THREE.Vector3( 0, 0, 1 );\r\n\t\r\n\t\tfor ( i = 0; i < phiSegments; i ++ ) { // concentric circles inside ring\r\n\t\r\n\t\t\tvar thetaSegment = i * (thetaSegments + 1);\r\n\t\r\n\t\t\tfor ( o = 0; o < thetaSegments ; o ++ ) { // number of segments per circle\r\n\t\r\n\t\t\t\tvar segment = o + thetaSegment;\r\n\t\r\n\t\t\t\tvar v1 = segment;\r\n\t\t\t\tvar v2 = segment + thetaSegments + 1;\r\n\t\t\t\tvar v3 = segment + thetaSegments + 2;\r\n\t\r\n\t\t\t\tthis.faces.push( new THREE.Face3( v1, v2, v3, [ n.clone(), n.clone(), n.clone() ] ) );\r\n\t\t\t\tthis.faceVertexUvs[ 0 ].push( [ uvs[ v1 ].clone(), uvs[ v2 ].clone(), uvs[ v3 ].clone() ]);\r\n\t\r\n\t\t\t\tv1 = segment;\r\n\t\t\t\tv2 = segment + thetaSegments + 2;\r\n\t\t\t\tv3 = segment + 1;\r\n\t\r\n\t\t\t\tthis.faces.push( new THREE.Face3( v1, v2, v3, [ n.clone(), n.clone(), n.clone() ] ) );\r\n\t\t\t\tthis.faceVertexUvs[ 0 ].push( [ uvs[ v1 ].clone(), uvs[ v2 ].clone(), uvs[ v3 ].clone() ]);\r\n\t\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tthis.computeFaceNormals();\r\n\t\r\n\t\tthis.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.RingGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\tTHREE.RingGeometry.prototype.constructor = THREE.RingGeometry;\r\n\t\r\n\t\r\n\t// File:src/extras/geometries/SphereGeometry.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.SphereGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {\r\n\t\r\n\t\tTHREE.Geometry.call( this );\r\n\t\r\n\t\tthis.type = 'SphereGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\tradius: radius,\r\n\t\t\twidthSegments: widthSegments,\r\n\t\t\theightSegments: heightSegments,\r\n\t\t\tphiStart: phiStart,\r\n\t\t\tphiLength: phiLength,\r\n\t\t\tthetaStart: thetaStart,\r\n\t\t\tthetaLength: thetaLength \r\n\t\t};\r\n\t\r\n\t\tradius = radius || 50;\r\n\t\r\n\t\twidthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );\r\n\t\theightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );\r\n\t\r\n\t\tphiStart = phiStart !== undefined ? phiStart : 0;\r\n\t\tphiLength = phiLength !== undefined ? phiLength : Math.PI * 2;\r\n\t\r\n\t\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\r\n\t\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI;\r\n\t\r\n\t\tvar x, y, vertices = [], uvs = [];\r\n\t\r\n\t\tfor ( y = 0; y <= heightSegments; y ++ ) {\r\n\t\r\n\t\t\tvar verticesRow = [];\r\n\t\t\tvar uvsRow = [];\r\n\t\r\n\t\t\tfor ( x = 0; x <= widthSegments; x ++ ) {\r\n\t\r\n\t\t\t\tvar u = x / widthSegments;\r\n\t\t\t\tvar v = y / heightSegments;\r\n\t\r\n\t\t\t\tvar vertex = new THREE.Vector3();\r\n\t\t\t\tvertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\r\n\t\t\t\tvertex.y = radius * Math.cos( thetaStart + v * thetaLength );\r\n\t\t\t\tvertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\r\n\t\r\n\t\t\t\tthis.vertices.push( vertex );\r\n\t\r\n\t\t\t\tverticesRow.push( this.vertices.length - 1 );\r\n\t\t\t\tuvsRow.push( new THREE.Vector2( u, 1 - v ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvertices.push( verticesRow );\r\n\t\t\tuvs.push( uvsRow );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfor ( y = 0; y < heightSegments; y ++ ) {\r\n\t\r\n\t\t\tfor ( x = 0; x < widthSegments; x ++ ) {\r\n\t\r\n\t\t\t\tvar v1 = vertices[ y ][ x + 1 ];\r\n\t\t\t\tvar v2 = vertices[ y ][ x ];\r\n\t\t\t\tvar v3 = vertices[ y + 1 ][ x ];\r\n\t\t\t\tvar v4 = vertices[ y + 1 ][ x + 1 ];\r\n\t\r\n\t\t\t\tvar n1 = this.vertices[ v1 ].clone().normalize();\r\n\t\t\t\tvar n2 = this.vertices[ v2 ].clone().normalize();\r\n\t\t\t\tvar n3 = this.vertices[ v3 ].clone().normalize();\r\n\t\t\t\tvar n4 = this.vertices[ v4 ].clone().normalize();\r\n\t\r\n\t\t\t\tvar uv1 = uvs[ y ][ x + 1 ].clone();\r\n\t\t\t\tvar uv2 = uvs[ y ][ x ].clone();\r\n\t\t\t\tvar uv3 = uvs[ y + 1 ][ x ].clone();\r\n\t\t\t\tvar uv4 = uvs[ y + 1 ][ x + 1 ].clone();\r\n\t\r\n\t\t\t\tif ( Math.abs( this.vertices[ v1 ].y ) === radius ) {\r\n\t\r\n\t\t\t\t\tuv1.x = ( uv1.x + uv2.x ) / 2;\r\n\t\t\t\t\tthis.faces.push( new THREE.Face3( v1, v3, v4, [ n1, n3, n4 ] ) );\r\n\t\t\t\t\tthis.faceVertexUvs[ 0 ].push( [ uv1, uv3, uv4 ] );\r\n\t\r\n\t\t\t\t} else if ( Math.abs( this.vertices[ v3 ].y ) === radius ) {\r\n\t\r\n\t\t\t\t\tuv3.x = ( uv3.x + uv4.x ) / 2;\r\n\t\t\t\t\tthis.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );\r\n\t\t\t\t\tthis.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tthis.faces.push( new THREE.Face3( v1, v2, v4, [ n1, n2, n4 ] ) );\r\n\t\t\t\t\tthis.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv4 ] );\r\n\t\r\n\t\t\t\t\tthis.faces.push( new THREE.Face3( v2, v3, v4, [ n2.clone(), n3, n4.clone() ] ) );\r\n\t\t\t\t\tthis.faceVertexUvs[ 0 ].push( [ uv2.clone(), uv3, uv4.clone() ] );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.computeFaceNormals();\r\n\t\r\n\t\tthis.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.SphereGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\tTHREE.SphereGeometry.prototype.constructor = THREE.SphereGeometry;\r\n\t\r\n\t// File:src/extras/geometries/TextGeometry.js\r\n\t\r\n\t/**\r\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t *\r\n\t * For creating 3D text geometry in three.js\r\n\t *\r\n\t * Text = 3D Text\r\n\t *\r\n\t * parameters = {\r\n\t *  size: \t\t\t<float>, \t// size of the text\r\n\t *  height: \t\t<float>, \t// thickness to extrude text\r\n\t *  curveSegments: \t<int>,\t\t// number of points on the curves\r\n\t *\r\n\t *  font: \t\t\t<string>,\t\t// font name\r\n\t *  weight: \t\t<string>,\t\t// font weight (normal, bold)\r\n\t *  style: \t\t\t<string>,\t\t// font style  (normal, italics)\r\n\t *\r\n\t *  bevelEnabled:\t<bool>,\t\t\t// turn on bevel\r\n\t *  bevelThickness: <float>, \t\t// how deep into text bevel goes\r\n\t *  bevelSize:\t\t<float>, \t\t// how far from text outline is bevel\r\n\t *  }\r\n\t *\r\n\t */\r\n\t\r\n\t/*\tUsage Examples\r\n\t\r\n\t\t// TextGeometry wrapper\r\n\t\r\n\t\tvar text3d = new TextGeometry( text, options );\r\n\t\r\n\t\t// Complete manner\r\n\t\r\n\t\tvar textShapes = THREE.FontUtils.generateShapes( text, options );\r\n\t\tvar text3d = new ExtrudeGeometry( textShapes, options );\r\n\t\r\n\t*/\r\n\t\r\n\t\r\n\tTHREE.TextGeometry = function ( text, parameters ) {\r\n\t\r\n\t\tparameters = parameters || {};\r\n\t\r\n\t\tvar textShapes = THREE.FontUtils.generateShapes( text, parameters );\r\n\t\r\n\t\t// translate parameters to ExtrudeGeometry API\r\n\t\r\n\t\tparameters.amount = parameters.height !== undefined ? parameters.height : 50;\r\n\t\r\n\t\t// defaults\r\n\t\r\n\t\tif ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;\r\n\t\tif ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;\r\n\t\tif ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;\r\n\t\r\n\t\tTHREE.ExtrudeGeometry.call( this, textShapes, parameters );\r\n\t\r\n\t\tthis.type = 'TextGeometry';\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.TextGeometry.prototype = Object.create( THREE.ExtrudeGeometry.prototype );\r\n\tTHREE.TextGeometry.prototype.constructor = THREE.TextGeometry;\r\n\t\r\n\t// File:src/extras/geometries/TorusGeometry.js\r\n\t\r\n\t/**\r\n\t * @author oosmoxiecode\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3DLite/src/away3dlite/primitives/Torus.as?r=2888\r\n\t */\r\n\t\r\n\tTHREE.TorusGeometry = function ( radius, tube, radialSegments, tubularSegments, arc ) {\r\n\t\r\n\t\tTHREE.Geometry.call( this );\r\n\t\r\n\t\tthis.type = 'TorusGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\tradius: radius,\r\n\t\t\ttube: tube,\r\n\t\t\tradialSegments: radialSegments,\r\n\t\t\ttubularSegments: tubularSegments,\r\n\t\t\tarc: arc\r\n\t\t};\r\n\t\r\n\t\tradius = radius || 100;\r\n\t\ttube = tube || 40;\r\n\t\tradialSegments = radialSegments || 8;\r\n\t\ttubularSegments = tubularSegments || 6;\r\n\t\tarc = arc || Math.PI * 2;\r\n\t\r\n\t\tvar center = new THREE.Vector3(), uvs = [], normals = [];\r\n\t\r\n\t\tfor ( var j = 0; j <= radialSegments; j ++ ) {\r\n\t\r\n\t\t\tfor ( var i = 0; i <= tubularSegments; i ++ ) {\r\n\t\r\n\t\t\t\tvar u = i / tubularSegments * arc;\r\n\t\t\t\tvar v = j / radialSegments * Math.PI * 2;\r\n\t\r\n\t\t\t\tcenter.x = radius * Math.cos( u );\r\n\t\t\t\tcenter.y = radius * Math.sin( u );\r\n\t\r\n\t\t\t\tvar vertex = new THREE.Vector3();\r\n\t\t\t\tvertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );\r\n\t\t\t\tvertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );\r\n\t\t\t\tvertex.z = tube * Math.sin( v );\r\n\t\r\n\t\t\t\tthis.vertices.push( vertex );\r\n\t\r\n\t\t\t\tuvs.push( new THREE.Vector2( i / tubularSegments, j / radialSegments ) );\r\n\t\t\t\tnormals.push( vertex.clone().sub( center ).normalize() );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfor ( var j = 1; j <= radialSegments; j ++ ) {\r\n\t\r\n\t\t\tfor ( var i = 1; i <= tubularSegments; i ++ ) {\r\n\t\r\n\t\t\t\tvar a = ( tubularSegments + 1 ) * j + i - 1;\r\n\t\t\t\tvar b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;\r\n\t\t\t\tvar c = ( tubularSegments + 1 ) * ( j - 1 ) + i;\r\n\t\t\t\tvar d = ( tubularSegments + 1 ) * j + i;\r\n\t\r\n\t\t\t\tvar face = new THREE.Face3( a, b, d, [ normals[ a ].clone(), normals[ b ].clone(), normals[ d ].clone() ] );\r\n\t\t\t\tthis.faces.push( face );\r\n\t\t\t\tthis.faceVertexUvs[ 0 ].push( [ uvs[ a ].clone(), uvs[ b ].clone(), uvs[ d ].clone() ] );\r\n\t\r\n\t\t\t\tface = new THREE.Face3( b, c, d, [ normals[ b ].clone(), normals[ c ].clone(), normals[ d ].clone() ] );\r\n\t\t\t\tthis.faces.push( face );\r\n\t\t\t\tthis.faceVertexUvs[ 0 ].push( [ uvs[ b ].clone(), uvs[ c ].clone(), uvs[ d ].clone() ] );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.computeFaceNormals();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.TorusGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\tTHREE.TorusGeometry.prototype.constructor = THREE.TorusGeometry;\r\n\t\r\n\t// File:src/extras/geometries/TorusKnotGeometry.js\r\n\t\r\n\t/**\r\n\t * @author oosmoxiecode\r\n\t * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3D/src/away3d/primitives/TorusKnot.as?spec=svn2473&r=2473\r\n\t */\r\n\t\r\n\tTHREE.TorusKnotGeometry = function ( radius, tube, radialSegments, tubularSegments, p, q, heightScale ) {\r\n\t\r\n\t\tTHREE.Geometry.call( this );\r\n\t\r\n\t\tthis.type = 'TorusKnotGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\tradius: radius,\r\n\t\t\ttube: tube,\r\n\t\t\tradialSegments: radialSegments,\r\n\t\t\ttubularSegments: tubularSegments,\r\n\t\t\tp: p,\r\n\t\t\tq: q,\r\n\t\t\theightScale: heightScale\r\n\t\t};\r\n\t\r\n\t\tradius = radius || 100;\r\n\t\ttube = tube || 40;\r\n\t\tradialSegments = radialSegments || 64;\r\n\t\ttubularSegments = tubularSegments || 8;\r\n\t\tp = p || 2;\r\n\t\tq = q || 3;\r\n\t\theightScale = heightScale || 1;\r\n\t\t\r\n\t\tvar grid = new Array( radialSegments );\r\n\t\tvar tang = new THREE.Vector3();\r\n\t\tvar n = new THREE.Vector3();\r\n\t\tvar bitan = new THREE.Vector3();\r\n\t\r\n\t\tfor ( var i = 0; i < radialSegments; ++ i ) {\r\n\t\r\n\t\t\tgrid[ i ] = new Array( tubularSegments );\r\n\t\t\tvar u = i / radialSegments * 2 * p * Math.PI;\r\n\t\t\tvar p1 = getPos( u, q, p, radius, heightScale );\r\n\t\t\tvar p2 = getPos( u + 0.01, q, p, radius, heightScale );\r\n\t\t\ttang.subVectors( p2, p1 );\r\n\t\t\tn.addVectors( p2, p1 );\r\n\t\r\n\t\t\tbitan.crossVectors( tang, n );\r\n\t\t\tn.crossVectors( bitan, tang );\r\n\t\t\tbitan.normalize();\r\n\t\t\tn.normalize();\r\n\t\r\n\t\t\tfor ( var j = 0; j < tubularSegments; ++ j ) {\r\n\t\r\n\t\t\t\tvar v = j / tubularSegments * 2 * Math.PI;\r\n\t\t\t\tvar cx = - tube * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.\r\n\t\t\t\tvar cy = tube * Math.sin( v );\r\n\t\r\n\t\t\t\tvar pos = new THREE.Vector3();\r\n\t\t\t\tpos.x = p1.x + cx * n.x + cy * bitan.x;\r\n\t\t\t\tpos.y = p1.y + cx * n.y + cy * bitan.y;\r\n\t\t\t\tpos.z = p1.z + cx * n.z + cy * bitan.z;\r\n\t\r\n\t\t\t\tgrid[ i ][ j ] = this.vertices.push( pos ) - 1;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfor ( var i = 0; i < radialSegments; ++ i ) {\r\n\t\r\n\t\t\tfor ( var j = 0; j < tubularSegments; ++ j ) {\r\n\t\r\n\t\t\t\tvar ip = ( i + 1 ) % radialSegments;\r\n\t\t\t\tvar jp = ( j + 1 ) % tubularSegments;\r\n\t\r\n\t\t\t\tvar a = grid[ i ][ j ];\r\n\t\t\t\tvar b = grid[ ip ][ j ];\r\n\t\t\t\tvar c = grid[ ip ][ jp ];\r\n\t\t\t\tvar d = grid[ i ][ jp ];\r\n\t\r\n\t\t\t\tvar uva = new THREE.Vector2( i / radialSegments, j / tubularSegments );\r\n\t\t\t\tvar uvb = new THREE.Vector2( ( i + 1 ) / radialSegments, j / tubularSegments );\r\n\t\t\t\tvar uvc = new THREE.Vector2( ( i + 1 ) / radialSegments, ( j + 1 ) / tubularSegments );\r\n\t\t\t\tvar uvd = new THREE.Vector2( i / radialSegments, ( j + 1 ) / tubularSegments );\r\n\t\r\n\t\t\t\tthis.faces.push( new THREE.Face3( a, b, d ) );\r\n\t\t\t\tthis.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );\r\n\t\r\n\t\t\t\tthis.faces.push( new THREE.Face3( b, c, d ) );\r\n\t\t\t\tthis.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );\r\n\t\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tthis.computeFaceNormals();\r\n\t\tthis.computeVertexNormals();\r\n\t\r\n\t\tfunction getPos( u, in_q, in_p, radius, heightScale ) {\r\n\t\r\n\t\t\tvar cu = Math.cos( u );\r\n\t\t\tvar su = Math.sin( u );\r\n\t\t\tvar quOverP = in_q / in_p * u;\r\n\t\t\tvar cs = Math.cos( quOverP );\r\n\t\r\n\t\t\tvar tx = radius * ( 2 + cs ) * 0.5 * cu;\r\n\t\t\tvar ty = radius * ( 2 + cs ) * su * 0.5;\r\n\t\t\tvar tz = heightScale * radius * Math.sin( quOverP ) * 0.5;\r\n\t\r\n\t\t\treturn new THREE.Vector3( tx, ty, tz );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.TorusKnotGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\tTHREE.TorusKnotGeometry.prototype.constructor = THREE.TorusKnotGeometry;\r\n\t\r\n\t// File:src/extras/geometries/TubeGeometry.js\r\n\t\r\n\t/**\r\n\t * @author WestLangley / https://github.com/WestLangley\r\n\t * @author zz85 / https://github.com/zz85\r\n\t * @author miningold / https://github.com/miningold\r\n\t * @author jonobr1 / https://github.com/jonobr1\r\n\t *\r\n\t * Modified from the TorusKnotGeometry by @oosmoxiecode\r\n\t *\r\n\t * Creates a tube which extrudes along a 3d spline\r\n\t *\r\n\t * Uses parallel transport frames as described in\r\n\t * http://www.cs.indiana.edu/pub/techreports/TR425.pdf\r\n\t */\r\n\t\r\n\tTHREE.TubeGeometry = function ( path, segments, radius, radialSegments, closed, taper ) {\r\n\t\r\n\t\tTHREE.Geometry.call( this );\r\n\t\r\n\t\tthis.type = 'TubeGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\tpath: path,\r\n\t\t\tsegments: segments,\r\n\t\t\tradius: radius,\r\n\t\t\tradialSegments: radialSegments,\r\n\t\t\tclosed: closed\r\n\t\t};\r\n\t\r\n\t\tsegments = segments || 64;\r\n\t\tradius = radius || 1;\r\n\t\tradialSegments = radialSegments || 8;\r\n\t\tclosed = closed || false;\r\n\t\ttaper = taper || THREE.TubeGeometry.NoTaper;\r\n\t\r\n\t\tvar grid = [];\r\n\t\r\n\t\tvar scope = this,\r\n\t\r\n\t\t\ttangent,\r\n\t\t\tnormal,\r\n\t\t\tbinormal,\r\n\t\r\n\t\t\tnumpoints = segments + 1,\r\n\t\r\n\t\t\tu, v, r,\r\n\t\r\n\t\t\tcx, cy,\r\n\t\t\tpos, pos2 = new THREE.Vector3(),\r\n\t\t\ti, j,\r\n\t\t\tip, jp,\r\n\t\t\ta, b, c, d,\r\n\t\t\tuva, uvb, uvc, uvd;\r\n\t\r\n\t\tvar frames = new THREE.TubeGeometry.FrenetFrames( path, segments, closed ),\r\n\t\t\ttangents = frames.tangents,\r\n\t\t\tnormals = frames.normals,\r\n\t\t\tbinormals = frames.binormals;\r\n\t\r\n\t\t// proxy internals\r\n\t\tthis.tangents = tangents;\r\n\t\tthis.normals = normals;\r\n\t\tthis.binormals = binormals;\r\n\t\r\n\t\tfunction vert( x, y, z ) {\r\n\t\r\n\t\t\treturn scope.vertices.push( new THREE.Vector3( x, y, z ) ) - 1;\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// consruct the grid\r\n\t\r\n\t\tfor ( i = 0; i < numpoints; i ++ ) {\r\n\t\r\n\t\t\tgrid[ i ] = [];\r\n\t\r\n\t\t\tu = i / ( numpoints - 1 );\r\n\t\r\n\t\t\tpos = path.getPointAt( u );\r\n\t\r\n\t\t\ttangent = tangents[ i ];\r\n\t\t\tnormal = normals[ i ];\r\n\t\t\tbinormal = binormals[ i ];\r\n\t\r\n\t\t\tr = radius * taper( u );\r\n\t\r\n\t\t\tfor ( j = 0; j < radialSegments; j ++ ) {\r\n\t\r\n\t\t\t\tv = j / radialSegments * 2 * Math.PI;\r\n\t\r\n\t\t\t\tcx = - r * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.\r\n\t\t\t\tcy = r * Math.sin( v );\r\n\t\r\n\t\t\t\tpos2.copy( pos );\r\n\t\t\t\tpos2.x += cx * normal.x + cy * binormal.x;\r\n\t\t\t\tpos2.y += cx * normal.y + cy * binormal.y;\r\n\t\t\t\tpos2.z += cx * normal.z + cy * binormal.z;\r\n\t\r\n\t\t\t\tgrid[ i ][ j ] = vert( pos2.x, pos2.y, pos2.z );\r\n\t\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\r\n\t\t// construct the mesh\r\n\t\r\n\t\tfor ( i = 0; i < segments; i ++ ) {\r\n\t\r\n\t\t\tfor ( j = 0; j < radialSegments; j ++ ) {\r\n\t\r\n\t\t\t\tip = ( closed ) ? (i + 1) % segments : i + 1;\r\n\t\t\t\tjp = (j + 1) % radialSegments;\r\n\t\r\n\t\t\t\ta = grid[ i ][ j ];\t\t// *** NOT NECESSARILY PLANAR ! ***\r\n\t\t\t\tb = grid[ ip ][ j ];\r\n\t\t\t\tc = grid[ ip ][ jp ];\r\n\t\t\t\td = grid[ i ][ jp ];\r\n\t\r\n\t\t\t\tuva = new THREE.Vector2( i / segments, j / radialSegments );\r\n\t\t\t\tuvb = new THREE.Vector2( ( i + 1 ) / segments, j / radialSegments );\r\n\t\t\t\tuvc = new THREE.Vector2( ( i + 1 ) / segments, ( j + 1 ) / radialSegments );\r\n\t\t\t\tuvd = new THREE.Vector2( i / segments, ( j + 1 ) / radialSegments );\r\n\t\r\n\t\t\t\tthis.faces.push( new THREE.Face3( a, b, d ) );\r\n\t\t\t\tthis.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );\r\n\t\r\n\t\t\t\tthis.faces.push( new THREE.Face3( b, c, d ) );\r\n\t\t\t\tthis.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );\r\n\t\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tthis.computeFaceNormals();\r\n\t\tthis.computeVertexNormals();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.TubeGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\tTHREE.TubeGeometry.prototype.constructor = THREE.TubeGeometry;\r\n\t\r\n\tTHREE.TubeGeometry.NoTaper = function ( u ) {\r\n\t\r\n\t\treturn 1;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.TubeGeometry.SinusoidalTaper = function ( u ) {\r\n\t\r\n\t\treturn Math.sin( Math.PI * u );\r\n\t\r\n\t};\r\n\t\r\n\t// For computing of Frenet frames, exposing the tangents, normals and binormals the spline\r\n\tTHREE.TubeGeometry.FrenetFrames = function ( path, segments, closed ) {\r\n\t\r\n\t\tvar\tnormal = new THREE.Vector3(),\r\n\t\r\n\t\t\ttangents = [],\r\n\t\t\tnormals = [],\r\n\t\t\tbinormals = [],\r\n\t\r\n\t\t\tvec = new THREE.Vector3(),\r\n\t\t\tmat = new THREE.Matrix4(),\r\n\t\r\n\t\t\tnumpoints = segments + 1,\r\n\t\t\ttheta,\r\n\t\t\tepsilon = 0.0001,\r\n\t\t\tsmallest,\r\n\t\r\n\t\t\ttx, ty, tz,\r\n\t\t\ti, u;\r\n\t\r\n\t\r\n\t\t// expose internals\r\n\t\tthis.tangents = tangents;\r\n\t\tthis.normals = normals;\r\n\t\tthis.binormals = binormals;\r\n\t\r\n\t\t// compute the tangent vectors for each segment on the path\r\n\t\r\n\t\tfor ( i = 0; i < numpoints; i ++ ) {\r\n\t\r\n\t\t\tu = i / ( numpoints - 1 );\r\n\t\r\n\t\t\ttangents[ i ] = path.getTangentAt( u );\r\n\t\t\ttangents[ i ].normalize();\r\n\t\r\n\t\t}\r\n\t\r\n\t\tinitialNormal3();\r\n\t\r\n\t\t/*\r\n\t\tfunction initialNormal1(lastBinormal) {\r\n\t\t\t// fixed start binormal. Has dangers of 0 vectors\r\n\t\t\tnormals[ 0 ] = new THREE.Vector3();\r\n\t\t\tbinormals[ 0 ] = new THREE.Vector3();\r\n\t\t\tif (lastBinormal===undefined) lastBinormal = new THREE.Vector3( 0, 0, 1 );\r\n\t\t\tnormals[ 0 ].crossVectors( lastBinormal, tangents[ 0 ] ).normalize();\r\n\t\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();\r\n\t\t}\r\n\t\r\n\t\tfunction initialNormal2() {\r\n\t\r\n\t\t\t// This uses the Frenet-Serret formula for deriving binormal\r\n\t\t\tvar t2 = path.getTangentAt( epsilon );\r\n\t\r\n\t\t\tnormals[ 0 ] = new THREE.Vector3().subVectors( t2, tangents[ 0 ] ).normalize();\r\n\t\t\tbinormals[ 0 ] = new THREE.Vector3().crossVectors( tangents[ 0 ], normals[ 0 ] );\r\n\t\r\n\t\t\tnormals[ 0 ].crossVectors( binormals[ 0 ], tangents[ 0 ] ).normalize(); // last binormal x tangent\r\n\t\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();\r\n\t\r\n\t\t}\r\n\t\t*/\r\n\t\r\n\t\tfunction initialNormal3() {\r\n\t\t\t// select an initial normal vector perpenicular to the first tangent vector,\r\n\t\t\t// and in the direction of the smallest tangent xyz component\r\n\t\r\n\t\t\tnormals[ 0 ] = new THREE.Vector3();\r\n\t\t\tbinormals[ 0 ] = new THREE.Vector3();\r\n\t\t\tsmallest = Number.MAX_VALUE;\r\n\t\t\ttx = Math.abs( tangents[ 0 ].x );\r\n\t\t\tty = Math.abs( tangents[ 0 ].y );\r\n\t\t\ttz = Math.abs( tangents[ 0 ].z );\r\n\t\r\n\t\t\tif ( tx <= smallest ) {\r\n\t\t\t\tsmallest = tx;\r\n\t\t\t\tnormal.set( 1, 0, 0 );\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( ty <= smallest ) {\r\n\t\t\t\tsmallest = ty;\r\n\t\t\t\tnormal.set( 0, 1, 0 );\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( tz <= smallest ) {\r\n\t\t\t\tnormal.set( 0, 0, 1 );\r\n\t\t\t}\r\n\t\r\n\t\t\tvec.crossVectors( tangents[ 0 ], normal ).normalize();\r\n\t\r\n\t\t\tnormals[ 0 ].crossVectors( tangents[ 0 ], vec );\r\n\t\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );\r\n\t\t}\r\n\t\r\n\t\r\n\t\t// compute the slowly-varying normal and binormal vectors for each segment on the path\r\n\t\r\n\t\tfor ( i = 1; i < numpoints; i ++ ) {\r\n\t\r\n\t\t\tnormals[ i ] = normals[ i - 1 ].clone();\r\n\t\r\n\t\t\tbinormals[ i ] = binormals[ i - 1 ].clone();\r\n\t\r\n\t\t\tvec.crossVectors( tangents[ i - 1 ], tangents[ i ] );\r\n\t\r\n\t\t\tif ( vec.length() > epsilon ) {\r\n\t\r\n\t\t\t\tvec.normalize();\r\n\t\r\n\t\t\t\ttheta = Math.acos( THREE.Math.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors\r\n\t\r\n\t\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\r\n\t\r\n\t\t}\r\n\t\r\n\t\r\n\t\t// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same\r\n\t\r\n\t\tif ( closed ) {\r\n\t\r\n\t\t\ttheta = Math.acos( THREE.Math.clamp( normals[ 0 ].dot( normals[ numpoints - 1 ] ), - 1, 1 ) );\r\n\t\t\ttheta /= ( numpoints - 1 );\r\n\t\r\n\t\t\tif ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ numpoints - 1 ] ) ) > 0 ) {\r\n\t\r\n\t\t\t\ttheta = - theta;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfor ( i = 1; i < numpoints; i ++ ) {\r\n\t\r\n\t\t\t\t// twist a little...\r\n\t\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );\r\n\t\t\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t};\r\n\t\r\n\t// File:src/extras/geometries/PolyhedronGeometry.js\r\n\t\r\n\t/**\r\n\t * @author clockworkgeek / https://github.com/clockworkgeek\r\n\t * @author timothypratley / https://github.com/timothypratley\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t*/\r\n\t\r\n\tTHREE.PolyhedronGeometry = function ( vertices, indices, radius, detail ) {\r\n\t\r\n\t\tTHREE.Geometry.call( this );\r\n\t\r\n\t\tthis.type = 'PolyhedronGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\tvertices: vertices,\r\n\t\t\tindices: indices,\r\n\t\t\tradius: radius,\r\n\t\t\tdetail: detail\r\n\t\t};\r\n\t\r\n\t\tradius = radius || 1;\r\n\t\tdetail = detail || 0;\r\n\t\r\n\t\tvar that = this;\r\n\t\r\n\t\tfor ( var i = 0, l = vertices.length; i < l; i += 3 ) {\r\n\t\r\n\t\t\tprepare( new THREE.Vector3( vertices[ i ], vertices[ i + 1 ], vertices[ i + 2 ] ) );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar p = this.vertices;\r\n\t\r\n\t\tvar faces = [];\r\n\t\r\n\t\tfor ( var i = 0, j = 0, l = indices.length; i < l; i += 3, j ++ ) {\r\n\t\r\n\t\t\tvar v1 = p[ indices[ i     ] ];\r\n\t\t\tvar v2 = p[ indices[ i + 1 ] ];\r\n\t\t\tvar v3 = p[ indices[ i + 2 ] ];\r\n\t\r\n\t\t\tfaces[ j ] = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ] );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar centroid = new THREE.Vector3();\r\n\t\r\n\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\t\r\n\t\t\tsubdivide( faces[ i ], detail );\r\n\t\r\n\t\t}\r\n\t\r\n\t\r\n\t\t// Handle case when face straddles the seam\r\n\t\r\n\t\tfor ( var i = 0, l = this.faceVertexUvs[ 0 ].length; i < l; i ++ ) {\r\n\t\r\n\t\t\tvar uvs = this.faceVertexUvs[ 0 ][ i ];\r\n\t\r\n\t\t\tvar x0 = uvs[ 0 ].x;\r\n\t\t\tvar x1 = uvs[ 1 ].x;\r\n\t\t\tvar x2 = uvs[ 2 ].x;\r\n\t\r\n\t\t\tvar max = Math.max( x0, Math.max( x1, x2 ) );\r\n\t\t\tvar min = Math.min( x0, Math.min( x1, x2 ) );\r\n\t\r\n\t\t\tif ( max > 0.9 && min < 0.1 ) { // 0.9 is somewhat arbitrary\r\n\t\r\n\t\t\t\tif ( x0 < 0.2 ) uvs[ 0 ].x += 1;\r\n\t\t\t\tif ( x1 < 0.2 ) uvs[ 1 ].x += 1;\r\n\t\t\t\tif ( x2 < 0.2 ) uvs[ 2 ].x += 1;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\r\n\t\t// Apply radius\r\n\t\r\n\t\tfor ( var i = 0, l = this.vertices.length; i < l; i ++ ) {\r\n\t\r\n\t\t\tthis.vertices[ i ].multiplyScalar( radius );\r\n\t\r\n\t\t}\r\n\t\r\n\t\r\n\t\t// Merge vertices\r\n\t\r\n\t\tthis.mergeVertices();\r\n\t\r\n\t\tthis.computeFaceNormals();\r\n\t\r\n\t\tthis.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\r\n\t\r\n\t\r\n\t\t// Project vector onto sphere's surface\r\n\t\r\n\t\tfunction prepare( vector ) {\r\n\t\r\n\t\t\tvar vertex = vector.normalize().clone();\r\n\t\t\tvertex.index = that.vertices.push( vertex ) - 1;\r\n\t\r\n\t\t\t// Texture coords are equivalent to map coords, calculate angle and convert to fraction of a circle.\r\n\t\r\n\t\t\tvar u = azimuth( vector ) / 2 / Math.PI + 0.5;\r\n\t\t\tvar v = inclination( vector ) / Math.PI + 0.5;\r\n\t\t\tvertex.uv = new THREE.Vector2( u, 1 - v );\r\n\t\r\n\t\t\treturn vertex;\r\n\t\r\n\t\t}\r\n\t\r\n\t\r\n\t\t// Approximate a curved face with recursively sub-divided triangles.\r\n\t\r\n\t\tfunction make( v1, v2, v3 ) {\r\n\t\r\n\t\t\tvar face = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ] );\r\n\t\t\tthat.faces.push( face );\r\n\t\r\n\t\t\tcentroid.copy( v1 ).add( v2 ).add( v3 ).divideScalar( 3 );\r\n\t\r\n\t\t\tvar azi = azimuth( centroid );\r\n\t\r\n\t\t\tthat.faceVertexUvs[ 0 ].push( [\r\n\t\t\t\tcorrectUV( v1.uv, v1, azi ),\r\n\t\t\t\tcorrectUV( v2.uv, v2, azi ),\r\n\t\t\t\tcorrectUV( v3.uv, v3, azi )\r\n\t\t\t] );\r\n\t\r\n\t\t}\r\n\t\r\n\t\r\n\t\t// Analytically subdivide a face to the required detail level.\r\n\t\r\n\t\tfunction subdivide( face, detail ) {\r\n\t\r\n\t\t\tvar cols = Math.pow(2, detail);\r\n\t\t\tvar a = prepare( that.vertices[ face.a ] );\r\n\t\t\tvar b = prepare( that.vertices[ face.b ] );\r\n\t\t\tvar c = prepare( that.vertices[ face.c ] );\r\n\t\t\tvar v = [];\r\n\t\r\n\t\t\t// Construct all of the vertices for this subdivision.\r\n\t\r\n\t\t\tfor ( var i = 0 ; i <= cols; i ++ ) {\r\n\t\r\n\t\t\t\tv[ i ] = [];\r\n\t\r\n\t\t\t\tvar aj = prepare( a.clone().lerp( c, i / cols ) );\r\n\t\t\t\tvar bj = prepare( b.clone().lerp( c, i / cols ) );\r\n\t\t\t\tvar rows = cols - i;\r\n\t\r\n\t\t\t\tfor ( var j = 0; j <= rows; j ++) {\r\n\t\r\n\t\t\t\t\tif ( j == 0 && i == cols ) {\r\n\t\r\n\t\t\t\t\t\tv[ i ][ j ] = aj;\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tv[ i ][ j ] = prepare( aj.clone().lerp( bj, j / rows ) );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// Construct all of the faces.\r\n\t\r\n\t\t\tfor ( var i = 0; i < cols ; i ++ ) {\r\n\t\r\n\t\t\t\tfor ( var j = 0; j < 2 * (cols - i) - 1; j ++ ) {\r\n\t\r\n\t\t\t\t\tvar k = Math.floor( j / 2 );\r\n\t\r\n\t\t\t\t\tif ( j % 2 == 0 ) {\r\n\t\r\n\t\t\t\t\t\tmake(\r\n\t\t\t\t\t\t\tv[ i ][ k + 1],\r\n\t\t\t\t\t\t\tv[ i + 1 ][ k ],\r\n\t\t\t\t\t\t\tv[ i ][ k ]\r\n\t\t\t\t\t\t);\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tmake(\r\n\t\t\t\t\t\t\tv[ i ][ k + 1 ],\r\n\t\t\t\t\t\t\tv[ i + 1][ k + 1],\r\n\t\t\t\t\t\t\tv[ i + 1 ][ k ]\r\n\t\t\t\t\t\t);\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\r\n\t\t// Angle around the Y axis, counter-clockwise when looking from above.\r\n\t\r\n\t\tfunction azimuth( vector ) {\r\n\t\r\n\t\t\treturn Math.atan2( vector.z, - vector.x );\r\n\t\r\n\t\t}\r\n\t\r\n\t\r\n\t\t// Angle above the XZ plane.\r\n\t\r\n\t\tfunction inclination( vector ) {\r\n\t\r\n\t\t\treturn Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );\r\n\t\r\n\t\t}\r\n\t\r\n\t\r\n\t\t// Texture fixing helper. Spheres have some odd behaviours.\r\n\t\r\n\t\tfunction correctUV( uv, vector, azimuth ) {\r\n\t\r\n\t\t\tif ( ( azimuth < 0 ) && ( uv.x === 1 ) ) uv = new THREE.Vector2( uv.x - 1, uv.y );\r\n\t\t\tif ( ( vector.x === 0 ) && ( vector.z === 0 ) ) uv = new THREE.Vector2( azimuth / 2 / Math.PI + 0.5, uv.y );\r\n\t\t\treturn uv.clone();\r\n\t\r\n\t\t}\r\n\t\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.PolyhedronGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\tTHREE.PolyhedronGeometry.prototype.constructor = THREE.PolyhedronGeometry;\r\n\t\r\n\t// File:src/extras/geometries/DodecahedronGeometry.js\r\n\t\r\n\t/**\r\n\t * @author Abe Pazos / https://hamoid.com\r\n\t */\r\n\t\r\n\tTHREE.DodecahedronGeometry = function ( radius, detail ) {\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\tradius: radius,\r\n\t\t\tdetail: detail\r\n\t\t};\r\n\t\r\n\t\tvar t = ( 1 + Math.sqrt( 5 ) ) / 2;\r\n\t\tvar r = 1 / t;\r\n\t\r\n\t\tvar vertices = [\r\n\t\r\n\t\t\t// (Â±1, Â±1, Â±1)\r\n\t\t\t-1, -1, -1,    -1, -1,  1,\r\n\t\t\t-1,  1, -1,    -1,  1,  1,\r\n\t\t\t 1, -1, -1,     1, -1,  1,\r\n\t\t\t 1,  1, -1,     1,  1,  1,\r\n\t\r\n\t\t\t// (0, Â±1/Ï, Â±Ï)\r\n\t\t\t 0, -r, -t,     0, -r,  t,\r\n\t\t\t 0,  r, -t,     0,  r,  t,\r\n\t\r\n\t\t\t// (Â±1/Ï, Â±Ï, 0)\r\n\t\t\t-r, -t,  0,    -r,  t,  0,\r\n\t\t\t r, -t,  0,     r,  t,  0,\r\n\t\r\n\t\t\t// (Â±Ï, 0, Â±1/Ï)\r\n\t\t\t-t,  0, -r,     t,  0, -r,\r\n\t\t\t-t,  0,  r,     t,  0,  r\r\n\t\t];\r\n\t\r\n\t\tvar indices = [\r\n\t\t\t 3, 11,  7,      3,  7, 15,      3, 15, 13,\r\n\t\t\t 7, 19, 17,      7, 17,  6,      7,  6, 15,\r\n\t\t\t17,  4,  8,     17,  8, 10,     17, 10,  6,\r\n\t\t\t 8,  0, 16,      8, 16,  2,      8,  2, 10,\r\n\t\t\t 0, 12,  1,      0,  1, 18,      0, 18, 16,\r\n\t\t\t 6, 10,  2,      6,  2, 13,      6, 13, 15,\r\n\t\t\t 2, 16, 18,      2, 18,  3,      2,  3, 13,\r\n\t\t\t18,  1,  9,     18,  9, 11,     18, 11,  3,\r\n\t\t\t 4, 14, 12,      4, 12,  0,      4,  0,  8,\r\n\t\t\t11,  9,  5,     11,  5, 19,     11, 19,  7,\r\n\t\t\t19,  5, 14,     19, 14,  4,     19,  4, 17,\r\n\t\t\t 1, 12, 14,      1, 14,  5,      1,  5,  9\r\n\t\t];\r\n\t\r\n\t\tTHREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.DodecahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\tTHREE.DodecahedronGeometry.prototype.constructor = THREE.DodecahedronGeometry;\r\n\t\r\n\t// File:src/extras/geometries/IcosahedronGeometry.js\r\n\t\r\n\t/**\r\n\t * @author timothypratley / https://github.com/timothypratley\r\n\t */\r\n\t\r\n\tTHREE.IcosahedronGeometry = function ( radius, detail ) {\r\n\t\r\n\t\tvar t = ( 1 + Math.sqrt( 5 ) ) / 2;\r\n\t\r\n\t\tvar vertices = [\r\n\t\t\t- 1,  t,  0,    1,  t,  0,   - 1, - t,  0,    1, - t,  0,\r\n\t\t\t 0, - 1,  t,    0,  1,  t,    0, - 1, - t,    0,  1, - t,\r\n\t\t\t t,  0, - 1,    t,  0,  1,   - t,  0, - 1,   - t,  0,  1\r\n\t\t];\r\n\t\r\n\t\tvar indices = [\r\n\t\t\t 0, 11,  5,    0,  5,  1,    0,  1,  7,    0,  7, 10,    0, 10, 11,\r\n\t\t\t 1,  5,  9,    5, 11,  4,   11, 10,  2,   10,  7,  6,    7,  1,  8,\r\n\t\t\t 3,  9,  4,    3,  4,  2,    3,  2,  6,    3,  6,  8,    3,  8,  9,\r\n\t\t\t 4,  9,  5,    2,  4, 11,    6,  2, 10,    8,  6,  7,    9,  8,  1\r\n\t\t];\r\n\t\r\n\t\tTHREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );\r\n\t\r\n\t\tthis.type = 'IcosahedronGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\tradius: radius,\r\n\t\t\tdetail: detail\r\n\t\t};\r\n\t};\r\n\t\r\n\tTHREE.IcosahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\tTHREE.IcosahedronGeometry.prototype.constructor = THREE.IcosahedronGeometry;\r\n\t\r\n\t// File:src/extras/geometries/OctahedronGeometry.js\r\n\t\r\n\t/**\r\n\t * @author timothypratley / https://github.com/timothypratley\r\n\t */\r\n\t\r\n\tTHREE.OctahedronGeometry = function ( radius, detail ) {\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\tradius: radius,\r\n\t\t\tdetail: detail\r\n\t\t};\r\n\t\r\n\t\tvar vertices = [\r\n\t\t\t1, 0, 0,   - 1, 0, 0,    0, 1, 0,    0,- 1, 0,    0, 0, 1,    0, 0,- 1\r\n\t\t];\r\n\t\r\n\t\tvar indices = [\r\n\t\t\t0, 2, 4,    0, 4, 3,    0, 3, 5,    0, 5, 2,    1, 2, 5,    1, 5, 3,    1, 3, 4,    1, 4, 2\r\n\t\t];\r\n\t\r\n\t\tTHREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );\r\n\t\r\n\t\tthis.type = 'OctahedronGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\tradius: radius,\r\n\t\t\tdetail: detail\r\n\t\t};\r\n\t};\r\n\t\r\n\tTHREE.OctahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\tTHREE.OctahedronGeometry.prototype.constructor = THREE.OctahedronGeometry;\r\n\t\r\n\t// File:src/extras/geometries/TetrahedronGeometry.js\r\n\t\r\n\t/**\r\n\t * @author timothypratley / https://github.com/timothypratley\r\n\t */\r\n\t\r\n\tTHREE.TetrahedronGeometry = function ( radius, detail ) {\r\n\t\r\n\t\tvar vertices = [\r\n\t\t\t 1,  1,  1,   - 1, - 1,  1,   - 1,  1, - 1,    1, - 1, - 1\r\n\t\t];\r\n\t\r\n\t\tvar indices = [\r\n\t\t\t 2,  1,  0,    0,  3,  2,    1,  3,  0,    2,  3,  1\r\n\t\t];\r\n\t\r\n\t\tTHREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );\r\n\t\r\n\t\tthis.type = 'TetrahedronGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\tradius: radius,\r\n\t\t\tdetail: detail\r\n\t\t};\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.TetrahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\tTHREE.TetrahedronGeometry.prototype.constructor = THREE.TetrahedronGeometry;\r\n\t\r\n\t// File:src/extras/geometries/ParametricGeometry.js\r\n\t\r\n\t/**\r\n\t * @author zz85 / https://github.com/zz85\r\n\t * Parametric Surfaces Geometry\r\n\t * based on the brilliant article by @prideout http://prideout.net/blog/?p=44\r\n\t *\r\n\t * new THREE.ParametricGeometry( parametricFunction, uSegments, ySegements );\r\n\t *\r\n\t */\r\n\t\r\n\tTHREE.ParametricGeometry = function ( func, slices, stacks ) {\r\n\t\r\n\t\tTHREE.Geometry.call( this );\r\n\t\r\n\t\tthis.type = 'ParametricGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\tfunc: func,\r\n\t\t\tslices: slices,\r\n\t\t\tstacks: stacks\r\n\t\t};\r\n\t\r\n\t\tvar verts = this.vertices;\r\n\t\tvar faces = this.faces;\r\n\t\tvar uvs = this.faceVertexUvs[ 0 ];\r\n\t\r\n\t\tvar i, j, p;\r\n\t\tvar u, v;\r\n\t\r\n\t\tvar sliceCount = slices + 1;\r\n\t\r\n\t\tfor ( i = 0; i <= stacks; i ++ ) {\r\n\t\r\n\t\t\tv = i / stacks;\r\n\t\r\n\t\t\tfor ( j = 0; j <= slices; j ++ ) {\r\n\t\r\n\t\t\t\tu = j / slices;\r\n\t\r\n\t\t\t\tp = func( u, v );\r\n\t\t\t\tverts.push( p );\r\n\t\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tvar a, b, c, d;\r\n\t\tvar uva, uvb, uvc, uvd;\r\n\t\r\n\t\tfor ( i = 0; i < stacks; i ++ ) {\r\n\t\r\n\t\t\tfor ( j = 0; j < slices; j ++ ) {\r\n\t\r\n\t\t\t\ta = i * sliceCount + j;\r\n\t\t\t\tb = i * sliceCount + j + 1;\r\n\t\t\t\tc = (i + 1) * sliceCount + j + 1;\r\n\t\t\t\td = (i + 1) * sliceCount + j;\r\n\t\r\n\t\t\t\tuva = new THREE.Vector2( j / slices, i / stacks );\r\n\t\t\t\tuvb = new THREE.Vector2( ( j + 1 ) / slices, i / stacks );\r\n\t\t\t\tuvc = new THREE.Vector2( ( j + 1 ) / slices, ( i + 1 ) / stacks );\r\n\t\t\t\tuvd = new THREE.Vector2( j / slices, ( i + 1 ) / stacks );\r\n\t\r\n\t\t\t\tfaces.push( new THREE.Face3( a, b, d ) );\r\n\t\t\t\tuvs.push( [ uva, uvb, uvd ] );\r\n\t\r\n\t\t\t\tfaces.push( new THREE.Face3( b, c, d ) );\r\n\t\t\t\tuvs.push( [ uvb.clone(), uvc, uvd.clone() ] );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// console.log(this);\r\n\t\r\n\t\t// magic bullet\r\n\t\t// var diff = this.mergeVertices();\r\n\t\t// console.log('removed ', diff, ' vertices by merging');\r\n\t\r\n\t\tthis.computeFaceNormals();\r\n\t\tthis.computeVertexNormals();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.ParametricGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\tTHREE.ParametricGeometry.prototype.constructor = THREE.ParametricGeometry;\r\n\t\r\n\t// File:src/extras/helpers/AxisHelper.js\r\n\t\r\n\t/**\r\n\t * @author sroucheray / http://sroucheray.org/\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.AxisHelper = function ( size ) {\r\n\t\r\n\t\tsize = size || 1;\r\n\t\r\n\t\tvar vertices = new Float32Array( [\r\n\t\t\t0, 0, 0,  size, 0, 0,\r\n\t\t\t0, 0, 0,  0, size, 0,\r\n\t\t\t0, 0, 0,  0, 0, size\r\n\t\t] );\r\n\t\r\n\t\tvar colors = new Float32Array( [\r\n\t\t\t1, 0, 0,  1, 0.6, 0,\r\n\t\t\t0, 1, 0,  0.6, 1, 0,\r\n\t\t\t0, 0, 1,  0, 0.6, 1\r\n\t\t] );\r\n\t\r\n\t\tvar geometry = new THREE.BufferGeometry();\r\n\t\tgeometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\r\n\t\tgeometry.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );\r\n\t\r\n\t\tvar material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );\r\n\t\r\n\t\tTHREE.Line.call( this, geometry, material, THREE.LinePieces );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.AxisHelper.prototype = Object.create( THREE.Line.prototype );\r\n\tTHREE.AxisHelper.prototype.constructor = THREE.AxisHelper;\r\n\t\r\n\t// File:src/extras/helpers/ArrowHelper.js\r\n\t\r\n\t/**\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t * @author zz85 / http://github.com/zz85\r\n\t * @author bhouston / http://exocortex.com\r\n\t *\r\n\t * Creates an arrow for visualizing directions\r\n\t *\r\n\t * Parameters:\r\n\t *  dir - Vector3\r\n\t *  origin - Vector3\r\n\t *  length - Number\r\n\t *  color - color in hex value\r\n\t *  headLength - Number\r\n\t *  headWidth - Number\r\n\t */\r\n\t\r\n\tTHREE.ArrowHelper = ( function () {\r\n\t\r\n\t\tvar lineGeometry = new THREE.Geometry();\r\n\t\tlineGeometry.vertices.push( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 1, 0 ) );\r\n\t\r\n\t\tvar coneGeometry = new THREE.CylinderGeometry( 0, 0.5, 1, 5, 1 );\r\n\t\tconeGeometry.applyMatrix( new THREE.Matrix4().makeTranslation( 0, - 0.5, 0 ) );\r\n\t\r\n\t\treturn function ( dir, origin, length, color, headLength, headWidth ) {\r\n\t\r\n\t\t\t// dir is assumed to be normalized\r\n\t\r\n\t\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t\t\tif ( color === undefined ) color = 0xffff00;\r\n\t\t\tif ( length === undefined ) length = 1;\r\n\t\t\tif ( headLength === undefined ) headLength = 0.2 * length;\r\n\t\t\tif ( headWidth === undefined ) headWidth = 0.2 * headLength;\r\n\t\r\n\t\t\tthis.position.copy( origin );\r\n\t\r\n\t\t\tthis.line = new THREE.Line( lineGeometry, new THREE.LineBasicMaterial( { color: color } ) );\r\n\t\t\tthis.line.matrixAutoUpdate = false;\r\n\t\t\tthis.add( this.line );\r\n\t\r\n\t\t\tthis.cone = new THREE.Mesh( coneGeometry, new THREE.MeshBasicMaterial( { color: color } ) );\r\n\t\t\tthis.cone.matrixAutoUpdate = false;\r\n\t\t\tthis.add( this.cone );\r\n\t\r\n\t\t\tthis.setDirection( dir );\r\n\t\t\tthis.setLength( length, headLength, headWidth );\r\n\t\r\n\t\t}\r\n\t\r\n\t}() );\r\n\t\r\n\tTHREE.ArrowHelper.prototype = Object.create( THREE.Object3D.prototype );\r\n\tTHREE.ArrowHelper.prototype.constructor = THREE.ArrowHelper;\r\n\t\r\n\tTHREE.ArrowHelper.prototype.setDirection = ( function () {\r\n\t\r\n\t\tvar axis = new THREE.Vector3();\r\n\t\tvar radians;\r\n\t\r\n\t\treturn function ( dir ) {\r\n\t\r\n\t\t\t// dir is assumed to be normalized\r\n\t\r\n\t\t\tif ( dir.y > 0.99999 ) {\r\n\t\r\n\t\t\t\tthis.quaternion.set( 0, 0, 0, 1 );\r\n\t\r\n\t\t\t} else if ( dir.y < - 0.99999 ) {\r\n\t\r\n\t\t\t\tthis.quaternion.set( 1, 0, 0, 0 );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\taxis.set( dir.z, 0, - dir.x ).normalize();\r\n\t\r\n\t\t\t\tradians = Math.acos( dir.y );\r\n\t\r\n\t\t\t\tthis.quaternion.setFromAxisAngle( axis, radians );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t}() );\r\n\t\r\n\tTHREE.ArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {\r\n\t\r\n\t\tif ( headLength === undefined ) headLength = 0.2 * length;\r\n\t\tif ( headWidth === undefined ) headWidth = 0.2 * headLength;\r\n\t\r\n\t\tthis.line.scale.set( 1, length - headLength, 1 );\r\n\t\tthis.line.updateMatrix();\r\n\t\r\n\t\tthis.cone.scale.set( headWidth, headLength, headWidth );\r\n\t\tthis.cone.position.y = length;\r\n\t\tthis.cone.updateMatrix();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.ArrowHelper.prototype.setColor = function ( color ) {\r\n\t\r\n\t\tthis.line.material.color.set( color );\r\n\t\tthis.cone.material.color.set( color );\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/helpers/BoxHelper.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.BoxHelper = function ( object ) {\r\n\t\r\n\t\tvar geometry = new THREE.BufferGeometry();\r\n\t\tgeometry.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array( 72 ), 3 ) );\r\n\t\r\n\t\tTHREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: 0xffff00 } ), THREE.LinePieces );\r\n\t\r\n\t\tif ( object !== undefined ) {\r\n\t\r\n\t\t\tthis.update( object );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.BoxHelper.prototype = Object.create( THREE.Line.prototype );\r\n\tTHREE.BoxHelper.prototype.constructor = THREE.BoxHelper;\r\n\t\r\n\tTHREE.BoxHelper.prototype.update = function ( object ) {\r\n\t\r\n\t\tvar geometry = object.geometry;\r\n\t\r\n\t\tif ( geometry.boundingBox === null ) {\r\n\t\r\n\t\t\tgeometry.computeBoundingBox();\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar min = geometry.boundingBox.min;\r\n\t\tvar max = geometry.boundingBox.max;\r\n\t\r\n\t\t/*\r\n\t\t  5____4\r\n\t\t1/___0/|\r\n\t\t| 6__|_7\r\n\t\t2/___3/\r\n\t\r\n\t\t0: max.x, max.y, max.z\r\n\t\t1: min.x, max.y, max.z\r\n\t\t2: min.x, min.y, max.z\r\n\t\t3: max.x, min.y, max.z\r\n\t\t4: max.x, max.y, min.z\r\n\t\t5: min.x, max.y, min.z\r\n\t\t6: min.x, min.y, min.z\r\n\t\t7: max.x, min.y, min.z\r\n\t\t*/\r\n\t\r\n\t\tvar vertices = this.geometry.attributes.position.array;\r\n\t\r\n\t\tvertices[  0 ] = max.x; vertices[  1 ] = max.y; vertices[  2 ] = max.z;\r\n\t\tvertices[  3 ] = min.x; vertices[  4 ] = max.y; vertices[  5 ] = max.z;\r\n\t\r\n\t\tvertices[  6 ] = min.x; vertices[  7 ] = max.y; vertices[  8 ] = max.z;\r\n\t\tvertices[  9 ] = min.x; vertices[ 10 ] = min.y; vertices[ 11 ] = max.z;\r\n\t\r\n\t\tvertices[ 12 ] = min.x; vertices[ 13 ] = min.y; vertices[ 14 ] = max.z;\r\n\t\tvertices[ 15 ] = max.x; vertices[ 16 ] = min.y; vertices[ 17 ] = max.z;\r\n\t\r\n\t\tvertices[ 18 ] = max.x; vertices[ 19 ] = min.y; vertices[ 20 ] = max.z;\r\n\t\tvertices[ 21 ] = max.x; vertices[ 22 ] = max.y; vertices[ 23 ] = max.z;\r\n\t\r\n\t\t//\r\n\t\r\n\t\tvertices[ 24 ] = max.x; vertices[ 25 ] = max.y; vertices[ 26 ] = min.z;\r\n\t\tvertices[ 27 ] = min.x; vertices[ 28 ] = max.y; vertices[ 29 ] = min.z;\r\n\t\r\n\t\tvertices[ 30 ] = min.x; vertices[ 31 ] = max.y; vertices[ 32 ] = min.z;\r\n\t\tvertices[ 33 ] = min.x; vertices[ 34 ] = min.y; vertices[ 35 ] = min.z;\r\n\t\r\n\t\tvertices[ 36 ] = min.x; vertices[ 37 ] = min.y; vertices[ 38 ] = min.z;\r\n\t\tvertices[ 39 ] = max.x; vertices[ 40 ] = min.y; vertices[ 41 ] = min.z;\r\n\t\r\n\t\tvertices[ 42 ] = max.x; vertices[ 43 ] = min.y; vertices[ 44 ] = min.z;\r\n\t\tvertices[ 45 ] = max.x; vertices[ 46 ] = max.y; vertices[ 47 ] = min.z;\r\n\t\r\n\t\t//\r\n\t\r\n\t\tvertices[ 48 ] = max.x; vertices[ 49 ] = max.y; vertices[ 50 ] = max.z;\r\n\t\tvertices[ 51 ] = max.x; vertices[ 52 ] = max.y; vertices[ 53 ] = min.z;\r\n\t\r\n\t\tvertices[ 54 ] = min.x; vertices[ 55 ] = max.y; vertices[ 56 ] = max.z;\r\n\t\tvertices[ 57 ] = min.x; vertices[ 58 ] = max.y; vertices[ 59 ] = min.z;\r\n\t\r\n\t\tvertices[ 60 ] = min.x; vertices[ 61 ] = min.y; vertices[ 62 ] = max.z;\r\n\t\tvertices[ 63 ] = min.x; vertices[ 64 ] = min.y; vertices[ 65 ] = min.z;\r\n\t\r\n\t\tvertices[ 66 ] = max.x; vertices[ 67 ] = min.y; vertices[ 68 ] = max.z;\r\n\t\tvertices[ 69 ] = max.x; vertices[ 70 ] = min.y; vertices[ 71 ] = min.z;\r\n\t\r\n\t\tthis.geometry.attributes.position.needsUpdate = true;\r\n\t\r\n\t\tthis.geometry.computeBoundingSphere();\r\n\t\r\n\t\tthis.matrix = object.matrixWorld;\r\n\t\tthis.matrixAutoUpdate = false;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/helpers/BoundingBoxHelper.js\r\n\t\r\n\t/**\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t */\r\n\t\r\n\t// a helper to show the world-axis-aligned bounding box for an object\r\n\t\r\n\tTHREE.BoundingBoxHelper = function ( object, hex ) {\r\n\t\r\n\t\tvar color = ( hex !== undefined ) ? hex : 0x888888;\r\n\t\r\n\t\tthis.object = object;\r\n\t\r\n\t\tthis.box = new THREE.Box3();\r\n\t\r\n\t\tTHREE.Mesh.call( this, new THREE.BoxGeometry( 1, 1, 1 ), new THREE.MeshBasicMaterial( { color: color, wireframe: true } ) );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.BoundingBoxHelper.prototype = Object.create( THREE.Mesh.prototype );\r\n\tTHREE.BoundingBoxHelper.prototype.constructor = THREE.BoundingBoxHelper;\r\n\t\r\n\tTHREE.BoundingBoxHelper.prototype.update = function () {\r\n\t\r\n\t\tthis.box.setFromObject( this.object );\r\n\t\r\n\t\tthis.box.size( this.scale );\r\n\t\r\n\t\tthis.box.center( this.position );\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/helpers/CameraHelper.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t *\r\n\t *\t- shows frustum, line of sight and up of the camera\r\n\t *\t- suitable for fast updates\r\n\t * \t- based on frustum visualization in lightgl.js shadowmap example\r\n\t *\t\thttp://evanw.github.com/lightgl.js/tests/shadowmap.html\r\n\t */\r\n\t\r\n\tTHREE.CameraHelper = function ( camera ) {\r\n\t\r\n\t\tvar geometry = new THREE.Geometry();\r\n\t\tvar material = new THREE.LineBasicMaterial( { color: 0xffffff, vertexColors: THREE.FaceColors } );\r\n\t\r\n\t\tvar pointMap = {};\r\n\t\r\n\t\t// colors\r\n\t\r\n\t\tvar hexFrustum = 0xffaa00;\r\n\t\tvar hexCone = 0xff0000;\r\n\t\tvar hexUp = 0x00aaff;\r\n\t\tvar hexTarget = 0xffffff;\r\n\t\tvar hexCross = 0x333333;\r\n\t\r\n\t\t// near\r\n\t\r\n\t\taddLine( \"n1\", \"n2\", hexFrustum );\r\n\t\taddLine( \"n2\", \"n4\", hexFrustum );\r\n\t\taddLine( \"n4\", \"n3\", hexFrustum );\r\n\t\taddLine( \"n3\", \"n1\", hexFrustum );\r\n\t\r\n\t\t// far\r\n\t\r\n\t\taddLine( \"f1\", \"f2\", hexFrustum );\r\n\t\taddLine( \"f2\", \"f4\", hexFrustum );\r\n\t\taddLine( \"f4\", \"f3\", hexFrustum );\r\n\t\taddLine( \"f3\", \"f1\", hexFrustum );\r\n\t\r\n\t\t// sides\r\n\t\r\n\t\taddLine( \"n1\", \"f1\", hexFrustum );\r\n\t\taddLine( \"n2\", \"f2\", hexFrustum );\r\n\t\taddLine( \"n3\", \"f3\", hexFrustum );\r\n\t\taddLine( \"n4\", \"f4\", hexFrustum );\r\n\t\r\n\t\t// cone\r\n\t\r\n\t\taddLine( \"p\", \"n1\", hexCone );\r\n\t\taddLine( \"p\", \"n2\", hexCone );\r\n\t\taddLine( \"p\", \"n3\", hexCone );\r\n\t\taddLine( \"p\", \"n4\", hexCone );\r\n\t\r\n\t\t// up\r\n\t\r\n\t\taddLine( \"u1\", \"u2\", hexUp );\r\n\t\taddLine( \"u2\", \"u3\", hexUp );\r\n\t\taddLine( \"u3\", \"u1\", hexUp );\r\n\t\r\n\t\t// target\r\n\t\r\n\t\taddLine( \"c\", \"t\", hexTarget );\r\n\t\taddLine( \"p\", \"c\", hexCross );\r\n\t\r\n\t\t// cross\r\n\t\r\n\t\taddLine( \"cn1\", \"cn2\", hexCross );\r\n\t\taddLine( \"cn3\", \"cn4\", hexCross );\r\n\t\r\n\t\taddLine( \"cf1\", \"cf2\", hexCross );\r\n\t\taddLine( \"cf3\", \"cf4\", hexCross );\r\n\t\r\n\t\tfunction addLine( a, b, hex ) {\r\n\t\r\n\t\t\taddPoint( a, hex );\r\n\t\t\taddPoint( b, hex );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction addPoint( id, hex ) {\r\n\t\r\n\t\t\tgeometry.vertices.push( new THREE.Vector3() );\r\n\t\t\tgeometry.colors.push( new THREE.Color( hex ) );\r\n\t\r\n\t\t\tif ( pointMap[ id ] === undefined ) {\r\n\t\r\n\t\t\t\tpointMap[ id ] = [];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tpointMap[ id ].push( geometry.vertices.length - 1 );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tTHREE.Line.call( this, geometry, material, THREE.LinePieces );\r\n\t\r\n\t\tthis.camera = camera;\r\n\t\tthis.matrix = camera.matrixWorld;\r\n\t\tthis.matrixAutoUpdate = false;\r\n\t\r\n\t\tthis.pointMap = pointMap;\r\n\t\r\n\t\tthis.update();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.CameraHelper.prototype = Object.create( THREE.Line.prototype );\r\n\tTHREE.CameraHelper.prototype.constructor = THREE.CameraHelper;\r\n\t\r\n\tTHREE.CameraHelper.prototype.update = function () {\r\n\t\r\n\t\tvar geometry, pointMap;\r\n\t\t\r\n\t\tvar vector = new THREE.Vector3();\r\n\t\tvar camera = new THREE.Camera();\r\n\t\r\n\t\tvar setPoint = function ( point, x, y, z ) {\r\n\t\r\n\t\t\tvector.set( x, y, z ).unproject( camera );\r\n\t\r\n\t\t\tvar points = pointMap[ point ];\r\n\t\r\n\t\t\tif ( points !== undefined ) {\r\n\t\r\n\t\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\tgeometry.vertices[ points[ i ] ].copy( vector );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\treturn function () {\r\n\t\r\n\t\t\tgeometry = this.geometry;\r\n\t\t\tpointMap = this.pointMap;\r\n\t\r\n\t\t\tvar w = 1, h = 1;\r\n\t\r\n\t\t\t// we need just camera projection matrix\r\n\t\t\t// world matrix must be identity\r\n\t\r\n\t\t\tcamera.projectionMatrix.copy( this.camera.projectionMatrix );\r\n\t\r\n\t\t\t// center / target\r\n\t\r\n\t\t\tsetPoint( \"c\", 0, 0, - 1 );\r\n\t\t\tsetPoint( \"t\", 0, 0,  1 );\r\n\t\r\n\t\t\t// near\r\n\t\r\n\t\t\tsetPoint( \"n1\", - w, - h, - 1 );\r\n\t\t\tsetPoint( \"n2\",   w, - h, - 1 );\r\n\t\t\tsetPoint( \"n3\", - w,   h, - 1 );\r\n\t\t\tsetPoint( \"n4\",   w,   h, - 1 );\r\n\t\r\n\t\t\t// far\r\n\t\r\n\t\t\tsetPoint( \"f1\", - w, - h, 1 );\r\n\t\t\tsetPoint( \"f2\",   w, - h, 1 );\r\n\t\t\tsetPoint( \"f3\", - w,   h, 1 );\r\n\t\t\tsetPoint( \"f4\",   w,   h, 1 );\r\n\t\r\n\t\t\t// up\r\n\t\r\n\t\t\tsetPoint( \"u1\",   w * 0.7, h * 1.1, - 1 );\r\n\t\t\tsetPoint( \"u2\", - w * 0.7, h * 1.1, - 1 );\r\n\t\t\tsetPoint( \"u3\",         0, h * 2,   - 1 );\r\n\t\r\n\t\t\t// cross\r\n\t\r\n\t\t\tsetPoint( \"cf1\", - w,   0, 1 );\r\n\t\t\tsetPoint( \"cf2\",   w,   0, 1 );\r\n\t\t\tsetPoint( \"cf3\",   0, - h, 1 );\r\n\t\t\tsetPoint( \"cf4\",   0,   h, 1 );\r\n\t\r\n\t\t\tsetPoint( \"cn1\", - w,   0, - 1 );\r\n\t\t\tsetPoint( \"cn2\",   w,   0, - 1 );\r\n\t\t\tsetPoint( \"cn3\",   0, - h, - 1 );\r\n\t\t\tsetPoint( \"cn4\",   0,   h, - 1 );\r\n\t\r\n\t\t\tgeometry.verticesNeedUpdate = true;\r\n\t\r\n\t\t};\r\n\t\r\n\t}();\r\n\t\r\n\t// File:src/extras/helpers/DirectionalLightHelper.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t */\r\n\t\r\n\tTHREE.DirectionalLightHelper = function ( light, size ) {\r\n\t\r\n\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t\tthis.light = light;\r\n\t\tthis.light.updateMatrixWorld();\r\n\t\r\n\t\tthis.matrix = light.matrixWorld;\r\n\t\tthis.matrixAutoUpdate = false;\r\n\t\r\n\t\tsize = size || 1;\r\n\t\r\n\t\tvar geometry = new THREE.Geometry();\r\n\t\tgeometry.vertices.push(\r\n\t\t\tnew THREE.Vector3( - size,   size, 0 ),\r\n\t\t\tnew THREE.Vector3(   size,   size, 0 ),\r\n\t\t\tnew THREE.Vector3(   size, - size, 0 ),\r\n\t\t\tnew THREE.Vector3( - size, - size, 0 ),\r\n\t\t\tnew THREE.Vector3( - size,   size, 0 )\r\n\t\t);\r\n\t\r\n\t\tvar material = new THREE.LineBasicMaterial( { fog: false } );\r\n\t\tmaterial.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\r\n\t\r\n\t\tthis.lightPlane = new THREE.Line( geometry, material );\r\n\t\tthis.add( this.lightPlane );\r\n\t\r\n\t\tgeometry = new THREE.Geometry();\r\n\t\tgeometry.vertices.push(\r\n\t\t\tnew THREE.Vector3(),\r\n\t\t\tnew THREE.Vector3()\r\n\t\t);\r\n\t\r\n\t\tmaterial = new THREE.LineBasicMaterial( { fog: false } );\r\n\t\tmaterial.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\r\n\t\r\n\t\tthis.targetLine = new THREE.Line( geometry, material );\r\n\t\tthis.add( this.targetLine );\r\n\t\r\n\t\tthis.update();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.DirectionalLightHelper.prototype = Object.create( THREE.Object3D.prototype );\r\n\tTHREE.DirectionalLightHelper.prototype.constructor = THREE.DirectionalLightHelper;\r\n\t\r\n\tTHREE.DirectionalLightHelper.prototype.dispose = function () {\r\n\t\r\n\t\tthis.lightPlane.geometry.dispose();\r\n\t\tthis.lightPlane.material.dispose();\r\n\t\tthis.targetLine.geometry.dispose();\r\n\t\tthis.targetLine.material.dispose();\r\n\t};\r\n\t\r\n\tTHREE.DirectionalLightHelper.prototype.update = function () {\r\n\t\r\n\t\tvar v1 = new THREE.Vector3();\r\n\t\tvar v2 = new THREE.Vector3();\r\n\t\tvar v3 = new THREE.Vector3();\r\n\t\r\n\t\treturn function () {\r\n\t\r\n\t\t\tv1.setFromMatrixPosition( this.light.matrixWorld );\r\n\t\t\tv2.setFromMatrixPosition( this.light.target.matrixWorld );\r\n\t\t\tv3.subVectors( v2, v1 );\r\n\t\r\n\t\t\tthis.lightPlane.lookAt( v3 );\r\n\t\t\tthis.lightPlane.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\r\n\t\r\n\t\t\tthis.targetLine.geometry.vertices[ 1 ].copy( v3 );\r\n\t\t\tthis.targetLine.geometry.verticesNeedUpdate = true;\r\n\t\t\tthis.targetLine.material.color.copy( this.lightPlane.material.color );\r\n\t\r\n\t\t};\r\n\t\r\n\t}();\r\n\t\r\n\t// File:src/extras/helpers/EdgesHelper.js\r\n\t\r\n\t/**\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t * @param object THREE.Mesh whose geometry will be used\r\n\t * @param hex line color\r\n\t * @param thresholdAngle the minimim angle (in degrees),\r\n\t * between the face normals of adjacent faces,\r\n\t * that is required to render an edge. A value of 10 means\r\n\t * an edge is only rendered if the angle is at least 10 degrees.\r\n\t */\r\n\t\r\n\tTHREE.EdgesHelper = function ( object, hex, thresholdAngle ) {\r\n\t\r\n\t\tvar color = ( hex !== undefined ) ? hex : 0xffffff;\r\n\t\tthresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;\r\n\t\r\n\t\tvar thresholdDot = Math.cos( THREE.Math.degToRad( thresholdAngle ) );\r\n\t\r\n\t\tvar edge = [ 0, 0 ], hash = {};\r\n\t\tvar sortFunction = function ( a, b ) { return a - b };\r\n\t\r\n\t\tvar keys = [ 'a', 'b', 'c' ];\r\n\t\tvar geometry = new THREE.BufferGeometry();\r\n\t\r\n\t\tvar geometry2;\r\n\t\r\n\t\tif ( object.geometry instanceof THREE.BufferGeometry ) {\r\n\t\r\n\t\t\tgeometry2 = new THREE.Geometry();\r\n\t\t\tgeometry2.fromBufferGeometry( object.geometry );\r\n\t\r\n\t\t} else {\r\n\t\r\n\t\t\tgeometry2 = object.geometry.clone();\r\n\t\r\n\t\t}\r\n\t\r\n\t\tgeometry2.mergeVertices();\r\n\t\tgeometry2.computeFaceNormals();\r\n\t\r\n\t\tvar vertices = geometry2.vertices;\r\n\t\tvar faces = geometry2.faces;\r\n\t\tvar numEdges = 0;\r\n\t\r\n\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\t\r\n\t\t\tvar face = faces[ i ];\r\n\t\r\n\t\t\tfor ( var j = 0; j < 3; j ++ ) {\r\n\t\r\n\t\t\t\tedge[ 0 ] = face[ keys[ j ] ];\r\n\t\t\t\tedge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];\r\n\t\t\t\tedge.sort( sortFunction );\r\n\t\r\n\t\t\t\tvar key = edge.toString();\r\n\t\r\n\t\t\t\tif ( hash[ key ] === undefined ) {\r\n\t\r\n\t\t\t\t\thash[ key ] = { vert1: edge[ 0 ], vert2: edge[ 1 ], face1: i, face2: undefined };\r\n\t\t\t\t\tnumEdges ++;\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\thash[ key ].face2 = i;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar coords = new Float32Array( numEdges * 2 * 3 );\r\n\t\r\n\t\tvar index = 0;\r\n\t\r\n\t\tfor ( var key in hash ) {\r\n\t\r\n\t\t\tvar h = hash[ key ];\r\n\t\r\n\t\t\tif ( h.face2 === undefined || faces[ h.face1 ].normal.dot( faces[ h.face2 ].normal ) <= thresholdDot ) {\r\n\t\r\n\t\t\t\tvar vertex = vertices[ h.vert1 ];\r\n\t\t\t\tcoords[ index ++ ] = vertex.x;\r\n\t\t\t\tcoords[ index ++ ] = vertex.y;\r\n\t\t\t\tcoords[ index ++ ] = vertex.z;\r\n\t\r\n\t\t\t\tvertex = vertices[ h.vert2 ];\r\n\t\t\t\tcoords[ index ++ ] = vertex.x;\r\n\t\t\t\tcoords[ index ++ ] = vertex.y;\r\n\t\t\t\tcoords[ index ++ ] = vertex.z;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tgeometry.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );\r\n\t\r\n\t\tTHREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color } ), THREE.LinePieces );\r\n\t\r\n\t\tthis.matrix = object.matrixWorld;\r\n\t\tthis.matrixAutoUpdate = false;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.EdgesHelper.prototype = Object.create( THREE.Line.prototype );\r\n\tTHREE.EdgesHelper.prototype.constructor = THREE.EdgesHelper;\r\n\t\r\n\t// File:src/extras/helpers/FaceNormalsHelper.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t*/\r\n\t\r\n\tTHREE.FaceNormalsHelper = function ( object, size, hex, linewidth ) {\r\n\t\r\n\t\tthis.object = object;\r\n\t\r\n\t\tthis.size = ( size !== undefined ) ? size : 1;\r\n\t\r\n\t\tvar color = ( hex !== undefined ) ? hex : 0xffff00;\r\n\t\r\n\t\tvar width = ( linewidth !== undefined ) ? linewidth : 1;\r\n\t\r\n\t\tvar geometry = new THREE.Geometry();\r\n\t\r\n\t\tvar faces = this.object.geometry.faces;\r\n\t\r\n\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\t\r\n\t\t\tgeometry.vertices.push( new THREE.Vector3(), new THREE.Vector3() );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tTHREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ), THREE.LinePieces );\r\n\t\r\n\t\tthis.matrixAutoUpdate = false;\r\n\t\r\n\t\tthis.normalMatrix = new THREE.Matrix3();\r\n\t\r\n\t\tthis.update();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.FaceNormalsHelper.prototype = Object.create( THREE.Line.prototype );\r\n\tTHREE.FaceNormalsHelper.prototype.constructor = THREE.FaceNormalsHelper;\r\n\t\r\n\tTHREE.FaceNormalsHelper.prototype.update = function () {\r\n\t\r\n\t\tvar vertices = this.geometry.vertices;\r\n\t\r\n\t\tvar object = this.object;\r\n\t\tvar objectVertices = object.geometry.vertices;\r\n\t\tvar objectFaces = object.geometry.faces;\r\n\t\tvar objectWorldMatrix = object.matrixWorld;\r\n\t\r\n\t\tobject.updateMatrixWorld( true );\r\n\t\r\n\t\tthis.normalMatrix.getNormalMatrix( objectWorldMatrix );\r\n\t\r\n\t\tfor ( var i = 0, i2 = 0, l = objectFaces.length; i < l; i ++, i2 += 2 ) {\r\n\t\r\n\t\t\tvar face = objectFaces[ i ];\r\n\t\r\n\t\t\tvertices[ i2 ].copy( objectVertices[ face.a ] )\r\n\t\t\t\t.add( objectVertices[ face.b ] )\r\n\t\t\t\t.add( objectVertices[ face.c ] )\r\n\t\t\t\t.divideScalar( 3 )\r\n\t\t\t\t.applyMatrix4( objectWorldMatrix );\r\n\t\r\n\t\t\tvertices[ i2 + 1 ].copy( face.normal )\r\n\t\t\t\t.applyMatrix3( this.normalMatrix )\r\n\t\t\t\t.normalize()\r\n\t\t\t\t.multiplyScalar( this.size )\r\n\t\t\t\t.add( vertices[ i2 ] );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.geometry.verticesNeedUpdate = true;\r\n\t\r\n\t\treturn this;\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\t// File:src/extras/helpers/GridHelper.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.GridHelper = function ( size, step ) {\r\n\t\r\n\t\tvar geometry = new THREE.Geometry();\r\n\t\tvar material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );\r\n\t\r\n\t\tthis.color1 = new THREE.Color( 0x444444 );\r\n\t\tthis.color2 = new THREE.Color( 0x888888 );\r\n\t\r\n\t\tfor ( var i = - size; i <= size; i += step ) {\r\n\t\r\n\t\t\tgeometry.vertices.push(\r\n\t\t\t\tnew THREE.Vector3( - size, 0, i ), new THREE.Vector3( size, 0, i ),\r\n\t\t\t\tnew THREE.Vector3( i, 0, - size ), new THREE.Vector3( i, 0, size )\r\n\t\t\t);\r\n\t\r\n\t\t\tvar color = i === 0 ? this.color1 : this.color2;\r\n\t\r\n\t\t\tgeometry.colors.push( color, color, color, color );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tTHREE.Line.call( this, geometry, material, THREE.LinePieces );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.GridHelper.prototype = Object.create( THREE.Line.prototype );\r\n\tTHREE.GridHelper.prototype.constructor = THREE.GridHelper;\r\n\t\r\n\tTHREE.GridHelper.prototype.setColors = function( colorCenterLine, colorGrid ) {\r\n\t\r\n\t\tthis.color1.set( colorCenterLine );\r\n\t\tthis.color2.set( colorGrid );\r\n\t\r\n\t\tthis.geometry.colorsNeedUpdate = true;\r\n\t\r\n\t}\r\n\t\r\n\t// File:src/extras/helpers/HemisphereLightHelper.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.HemisphereLightHelper = function ( light, sphereSize ) {\r\n\t\r\n\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t\tthis.light = light;\r\n\t\tthis.light.updateMatrixWorld();\r\n\t\r\n\t\tthis.matrix = light.matrixWorld;\r\n\t\tthis.matrixAutoUpdate = false;\r\n\t\r\n\t\tthis.colors = [ new THREE.Color(), new THREE.Color() ];\r\n\t\r\n\t\tvar geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );\r\n\t\tgeometry.applyMatrix( new THREE.Matrix4().makeRotationX( - Math.PI / 2 ) );\r\n\t\r\n\t\tfor ( var i = 0, il = 8; i < il; i ++ ) {\r\n\t\r\n\t\t\tgeometry.faces[ i ].color = this.colors[ i < 4 ? 0 : 1 ];\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar material = new THREE.MeshBasicMaterial( { vertexColors: THREE.FaceColors, wireframe: true } );\r\n\t\r\n\t\tthis.lightSphere = new THREE.Mesh( geometry, material );\r\n\t\tthis.add( this.lightSphere );\r\n\t\r\n\t\tthis.update();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.HemisphereLightHelper.prototype = Object.create( THREE.Object3D.prototype );\r\n\tTHREE.HemisphereLightHelper.prototype.constructor = THREE.HemisphereLightHelper;\r\n\t\r\n\tTHREE.HemisphereLightHelper.prototype.dispose = function () {\r\n\t\tthis.lightSphere.geometry.dispose();\r\n\t\tthis.lightSphere.material.dispose();\r\n\t};\r\n\t\r\n\tTHREE.HemisphereLightHelper.prototype.update = function () {\r\n\t\r\n\t\tvar vector = new THREE.Vector3();\r\n\t\r\n\t\treturn function () {\r\n\t\r\n\t\t\tthis.colors[ 0 ].copy( this.light.color ).multiplyScalar( this.light.intensity );\r\n\t\t\tthis.colors[ 1 ].copy( this.light.groundColor ).multiplyScalar( this.light.intensity );\r\n\t\r\n\t\t\tthis.lightSphere.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );\r\n\t\t\tthis.lightSphere.geometry.colorsNeedUpdate = true;\r\n\t\r\n\t\t}\r\n\t\r\n\t}();\r\n\t\r\n\t// File:src/extras/helpers/PointLightHelper.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.PointLightHelper = function ( light, sphereSize ) {\r\n\t\r\n\t\tthis.light = light;\r\n\t\tthis.light.updateMatrixWorld();\r\n\t\r\n\t\tvar geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );\r\n\t\tvar material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );\r\n\t\tmaterial.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\r\n\t\r\n\t\tTHREE.Mesh.call( this, geometry, material );\r\n\t\r\n\t\tthis.matrix = this.light.matrixWorld;\r\n\t\tthis.matrixAutoUpdate = false;\r\n\t\r\n\t\t/*\r\n\t\tvar distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );\r\n\t\tvar distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );\r\n\t\r\n\t\tthis.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );\r\n\t\tthis.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );\r\n\t\r\n\t\tvar d = light.distance;\r\n\t\r\n\t\tif ( d === 0.0 ) {\r\n\t\r\n\t\t\tthis.lightDistance.visible = false;\r\n\t\r\n\t\t} else {\r\n\t\r\n\t\t\tthis.lightDistance.scale.set( d, d, d );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.add( this.lightDistance );\r\n\t\t*/\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.PointLightHelper.prototype = Object.create( THREE.Mesh.prototype );\r\n\tTHREE.PointLightHelper.prototype.constructor = THREE.PointLightHelper;\r\n\t\r\n\tTHREE.PointLightHelper.prototype.dispose = function () {\r\n\t\r\n\t\tthis.geometry.dispose();\r\n\t\tthis.material.dispose();\r\n\t};\r\n\t\r\n\tTHREE.PointLightHelper.prototype.update = function () {\r\n\t\r\n\t\tthis.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\r\n\t\r\n\t\t/*\r\n\t\tvar d = this.light.distance;\r\n\t\r\n\t\tif ( d === 0.0 ) {\r\n\t\r\n\t\t\tthis.lightDistance.visible = false;\r\n\t\r\n\t\t} else {\r\n\t\r\n\t\t\tthis.lightDistance.visible = true;\r\n\t\t\tthis.lightDistance.scale.set( d, d, d );\r\n\t\r\n\t\t}\r\n\t\t*/\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/helpers/SkeletonHelper.js\r\n\t\r\n\t/**\r\n\t * @author Sean Griffin / http://twitter.com/sgrif\r\n\t * @author Michael Guerrero / http://realitymeltdown.com\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author ikerr / http://verold.com\r\n\t */\r\n\t\r\n\tTHREE.SkeletonHelper = function ( object ) {\r\n\t\r\n\t\tthis.bones = this.getBoneList( object );\r\n\t\r\n\t\tvar geometry = new THREE.Geometry();\r\n\t\r\n\t\tfor ( var i = 0; i < this.bones.length; i ++ ) {\r\n\t\r\n\t\t\tvar bone = this.bones[ i ];\r\n\t\r\n\t\t\tif ( bone.parent instanceof THREE.Bone ) {\r\n\t\r\n\t\t\t\tgeometry.vertices.push( new THREE.Vector3() );\r\n\t\t\t\tgeometry.vertices.push( new THREE.Vector3() );\r\n\t\t\t\tgeometry.colors.push( new THREE.Color( 0, 0, 1 ) );\r\n\t\t\t\tgeometry.colors.push( new THREE.Color( 0, 1, 0 ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors, depthTest: false, depthWrite: false, transparent: true } );\r\n\t\r\n\t\tTHREE.Line.call( this, geometry, material, THREE.LinePieces );\r\n\t\r\n\t\tthis.root = object;\r\n\t\r\n\t\tthis.matrix = object.matrixWorld;\r\n\t\tthis.matrixAutoUpdate = false;\r\n\t\r\n\t\tthis.update();\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\tTHREE.SkeletonHelper.prototype = Object.create( THREE.Line.prototype );\r\n\tTHREE.SkeletonHelper.prototype.constructor = THREE.SkeletonHelper;\r\n\t\r\n\tTHREE.SkeletonHelper.prototype.getBoneList = function( object ) {\r\n\t\r\n\t\tvar boneList = [];\r\n\t\r\n\t\tif ( object instanceof THREE.Bone ) {\r\n\t\r\n\t\t\tboneList.push( object );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfor ( var i = 0; i < object.children.length; i ++ ) {\r\n\t\r\n\t\t\tboneList.push.apply( boneList, this.getBoneList( object.children[ i ] ) );\r\n\t\r\n\t\t}\r\n\t\r\n\t\treturn boneList;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.SkeletonHelper.prototype.update = function () {\r\n\t\r\n\t\tvar geometry = this.geometry;\r\n\t\r\n\t\tvar matrixWorldInv = new THREE.Matrix4().getInverse( this.root.matrixWorld );\r\n\t\r\n\t\tvar boneMatrix = new THREE.Matrix4();\r\n\t\r\n\t\tvar j = 0;\r\n\t\r\n\t\tfor ( var i = 0; i < this.bones.length; i ++ ) {\r\n\t\r\n\t\t\tvar bone = this.bones[ i ];\r\n\t\r\n\t\t\tif ( bone.parent instanceof THREE.Bone ) {\r\n\t\r\n\t\t\t\tboneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );\r\n\t\t\t\tgeometry.vertices[ j ].setFromMatrixPosition( boneMatrix );\r\n\t\r\n\t\t\t\tboneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );\r\n\t\t\t\tgeometry.vertices[ j + 1 ].setFromMatrixPosition( boneMatrix );\r\n\t\r\n\t\t\t\tj += 2;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tgeometry.verticesNeedUpdate = true;\r\n\t\r\n\t\tgeometry.computeBoundingSphere();\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/helpers/SpotLightHelper.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t*/\r\n\t\r\n\tTHREE.SpotLightHelper = function ( light ) {\r\n\t\r\n\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t\tthis.light = light;\r\n\t\tthis.light.updateMatrixWorld();\r\n\t\r\n\t\tthis.matrix = light.matrixWorld;\r\n\t\tthis.matrixAutoUpdate = false;\r\n\t\r\n\t\tvar geometry = new THREE.CylinderGeometry( 0, 1, 1, 8, 1, true );\r\n\t\r\n\t\tgeometry.applyMatrix( new THREE.Matrix4().makeTranslation( 0, - 0.5, 0 ) );\r\n\t\tgeometry.applyMatrix( new THREE.Matrix4().makeRotationX( - Math.PI / 2 ) );\r\n\t\r\n\t\tvar material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );\r\n\t\r\n\t\tthis.cone = new THREE.Mesh( geometry, material );\r\n\t\tthis.add( this.cone );\r\n\t\r\n\t\tthis.update();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.SpotLightHelper.prototype = Object.create( THREE.Object3D.prototype );\r\n\tTHREE.SpotLightHelper.prototype.constructor = THREE.SpotLightHelper;\r\n\t\r\n\tTHREE.SpotLightHelper.prototype.dispose = function () {\r\n\t\tthis.cone.geometry.dispose();\r\n\t\tthis.cone.material.dispose();\r\n\t};\r\n\t\r\n\tTHREE.SpotLightHelper.prototype.update = function () {\r\n\t\r\n\t\tvar vector = new THREE.Vector3();\r\n\t\tvar vector2 = new THREE.Vector3();\r\n\t\r\n\t\treturn function () {\r\n\t\r\n\t\t\tvar coneLength = this.light.distance ? this.light.distance : 10000;\r\n\t\t\tvar coneWidth = coneLength * Math.tan( this.light.angle );\r\n\t\r\n\t\t\tthis.cone.scale.set( coneWidth, coneWidth, coneLength );\r\n\t\r\n\t\t\tvector.setFromMatrixPosition( this.light.matrixWorld );\r\n\t\t\tvector2.setFromMatrixPosition( this.light.target.matrixWorld );\r\n\t\r\n\t\t\tthis.cone.lookAt( vector2.sub( vector ) );\r\n\t\r\n\t\t\tthis.cone.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\r\n\t\r\n\t\t};\r\n\t\r\n\t}();\r\n\t\r\n\t// File:src/extras/helpers/VertexNormalsHelper.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t*/\r\n\t\r\n\tTHREE.VertexNormalsHelper = function ( object, size, hex, linewidth ) {\r\n\t\r\n\t\tthis.object = object;\r\n\t\r\n\t\tthis.size = ( size !== undefined ) ? size : 1;\r\n\t\r\n\t\tvar color = ( hex !== undefined ) ? hex : 0xff0000;\r\n\t\r\n\t\tvar width = ( linewidth !== undefined ) ? linewidth : 1;\r\n\t\r\n\t\tvar geometry = new THREE.Geometry();\r\n\t\r\n\t\tvar faces = object.geometry.faces;\r\n\t\r\n\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\t\r\n\t\t\tvar face = faces[ i ];\r\n\t\r\n\t\t\tfor ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\r\n\t\r\n\t\t\t\tgeometry.vertices.push( new THREE.Vector3(), new THREE.Vector3() );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tTHREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ), THREE.LinePieces );\r\n\t\r\n\t\tthis.matrixAutoUpdate = false;\r\n\t\r\n\t\tthis.normalMatrix = new THREE.Matrix3();\r\n\t\r\n\t\tthis.update();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.VertexNormalsHelper.prototype = Object.create( THREE.Line.prototype );\r\n\tTHREE.VertexNormalsHelper.prototype.constructor = THREE.VertexNormalsHelper;\r\n\t\r\n\tTHREE.VertexNormalsHelper.prototype.update = ( function ( object ) {\r\n\t\r\n\t\tvar v1 = new THREE.Vector3();\r\n\t\r\n\t\treturn function( object ) {\r\n\t\r\n\t\t\tvar keys = [ 'a', 'b', 'c', 'd' ];\r\n\t\r\n\t\t\tthis.object.updateMatrixWorld( true );\r\n\t\r\n\t\t\tthis.normalMatrix.getNormalMatrix( this.object.matrixWorld );\r\n\t\r\n\t\t\tvar vertices = this.geometry.vertices;\r\n\t\r\n\t\t\tvar verts = this.object.geometry.vertices;\r\n\t\r\n\t\t\tvar faces = this.object.geometry.faces;\r\n\t\r\n\t\t\tvar worldMatrix = this.object.matrixWorld;\r\n\t\r\n\t\t\tvar idx = 0;\r\n\t\r\n\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tvar face = faces[ i ];\r\n\t\r\n\t\t\t\tfor ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\r\n\t\r\n\t\t\t\t\tvar vertexId = face[ keys[ j ] ];\r\n\t\t\t\t\tvar vertex = verts[ vertexId ];\r\n\t\r\n\t\t\t\t\tvar normal = face.vertexNormals[ j ];\r\n\t\r\n\t\t\t\t\tvertices[ idx ].copy( vertex ).applyMatrix4( worldMatrix );\r\n\t\r\n\t\t\t\t\tv1.copy( normal ).applyMatrix3( this.normalMatrix ).normalize().multiplyScalar( this.size );\r\n\t\r\n\t\t\t\t\tv1.add( vertices[ idx ] );\r\n\t\t\t\t\tidx = idx + 1;\r\n\t\r\n\t\t\t\t\tvertices[ idx ].copy( v1 );\r\n\t\t\t\t\tidx = idx + 1;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.geometry.verticesNeedUpdate = true;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t}\r\n\t\r\n\t}());\r\n\t\r\n\t// File:src/extras/helpers/VertexTangentsHelper.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t*/\r\n\t\r\n\tTHREE.VertexTangentsHelper = function ( object, size, hex, linewidth ) {\r\n\t\r\n\t\tthis.object = object;\r\n\t\r\n\t\tthis.size = ( size !== undefined ) ? size : 1;\r\n\t\r\n\t\tvar color = ( hex !== undefined ) ? hex : 0x0000ff;\r\n\t\r\n\t\tvar width = ( linewidth !== undefined ) ? linewidth : 1;\r\n\t\r\n\t\tvar geometry = new THREE.Geometry();\r\n\t\r\n\t\tvar faces = object.geometry.faces;\r\n\t\r\n\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\t\r\n\t\t\tvar face = faces[ i ];\r\n\t\r\n\t\t\tfor ( var j = 0, jl = face.vertexTangents.length; j < jl; j ++ ) {\r\n\t\r\n\t\t\t\tgeometry.vertices.push( new THREE.Vector3() );\r\n\t\t\t\tgeometry.vertices.push( new THREE.Vector3() );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tTHREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ), THREE.LinePieces );\r\n\t\r\n\t\tthis.matrixAutoUpdate = false;\r\n\t\r\n\t\tthis.update();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.VertexTangentsHelper.prototype = Object.create( THREE.Line.prototype );\r\n\tTHREE.VertexTangentsHelper.prototype.constructor = THREE.VertexTangentsHelper;\r\n\t\r\n\tTHREE.VertexTangentsHelper.prototype.update = ( function ( object ) {\r\n\t\r\n\t\tvar v1 = new THREE.Vector3();\r\n\t\r\n\t\treturn function( object ) {\r\n\t\r\n\t\t\tvar keys = [ 'a', 'b', 'c', 'd' ];\r\n\t\r\n\t\t\tthis.object.updateMatrixWorld( true );\r\n\t\r\n\t\t\tvar vertices = this.geometry.vertices;\r\n\t\r\n\t\t\tvar verts = this.object.geometry.vertices;\r\n\t\r\n\t\t\tvar faces = this.object.geometry.faces;\r\n\t\r\n\t\t\tvar worldMatrix = this.object.matrixWorld;\r\n\t\r\n\t\t\tvar idx = 0;\r\n\t\r\n\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tvar face = faces[ i ];\r\n\t\r\n\t\t\t\tfor ( var j = 0, jl = face.vertexTangents.length; j < jl; j ++ ) {\r\n\t\r\n\t\t\t\t\tvar vertexId = face[ keys[ j ] ];\r\n\t\t\t\t\tvar vertex = verts[ vertexId ];\r\n\t\r\n\t\t\t\t\tvar tangent = face.vertexTangents[ j ];\r\n\t\r\n\t\t\t\t\tvertices[ idx ].copy( vertex ).applyMatrix4( worldMatrix );\r\n\t\r\n\t\t\t\t\tv1.copy( tangent ).transformDirection( worldMatrix ).multiplyScalar( this.size );\r\n\t\r\n\t\t\t\t\tv1.add( vertices[ idx ] );\r\n\t\t\t\t\tidx = idx + 1;\r\n\t\r\n\t\t\t\t\tvertices[ idx ].copy( v1 );\r\n\t\t\t\t\tidx = idx + 1;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.geometry.verticesNeedUpdate = true;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t}\r\n\t\r\n\t}());\r\n\t\r\n\t// File:src/extras/helpers/WireframeHelper.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.WireframeHelper = function ( object, hex ) {\r\n\t\r\n\t\tvar color = ( hex !== undefined ) ? hex : 0xffffff;\r\n\t\r\n\t\tvar edge = [ 0, 0 ], hash = {};\r\n\t\tvar sortFunction = function ( a, b ) { return a - b };\r\n\t\r\n\t\tvar keys = [ 'a', 'b', 'c' ];\r\n\t\tvar geometry = new THREE.BufferGeometry();\r\n\t\r\n\t\tif ( object.geometry instanceof THREE.Geometry ) {\r\n\t\r\n\t\t\tvar vertices = object.geometry.vertices;\r\n\t\t\tvar faces = object.geometry.faces;\r\n\t\t\tvar numEdges = 0;\r\n\t\r\n\t\t\t// allocate maximal size\r\n\t\t\tvar edges = new Uint32Array( 6 * faces.length );\r\n\t\r\n\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tvar face = faces[ i ];\r\n\t\r\n\t\t\t\tfor ( var j = 0; j < 3; j ++ ) {\r\n\t\r\n\t\t\t\t\tedge[ 0 ] = face[ keys[ j ] ];\r\n\t\t\t\t\tedge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];\r\n\t\t\t\t\tedge.sort( sortFunction );\r\n\t\r\n\t\t\t\t\tvar key = edge.toString();\r\n\t\r\n\t\t\t\t\tif ( hash[ key ] === undefined ) {\r\n\t\r\n\t\t\t\t\t\tedges[ 2 * numEdges ] = edge[ 0 ];\r\n\t\t\t\t\t\tedges[ 2 * numEdges + 1 ] = edge[ 1 ];\r\n\t\t\t\t\t\thash[ key ] = true;\r\n\t\t\t\t\t\tnumEdges ++;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar coords = new Float32Array( numEdges * 2 * 3 );\r\n\t\r\n\t\t\tfor ( var i = 0, l = numEdges; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tfor ( var j = 0; j < 2; j ++ ) {\r\n\t\r\n\t\t\t\t\tvar vertex = vertices[ edges [ 2 * i + j] ];\r\n\t\r\n\t\t\t\t\tvar index = 6 * i + 3 * j;\r\n\t\t\t\t\tcoords[ index + 0 ] = vertex.x;\r\n\t\t\t\t\tcoords[ index + 1 ] = vertex.y;\r\n\t\t\t\t\tcoords[ index + 2 ] = vertex.z;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tgeometry.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );\r\n\t\r\n\t\t} else if ( object.geometry instanceof THREE.BufferGeometry ) {\r\n\t\r\n\t\t\tif ( object.geometry.attributes.index !== undefined ) { // Indexed BufferGeometry\r\n\t\r\n\t\t\t\tvar vertices = object.geometry.attributes.position.array;\r\n\t\t\t\tvar indices = object.geometry.attributes.index.array;\r\n\t\t\t\tvar drawcalls = object.geometry.drawcalls;\r\n\t\t\t\tvar numEdges = 0;\r\n\t\r\n\t\t\t\tif ( drawcalls.length === 0 ) {\r\n\t\r\n\t\t\t\t\tdrawcalls = [ { count : indices.length, index : 0, start : 0 } ];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// allocate maximal size\r\n\t\t\t\tvar edges = new Uint32Array( 2 * indices.length );\r\n\t\r\n\t\t\t\tfor ( var o = 0, ol = drawcalls.length; o < ol; ++ o ) {\r\n\t\r\n\t\t\t\t\tvar start = drawcalls[ o ].start;\r\n\t\t\t\t\tvar count = drawcalls[ o ].count;\r\n\t\t\t\t\tvar index = drawcalls[ o ].index;\r\n\t\r\n\t\t\t\t\tfor ( var i = start, il = start + count; i < il; i += 3 ) {\r\n\t\r\n\t\t\t\t\t\tfor ( var j = 0; j < 3; j ++ ) {\r\n\t\r\n\t\t\t\t\t\t\tedge[ 0 ] = index + indices[ i + j ];\r\n\t\t\t\t\t\t\tedge[ 1 ] = index + indices[ i + ( j + 1 ) % 3 ];\r\n\t\t\t\t\t\t\tedge.sort( sortFunction );\r\n\t\r\n\t\t\t\t\t\t\tvar key = edge.toString();\r\n\t\r\n\t\t\t\t\t\t\tif ( hash[ key ] === undefined ) {\r\n\t\r\n\t\t\t\t\t\t\t\tedges[ 2 * numEdges ] = edge[ 0 ];\r\n\t\t\t\t\t\t\t\tedges[ 2 * numEdges + 1 ] = edge[ 1 ];\r\n\t\t\t\t\t\t\t\thash[ key ] = true;\r\n\t\t\t\t\t\t\t\tnumEdges ++;\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar coords = new Float32Array( numEdges * 2 * 3 );\r\n\t\r\n\t\t\t\tfor ( var i = 0, l = numEdges; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\tfor ( var j = 0; j < 2; j ++ ) {\r\n\t\r\n\t\t\t\t\t\tvar index = 6 * i + 3 * j;\r\n\t\t\t\t\t\tvar index2 = 3 * edges[ 2 * i + j];\r\n\t\t\t\t\t\tcoords[ index + 0 ] = vertices[ index2 ];\r\n\t\t\t\t\t\tcoords[ index + 1 ] = vertices[ index2 + 1 ];\r\n\t\t\t\t\t\tcoords[ index + 2 ] = vertices[ index2 + 2 ];\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tgeometry.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );\r\n\t\r\n\t\t\t} else { // non-indexed BufferGeometry\r\n\t\r\n\t\t\t\tvar vertices = object.geometry.attributes.position.array;\r\n\t\t\t\tvar numEdges = vertices.length / 3;\r\n\t\t\t\tvar numTris = numEdges / 3;\r\n\t\r\n\t\t\t\tvar coords = new Float32Array( numEdges * 2 * 3 );\r\n\t\r\n\t\t\t\tfor ( var i = 0, l = numTris; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\tfor ( var j = 0; j < 3; j ++ ) {\r\n\t\r\n\t\t\t\t\t\tvar index = 18 * i + 6 * j;\r\n\t\r\n\t\t\t\t\t\tvar index1 = 9 * i + 3 * j;\r\n\t\t\t\t\t\tcoords[ index + 0 ] = vertices[ index1 ];\r\n\t\t\t\t\t\tcoords[ index + 1 ] = vertices[ index1 + 1 ];\r\n\t\t\t\t\t\tcoords[ index + 2 ] = vertices[ index1 + 2 ];\r\n\t\r\n\t\t\t\t\t\tvar index2 = 9 * i + 3 * ( ( j + 1 ) % 3 );\r\n\t\t\t\t\t\tcoords[ index + 3 ] = vertices[ index2 ];\r\n\t\t\t\t\t\tcoords[ index + 4 ] = vertices[ index2 + 1 ];\r\n\t\t\t\t\t\tcoords[ index + 5 ] = vertices[ index2 + 2 ];\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tgeometry.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tTHREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color } ), THREE.LinePieces );\r\n\t\r\n\t\tthis.matrix = object.matrixWorld;\r\n\t\tthis.matrixAutoUpdate = false;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.WireframeHelper.prototype = Object.create( THREE.Line.prototype );\r\n\tTHREE.WireframeHelper.prototype.constructor = THREE.WireframeHelper;\r\n\t\r\n\t// File:src/extras/objects/ImmediateRenderObject.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.ImmediateRenderObject = function () {\r\n\t\r\n\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t\tthis.render = function ( renderCallback ) {};\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.ImmediateRenderObject.prototype = Object.create( THREE.Object3D.prototype );\r\n\tTHREE.ImmediateRenderObject.prototype.constructor = THREE.ImmediateRenderObject;\r\n\t\r\n\t// File:src/extras/objects/MorphBlendMesh.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.MorphBlendMesh = function( geometry, material ) {\r\n\t\r\n\t\tTHREE.Mesh.call( this, geometry, material );\r\n\t\r\n\t\tthis.animationsMap = {};\r\n\t\tthis.animationsList = [];\r\n\t\r\n\t\t// prepare default animation\r\n\t\t// (all frames played together in 1 second)\r\n\t\r\n\t\tvar numFrames = this.geometry.morphTargets.length;\r\n\t\r\n\t\tvar name = \"__default\";\r\n\t\r\n\t\tvar startFrame = 0;\r\n\t\tvar endFrame = numFrames - 1;\r\n\t\r\n\t\tvar fps = numFrames / 1;\r\n\t\r\n\t\tthis.createAnimation( name, startFrame, endFrame, fps );\r\n\t\tthis.setAnimationWeight( name, 1 );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MorphBlendMesh.prototype = Object.create( THREE.Mesh.prototype );\r\n\tTHREE.MorphBlendMesh.prototype.constructor = THREE.MorphBlendMesh;\r\n\t\r\n\tTHREE.MorphBlendMesh.prototype.createAnimation = function ( name, start, end, fps ) {\r\n\t\r\n\t\tvar animation = {\r\n\t\r\n\t\t\tstartFrame: start,\r\n\t\t\tendFrame: end,\r\n\t\r\n\t\t\tlength: end - start + 1,\r\n\t\r\n\t\t\tfps: fps,\r\n\t\t\tduration: ( end - start ) / fps,\r\n\t\r\n\t\t\tlastFrame: 0,\r\n\t\t\tcurrentFrame: 0,\r\n\t\r\n\t\t\tactive: false,\r\n\t\r\n\t\t\ttime: 0,\r\n\t\t\tdirection: 1,\r\n\t\t\tweight: 1,\r\n\t\r\n\t\t\tdirectionBackwards: false,\r\n\t\t\tmirroredLoop: false\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.animationsMap[ name ] = animation;\r\n\t\tthis.animationsList.push( animation );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MorphBlendMesh.prototype.autoCreateAnimations = function ( fps ) {\r\n\t\r\n\t\tvar pattern = /([a-z]+)_?(\\d+)/;\r\n\t\r\n\t\tvar firstAnimation, frameRanges = {};\r\n\t\r\n\t\tvar geometry = this.geometry;\r\n\t\r\n\t\tfor ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {\r\n\t\r\n\t\t\tvar morph = geometry.morphTargets[ i ];\r\n\t\t\tvar chunks = morph.name.match( pattern );\r\n\t\r\n\t\t\tif ( chunks && chunks.length > 1 ) {\r\n\t\r\n\t\t\t\tvar name = chunks[ 1 ];\r\n\t\r\n\t\t\t\tif ( ! frameRanges[ name ] ) frameRanges[ name ] = { start: Infinity, end: - Infinity };\r\n\t\r\n\t\t\t\tvar range = frameRanges[ name ];\r\n\t\r\n\t\t\t\tif ( i < range.start ) range.start = i;\r\n\t\t\t\tif ( i > range.end ) range.end = i;\r\n\t\r\n\t\t\t\tif ( ! firstAnimation ) firstAnimation = name;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfor ( var name in frameRanges ) {\r\n\t\r\n\t\t\tvar range = frameRanges[ name ];\r\n\t\t\tthis.createAnimation( name, range.start, range.end, fps );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.firstAnimation = firstAnimation;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function ( name ) {\r\n\t\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\t\r\n\t\tif ( animation ) {\r\n\t\r\n\t\t\tanimation.direction = 1;\r\n\t\t\tanimation.directionBackwards = false;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function ( name ) {\r\n\t\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\t\r\n\t\tif ( animation ) {\r\n\t\r\n\t\t\tanimation.direction = - 1;\r\n\t\t\tanimation.directionBackwards = true;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MorphBlendMesh.prototype.setAnimationFPS = function ( name, fps ) {\r\n\t\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\t\r\n\t\tif ( animation ) {\r\n\t\r\n\t\t\tanimation.fps = fps;\r\n\t\t\tanimation.duration = ( animation.end - animation.start ) / animation.fps;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MorphBlendMesh.prototype.setAnimationDuration = function ( name, duration ) {\r\n\t\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\t\r\n\t\tif ( animation ) {\r\n\t\r\n\t\t\tanimation.duration = duration;\r\n\t\t\tanimation.fps = ( animation.end - animation.start ) / animation.duration;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MorphBlendMesh.prototype.setAnimationWeight = function ( name, weight ) {\r\n\t\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\t\r\n\t\tif ( animation ) {\r\n\t\r\n\t\t\tanimation.weight = weight;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MorphBlendMesh.prototype.setAnimationTime = function ( name, time ) {\r\n\t\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\t\r\n\t\tif ( animation ) {\r\n\t\r\n\t\t\tanimation.time = time;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MorphBlendMesh.prototype.getAnimationTime = function ( name ) {\r\n\t\r\n\t\tvar time = 0;\r\n\t\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\t\r\n\t\tif ( animation ) {\r\n\t\r\n\t\t\ttime = animation.time;\r\n\t\r\n\t\t}\r\n\t\r\n\t\treturn time;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MorphBlendMesh.prototype.getAnimationDuration = function ( name ) {\r\n\t\r\n\t\tvar duration = - 1;\r\n\t\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\t\r\n\t\tif ( animation ) {\r\n\t\r\n\t\t\tduration = animation.duration;\r\n\t\r\n\t\t}\r\n\t\r\n\t\treturn duration;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MorphBlendMesh.prototype.playAnimation = function ( name ) {\r\n\t\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\t\r\n\t\tif ( animation ) {\r\n\t\r\n\t\t\tanimation.time = 0;\r\n\t\t\tanimation.active = true;\r\n\t\r\n\t\t} else {\r\n\t\r\n\t\t\tTHREE.warn( \"THREE.MorphBlendMesh: animation[\" + name + \"] undefined in .playAnimation()\" );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MorphBlendMesh.prototype.stopAnimation = function ( name ) {\r\n\t\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\t\r\n\t\tif ( animation ) {\r\n\t\r\n\t\t\tanimation.active = false;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MorphBlendMesh.prototype.update = function ( delta ) {\r\n\t\r\n\t\tfor ( var i = 0, il = this.animationsList.length; i < il; i ++ ) {\r\n\t\r\n\t\t\tvar animation = this.animationsList[ i ];\r\n\t\r\n\t\t\tif ( ! animation.active ) continue;\r\n\t\r\n\t\t\tvar frameTime = animation.duration / animation.length;\r\n\t\r\n\t\t\tanimation.time += animation.direction * delta;\r\n\t\r\n\t\t\tif ( animation.mirroredLoop ) {\r\n\t\r\n\t\t\t\tif ( animation.time > animation.duration || animation.time < 0 ) {\r\n\t\r\n\t\t\t\t\tanimation.direction *= - 1;\r\n\t\r\n\t\t\t\t\tif ( animation.time > animation.duration ) {\r\n\t\r\n\t\t\t\t\t\tanimation.time = animation.duration;\r\n\t\t\t\t\t\tanimation.directionBackwards = true;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( animation.time < 0 ) {\r\n\t\r\n\t\t\t\t\t\tanimation.time = 0;\r\n\t\t\t\t\t\tanimation.directionBackwards = false;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tanimation.time = animation.time % animation.duration;\r\n\t\r\n\t\t\t\tif ( animation.time < 0 ) animation.time += animation.duration;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar keyframe = animation.startFrame + THREE.Math.clamp( Math.floor( animation.time / frameTime ), 0, animation.length - 1 );\r\n\t\t\tvar weight = animation.weight;\r\n\t\r\n\t\t\tif ( keyframe !== animation.currentFrame ) {\r\n\t\r\n\t\t\t\tthis.morphTargetInfluences[ animation.lastFrame ] = 0;\r\n\t\t\t\tthis.morphTargetInfluences[ animation.currentFrame ] = 1 * weight;\r\n\t\r\n\t\t\t\tthis.morphTargetInfluences[ keyframe ] = 0;\r\n\t\r\n\t\t\t\tanimation.lastFrame = animation.currentFrame;\r\n\t\t\t\tanimation.currentFrame = keyframe;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar mix = ( animation.time % frameTime ) / frameTime;\r\n\t\r\n\t\t\tif ( animation.directionBackwards ) mix = 1 - mix;\r\n\t\r\n\t\t\tthis.morphTargetInfluences[ animation.currentFrame ] = mix * weight;\r\n\t\t\tthis.morphTargetInfluences[ animation.lastFrame ] = ( 1 - mix ) * weight;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\t// Export the THREE object for **Node.js**, with\r\n\t// backwards-compatibility for the old `require()` API. If we're in\r\n\t// the browser, add `_` as a global object via a string identifier,\r\n\t// for Closure Compiler \"advanced\" mode.\r\n\tif (true) {\r\n\t  if (typeof module !== 'undefined' && module.exports) {\r\n\t    exports = module.exports = THREE;\r\n\t  }\r\n\t  exports.THREE = THREE;\r\n\t} else {\r\n\t  this['THREE'] = THREE;\r\n\t}\r\n\n\n/***/ },\n/* 34 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar map = {\n\t\t\"./asphalt.jpg\": 42,\n\t\t\"./brick-tiles.jpg\": 43,\n\t\t\"./bricks-normal.jpg\": 44,\n\t\t\"./bricks-specular.jpg\": 45,\n\t\t\"./bricks.jpg\": 46,\n\t\t\"./checkerboard.png\": 47,\n\t\t\"./cloud10.png\": 48,\n\t\t\"./grass.jpg\": 49,\n\t\t\"./metal-floor.jpg\": 50,\n\t\t\"./metal.jpg\": 51,\n\t\t\"./stone.jpg\": 52,\n\t\t\"./tiles.jpg\": 53,\n\t\t\"./weathered-wood.jpg\": 54,\n\t\t\"./wood.jpg\": 55\n\t};\n\tfunction webpackContext(req) {\n\t\treturn __webpack_require__(webpackContextResolve(req));\n\t};\n\tfunction webpackContextResolve(req) {\n\t\treturn map[req] || (function() { throw new Error(\"Cannot find module '\" + req + \"'.\") }());\n\t};\n\twebpackContext.keys = function webpackContextKeys() {\n\t\treturn Object.keys(map);\n\t};\n\twebpackContext.resolve = webpackContextResolve;\n\tmodule.exports = webpackContext;\n\twebpackContext.id = 34;\n\n\n/***/ },\n/* 35 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = new RegExp(\n\t\t'^' +\n\t\n\t\t// protocol identifier\n\t\t'(?:(?:(?:https?):)?//)' +\n\t\n\t\t// user:pass authentication\n\t\t'(?:\\\\S+(?::\\\\S*)?@)?' +\n\t\t'(?:' +\n\t\n\t\t// IP address exclusion\n\t\t// private & local networks\n\t\t'(' +\n\t\t'(?!(?:10|127)(?:\\\\.\\\\d{1,3}){3})' +\n\t\t'(?!(?:169\\\\.254|192\\\\.168)(?:\\\\.\\\\d{1,3}){2})' +\n\t\t'(?!172\\\\.(?:1[6-9]|2\\\\d|3[0-1])(?:\\\\.\\\\d{1,3}){2})' +\n\t\n\t\t// IP address dotted notation octets\n\t\t// excludes loopback network 0.0.0.0\n\t\t// excludes reserved space >= 224.0.0.0\n\t\t// excludes network & broacast addresses\n\t\t// (first & last IP address of each class)\n\t\t'(?:[1-9]\\\\d?|1\\\\d\\\\d|2[01]\\\\d|22[0-3])' +\n\t\t'(?:\\\\.(?:1?\\\\d{1,2}|2[0-4]\\\\d|25[0-5])){2}' +\n\t\t'(?:\\\\.(?:[1-9]\\\\d?|1\\\\d\\\\d|2[0-4]\\\\d|25[0-4]))' +\n\t\t'|' +\n\t\n\t\t// host name\n\t\t'(?:(?:[a-z\\\\u00a1-\\\\uffff0-9]-*)*[a-z\\\\u00a1-\\\\uffff0-9]+)' +\n\t\n\t\t// domain name\n\t\t'(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff0-9]-*)*[a-z\\\\u00a1-\\\\uffff0-9]+)*' +\n\t\n\t\t// TLD identifier\n\t\t'(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff]{2,}))?' +\n\t\t')' +\n\t\n\t\t')' +\n\t\n\t\t// port number\n\t\t'(?::(\\\\d{2,5}))?' +\n\t\n\t\t// resource path\n\t\t'(?:/\\\\S*)?' +\n\t\t'$', 'i'\n\t);\n\n\n/***/ },\n/* 36 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * lodash 3.0.3 (Custom Build) <https://lodash.com/>\n\t * Build: `lodash modern modularize exports=\"npm\" -o ./`\n\t * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>\n\t * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n\t * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n\t * Available under MIT license <https://lodash.com/license>\n\t */\n\tvar arrayEach = __webpack_require__(62),\n\t    baseEach = __webpack_require__(61),\n\t    bindCallback = __webpack_require__(63),\n\t    isArray = __webpack_require__(64);\n\t\n\t/**\n\t * Creates a function for `_.forEach` or `_.forEachRight`.\n\t *\n\t * @private\n\t * @param {Function} arrayFunc The function to iterate over an array.\n\t * @param {Function} eachFunc The function to iterate over a collection.\n\t * @returns {Function} Returns the new each function.\n\t */\n\tfunction createForEach(arrayFunc, eachFunc) {\n\t  return function(collection, iteratee, thisArg) {\n\t    return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection))\n\t      ? arrayFunc(collection, iteratee)\n\t      : eachFunc(collection, bindCallback(iteratee, thisArg, 3));\n\t  };\n\t}\n\t\n\t/**\n\t * Iterates over elements of `collection` invoking `iteratee` for each element.\n\t * The `iteratee` is bound to `thisArg` and invoked with three arguments:\n\t * (value, index|key, collection). Iteratee functions may exit iteration early\n\t * by explicitly returning `false`.\n\t *\n\t * **Note:** As with other \"Collections\" methods, objects with a \"length\" property\n\t * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`\n\t * may be used for object iteration.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @alias each\n\t * @category Collection\n\t * @param {Array|Object|string} collection The collection to iterate over.\n\t * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n\t * @param {*} [thisArg] The `this` binding of `iteratee`.\n\t * @returns {Array|Object|string} Returns `collection`.\n\t * @example\n\t *\n\t * _([1, 2]).forEach(function(n) {\n\t *   console.log(n);\n\t * }).value();\n\t * // => logs each value from left to right and returns the array\n\t *\n\t * _.forEach({ 'a': 1, 'b': 2 }, function(n, key) {\n\t *   console.log(n, key);\n\t * });\n\t * // => logs each value-key pair and returns the object (iteration order is not guaranteed)\n\t */\n\tvar forEach = createForEach(arrayEach, baseEach);\n\t\n\tmodule.exports = forEach;\n\n\n/***/ },\n/* 37 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * lodash 3.1.0 (Custom Build) <https://lodash.com/>\n\t * Build: `lodash modern modularize exports=\"npm\" -o ./`\n\t * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>\n\t * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n\t * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n\t * Available under MIT license <https://lodash.com/license>\n\t */\n\tvar baseAssign = __webpack_require__(59),\n\t    createAssigner = __webpack_require__(57),\n\t    isNative = __webpack_require__(58),\n\t    keys = __webpack_require__(60);\n\t\n\t/** Used for native method references. */\n\tvar arrayProto = Array.prototype;\n\t\n\t/** Native method references. */\n\tvar getOwnPropertySymbols = isNative(getOwnPropertySymbols = Object.getOwnPropertySymbols) && getOwnPropertySymbols,\n\t    push = arrayProto.push;\n\t\n\t/**\n\t * A specialized version of `_.assign` for customizing assigned values without\n\t * support for argument juggling, multiple sources, and `this` binding `customizer`\n\t * functions.\n\t *\n\t * @private\n\t * @param {Object} object The destination object.\n\t * @param {Object} source The source object.\n\t * @param {Function} customizer The function to customize assigned values.\n\t * @returns {Object} Returns `object`.\n\t */\n\tfunction assignWith(object, source, customizer) {\n\t  var props = keys(source);\n\t  push.apply(props, getSymbols(source));\n\t\n\t  var index = -1,\n\t      length = props.length;\n\t\n\t  while (++index < length) {\n\t    var key = props[index],\n\t        value = object[key],\n\t        result = customizer(value, source[key], key, object, source);\n\t\n\t    if ((result === result ? (result !== value) : (value === value)) ||\n\t        (value === undefined && !(key in object))) {\n\t      object[key] = result;\n\t    }\n\t  }\n\t  return object;\n\t}\n\t\n\t/**\n\t * Creates an array of the own symbols of `object`.\n\t *\n\t * @private\n\t * @param {Object} object The object to query.\n\t * @returns {Array} Returns the array of symbols.\n\t */\n\tvar getSymbols = !getOwnPropertySymbols ? constant([]) : function(object) {\n\t  return getOwnPropertySymbols(toObject(object));\n\t};\n\t\n\t/**\n\t * Converts `value` to an object if it is not one.\n\t *\n\t * @private\n\t * @param {*} value The value to process.\n\t * @returns {Object} Returns the object.\n\t */\n\tfunction toObject(value) {\n\t  return isObject(value) ? value : Object(value);\n\t}\n\t\n\t/**\n\t * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.\n\t * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n\t *\n\t * @static\n\t * @memberOf _\n\t * @category Lang\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n\t * @example\n\t *\n\t * _.isObject({});\n\t * // => true\n\t *\n\t * _.isObject([1, 2, 3]);\n\t * // => true\n\t *\n\t * _.isObject(1);\n\t * // => false\n\t */\n\tfunction isObject(value) {\n\t  // Avoid a V8 JIT bug in Chrome 19-20.\n\t  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n\t  var type = typeof value;\n\t  return type == 'function' || (!!value && type == 'object');\n\t}\n\t\n\t/**\n\t * Assigns own enumerable properties of source object(s) to the destination\n\t * object. Subsequent sources overwrite property assignments of previous sources.\n\t * If `customizer` is provided it is invoked to produce the assigned values.\n\t * The `customizer` is bound to `thisArg` and invoked with five arguments:\n\t * (objectValue, sourceValue, key, object, source).\n\t *\n\t * **Note:** This method mutates `object` and is based on\n\t * [`Object.assign`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.assign).\n\t *\n\t *\n\t * @static\n\t * @memberOf _\n\t * @alias extend\n\t * @category Object\n\t * @param {Object} object The destination object.\n\t * @param {...Object} [sources] The source objects.\n\t * @param {Function} [customizer] The function to customize assigned values.\n\t * @param {*} [thisArg] The `this` binding of `customizer`.\n\t * @returns {Object} Returns `object`.\n\t * @example\n\t *\n\t * _.assign({ 'user': 'barney' }, { 'age': 40 }, { 'user': 'fred' });\n\t * // => { 'user': 'fred', 'age': 40 }\n\t *\n\t * // using a customizer callback\n\t * var defaults = _.partialRight(_.assign, function(value, other) {\n\t *   return _.isUndefined(value) ? other : value;\n\t * });\n\t *\n\t * defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });\n\t * // => { 'user': 'barney', 'age': 36 }\n\t */\n\tvar assign = createAssigner(function(object, source, customizer) {\n\t  return customizer\n\t    ? assignWith(object, source, customizer)\n\t    : baseAssign(object, source);\n\t});\n\t\n\t/**\n\t * Creates a function that returns `value`.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @category Utility\n\t * @param {*} value The value to return from the new function.\n\t * @returns {Function} Returns the new function.\n\t * @example\n\t *\n\t * var object = { 'user': 'fred' };\n\t * var getter = _.constant(object);\n\t *\n\t * getter() === object;\n\t * // => true\n\t */\n\tfunction constant(value) {\n\t  return function() {\n\t    return value;\n\t  };\n\t}\n\t\n\tmodule.exports = assign;\n\n\n/***/ },\n/* 38 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*** IMPORTS FROM imports-loader ***/\n\tvar THREE = __webpack_require__(33);\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.Audio = function ( listener ) {\n\t\n\t\tTHREE.Object3D.call( this );\n\t\n\t\tthis.type = 'Audio';\n\t\tthis.started = false;\n\t\n\t\tif (listener.context) {\n\t\n\t\t\tthis.context = listener.context;\n\t\t\t// this.source = this.context.createBufferSource();\n\t\n\t\t\tthis.gain = this.context.createGain();\n\t\t\tthis.gain.connect( listener.input );\n\t\n\t\t\tthis.panner = this.context.createPanner();\n\t\t\tthis.panner.connect( this.gain );\n\t\n\t\t} else {\n\t\n\t\t\tthis.source = new Audio();\n\t\n\t\t}\n\t};\n\t\n\tTHREE.Audio.prototype = Object.create( THREE.Object3D.prototype );\n\t\n\tTHREE.Audio.prototype.load = function ( sources ) {\n\t\t//todo: support multiple sources for different audio formats\n\t\n\t\tvar scope = this;\n\t\tvar file;\n\t\tvar i;\n\t\tvar match;\n\t\tvar element = this.source instanceof window.HTMLAudioElement ? this.source : new Audio();\n\t\n\t\tif (typeof sources === 'string') {\n\t\t\tsources = [sources];\n\t\t}\n\t\n\t\tfor (i = 0; i < sources.length; i++) {\n\t\t\tfile = sources[i];\n\t\t\tmatch = /\\.([a-z0-9]+)$/i.exec(file);\n\t\t\tif (match && element.canPlayType('audio/' + match[1])) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\n\t\tif (this.context) {\n\t\t\tvar request = new XMLHttpRequest();\n\t\t\trequest.open( 'GET', file, true );\n\t\t\trequest.responseType = 'arraybuffer';\n\t\t\trequest.onload = function ( e ) {\n\t\t\t\tconsole.log('audio buffer loaded. decoding...', e );\n\t\t\t\tscope.context.decodeAudioData( this.response, function ( buffer ) {\n\t\n\t\t\t\t\tscope.buffer = buffer;\n\t\t\t\t\tif (scope.started) {\n\t\t\t\t\t\tscope.start();\n\t\t\t\t\t}\n\t\n\t\t\t\t}, function onFailure(e) {\n\t\t\t\t\tconsole.log('Decoding the audio buffer failed', e);\n\t\t\t\t} );\n\t\n\t\t\t};\n\t\n\t\t\trequest.onerror = function ( e ) {\n\t\t\t\tconsole.log('error', e);\n\t\t\t};\n\t\n\t\t\trequest.send();\n\t\n\t\t} else {\n\t\n\t\t\tthis.source.src = file;\n\t\t\tthis.source.play();\n\t\n\t\t}\n\t\n\t\treturn this;\n\t};\n\t\n\tTHREE.Audio.prototype.stop = function ( value ) {\n\t\n\t\tif (this.context) {\n\t\t\tthis.source.stop();\n\t\t\tthis.source.disconnect( this.panner );\n\t\t\tthis.source = null;\n\t\t} else {\n\t\t\tthis.source.pause();\n\t\t\tthis.source.currentTime = 0;\n\t\t}\n\t\tthis.started = false;\n\t};\n\t\n\tTHREE.Audio.prototype.start = function ( value ) {\n\t\n\t\tthis.started = true;\n\t\tif (this.context) {\n\t\t\tif (this.source) {\n\t\t\t\tthis.source.disconnect( this.panner );\n\t\t\t}\n\t\n\t\t\tif (this.buffer) {\n\t\t\t\tthis.source = this.context.createBufferSource();\n\t\t\t\tthis.source.buffer = this.buffer;\n\t\t\t\tthis.source.connect( this.panner );\n\t\t\t\tthis.source.start( 0 );\n\t\t\t}\n\t\t} else {\n\t\t\tthis.source.currentTime = 0;\n\t\t\tthis.source.play();\n\t\t}\n\t\n\t};\n\t\n\tTHREE.Audio.prototype.setLoop = function ( value ) {\n\t\n\t\tthis.source.loop = value;\n\t\n\t};\n\t\n\tTHREE.Audio.prototype.setRefDistance = function ( value ) {\n\t\n\t\tif ( this.panner ) {\n\t\n\t\t\tthis.panner.refDistance = value;\n\t\n\t\t}\n\t\n\t};\n\t\n\tTHREE.Audio.prototype.setRolloffFactor = function ( value ) {\n\t\n\t\tif ( this.panner ) {\n\t\n\t\t\tthis.panner.rolloffFactor = value;\n\t\n\t\t}\n\t\n\t};\n\t\n\tTHREE.Audio.prototype.volume = function ( volume, time ) {\n\t\n\t\tif ( this.gain ) {\n\t\n\t\t\tif ( volume !== undefined ) {\n\t\t\t\tthis.gain.gain.linearRampToValueAtTime( volume, this.context.currentTime + (time || 0));\n\t\t\t}\n\t\n\t\t\treturn this.gain.gain.value;\n\t\t}\n\t\n\t\tif ( volume !== undefined ) {\n\t\t\tthis.source.volume = volume;\n\t\t}\n\t\n\t\treturn this.source.volume;\n\t};\n\t\n\tTHREE.Audio.prototype.updateMatrixWorld = ( function () {\n\t\n\t\tvar position = new THREE.Vector3();\n\t\n\t\treturn function ( force ) {\n\t\n\t\t\tTHREE.Object3D.prototype.updateMatrixWorld.call( this, force );\n\t\n\t\t\tposition.setFromMatrixPosition( this.matrixWorld );\n\t\n\t\t\tif (this.panner) {\n\t\n\t\t\t\tthis.panner.setPosition( position.x, position.y, position.z );\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t} )();\n\t\n\t// File:src/extras/audio/AudioListener.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.AudioListener = function () {\n\t\tvar AudioContext = window.AudioContext || window.webkitAudioContext;\n\t\n\t\tTHREE.Object3D.call( this );\n\t\n\t\tthis.type = 'AudioListener';\n\t\n\t\tif (AudioContext) {\n\t\t\tthis.context = new AudioContext();\n\t\t\tthis.input = this.context.createGain();\n\t\n\t\t\tthis.input.connect( this.context.destination );\n\t\t}\n\t};\n\t\n\tTHREE.AudioListener.prototype = Object.create( THREE.Object3D.prototype );\n\t\n\tTHREE.AudioListener.prototype.volume = function (val) {\n\t\tif (this.input) {\n\t\t\tval = val !== undefined && parseFloat(val);\n\t\t\tif (!isNaN(val)) {\n\t\t\t\tthis.input.gain.value = val;\n\t\t\t}\n\t\n\t\t\treturn this.input.gain.value;\n\t\t}\n\t};\n\t\n\tTHREE.AudioListener.prototype.updateMatrixWorld = ( function () {\n\t\n\t\tvar position = new THREE.Vector3();\n\t\tvar quaternion = new THREE.Quaternion();\n\t\tvar scale = new THREE.Vector3();\n\t\n\t\tvar orientation = new THREE.Vector3();\n\t\n\t\treturn function ( force ) {\n\t\n\t\t\tTHREE.Object3D.prototype.updateMatrixWorld.call( this, force );\n\t\n\t\t\tvar listener;\n\t\n\t\t\tif (this.context) {\n\t\t\t\tlistener = this.context.listener;\n\t\n\t\t\t\tthis.matrixWorld.decompose( position, quaternion, scale );\n\t\n\t\t\t\torientation.set( 0, 0, -1 ).applyQuaternion( quaternion );\n\t\n\t\t\t\tlistener.setPosition( position.x, position.y, position.z );\n\t\t\t\tlistener.setOrientation( orientation.x, orientation.y, orientation.z, this.up.x, this.up.y, this.up.z );\n\t\n\t\t\t}\n\t\t};\n\t\n\t} ());\n\t\n\n\n/***/ },\n/* 39 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*** IMPORTS FROM imports-loader ***/\n\tvar THREE = __webpack_require__(33);\n\t\n\t/**\n\t * @author zz85 / https://github.com/zz85\n\t * \n\t * Based on \"A Practical Analytic Model for Daylight\" \n\t * aka The Preetham Model, the de facto standard analytic skydome model\n\t * http://www.cs.utah.edu/~shirley/papers/sunsky/sunsky.pdf\n\t * \n\t * First implemented by Simon Wallner\n\t * http://www.simonwallner.at/projects/atmospheric-scattering\n\t * \n\t * Improved by Martin Upitis\n\t * http://blenderartists.org/forum/showthread.php?245954-preethams-sky-impementation-HDR\n\t * \n\t * Three.js integration by zz85 http://twitter.com/blurspline\n\t*/\n\t\n\tTHREE.ShaderLib['sky'] = {\n\t\n\t\tuniforms: {\n\t\n\t\t\tluminance:\t { type: \"f\", value:1 },\n\t\t\tturbidity:\t { type: \"f\", value:2 },\n\t\t\treileigh:\t { type: \"f\", value:1 },\n\t\t\tmieCoefficient:\t { type: \"f\", value:0.005 },\n\t\t\tmieDirectionalG: { type: \"f\", value:0.8 },\n\t\t\tsunPosition: \t { type: \"v3\", value: new THREE.Vector3() }\n\t\n\t\t},\n\t\n\t\tvertexShader: [\n\t\n\t\t\t\"varying vec3 vWorldPosition;\",\n\t\t\t\"varying vec2 vUv;\",\n\t\n\t\t\t\"void main() {\",\n\t\n\t\t\t\t\"vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\",\n\t\t\t\t\"vWorldPosition = worldPosition.xyz;\",\n\t\t\t\t\"vUv = uv;\",\n\t\n\t\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\t\n\t\t\t\"}\",\n\t\n\t\t].join(\"\\n\"),\n\t\n\t\tfragmentShader: [\n\t\n\t\n\t\t\t\"uniform sampler2D skySampler;\",\n\t\t\t\"uniform vec3 sunPosition;\",\n\t\t\t\"varying vec3 vWorldPosition;\",\n\t\t\t\"varying vec2 vUv;\",\n\t\n\t\n\t\t\t\"vec3 cameraPos = vec3(0., 0., 0.);\",\n\t\t\t\"// uniform sampler2D sDiffuse;\",\n\t\t\t\"// const float turbidity = 10.0; //\",\n\t\t\t\"// const float reileigh = 2.; //\",\n\t\t\t\"// const float luminance = 1.0; //\",\n\t\t\t\"// const float mieCoefficient = 0.005;\",\n\t\t\t\"// const float mieDirectionalG = 0.8;\",\n\t\n\t\t\t\"uniform float luminance;\",\n\t\t\t\"uniform float turbidity;\",\n\t\t\t\"uniform float reileigh;\",\n\t\t\t\"uniform float mieCoefficient;\",\n\t\t\t\"uniform float mieDirectionalG;\",\n\t\n\t\n\t\t\t\"vec3 sunDirection = normalize(sunPosition);\",\n\t\t\t\"float reileighCoefficient = reileigh;\",\n\t\n\t\t\t\"// constants for atmospheric scattering\",\n\t\t\t\"const float e = 2.71828182845904523536028747135266249775724709369995957;\",\n\t\t\t\"const float pi = 3.141592653589793238462643383279502884197169;\",\n\t\n\t\t\t\"const float n = 1.0003; // refractive index of air\",\n\t\t\t\"const float N = 2.545E25; // number of molecules per unit volume for air at\",\n\t\t\t\t\t\t\t\t\t\"// 288.15K and 1013mb (sea level -45 celsius)\",\n\t\t\t\"const float pn = 0.035;\t// depolatization factor for standard air\",\n\t\n\t\t\t\"// wavelength of used primaries, according to preetham\",\n\t\t\t\"const vec3 lambda = vec3(680E-9, 550E-9, 450E-9);\",\n\t\n\t\t\t\"// mie stuff\",\n\t\t\t\"// K coefficient for the primaries\",\n\t\t\t\"const vec3 K = vec3(0.686, 0.678, 0.666);\",\n\t\t\t\"const float v = 4.0;\",\n\t\n\t\t\t\"// optical length at zenith for molecules\",\n\t\t\t\"const float rayleighZenithLength = 8.4E3;\",\n\t\t\t\"const float mieZenithLength = 1.25E3;\",\n\t\t\t\"const vec3 up = vec3(0.0, 1.0, 0.0);\",\n\t\n\t\t\t\"const float EE = 1000.0;\",\n\t\t\t\"const float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;\",\n\t\t\t\"// 66 arc seconds -> degrees, and the cosine of that\",\n\t\n\t\t\t\"// earth shadow hack\",\n\t\t\t\"const float cutoffAngle = pi/1.95;\",\n\t\t\t\"const float steepness = 1.5;\",\n\t\n\t\n\t\t\t\"vec3 totalRayleigh(vec3 lambda)\",\n\t\t\t\"{\",\n\t\t\t\t\"return (8.0 * pow(pi, 3.0) * pow(pow(n, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * pn)) / (3.0 * N * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * pn));\",\n\t\t\t\"}\",\n\t\n\t\t\t// see http://blenderartists.org/forum/showthread.php?321110-Shaders-and-Skybox-madness\n\t\t\t\"// A simplied version of the total Reayleigh scattering to works on browsers that use ANGLE\",\n\t\t\t\"vec3 simplifiedRayleigh()\",\n\t\t\t\"{\",\n\t\t\t\t\"return 0.0005 / vec3(94, 40, 18);\",\n\t\t\t\t// return 0.00054532832366 / (3.0 * 2.545E25 * pow(vec3(680E-9, 550E-9, 450E-9), vec3(4.0)) * 6.245);\n\t\t\t\"}\",\n\t\n\t\t\t\"float rayleighPhase(float cosTheta)\",\n\t\t\t\"{\t \",\n\t\t\t\t\"return (3.0 / (16.0*pi)) * (1.0 + pow(cosTheta, 2.0));\",\n\t\t\t\"//\treturn (1.0 / (3.0*pi)) * (1.0 + pow(cosTheta, 2.0));\",\n\t\t\t\"//\treturn (3.0 / 4.0) * (1.0 + pow(cosTheta, 2.0));\",\n\t\t\t\"}\",\n\t\n\t\t\t\"vec3 totalMie(vec3 lambda, vec3 K, float T)\",\n\t\t\t\"{\",\n\t\t\t\t\"float c = (0.2 * T ) * 10E-18;\",\n\t\t\t\t\"return 0.434 * c * pi * pow((2.0 * pi) / lambda, vec3(v - 2.0)) * K;\",\n\t\t\t\"}\",\n\t\n\t\t\t\"float hgPhase(float cosTheta, float g)\",\n\t\t\t\"{\",\n\t\t\t\t\"return (1.0 / (4.0*pi)) * ((1.0 - pow(g, 2.0)) / pow(1.0 - 2.0*g*cosTheta + pow(g, 2.0), 1.5));\",\n\t\t\t\"}\",\n\t\n\t\t\t\"float sunIntensity(float zenithAngleCos)\",\n\t\t\t\"{\",\n\t\t\t\t\"return EE * max(0.0, 1.0 - exp(-((cutoffAngle - acos(zenithAngleCos))/steepness)));\",\n\t\t\t\"}\",\n\t\n\t\t\t\"// float logLuminance(vec3 c)\",\n\t\t\t\"// {\",\n\t\t\t\"// \treturn log(c.r * 0.2126 + c.g * 0.7152 + c.b * 0.0722);\",\n\t\t\t\"// }\",\n\t\n\t\t\t\"// Filmic ToneMapping http://filmicgames.com/archives/75\",\n\t\t\t\"float A = 0.15;\",\n\t\t\t\"float B = 0.50;\",\n\t\t\t\"float C = 0.10;\",\n\t\t\t\"float D = 0.20;\",\n\t\t\t\"float E = 0.02;\",\n\t\t\t\"float F = 0.30;\",\n\t\t\t\"float W = 1000.0;\",\n\t\n\t\t\t\"vec3 Uncharted2Tonemap(vec3 x)\",\n\t\t\t\"{\",\n\t\t\t   \"return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;\",\n\t\t\t\"}\",\n\t\n\t\n\t\t\t\"void main() \",\n\t\t\t\"{\",\n\t\t\t\t\"float sunfade = 1.0-clamp(1.0-exp((sunPosition.y/450000.0)),0.0,1.0);\",\n\t\n\t\t\t\t\"// luminance =  1.0 ;// vWorldPosition.y / 450000. + 0.5; //sunPosition.y / 450000. * 1. + 0.5;\",\n\t\n\t\t\t\t \"// gl_FragColor = vec4(sunfade, sunfade, sunfade, 1.0);\",\n\t\t\t\t\n\t\t\t\t\"reileighCoefficient = reileighCoefficient - (1.0* (1.0-sunfade));\",\n\t\t\t\t\n\t\t\t\t\"float sunE = sunIntensity(dot(sunDirection, up));\",\n\t\n\t\t\t\t\"// extinction (absorbtion + out scattering) \",\n\t\t\t\t\"// rayleigh coefficients\",\n\t\n\t\t\t\t// \"vec3 betaR = totalRayleigh(lambda) * reileighCoefficient;\",\n\t\t\t\t\"vec3 betaR = simplifiedRayleigh() * reileighCoefficient;\",\n\t\n\t\t\t\t\"// mie coefficients\",\n\t\t\t\t\"vec3 betaM = totalMie(lambda, K, turbidity) * mieCoefficient;\",\n\t\n\t\t\t\t\"// optical length\",\n\t\t\t\t\"// cutoff angle at 90 to avoid singularity in next formula.\",\n\t\t\t\t\"float zenithAngle = acos(max(0.0, dot(up, normalize(vWorldPosition - cameraPos))));\",\n\t\t\t\t\"float sR = rayleighZenithLength / (cos(zenithAngle) + 0.15 * pow(93.885 - ((zenithAngle * 180.0) / pi), -1.253));\",\n\t\t\t\t\"float sM = mieZenithLength / (cos(zenithAngle) + 0.15 * pow(93.885 - ((zenithAngle * 180.0) / pi), -1.253));\",\n\t\n\t\n\t\n\t\t\t\t\"// combined extinction factor\t\",\n\t\t\t\t\"vec3 Fex = exp(-(betaR * sR + betaM * sM));\",\n\t\n\t\t\t\t\"// in scattering\",\n\t\t\t\t\"float cosTheta = dot(normalize(vWorldPosition - cameraPos), sunDirection);\",\n\t\n\t\t\t\t\"float rPhase = rayleighPhase(cosTheta*0.5+0.5);\",\n\t\t\t\t\"vec3 betaRTheta = betaR * rPhase;\",\n\t\n\t\t\t\t\"float mPhase = hgPhase(cosTheta, mieDirectionalG);\",\n\t\t\t\t\"vec3 betaMTheta = betaM * mPhase;\",\n\t\n\t\n\t\t\t\t\"vec3 Lin = pow(sunE * ((betaRTheta + betaMTheta) / (betaR + betaM)) * (1.0 - Fex),vec3(1.5));\",\n\t\t\t\t\"Lin *= mix(vec3(1.0),pow(sunE * ((betaRTheta + betaMTheta) / (betaR + betaM)) * Fex,vec3(1.0/2.0)),clamp(pow(1.0-dot(up, sunDirection),5.0),0.0,1.0));\",\n\t\n\t\t\t\t\"//nightsky\",\n\t\t\t\t\"vec3 direction = normalize(vWorldPosition - cameraPos);\",\n\t\t\t\t\"float theta = acos(direction.y); // elevation --> y-axis, [-pi/2, pi/2]\",\n\t\t\t\t\"float phi = atan(direction.z, direction.x); // azimuth --> x-axis [-pi/2, pi/2]\",\n\t\t\t\t\"vec2 uv = vec2(phi, theta) / vec2(2.0*pi, pi) + vec2(0.5, 0.0);\",\n\t\t\t\t\"// vec3 L0 = texture2D(skySampler, uv).rgb+0.1 * Fex;\",\n\t\t\t\t\"vec3 L0 = vec3(0.1) * Fex;\",\n\t\t\t\t\n\t\t\t\t\"// composition + solar disc\",\n\t\t\t\t\"//if (cosTheta > sunAngularDiameterCos)\",\n\t\t\t\t\"float sundisk = smoothstep(sunAngularDiameterCos,sunAngularDiameterCos+0.00002,cosTheta);\",\n\t\t\t\t\"// if (normalize(vWorldPosition - cameraPos).y>0.0)\",\n\t\t\t\t\"L0 += (sunE * 19000.0 * Fex)*sundisk;\",\n\t\n\t\n\t\t\t\t\"vec3 whiteScale = 1.0/Uncharted2Tonemap(vec3(W));\",\n\t\t\t\t\n\t\t\t\t\"vec3 texColor = (Lin+L0);   \",\n\t\t\t\t\"texColor *= 0.04 ;\",\n\t\t\t\t\"texColor += vec3(0.0,0.001,0.0025)*0.3;\",\n\t\t\t\t\n\t\t\t\t\"float g_fMaxLuminance = 1.0;\",\n\t\t\t\t\"float fLumScaled = 0.1 / luminance;     \",\n\t\t\t\t\"float fLumCompressed = (fLumScaled * (1.0 + (fLumScaled / (g_fMaxLuminance * g_fMaxLuminance)))) / (1.0 + fLumScaled); \",\n\t\n\t\t\t\t\"float ExposureBias = fLumCompressed;\",\n\t\t\t   \n\t\t\t\t\"vec3 curr = Uncharted2Tonemap((log2(2.0/pow(luminance,4.0)))*texColor);\",\n\t\t\t\t\"vec3 color = curr*whiteScale;\",\n\t\n\t\t\t\t\"vec3 retColor = pow(color,vec3(1.0/(1.2+(1.2*sunfade))));\",\n\t\n\t\t\t\t\n\t\t\t\t\"gl_FragColor.rgb = retColor;\",\n\t\t\t\t\t\n\t\t\t\t\"gl_FragColor.a = 1.0;\",\n\t\t\t\"}\",\n\t\n\t\t].join(\"\\n\")\n\t\n\t};\n\t\n\tTHREE.Sky = function () {\n\t\n\t\tvar skyShader = THREE.ShaderLib[ \"sky\" ];\n\t\tvar skyUniforms = THREE.UniformsUtils.clone( skyShader.uniforms );\n\t\n\t\tvar skyMat = new THREE.ShaderMaterial( { \n\t\t\tfragmentShader: skyShader.fragmentShader, \n\t\t\tvertexShader: skyShader.vertexShader, \n\t\t\tuniforms: skyUniforms,\n\t\t\tside: THREE.BackSide\n\t\t} );\n\t\n\t\tvar skyGeo = new THREE.SphereGeometry( 450000, 32, 15 );\n\t\tvar skyMesh = new THREE.Mesh( skyGeo, skyMat );\n\t\n\t\n\t\t// Expose variables\n\t\tthis.mesh = skyMesh;\n\t\tthis.uniforms = skyUniforms;\n\t\n\t\n\t};\n\n\n/***/ },\n/* 40 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*** IMPORTS FROM imports-loader ***/\n\tvar THREE = __webpack_require__(33);\n\t\n\t// ShaderParticleUtils 0.7.9\n\t//\n\t// (c) 2014 Luke Moody (http://www.github.com/squarefeet)\n\t//     & Lee Stemkoski (http://www.adelphi.edu/~stemkoski/)\n\t//\n\t// Based on Lee Stemkoski's original work:\n\t//    (https://github.com/stemkoski/stemkoski.github.com/blob/master/Three.js/js/ParticleEngine.js).\n\t//\n\t// ShaderParticleGroup may be freely distributed under the MIT license (See LICENSE.txt)\n\t\n\tvar SPE = SPE || {};\n\t\n\tSPE.utils = {\n\t\n\t    /**\n\t     * Given a base vector and a spread range vector, create\n\t     * a new THREE.Vector3 instance with randomised values.\n\t     *\n\t     * @private\n\t     *\n\t     * @param  {THREE.Vector3} base\n\t     * @param  {THREE.Vector3} spread\n\t     * @return {THREE.Vector3}\n\t     */\n\t    randomVector3: function( base, spread ) {\n\t        var v = new THREE.Vector3();\n\t\n\t        v.copy( base );\n\t\n\t        v.x += Math.random() * spread.x - (spread.x/2);\n\t        v.y += Math.random() * spread.y - (spread.y/2);\n\t        v.z += Math.random() * spread.z - (spread.z/2);\n\t\n\t        return v;\n\t    },\n\t\n\t    /**\n\t     * Create a new THREE.Color instance and given a base vector and\n\t     * spread range vector, assign random values.\n\t     *\n\t     * Note that THREE.Color RGB values are in the range of 0 - 1, not 0 - 255.\n\t     *\n\t     * @private\n\t     *\n\t     * @param  {THREE.Vector3} base\n\t     * @param  {THREE.Vector3} spread\n\t     * @return {THREE.Color}\n\t     */\n\t    randomColor: function( base, spread ) {\n\t        var v = new THREE.Color();\n\t\n\t        v.copy( base );\n\t\n\t        v.r += (Math.random() * spread.x) - (spread.x/2);\n\t        v.g += (Math.random() * spread.y) - (spread.y/2);\n\t        v.b += (Math.random() * spread.z) - (spread.z/2);\n\t\n\t        v.r = Math.max( 0, Math.min( v.r, 1 ) );\n\t        v.g = Math.max( 0, Math.min( v.g, 1 ) );\n\t        v.b = Math.max( 0, Math.min( v.b, 1 ) );\n\t\n\t        return v;\n\t    },\n\t\n\t    /**\n\t     * Create a random Number value based on an initial value and\n\t     * a spread range\n\t     *\n\t     * @private\n\t     *\n\t     * @param  {Number} base\n\t     * @param  {Number} spread\n\t     * @return {Number}\n\t     */\n\t    randomFloat: function( base, spread ) {\n\t        return base + spread * (Math.random() - 0.5);\n\t    },\n\t\n\t    /**\n\t     * Create a new THREE.Vector3 instance and project it onto a random point\n\t     * on a sphere with randomized radius.\n\t     *\n\t     * @param  {THREE.Vector3} base\n\t     * @param  {Number} radius\n\t     * @param  {THREE.Vector3} radiusSpread\n\t     * @param  {THREE.Vector3} radiusScale\n\t     *\n\t     * @private\n\t     *\n\t     * @return {THREE.Vector3}\n\t     */\n\t    randomVector3OnSphere: function( base, radius, radiusSpread, radiusScale, radiusSpreadClamp ) {\n\t        var z = 2 * Math.random() - 1;\n\t        var t = 6.2832 * Math.random();\n\t        var r = Math.sqrt( 1 - z*z );\n\t        var vec = new THREE.Vector3( r * Math.cos(t), r * Math.sin(t), z );\n\t\n\t        var rand = this._randomFloat( radius, radiusSpread );\n\t\n\t        if( radiusSpreadClamp ) {\n\t            rand = Math.round( rand / radiusSpreadClamp ) * radiusSpreadClamp;\n\t        }\n\t\n\t        vec.multiplyScalar( rand );\n\t\n\t        if( radiusScale ) {\n\t            vec.multiply( radiusScale );\n\t        }\n\t\n\t        vec.add( base );\n\t\n\t        return vec;\n\t    },\n\t\n\t    /**\n\t     * Create a new THREE.Vector3 instance and project it onto a random point\n\t     * on a disk (in the XY-plane) centered at `base` and with randomized radius.\n\t     *\n\t     * @param  {THREE.Vector3} base\n\t     * @param  {Number} radius\n\t     * @param  {THREE.Vector3} radiusSpread\n\t     * @param  {THREE.Vector3} radiusScale\n\t     *\n\t     * @private\n\t     *\n\t     * @return {THREE.Vector3}\n\t     */\n\t    randomVector3OnDisk: function( base, radius, radiusSpread, radiusScale, radiusSpreadClamp ) {\n\t        var t = 6.2832 * Math.random();\n\t        var rand = this._randomFloat( radius, radiusSpread );\n\t\n\t        if( radiusSpreadClamp ) {\n\t            rand = Math.round( rand / radiusSpreadClamp ) * radiusSpreadClamp;\n\t        }\n\t\n\t        var vec = new THREE.Vector3( Math.cos(t), Math.sin(t), 0 ).multiplyScalar( rand );\n\t\n\t        if ( radiusScale ) {\n\t            vec.multiply( radiusScale );\n\t        }\n\t\n\t        vec.add( base );\n\t\n\t        return vec ;\n\t    },\n\t\n\t\n\t    /**\n\t     * Create a new THREE.Vector3 instance, and given a sphere with center `base` and\n\t     * point `position` on sphere, set direction away from sphere center with random magnitude.\n\t     *\n\t     * @param  {THREE.Vector3} base\n\t     * @param  {THREE.Vector3} position\n\t     * @param  {Number} speed\n\t     * @param  {Number} speedSpread\n\t     * @param  {THREE.Vector3} scale\n\t     *\n\t     * @private\n\t     *\n\t     * @return {THREE.Vector3}\n\t     */\n\t    randomVelocityVector3OnSphere: function( base, position, speed, speedSpread, scale ) {\n\t        var direction = new THREE.Vector3().subVectors( base, position );\n\t\n\t        direction.normalize().multiplyScalar( Math.abs( this._randomFloat( speed, speedSpread ) ) );\n\t\n\t        if( scale ) {\n\t            direction.multiply( scale );\n\t        }\n\t\n\t        return direction;\n\t    },\n\t\n\t\n\t\n\t    /**\n\t     * Given a base vector and a spread vector, randomise the given vector\n\t     * accordingly.\n\t     *\n\t     * @param  {THREE.Vector3} vector\n\t     * @param  {THREE.Vector3} base\n\t     * @param  {THREE.Vector3} spread\n\t     *\n\t     * @private\n\t     *\n\t     * @return {[type]}\n\t     */\n\t    randomizeExistingVector3: function( v, base, spread ) {\n\t        v.copy( base );\n\t\n\t        v.x += Math.random() * spread.x - (spread.x/2);\n\t        v.y += Math.random() * spread.y - (spread.y/2);\n\t        v.z += Math.random() * spread.z - (spread.z/2);\n\t    },\n\t\n\t\n\t    /**\n\t     * Randomize a THREE.Color instance and given a base vector and\n\t     * spread range vector, assign random values.\n\t     *\n\t     * Note that THREE.Color RGB values are in the range of 0 - 1, not 0 - 255.\n\t     *\n\t     * @private\n\t     *\n\t     * @param  {THREE.Vector3} base\n\t     * @param  {THREE.Vector3} spread\n\t     * @return {THREE.Color}\n\t     */\n\t    randomizeExistingColor: function( v, base, spread ) {\n\t        v.copy( base );\n\t\n\t        v.r += (Math.random() * spread.x) - (spread.x/2);\n\t        v.g += (Math.random() * spread.y) - (spread.y/2);\n\t        v.b += (Math.random() * spread.z) - (spread.z/2);\n\t\n\t        v.r = Math.max( 0, Math.min( v.r, 1 ) );\n\t        v.g = Math.max( 0, Math.min( v.g, 1 ) );\n\t        v.b = Math.max( 0, Math.min( v.b, 1 ) );\n\t    },\n\t\n\t    /**\n\t     * Given an existing particle vector, project it onto a random point on a\n\t     * sphere with radius `radius` and position `base`.\n\t     *\n\t     * @private\n\t     *\n\t     * @param  {THREE.Vector3} v\n\t     * @param  {THREE.Vector3} base\n\t     * @param  {Number} radius\n\t     */\n\t    randomizeExistingVector3OnSphere: function( v, base, radius, radiusSpread, radiusScale, radiusSpreadClamp ) {\n\t        var z = 2 * Math.random() - 1,\n\t            t = 6.2832 * Math.random(),\n\t            r = Math.sqrt( 1 - z*z ),\n\t            rand = this._randomFloat( radius, radiusSpread );\n\t\n\t        if( radiusSpreadClamp ) {\n\t            rand = Math.round( rand / radiusSpreadClamp ) * radiusSpreadClamp;\n\t        }\n\t\n\t        v.set(\n\t            (r * Math.cos(t)) * rand,\n\t            (r * Math.sin(t)) * rand,\n\t            z * rand\n\t        ).multiply( radiusScale );\n\t\n\t        v.add( base );\n\t    },\n\t\n\t\n\t    /**\n\t     * Given an existing particle vector, project it onto a random point\n\t     * on a disk (in the XY-plane) centered at `base` and with radius `radius`.\n\t     *\n\t     * @private\n\t     *\n\t     * @param  {THREE.Vector3} v\n\t     * @param  {THREE.Vector3} base\n\t     * @param  {Number} radius\n\t     */\n\t    randomizeExistingVector3OnDisk: function( v, base, radius, radiusSpread, radiusScale, radiusSpreadClamp ) {\n\t        var t = 6.2832 * Math.random(),\n\t            rand = Math.abs( this._randomFloat( radius, radiusSpread ) );\n\t\n\t        if( radiusSpreadClamp ) {\n\t            rand = Math.round( rand / radiusSpreadClamp ) * radiusSpreadClamp;\n\t        }\n\t\n\t        v.set(\n\t            Math.cos( t ),\n\t            Math.sin( t ),\n\t            0\n\t        ).multiplyScalar( rand );\n\t\n\t        if ( radiusScale ) {\n\t            v.multiply( radiusScale );\n\t        }\n\t\n\t        v.add( base );\n\t    },\n\t\n\t    randomizeExistingVelocityVector3OnSphere: function( v, base, position, speed, speedSpread ) {\n\t        v.copy(position)\n\t            .sub(base)\n\t            .normalize()\n\t            .multiplyScalar( Math.abs( this._randomFloat( speed, speedSpread ) ) );\n\t    },\n\t\n\t    generateID: function() {\n\t        var str = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx';\n\t\n\t        str = str.replace(/[xy]/g, function(c) {\n\t            var rand = Math.random();\n\t            var r = rand*16|0%16, v = c === 'x' ? r : (r&0x3|0x8);\n\t\n\t            return v.toString(16);\n\t        });\n\t\n\t        return str;\n\t    }\n\t};;\n\t\n\t// ShaderParticleGroup 0.7.9\n\t//\n\t// (c) 2014 Luke Moody (http://www.github.com/squarefeet)\n\t//     & Lee Stemkoski (http://www.adelphi.edu/~stemkoski/)\n\t//\n\t// Based on Lee Stemkoski's original work:\n\t//    (https://github.com/stemkoski/stemkoski.github.com/blob/master/Three.js/js/ParticleEngine.js).\n\t//\n\t// ShaderParticleGroup may be freely distributed under the MIT license (See LICENSE.txt)\n\t\n\tvar SPE = SPE || {};\n\t\n\tSPE.Group = function( options ) {\n\t    var that = this;\n\t\n\t    that.fixedTimeStep          = parseFloat( typeof options.fixedTimeStep === 'number' ? options.fixedTimeStep : 0.016 );\n\t\n\t    // Uniform properties ( applied to all particles )\n\t    that.maxAge                 = parseFloat( options.maxAge || 3 );\n\t    that.texture                = options.texture || null;\n\t    that.hasPerspective         = parseInt( typeof options.hasPerspective === 'number' ? options.hasPerspective : 1, 10 );\n\t    that.colorize               = parseInt( typeof options.colorize === 'number' ? options.colorize : 1, 10 );\n\t\n\t    // Material properties\n\t    that.blending               = typeof options.blending === 'number' ? options.blending : THREE.AdditiveBlending;\n\t    that.transparent            = typeof options.transparent === 'boolean' ? options.transparent : true;\n\t    that.alphaTest              = typeof options.alphaTest === 'number' ? options.alphaTest : 0.5;\n\t    that.depthWrite             = typeof options.depthWrite === 'boolean' ? options.depthWrite : false;\n\t    that.depthTest              = typeof options.depthTest === 'boolean' ? options.depthTest : true;\n\t\n\t    // Create uniforms\n\t    that.uniforms = {\n\t        duration:       { type: 'f',    value: that.maxAge },\n\t        texture:        { type: 't',    value: that.texture },\n\t        hasPerspective: { type: 'i',    value: that.hasPerspective },\n\t        colorize:       { type: 'i',    value: that.colorize }\n\t    };\n\t\n\t    // Create a map of attributes that will hold values for each particle in this group.\n\t    that.attributes = {\n\t        acceleration:           { type: 'v3',   value: [] },\n\t        velocity:               { type: 'v3',   value: [] },\n\t\n\t        alive:                  { type: 'f',    value: [] },\n\t        age:                    { type: 'f',    value: [] },\n\t\n\t        size:                   { type: 'v3',   value: [] },\n\t        angle:                  { type: 'v4',   value: [] },\n\t\n\t        colorStart:             { type: 'c',    value: [] },\n\t        colorMiddle:            { type: 'c',    value: [] },\n\t        colorEnd:               { type: 'c',    value: [] },\n\t\n\t        opacity:                { type: 'v3',   value: [] }\n\t    };\n\t\n\t    // Emitters (that aren't static) will be added to this array for\n\t    // processing during the `tick()` function.\n\t    that.emitters = [];\n\t\n\t    // Create properties for use by the emitter pooling functions.\n\t    that._pool = [];\n\t    that._poolCreationSettings = null;\n\t    that._createNewWhenPoolEmpty = 0;\n\t    that.maxAgeMilliseconds = that.maxAge * 1000;\n\t\n\t    // Create an empty geometry to hold the particles.\n\t    // Each particle is a vertex pushed into this geometry's\n\t    // vertices array.\n\t    that.geometry = new THREE.Geometry();\n\t\n\t    // Create the shader material using the properties we set above.\n\t    that.material = new THREE.ShaderMaterial({\n\t        uniforms:       that.uniforms,\n\t        attributes:     that.attributes,\n\t        vertexShader:   SPE.shaders.vertex,\n\t        fragmentShader: SPE.shaders.fragment,\n\t        blending:       that.blending,\n\t        transparent:    that.transparent,\n\t        alphaTest:      that.alphaTest,\n\t        depthWrite:     that.depthWrite,\n\t        depthTest:      that.depthTest\n\t    });\n\t\n\t    // And finally create the ParticleSystem. It's got its `dynamic` property\n\t    // set so that THREE.js knows to update it on each frame.\n\t    that.mesh = new THREE.PointCloud( that.geometry, that.material );\n\t    that.mesh.dynamic = true;\n\t};\n\t\n\tSPE.Group.prototype = {\n\t\n\t    /**\n\t     * Tells the age and alive attributes (and the geometry vertices)\n\t     * that they need updating by THREE.js's internal tick functions.\n\t     *\n\t     * @private\n\t     *\n\t     * @return {this}\n\t     */\n\t    _flagUpdate: function() {\n\t        var that = this;\n\t\n\t        // Set flags to update (causes less garbage than\n\t        // ```ParticleSystem.sortParticles = true``` in THREE.r58 at least)\n\t        that.attributes.age.needsUpdate = true;\n\t        that.attributes.alive.needsUpdate = true;\n\t        that.attributes.angle.needsUpdate = true;\n\t        // that.attributes.angleAlignVelocity.needsUpdate = true;\n\t        that.attributes.velocity.needsUpdate = true;\n\t        that.attributes.acceleration.needsUpdate = true;\n\t        that.geometry.verticesNeedUpdate = true;\n\t\n\t        return that;\n\t    },\n\t\n\t    /**\n\t     * Add an emitter to this particle group. Once added, an emitter will be automatically\n\t     * updated when SPE.Group#tick() is called.\n\t     *\n\t     * @param {SPE.Emitter} emitter\n\t     * @return {this}\n\t     */\n\t    addEmitter: function( emitter ) {\n\t        var that = this;\n\t\n\t        if( emitter.duration ) {\n\t            emitter.particlesPerSecond = emitter.particleCount / (that.maxAge < emitter.duration ? that.maxAge : emitter.duration) | 0;\n\t        }\n\t        else {\n\t            emitter.particlesPerSecond = emitter.particleCount / that.maxAge | 0\n\t        }\n\t\n\t        var vertices            = that.geometry.vertices,\n\t            start               = vertices.length,\n\t            end                 = emitter.particleCount + start,\n\t            a                   = that.attributes,\n\t            acceleration        = a.acceleration.value,\n\t            velocity            = a.velocity.value,\n\t            alive               = a.alive.value,\n\t            age                 = a.age.value,\n\t            size                = a.size.value,\n\t            angle               = a.angle.value,\n\t            colorStart          = a.colorStart.value,\n\t            colorMiddle         = a.colorMiddle.value,\n\t            colorEnd            = a.colorEnd.value,\n\t            opacity             = a.opacity.value;\n\t\n\t        emitter.particleIndex = parseFloat( start );\n\t\n\t        // Create the values\n\t        for( var i = start; i < end; ++i ) {\n\t\n\t            if( emitter.type === 'sphere' ) {\n\t                vertices[i]         = that._randomVector3OnSphere( emitter.position, emitter.radius, emitter.radiusSpread, emitter.radiusScale, emitter.radiusSpreadClamp );\n\t                velocity[i]         = that._randomVelocityVector3OnSphere( vertices[i], emitter.position, emitter.speed, emitter.speedSpread );\n\t            }\n\t            else if( emitter.type === 'disk' ) {\n\t                vertices[i]         = that._randomVector3OnDisk( emitter.position, emitter.radius, emitter.radiusSpread, emitter.radiusScale, emitter.radiusSpreadClamp );\n\t                velocity[i]         = that._randomVelocityVector3OnSphere( vertices[i], emitter.position, emitter.speed, emitter.speedSpread );\n\t            }\n\t            else {\n\t                vertices[i]         = that._randomVector3( emitter.position, emitter.positionSpread );\n\t                velocity[i]         = that._randomVector3( emitter.velocity, emitter.velocitySpread );\n\t            }\n\t\n\t            acceleration[i]         = that._randomVector3( emitter.acceleration, emitter.accelerationSpread );\n\t\n\t            size[i]                 = new THREE.Vector3(\n\t                Math.abs( that._randomFloat( emitter.sizeStart, emitter.sizeStartSpread ) ),\n\t                Math.abs( that._randomFloat( emitter.sizeMiddle, emitter.sizeMiddleSpread ) ),\n\t                Math.abs( that._randomFloat( emitter.sizeEnd, emitter.sizeEndSpread ) )\n\t            );\n\t\n\t            angle[i]                = new THREE.Vector4(\n\t                that._randomFloat( emitter.angleStart, emitter.angleStartSpread ),\n\t                that._randomFloat( emitter.angleMiddle, emitter.angleMiddleSpread ),\n\t                that._randomFloat( emitter.angleEnd, emitter.angleEndSpread ),\n\t                emitter.angleAlignVelocity ? 1.0 : 0.0\n\t            );\n\t\n\t            age[i]                  = 0.0;\n\t            alive[i]                = emitter.isStatic ? 1.0 : 0.0;\n\t\n\t            colorStart[i]           = that._randomColor( emitter.colorStart,    emitter.colorStartSpread );\n\t            colorMiddle[i]          = that._randomColor( emitter.colorMiddle,   emitter.colorMiddleSpread );\n\t            colorEnd[i]             = that._randomColor( emitter.colorEnd,      emitter.colorEndSpread );\n\t\n\t            opacity[i]              = new THREE.Vector3(\n\t                Math.abs( that._randomFloat( emitter.opacityStart, emitter.opacityStartSpread ) ),\n\t                Math.abs( that._randomFloat( emitter.opacityMiddle, emitter.opacityMiddleSpread ) ),\n\t                Math.abs( that._randomFloat( emitter.opacityEnd, emitter.opacityEndSpread ) )\n\t            );\n\t        }\n\t\n\t        // Cache properties on the emitter so we can access\n\t        // them from its tick function.\n\t        emitter.verticesIndex   = parseFloat( start );\n\t        emitter.attributes      = a;\n\t        emitter.vertices        = that.geometry.vertices;\n\t        emitter.maxAge          = that.maxAge;\n\t\n\t        // Assign a unique ID to this emitter\n\t        emitter.__id = that._generateID();\n\t\n\t        // Save this emitter in an array for processing during this.tick()\n\t        if( !emitter.isStatic ) {\n\t            that.emitters.push( emitter );\n\t        }\n\t\n\t        return that;\n\t    },\n\t\n\t\n\t    removeEmitter: function( emitter ) {\n\t        var id,\n\t            emitters = this.emitters;\n\t\n\t        if( emitter instanceof SPE.Emitter ) {\n\t            id = emitter.__id;\n\t        }\n\t        else if( typeof emitter === 'string' ) {\n\t            id = emitter;\n\t        }\n\t        else {\n\t            console.warn('Invalid emitter or emitter ID passed to SPE.Group#removeEmitter.' );\n\t            return;\n\t        }\n\t\n\t        for( var i = 0, il = emitters.length; i < il; ++i ) {\n\t            if( emitters[i].__id === id ) {\n\t                emitters.splice(i, 1);\n\t                break;\n\t            }\n\t        }\n\t    },\n\t\n\t\n\t    /**\n\t     * The main particle group update function. Call this once per frame.\n\t     *\n\t     * @param  {Number} dt\n\t     * @return {this}\n\t     */\n\t    tick: function( dt ) {\n\t        var that = this,\n\t            emitters = that.emitters,\n\t            numEmitters = emitters.length;\n\t\n\t        dt = dt || that.fixedTimeStep;\n\t\n\t        if( numEmitters === 0 ) {\n\t            return;\n\t        }\n\t\n\t        for( var i = 0; i < numEmitters; ++i ) {\n\t            emitters[i].tick( dt );\n\t        }\n\t\n\t        that._flagUpdate();\n\t        return that;\n\t    },\n\t\n\t\n\t    /**\n\t     * Fetch a single emitter instance from the pool.\n\t     * If there are no objects in the pool, a new emitter will be\n\t     * created if specified.\n\t     *\n\t     * @return {ShaderParticleEmitter | null}\n\t     */\n\t    getFromPool: function() {\n\t        var that = this,\n\t            pool = that._pool,\n\t            createNew = that._createNewWhenPoolEmpty;\n\t\n\t        if( pool.length ) {\n\t            return pool.pop();\n\t        }\n\t        else if( createNew ) {\n\t            return new SPE.Emitter( that._poolCreationSettings );\n\t        }\n\t\n\t        return null;\n\t    },\n\t\n\t\n\t    /**\n\t     * Release an emitter into the pool.\n\t     *\n\t     * @param  {ShaderParticleEmitter} emitter\n\t     * @return {this}\n\t     */\n\t    releaseIntoPool: function( emitter ) {\n\t        if( !(emitter instanceof SPE.Emitter) ) {\n\t            console.error( 'Will not add non-emitter to particle group pool:', emitter );\n\t            return;\n\t        }\n\t\n\t        emitter.reset();\n\t        this._pool.unshift( emitter );\n\t\n\t        return this;\n\t    },\n\t\n\t\n\t    /**\n\t     * Get the pool array\n\t     *\n\t     * @return {Array}\n\t     */\n\t    getPool: function() {\n\t        return this._pool;\n\t    },\n\t\n\t\n\t    /**\n\t     * Add a pool of emitters to this particle group\n\t     *\n\t     * @param {Number} numEmitters      The number of emitters to add to the pool.\n\t     * @param {Object} emitterSettings  An object describing the settings to pass to each emitter.\n\t     * @param {Boolean} createNew       Should a new emitter be created if the pool runs out?\n\t     * @return {this}\n\t     */\n\t    addPool: function( numEmitters, emitterSettings, createNew ) {\n\t        var that = this,\n\t            emitter;\n\t\n\t        // Save relevant settings and flags.\n\t        that._poolCreationSettings = emitterSettings;\n\t        that._createNewWhenPoolEmpty = !!createNew;\n\t\n\t        // Create the emitters, add them to this group and the pool.\n\t        for( var i = 0; i < numEmitters; ++i ) {\n\t            emitter = new SPE.Emitter( emitterSettings );\n\t            that.addEmitter( emitter );\n\t            that.releaseIntoPool( emitter );\n\t        }\n\t\n\t        return that;\n\t    },\n\t\n\t\n\t    /**\n\t     * Internal method. Sets a single emitter to be alive\n\t     *\n\t     * @private\n\t     *\n\t     * @param  {THREE.Vector3} pos\n\t     * @return {this}\n\t     */\n\t    _triggerSingleEmitter: function( pos ) {\n\t        var that = this,\n\t            emitter = that.getFromPool();\n\t\n\t        if( emitter === null ) {\n\t            console.log('SPE.Group pool ran out.');\n\t            return;\n\t        }\n\t\n\t        // TODO: Should an instanceof check happen here? Or maybe at least a typeof?\n\t        if( pos ) {\n\t            emitter.position.copy( pos );\n\t        }\n\t\n\t        emitter.enable();\n\t\n\t        setTimeout( function() {\n\t            emitter.disable();\n\t            that.releaseIntoPool( emitter );\n\t        }, that.maxAgeMilliseconds );\n\t\n\t        return that;\n\t    },\n\t\n\t\n\t    /**\n\t     * Set a given number of emitters as alive, with an optional position\n\t     * vector3 to move them to.\n\t     *\n\t     * @param  {Number} numEmitters\n\t     * @param  {THREE.Vector3} position\n\t     * @return {this}\n\t     */\n\t    triggerPoolEmitter: function( numEmitters, position ) {\n\t        var that = this;\n\t\n\t        if( typeof numEmitters === 'number' && numEmitters > 1) {\n\t            for( var i = 0; i < numEmitters; ++i ) {\n\t                that._triggerSingleEmitter( position );\n\t            }\n\t        }\n\t        else {\n\t            that._triggerSingleEmitter( position );\n\t        }\n\t\n\t        return that;\n\t    }\n\t};\n\t\n\t\n\t// Extend ShaderParticleGroup's prototype with functions from utils object.\n\tfor( var i in SPE.utils ) {\n\t    SPE.Group.prototype[ '_' + i ] = SPE.utils[i];\n\t}\n\t\n\t\n\t// The all-important shaders\n\tSPE.shaders = {\n\t    vertex: [\n\t        'uniform float duration;',\n\t        'uniform int hasPerspective;',\n\t\n\t        'attribute vec3 colorStart;',\n\t        'attribute vec3 colorMiddle;',\n\t        'attribute vec3 colorEnd;',\n\t        'attribute vec3 opacity;',\n\t\n\t        'attribute vec3 acceleration;',\n\t        'attribute vec3 velocity;',\n\t        'attribute float alive;',\n\t        'attribute float age;',\n\t\n\t        'attribute vec3 size;',\n\t        'attribute vec4 angle;',\n\t\n\t        // values to be passed to the fragment shader\n\t        'varying vec4 vColor;',\n\t        'varying float vAngle;',\n\t\n\t\n\t        // Integrate acceleration into velocity and apply it to the particle's position\n\t        'vec4 GetPos() {',\n\t            'vec3 newPos = vec3( position );',\n\t\n\t            // Move acceleration & velocity vectors to the value they\n\t            // should be at the current age\n\t            'vec3 a = acceleration * age;',\n\t            'vec3 v = velocity * age;',\n\t\n\t            // Move velocity vector to correct values at this age\n\t            'v = v + (a * age);',\n\t\n\t            // Add velocity vector to the newPos vector\n\t            'newPos = newPos + v;',\n\t\n\t            // Convert the newPos vector into world-space\n\t            'vec4 mvPosition = modelViewMatrix * vec4( newPos, 1.0 );',\n\t\n\t            'return mvPosition;',\n\t        '}',\n\t\n\t\n\t        'void main() {',\n\t\n\t            'float positionInTime = (age / duration);',\n\t\n\t            'float lerpAmount1 = (age / (0.5 * duration));', // percentage during first half\n\t            'float lerpAmount2 = ((age - 0.5 * duration) / (0.5 * duration));', // percentage during second half\n\t            'float halfDuration = duration / 2.0;',\n\t            'float pointSize = 0.0;',\n\t\n\t            'vAngle = 0.0;',\n\t\n\t            'if( alive > 0.5 ) {',\n\t\n\t                // lerp the color and opacity\n\t                'if( positionInTime < 0.5 ) {',\n\t                    'vColor = vec4( mix(colorStart, colorMiddle, lerpAmount1), mix(opacity.x, opacity.y, lerpAmount1) );',\n\t                '}',\n\t                'else {',\n\t                    'vColor = vec4( mix(colorMiddle, colorEnd, lerpAmount2), mix(opacity.y, opacity.z, lerpAmount2) );',\n\t                '}',\n\t\n\t\n\t                // Get the position of this particle so we can use it\n\t                // when we calculate any perspective that might be required.\n\t                'vec4 pos = GetPos();',\n\t\n\t\n\t                // Determine the angle we should use for this particle.\n\t                'if( angle[3] == 1.0 ) {',\n\t                    'vAngle = -atan(pos.y, pos.x);',\n\t                '}',\n\t                'else if( positionInTime < 0.5 ) {',\n\t                    'vAngle = mix( angle.x, angle.y, lerpAmount1 );',\n\t                '}',\n\t                'else {',\n\t                    'vAngle = mix( angle.y, angle.z, lerpAmount2 );',\n\t                '}',\n\t\n\t                // Determine point size.\n\t                'if( positionInTime < 0.5) {',\n\t                    'pointSize = mix( size.x, size.y, lerpAmount1 );',\n\t                '}',\n\t                'else {',\n\t                    'pointSize = mix( size.y, size.z, lerpAmount2 );',\n\t                '}',\n\t\n\t\n\t                'if( hasPerspective == 1 ) {',\n\t                    'pointSize = pointSize * ( 300.0 / length( pos.xyz ) );',\n\t                '}',\n\t\n\t                // Set particle size and position\n\t                'gl_PointSize = pointSize;',\n\t                'gl_Position = projectionMatrix * pos;',\n\t            '}',\n\t\n\t            'else {',\n\t                // Hide particle and set its position to the (maybe) glsl\n\t                // equivalent of Number.POSITIVE_INFINITY\n\t                'vColor = vec4( 0.0, 0.0, 0.0, 0.0 );',\n\t                'gl_Position = vec4(1000000000.0, 1000000000.0, 1000000000.0, 0.0);',\n\t            '}',\n\t        '}',\n\t    ].join('\\n'),\n\t\n\t    fragment: [\n\t        'uniform sampler2D texture;',\n\t        'uniform int colorize;',\n\t\n\t        'varying vec4 vColor;',\n\t        'varying float vAngle;',\n\t\n\t        'void main() {',\n\t            'float c = cos(vAngle);',\n\t            'float s = sin(vAngle);',\n\t\n\t            'vec2 rotatedUV = vec2(c * (gl_PointCoord.x - 0.5) + s * (gl_PointCoord.y - 0.5) + 0.5,',\n\t                                  'c * (gl_PointCoord.y - 0.5) - s * (gl_PointCoord.x - 0.5) + 0.5);',\n\t\n\t            'vec4 rotatedTexture = texture2D( texture, rotatedUV );',\n\t\n\t            'if( colorize == 1 ) {',\n\t                'gl_FragColor = vColor * rotatedTexture;',\n\t            '}',\n\t            'else {',\n\t                'gl_FragColor = rotatedTexture;',\n\t            '}',\n\t        '}'\n\t    ].join('\\n')\n\t};\n\t;\n\t\n\t// ShaderParticleEmitter 0.7.9\n\t//\n\t// (c) 2014 Luke Moody (http://www.github.com/squarefeet)\n\t//     & Lee Stemkoski (http://www.adelphi.edu/~stemkoski/)\n\t//\n\t// Based on Lee Stemkoski's original work:\n\t//    (https://github.com/stemkoski/stemkoski.github.com/blob/master/Three.js/js/ParticleEngine.js).\n\t//\n\t// ShaderParticleEmitter may be freely distributed under the MIT license (See LICENSE.txt)\n\t\n\tvar SPE = SPE || {};\n\t\n\tSPE.Emitter = function( options ) {\n\t    // If no options are provided, fallback to an empty object.\n\t    options = options || {};\n\t\n\t    // Helps with minification. Not as easy to read the following code,\n\t    // but should still be readable enough!\n\t    var that = this;\n\t\n\t\n\t    that.particleCount          = typeof options.particleCount === 'number' ? options.particleCount : 100;\n\t    that.type                   = (options.type === 'cube' || options.type === 'sphere' || options.type === 'disk') ? options.type : 'cube';\n\t\n\t    that.position               = options.position instanceof THREE.Vector3 ? options.position : new THREE.Vector3();\n\t    that.positionSpread         = options.positionSpread instanceof THREE.Vector3 ? options.positionSpread : new THREE.Vector3();\n\t\n\t    // These two properties are only used when this.type === 'sphere' or 'disk'\n\t    that.radius                 = typeof options.radius === 'number' ? options.radius : 10;\n\t    that.radiusSpread           = typeof options.radiusSpread === 'number' ? options.radiusSpread : 0;\n\t    that.radiusScale            = options.radiusScale instanceof THREE.Vector3 ? options.radiusScale : new THREE.Vector3(1, 1, 1);\n\t    that.radiusSpreadClamp      = typeof options.radiusSpreadClamp === 'number' ? options.radiusSpreadClamp : 0;\n\t\n\t    that.acceleration           = options.acceleration instanceof THREE.Vector3 ? options.acceleration : new THREE.Vector3();\n\t    that.accelerationSpread     = options.accelerationSpread instanceof THREE.Vector3 ? options.accelerationSpread : new THREE.Vector3();\n\t\n\t    that.velocity               = options.velocity instanceof THREE.Vector3 ? options.velocity : new THREE.Vector3();\n\t    that.velocitySpread         = options.velocitySpread instanceof THREE.Vector3 ? options.velocitySpread : new THREE.Vector3();\n\t\n\t\n\t    // And again here; only used when this.type === 'sphere' or 'disk'\n\t    that.speed                  = parseFloat( typeof options.speed === 'number' ? options.speed : 0.0 );\n\t    that.speedSpread            = parseFloat( typeof options.speedSpread === 'number' ? options.speedSpread : 0.0 );\n\t\n\t\n\t    // Sizes\n\t    that.sizeStart              = parseFloat( typeof options.sizeStart === 'number' ? options.sizeStart : 1.0 );\n\t    that.sizeStartSpread        = parseFloat( typeof options.sizeStartSpread === 'number' ? options.sizeStartSpread : 0.0 );\n\t\n\t    that.sizeEnd                = parseFloat( typeof options.sizeEnd === 'number' ? options.sizeEnd : that.sizeStart );\n\t    that.sizeEndSpread          = parseFloat( typeof options.sizeEndSpread === 'number' ? options.sizeEndSpread : 0.0 );\n\t\n\t    that.sizeMiddle             = parseFloat(\n\t        typeof options.sizeMiddle !== 'undefined' ?\n\t        options.sizeMiddle :\n\t        Math.abs(that.sizeEnd + that.sizeStart) / 2\n\t    );\n\t    that.sizeMiddleSpread       = parseFloat( typeof options.sizeMiddleSpread === 'number' ? options.sizeMiddleSpread : 0 );\n\t\n\t\n\t    // Angles\n\t    that.angleStart             = parseFloat( typeof options.angleStart === 'number' ? options.angleStart : 0 );\n\t    that.angleStartSpread       = parseFloat( typeof options.angleStartSpread === 'number' ? options.angleStartSpread : 0 );\n\t\n\t    that.angleEnd               = parseFloat( typeof options.angleEnd === 'number' ? options.angleEnd : 0 );\n\t    that.angleEndSpread         = parseFloat( typeof options.angleEndSpread === 'number' ? options.angleEndSpread : 0 );\n\t\n\t    that.angleMiddle            = parseFloat(\n\t        typeof options.angleMiddle !== 'undefined' ?\n\t        options.angleMiddle :\n\t        Math.abs(that.angleEnd + that.angleStart) / 2\n\t    );\n\t    that.angleMiddleSpread      = parseFloat( typeof options.angleMiddleSpread === 'number' ? options.angleMiddleSpread : 0 );\n\t\n\t    that.angleAlignVelocity     = options.angleAlignVelocity || false;\n\t\n\t\n\t    // Colors\n\t    that.colorStart             = options.colorStart instanceof THREE.Color ? options.colorStart : new THREE.Color( 'white' );\n\t    that.colorStartSpread       = options.colorStartSpread instanceof THREE.Vector3 ? options.colorStartSpread : new THREE.Vector3();\n\t\n\t    that.colorEnd               = options.colorEnd instanceof THREE.Color ? options.colorEnd : that.colorStart.clone();\n\t    that.colorEndSpread         = options.colorEndSpread instanceof THREE.Vector3 ? options.colorEndSpread : new THREE.Vector3();\n\t\n\t    that.colorMiddle            =\n\t        options.colorMiddle instanceof THREE.Color ?\n\t        options.colorMiddle :\n\t        new THREE.Color().addColors( that.colorStart, that.colorEnd ).multiplyScalar( 0.5 );\n\t    that.colorMiddleSpread      = options.colorMiddleSpread instanceof THREE.Vector3 ? options.colorMiddleSpread : new THREE.Vector3();\n\t\n\t\n\t\n\t    // Opacities\n\t    that.opacityStart           = parseFloat( typeof options.opacityStart !== 'undefined' ? options.opacityStart : 1 );\n\t    that.opacityStartSpread     = parseFloat( typeof options.opacityStartSpread !== 'undefined' ? options.opacityStartSpread : 0 );\n\t\n\t    that.opacityEnd             = parseFloat( typeof options.opacityEnd === 'number' ? options.opacityEnd : 0 );\n\t    that.opacityEndSpread       = parseFloat( typeof options.opacityEndSpread !== 'undefined' ? options.opacityEndSpread : 0 );\n\t\n\t    that.opacityMiddle          = parseFloat(\n\t        typeof options.opacityMiddle !== 'undefined' ?\n\t        options.opacityMiddle :\n\t        Math.abs(that.opacityEnd + that.opacityStart) / 2\n\t    );\n\t    that.opacityMiddleSpread      = parseFloat( typeof options.opacityMiddleSpread === 'number' ? options.opacityMiddleSpread : 0 );\n\t\n\t\n\t    // Generic\n\t    that.duration               = typeof options.duration === 'number' ? options.duration : null;\n\t    that.alive                  = parseFloat( typeof options.alive === 'number' ? options.alive : 1.0 );\n\t    that.isStatic               = typeof options.isStatic === 'number' ? options.isStatic : 0;\n\t\n\t    // Particle spawn callback function.\n\t    that.onParticleSpawn = typeof options.onParticleSpawn === 'function' ? options.onParticleSpawn : null;\n\t\n\t\n\t    // The following properties are used internally, and mostly set when this emitter\n\t    // is added to a particle group.\n\t    that.particlesPerSecond     = 0;\n\t    that.attributes             = null;\n\t    that.vertices               = null;\n\t    that.verticesIndex          = 0;\n\t    that.age                    = 0.0;\n\t    that.maxAge                 = 0.0;\n\t\n\t    that.particleIndex = 0.0;\n\t\n\t    that.__id = null;\n\t\n\t    that.userData = {};\n\t};\n\t\n\tSPE.Emitter.prototype = {\n\t\n\t    /**\n\t     * Reset a particle's position. Accounts for emitter type and spreads.\n\t     *\n\t     * @private\n\t     *\n\t     * @param  {THREE.Vector3} p\n\t     */\n\t    _resetParticle: function( i ) {\n\t        var that = this,\n\t            type = that.type,\n\t            spread = that.positionSpread,\n\t            particlePosition = that.vertices[i],\n\t            a = that.attributes,\n\t            particleVelocity = a.velocity.value[i],\n\t\n\t            vSpread = that.velocitySpread,\n\t            aSpread = that.accelerationSpread;\n\t\n\t        // Optimise for no position spread or radius\n\t        if(\n\t            ( type === 'cube' && spread.x === 0 && spread.y === 0 && spread.z === 0 ) ||\n\t            ( type === 'sphere' && that.radius === 0 ) ||\n\t            ( type === 'disk' && that.radius === 0 )\n\t        ) {\n\t            particlePosition.copy( that.position );\n\t            that._randomizeExistingVector3( particleVelocity, that.velocity, vSpread );\n\t\n\t            if( type === 'cube' ) {\n\t                that._randomizeExistingVector3( that.attributes.acceleration.value[i], that.acceleration, aSpread );\n\t            }\n\t        }\n\t\n\t        // If there is a position spread, then get a new position based on this spread.\n\t        else if( type === 'cube' ) {\n\t            that._randomizeExistingVector3( particlePosition, that.position, spread );\n\t            that._randomizeExistingVector3( particleVelocity, that.velocity, vSpread );\n\t            that._randomizeExistingVector3( that.attributes.acceleration.value[i], that.acceleration, aSpread );\n\t        }\n\t\n\t        else if( type === 'sphere') {\n\t            that._randomizeExistingVector3OnSphere( particlePosition, that.position, that.radius, that.radiusSpread, that.radiusScale, that.radiusSpreadClamp );\n\t            that._randomizeExistingVelocityVector3OnSphere( particleVelocity, that.position, particlePosition, that.speed, that.speedSpread );\n\t        }\n\t\n\t        else if( type === 'disk') {\n\t            that._randomizeExistingVector3OnDisk( particlePosition, that.position, that.radius, that.radiusSpread, that.radiusScale, that.radiusSpreadClamp );\n\t            that._randomizeExistingVelocityVector3OnSphere( particleVelocity, that.position, particlePosition, that.speed, that.speedSpread );\n\t        }\n\t\n\t        if( typeof that.onParticleSpawn === 'function' ) {\n\t            that.onParticleSpawn( a, i );\n\t        }\n\t    },\n\t\n\t    /**\n\t     * Update this emitter's particle's positions. Called by the SPE.Group\n\t     * that this emitter belongs to.\n\t     *\n\t     * @param  {Number} dt\n\t     */\n\t    tick: function( dt ) {\n\t\n\t        if( this.isStatic ) {\n\t            return;\n\t        }\n\t\n\t        // Cache some values for quicker access in loops.\n\t        var that = this,\n\t            a = that.attributes,\n\t            alive = a.alive.value,\n\t            age = a.age.value,\n\t            start = that.verticesIndex,\n\t            particleCount = that.particleCount,\n\t            end = start + particleCount,\n\t            pps = that.particlesPerSecond * that.alive,\n\t            ppsdt = pps * dt,\n\t            m = that.maxAge,\n\t            emitterAge = that.age,\n\t            duration = that.duration,\n\t            pIndex = that.particleIndex;\n\t\n\t        // Loop through all the particles in this emitter and\n\t        // determine whether they're still alive and need advancing\n\t        // or if they should be dead and therefore marked as such.\n\t        for( var i = start; i < end; ++i ) {\n\t            if( alive[ i ] === 1.0 ) {\n\t                age[ i ] += dt;\n\t            }\n\t\n\t            if( age[ i ] >= m ) {\n\t                age[ i ] = 0.0;\n\t                alive[ i ] = 0.0;\n\t            }\n\t        }\n\t\n\t        // If the emitter is dead, reset any particles that are in\n\t        // the recycled vertices array and reset the age of the\n\t        // emitter to zero ready to go again if required, then\n\t        // exit this function.\n\t        if( that.alive === 0.0 ) {\n\t            that.age = 0.0;\n\t            return;\n\t        }\n\t\n\t        // If the emitter has a specified lifetime and we've exceeded it,\n\t        // mark the emitter as dead and exit this function.\n\t        if( typeof duration === 'number' && emitterAge > duration ) {\n\t            that.alive = 0.0;\n\t            that.age = 0.0;\n\t            return;\n\t        }\n\t\n\t\n\t\n\t        var n = Math.max( Math.min( end, pIndex + ppsdt ), 0),\n\t            count = 0,\n\t            index = 0,\n\t            pIndexFloor = pIndex | 0,\n\t            dtInc;\n\t\n\t        for( i = pIndexFloor; i < n; ++i ) {\n\t            if( alive[ i ] !== 1.0 ) {\n\t                ++count;\n\t            }\n\t        }\n\t\n\t        if( count !== 0 ) {\n\t            dtInc = dt / count;\n\t\n\t            for( i = pIndexFloor; i < n; ++i, ++index ) {\n\t                if( alive[ i ] !== 1.0 ) {\n\t                    alive[ i ] = 1.0;\n\t                    age[ i ] = dtInc * index;\n\t                    that._resetParticle( i );\n\t                }\n\t            }\n\t        }\n\t\n\t        that.particleIndex += ppsdt;\n\t\n\t        if( that.particleIndex < 0.0 ) {\n\t            that.particleIndex = 0.0;\n\t        }\n\t\n\t        if( pIndex >= start + particleCount ) {\n\t            that.particleIndex = parseFloat( start );\n\t        }\n\t\n\t        // Add the delta time value to the age of the emitter.\n\t        that.age += dt;\n\t\n\t        if( that.age < 0.0 ) {\n\t            that.age = 0.0;\n\t        }\n\t    },\n\t\n\t    /**\n\t     * Reset this emitter back to its starting position.\n\t     * If `force` is truthy, then reset all particles in this\n\t     * emitter as well, even if they're currently alive.\n\t     *\n\t     * @param  {Boolean} force\n\t     * @return {this}\n\t     */\n\t    reset: function( force ) {\n\t        var that = this;\n\t\n\t        that.age = 0.0;\n\t        that.alive = 0;\n\t\n\t        if( force ) {\n\t            var start = that.verticesIndex,\n\t                end = that.verticesIndex + that.particleCount,\n\t                a = that.attributes,\n\t                alive = a.alive.value,\n\t                age = a.age.value;\n\t\n\t            for( var i = start; i < end; ++i ) {\n\t                alive[ i ] = 0.0;\n\t                age[ i ] = 0.0;\n\t            }\n\t        }\n\t\n\t        return that;\n\t    },\n\t\n\t\n\t    /**\n\t     * Enable this emitter.\n\t     */\n\t    enable: function() {\n\t        this.alive = 1;\n\t    },\n\t\n\t    /**\n\t     * Disable this emitter.\n\t     */\n\t    disable: function() {\n\t        this.alive = 0;\n\t    }\n\t};\n\t\n\t// Extend SPE.Emitter's prototype with functions from utils object.\n\tfor( var i in SPE.utils ) {\n\t    SPE.Emitter.prototype[ '_' + i ] = SPE.utils[i];\n\t}\n\t\n\t\n\t/*** EXPORTS FROM exports-loader ***/\n\tmodule.exports = SPE\n\n/***/ },\n/* 41 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar assign        = __webpack_require__(67)\n\t  , normalizeOpts = __webpack_require__(65)\n\t  , isCallable    = __webpack_require__(66)\n\t  , contains      = __webpack_require__(68)\n\t\n\t  , d;\n\t\n\td = module.exports = function (dscr, value/*, options*/) {\n\t\tvar c, e, w, options, desc;\n\t\tif ((arguments.length < 2) || (typeof dscr !== 'string')) {\n\t\t\toptions = value;\n\t\t\tvalue = dscr;\n\t\t\tdscr = null;\n\t\t} else {\n\t\t\toptions = arguments[2];\n\t\t}\n\t\tif (dscr == null) {\n\t\t\tc = w = true;\n\t\t\te = false;\n\t\t} else {\n\t\t\tc = contains.call(dscr, 'c');\n\t\t\te = contains.call(dscr, 'e');\n\t\t\tw = contains.call(dscr, 'w');\n\t\t}\n\t\n\t\tdesc = { value: value, configurable: c, enumerable: e, writable: w };\n\t\treturn !options ? desc : assign(normalizeOpts(options), desc);\n\t};\n\t\n\td.gs = function (dscr, get, set/*, options*/) {\n\t\tvar c, e, options, desc;\n\t\tif (typeof dscr !== 'string') {\n\t\t\toptions = set;\n\t\t\tset = get;\n\t\t\tget = dscr;\n\t\t\tdscr = null;\n\t\t} else {\n\t\t\toptions = arguments[3];\n\t\t}\n\t\tif (get == null) {\n\t\t\tget = undefined;\n\t\t} else if (!isCallable(get)) {\n\t\t\toptions = get;\n\t\t\tget = set = undefined;\n\t\t} else if (set == null) {\n\t\t\tset = undefined;\n\t\t} else if (!isCallable(set)) {\n\t\t\toptions = set;\n\t\t\tset = undefined;\n\t\t}\n\t\tif (dscr == null) {\n\t\t\tc = true;\n\t\t\te = false;\n\t\t} else {\n\t\t\tc = contains.call(dscr, 'c');\n\t\t\te = contains.call(dscr, 'e');\n\t\t}\n\t\n\t\tdesc = { get: get, set: set, configurable: c, enumerable: e };\n\t\treturn !options ? desc : assign(normalizeOpts(options), desc);\n\t};\n\n\n/***/ },\n/* 42 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__.p + \"image/asphalt.jpg\"\n\n/***/ },\n/* 43 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__.p + \"image/brick-tiles.jpg\"\n\n/***/ },\n/* 44 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__.p + \"image/bricks-normal.jpg\"\n\n/***/ },\n/* 45 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__.p + \"image/bricks-specular.jpg\"\n\n/***/ },\n/* 46 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__.p + \"image/bricks.jpg\"\n\n/***/ },\n/* 47 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEAAQMAAABmvDolAAAABlBMVEUsLCzp6enLhVdXAAAAAWJLR0QAiAUdSAAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB94KFBIOCP7R3TQAAAA4SURBVGje7dAhEgAACMOw/f/T4Gc5XKqjmlRTBQAAAAAAAAAAAAAA4AiMAQAAAAAAAAAAAADgGSyKafDiEFszywAAAABJRU5ErkJggg==\"\n\n/***/ },\n/* 48 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAYAAABccqhmAAAAAXNSR0IArs4c6QAAAAZiS0dEAJYApQCsp9YZhwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9sDGQUxMtbdsFAAACAASURBVHja7L1JkyRpciX29DMz94jIzFp6AboBELOQGG7C4YkyIiQvPPAXz4HCAw88kTxwZITCGZIYzEbBNIABGrVmRri72fd4+FTNnql/nlnVtWUVw1uiKyPCw93czHR7+vQp8Px4fjw/nh/Pj+fH8+P58fx4fjw/nh/Pj+fH8+P58fx4fjw/nh/Pj+fH8+P58fx4fjw/nh/Pj+fH8+P58fz41h4kTf/7df82vp7P5PPj+fEjN3R9zlcxapJD73nPDuH58fx4T50AyZHkQY33dzXY3t8/G//z46s+nm+U78nozYwkC4DRvwCgAFgAzABoZnM893dwAgOAamb1qziMr/sez49nB/D8+GZOYHQjPfp/D+IALgAqgCf/fvkdnMCQf6T/fjb450fvMT6fgu+t9jc3+hHAKwD3/v0ZwMm/Bs8GLiRndwYmxtw1ZHl9/dLnLSTrsxN4fjw7gB8u/YcbNAB85gZf3FDPngEs/n2k9Dmak2RNBh7/rv568H8/P54fzw7gB6+xtto/InMBMMlX4AJnj/6L4ANDMugqv1cj19fPpV04CKas4Pnx/Hh2AN/To4jxD/LfgziEs39d/L9M0b36vyNrWOR7JMNXZ7BmB2zpCN9RpvQwhG8MGn4dcPN3AUKfH88O4L1I9Ts/D+MfJbUf3OgDGAxDLvL7AcALf5mTO4Y3Ui6ooRZxGOg4BL6rLJBMBfJaJqVHPGf9nFLeWP7du87N24z82fifHcCPMtW/9SsxbO0EjBK9J39eRPkRwK8B/Equ0RsAnwL41wC+EIcRJUEPNNw5CDObb+ATljKJITmB4BoAwDn+Ln/mtwCUJYOQb8tEnh3AswP4SWQEbjgR6UdP+Y9oHQCt/+NahAM4APgPAPzSs4Co/Z8A/AzAvwPw4L8z//knAP4CwGt/vknUHwDMckxhYMXbk6NE+7P/+wWAl9g6Fwd/n98AeBTHA3Ei6ki0HJkBmBt3fZuxPxv/swP4qZQAJaX6d274D/79hH3LLgznAcAH8nWUaPzKf/Yr//sH/291o/wXAP4PAF+KkdNLiMmNNgzw4Ab+awAf+fefA/iX/tz/0t9Hs5gzgP8HwJ+SfHTDHsTJPPjXvX/GxV9zLV08i2Czdau5pFCH8uwMnh3Aj7IE8FpaAb+DO4Do/xf5UoP8AMAv/Hl34ixGKSGe/HnFnxPR++x/RwD/zI2ekg2sjEN/rV8D+M8AfOzvPUmGcQfgP/TXO0hm8OiZwc/d2fytO6gJwO8B+I8BfOjPiWP9FMCfA/i37gwu/jqXwEe8tYmvUiI8P54dwPueCfTAvKNkAAf/mYkDKAD+wI3yhUTVOzH8ewETqz/vgK0jEM+PiP2XbvBfuCFe/HkvPLL/PQB/5MZ7FGfxS8ku1AktAkT+GsAfA/itOLejO4ZwKIt//V0A/8CP57Ufy7/wTOMsx0U0wtIVyPh8V32Hgev5FHzrdf8gRjt5mv1SIuNRHEAY7+DR8+cSceHPDYehjmOWdLtKZD85FvCJv/8JwJ8B+OcA/sqf+5/618Ej/NGPa5ZsIwBK898f/W/Pfryv/esNrrkH4ZgexOFF1H/yLOCv/OszdwR/5a+30qCfjf85A/gxGb3W/Ur0uXcj+9jT9hcAft+fE8Bd1OcX/zoIbnBMeEFJ+MILMciLO4E7AH/iDufi0fpDAP+Lv9fv+TG9FOMPItIH/veRmVTsh5fu3eirOJCo6Wf5/C/dmb0SMNL8OD/xn/+xf4Y/dyfwvzvAWCGU5x/aEfzUHdGzA/iaN0ACqtQggX1v/+j19C+9rv/QjSJS7DcOqA2eioeTeBCjuhPMIIaFzpJeTwK4PbmBv/L3MCkZfgHgv/a/+blkIvcSlenff+h/E0YNcQKRJTz4MQUIGBFeS50P/fuSsonIZL7w5/2elz9HAP8DgM+dc1DfByzgp56FPDuAr38DGIAhgKt0gxeJ3D/D1sr7uRvNxxJ57/138Dr5haTPT+4gRmxtwMf0XvCIGsc0SYlw8b+NNP2lOxflJBzFaUySBbzxY5+kvChSstxh60oogHknWMULATKjPAkn9uDHE9jHR/683/oxfulj0eVdo83Pj2cH8H2n+YMYmdbxRVL1D93QP/ab+0GiYtTTYXB/gq29dxBDG1LqPQgQZ5Kah4He+3MWSbVHNAR+FKwg3jvAxb/G1nYcBQg8+/HciwOI7oH+exYnaFIWHKR8gbxGvMcr/9mTP+8BwH8E4L8A8Jk71+U5/X92AD+00VuKmvGlPfb42YMY/UuPgvcChIXxFTH2BykZ9L0WN9KDGL8yBSlROHCDMPRHj+KzP/9ODPXej+1OALyj/P291Ovx84O8T2QgF8E6ohSJ9P8V+sNJi3y+F2785n9jjo38d2jdgv9TPuu34rzfxTx8GynplsLST8E5PDuAt2T/2A/uKN9e0/BJavcPJLofBAw0iZST/Fd7/BfsZwNmSevDQTzJ30OyD20pRr9/wZ5l+EI+i3YfdEYB4nQiYwm8QScStduhQ0mDnLuKTegkjmmW1wodhBlbp+RXjgf8eZRBJC+/SynwVZWPOviOzk8AbxmQ+ilkCM8O4PbNU97yRam7X/nXlEqBiIiTZAARCSGOYUlvHwZ4wr7HHxThMKAh1fPVU/9wHA9ugLOAhQHWDVISFOx1CEY5rni/J0nfTer9WZyPGkw4pTk5pLM4hiLg5Us/3t8H8F8B+Dv+3P8JwL952xTjO0q2d0Zv+X1vlLoXFPi7OJpnB/AeG3u6GTQVLymyQaJv1PV3YvRFongGBvVcn8WQNEMIAHGWLICCAyydkiSM70mM/SBGXiSTUEcC7OcPgllYxOjfJOCRnewjInwRQ5/kZ5ol6L+P4hQDF1gA/EM/rr8A8L/2jOttU4dfIcIDjX1YUlQvnZLD5BwaricuV42FH6sjGH+Khvyu53Rae4MYiUayXMdqbTslw9KZ/ZqezxRRB3mNgxjuUV5jwLUGAKUmH1NNPovBRV199p9FOn8SDCLqen3dQY7zmBzOkm7+eM+TZDQqclrScZ7l70bJYg6CG8BB1AmNwPQp2vxAOBTqFGJvjkAN3xWYC/Ydi9IxcqRrjeR4c/qfZz7qj7Us+Mk4gHcRR7J8ttww0Sf/hRhh1Kd/KTfsnRimRofcKtN/6+819dU6fPafK1gXx7+IQc8pGo2pDh+lhLgTJF/1B86Czl8EjHyS8kAnGOPYx2TMxEbhXRJAGu9VxbGpKtGEPf03qM9foJGEHtEYgv/Ef/+hYyufAfiC5NLTJUjpufnQ0a2org72lopSvsYlvQdT9lDF6fxosoGfhAPQm+FGype9tUb3OwB/6ADUR5JWV3cAf+k34EdilF+gDcJcxKjDwKdk2LNEylEAMJP/juI8NLXOCsLAfqBnTA7oTox3FoPNAF9EbEgGcUqZzUWMZOmUApM4LEudgiP2FOWlk2qb3H9f+nn+xM/tX7hD/u/9eX+EpoPwTwH8GcnXncjPG5G9SCRnyqh6GR8694zdKBWKdivCEcWU44/BEfwkHEBHoaZ0nhYXW4U4grDzawegXiaD+6UDUgds7Lkw4H8J4P+WNHrGNlSzSESdkrEN2E/nHSQ1vogRK8twTqn7jL1cmKbU+nvlLFyw5/grtXhKz4WktUwZByTjGLEXI53TOdaaeZHjVeP7wsHLz/13MVn4M2wcijs0UtWfAPgfAfxvAE5+nd9lXDWdSybHUDplADsZQ+1gBtnRdDOS97ks+MmBgAnVLR1vHgb+awB/32+0lx5xlCgTaewTtuEWioEHD//PJA1WkOxJAD9tB1oytCDQnLDvlyuAqJmLGpdG5Uu6WU2Q+5Kim4Jxizwvsp/IVpbkHAx7bn/pgIKzZA9zygR0xmCRL4ojivmBJ2wDRRcBSH8fwETy/A7j70V0w3Ub1zp4D244gprKmVtZg2IO7zU2MP6EjP6W4auxhUH952jTd7+HrRX2QjAAHYENEY6gysZN8CDv80kC7ZQi+8qfq4QbjeZFwLpBjvVejCNq+os4prMY5jmh7ta5EW9F93Bcp2ScRV47HEZNBj/I54ZkQm8E8JxTpAz143NKv0fs+QbBDTDPpD5Fm2r8vwRQXNPtjpHnyFw69X55S9S3lMXkEoAdvIA3sgfDe6rIPP4UjF9090u6gFMHwb/zyP9H2MgxJqnmnaDgcUMHT/8kTqB4FvHfYBt5/X/RSCyBjH/kEUsn/NTIRznORRzDUUCxMxrDMJ57L1F1kKxlEQekxKBc+yoSfxDsAtiWk+QJxIjISzpeRcgVW5lTd2JIGYEaTk3GGF2IUE+6APhXAP6xG/9fy7lbOmXArTo+R+cxPbd0nAdvOBDK58xOgbeM/33MAn70DkBq/oJ9H/6VA3t0kOkTbNTYi9z0R7nh7sSgAuh68tf9wA3kS2xDOA8OIH7kN8PfRVPj+Wd+HDH4c8R+FwDSsV48wgWv/97fJ1LnTxJWEOo80cFQ1Z4iRnqWtPwsDqFKxB/EKDTSm5RDMXI8diLg0nEAi2QlipprWzGcyBF7taKDXI8LmsTZP3a85VPsRVEUpe+l6gV9jcK37VHIWUDtOBN2nMKSuj+9jOC9cwI/OgfQaf9EdAnRjeDh/75H6KPfOP+zv8Q/8gzgF264caE/lJZU3MBfiLM4prT/4n//hxIN/hZt8u8f+ut8hI2Fl8kxgaIHADZLSy4ovw+SbYwpLS1SPiiAt0g6PUhNbvK9MhAtpeo5kim/YZZ7JlL5p9QCVGd8kc+sToWCLwB7bsQgTus3aFJif8fP878B8Kd+XZQslWnKYyeS9xh/dgvIu+EIsoYjO69fO06F75oreHYAXy/d1x5+AEf/iafKocLzgf881G3/vn//j9xIP/LffSnR7aVfTFW6CUT+C7kBDmKUYXB59HaSm2RKrbRofT3JDXS48bEn7Ad0RuwVgpSSW9PNXOR9ldKrdf4lPScc0ZsESMaNf07Pq7imA2s2Auy5EUVTeOxnIKJMumATNv17aApGxVuBH3qbMBzlF36spw5Qek7GyQQG9469dAyZ7zivGWvIexiClxD3ccF7srB1/LEYvbb7sJFjwth+5cYf6fNLSSXDaP5b/90fCKhnuKbvFrkJ478qyPGBnDcTZ/FbbMw+YGPjhfF/KrUnsCnrHDup6ZhuslEi50kAuGAR3kn7TbX/T6lzMUjkLgkXsATMQZyGziuoUEgY8EvJFEyyDlVI0ntu7pQaB7kOJz8/0Qn4CHsuw6fymp+gSYr9azS59C+wp1fPKU0fUjRHOv86Z7GkzAIdrOGKhPSOzgTxHm1rfu8dQIeyG/Xhrx3FV07+IdWQOpn3kZQIweyrCUizlHpT2mA60PLgP/vS0/e4mR8kamrJ8JmAW1WM9iIZRU67SycCKVlII/Ik6f+QItxJjHFJab3W/RfsSTu1U/NW7EeilYykxr/IZywpcl5S1DwkJ7GIIzrL+QwJ9I+xH6H+BMDfuBP4J94peBTcY0o1+4xrAhDkvAwp+1sSnlBTWVM6tb62PJF+/twF+AZtvqjtf+5fg4Bs99hv3TFci3O+EmMrUoeP2HPs9fdj8va5vpylVVflvYaU8h9ShqHDMQcxQktOgII5KA0X4mimzvU0cUyLGIMSg5bU+kPKFpCMW51CTeVNGIp2EkqKpotkcHp97iRzei1OeJEOxEXwlI/kHKrSUmQSf+oZxM/95+GE/1oAXJ3HmLHnZ2jKP6TyakhZgX2FjOCZCfgNDF/15H6Fxs4LpR2T1tiE/SSc1nH3UqdD0uWI5G86hjVhm1efxIjv/d+fY1O0OYhBRUYSAJ8eP5PhVrn5xk5LDCn6awQaJUo+enZzj23gZ5HIpJReE2OKdH7uOJ2cjSzpXNR0PGfBPbSdeYc9QQhSviiOoyVBSKO9kHOiikWfYxNcOfj1i6xQj+kfuNP/Ao1q/DdokuS/7XQ/6o2sIGMgS6frQFzTzJnxA+UsvC/dgPFHYPxB0vmlO4Cg5GptrGn8XYqyX/pL/kxq4CHVfYeU+mbZr4L9/r4v3dAizT9g29c3Yj9sozdZtPDu0Vf4GRISr0h5FtcokuJ/LvjCUer5mj5nZCyPchxzJ0JF+1P//oC9GlAYzSUh5Zo5RS8f4jyYuhpHqfsXXIulZLpyjCmHzHg4wJhB+LkDvUfpwjyhUYn/xp/3z8XhX1LJlbsTSgaq6A8D9bAB5K7K+9YBeG8dQDL+0aPbrx2Ay+llROAwftXRy3PzKmhZEmBGXPesdSPPIDfTOTkPPdbIRi4JYX7Cnl6rYh+TRMeSWnQXMRpNtaukxnBg7OSO7hdyjJkApBN8izim4OXDz7dJl+IOex0CpJpayxY9V3FOj9iPKWu6PeGaVvuITbeQ2NOcR3m9OLYPpPPwuX/+Of3Ng7R71fFd1fPLshTKeTY/DgIGxjHS2T3hJLlGeuo91XERBHF3PD6DgO+o98OgXkh7T9Hig9SK93JT5HXcymWPOvsBe4prGNoReyHMjCOoYSv2cMFe3ssEDxgl5Q5a6wn7sdSS6mrKDTmjPwcQrcOztApjMcgHYoxzArKIvXrwIpF8ltcZ5f3n9Pmy7gFT9nMn6bsea4BzH2Avqkq5Fxc53wf5WwU/9dh0uWlgCX/j52WU8uRLBwofPTN4A2BZlirtypVNWg0IJ1AI0MIBGwafQwgXbe3PjAABM5rvP2T77eoRjsdDPZ3OzzyAdwH/2JNloubXJRmjtPyizjyKwSrVc5QoMiRDVNBnxH4ZBzs16yzpZtzoOjqrgM+UjFxT87N81rtOO25KoJyi9UxtvjGVBLMAaZcURSGtx9whiIUemh2x41TzLP2EvervUa6NpRbjpxKJb43nQkoyxUPm1IJEAuxeS6ZVsbEwz+4QPgXwptYaOxgJ4LUbcMU1u6/aatUAgcWAkUBtf8LtWq//8prezECaxd8aqLmAmT07AI34wpLSoZ0sMDGl7++l/Tek2nSQuhUJvBkljQ/KsKL155Tan1MNfkhlw1MHpHotP7NOTYnU+qodxFlppXNybnnKUdt/ZzRG4sfiBCh1eF5moqn3XTJ+5Ucg1fiLpNZ6DmJuYsJeGISSgut10ZacdkzmlJ4ztRN1CjLmJiCO+Q5t/Xlkib8AMJvZjLbXIUavzzBcmhMwyZI4RCYA2ARwBlAMuNAwtDgv7B7bdUwU11k9xel8fsYArsL9tUTX1DESNQAFiR4kOpyxH7hREE3ZcxP2QzJItf6Y0Nwj9sQbSyn8nKIRJDXV6LbI5zjimomWb3KTyKnHhNSS01pWx4FP0uXQCD1gr/Srra0hXZ5BPodiFroyLAxuSe3YUTop4QQ/wp6zUNCfmCspM2L6HLrxOEqqF+H0SSo3IUq1kGy/B3A0s0KCBg6eqj+CqnBsxZ3A0LIEGyPMx7WyliDQs4OZqndghtU/mBUzVBJ83zqC70UJIAM9hmshi0GcgkmaeUjRcErRSrOGA/ZKP0PqINzLjf0gafpB0mftAiitVzsFl+SomMDAQWrhkziNXpRfknOAvFYGL1W2Sh3OQcqAkiK5HiNSC1KnFV9K9gN5jvIpjoJ56HJUzX7uU+qvXYkhgYrs9NX1OUVKoMBfJsePptQiHaQTcSfH/rEZfkHaXxj47wn8BuYDWIzs0QrMz4dhNNhA4GLkEYZHz+9PJp7BAz7cCVQFBVvmb++VD3ifSgDD9R65X/pXpLNHXK/YRmovldSLVg56MMqiXIg1Vp+gDZ48olGFg8H3oRtSqON+jG0kuCQDmiUlveB6nh9i9IMY1SDRGdiPzgL7kdPcaiqd7oW2Lc/YE3mGhBUM2It1FFzrByj7T7srGvFLQvXHVFPrliAFI6s8F+l7piwFuBYgGTzF19r9jD1pqkomGJlF7Gr8lRn+ELDfgPwlgH9L4K9hWEAUsxW7CaHSYkCF2RuSvzWANJBkNZhncAEb2Jr9u8lzmiaeLxc7HKbnacBcAsiNEzXgH6ANgkTbZhRvfo/96KkuwhwSYj0KHhCkkT/HNmf/wmvm2MX3V/L3b6S1dERbX/WQyoC4oVXR5yml0687SL9yD7IYyAn7oRmNljP2Cj3oAFhDqqPZ6WnPNzAHS46ECc8YU1tP5x+yWtGYnEleKTZgzw5kuqbZ8Q1b3KCWjBkc1bHr0DuM/YqLZJArsGxmdyQna99/5u/urE57CfAVzNo5ID8zsyOAvwH5KaKMhfnninJ2TwK8XC4AYJfLBdM0PbcBpe2ngN69G2b0/V/gWnNfoxNS3Zx79wESvnHj/vdyA36JbXDoQ3E+Q6rTlQMQNWVur43YyCwj9go3WSYc6bgV26ipRTmmG1x/TnFuc6elWBNaH5/lLI4DqZTJ+wc005hwPWSV26XW6R4orbamlp9mMUPiOeSITxEAYQIYM55zSK3UpfO5Yi/jDODsS0mJTQ36BYGfAzw0s27y5ASItr+QJAayWm1/J5lMpP9r2U8zYBgGPpcAe+MPg3olEflDiS6Z3qsps27JOaTOwSgA3m/Q6J+q3Kv79jK4GABj7NoLTcAx1dSW+tI9xF3BwgOueeaKMbDTWqu4VpopuCYSqZEqEJlRfYozGBOOYLjeU8jEaZjEOWYxUc1a8sxEQV+qLc8aZM2DiPiWjnXGft0YUhl0ls8/pa6K0nkXf/0AM39GoIJYYKssmVbuNGCgWQExwEhDqYZ6kY3R2J5rFcb1+JZleQYBU/TT/vsRe453SYBdj2uta7hOns7TsYOjp+//TkCgF6nWPkhNe0i/+1S6C7FY4w77CbhB2odzMhpKHX6QzGPEnvl3SWi85o+K8CuBR7X2FuyXe5TURkPCHlSQREFHJGyDnTJDJy6VutuL+D31nYK+Bh/QEdxIUm86s3BJXQnNVOYEvCrngWhSYnNyiEHoqgaMMJycADQlRxklzAQDjVZpPBnsFYl5YwTyAhjMUJocAN/LVec/tAMYJNoeUlQeU4SZsF+uccCe//7k6f0T9mSWLxNif8B+I84ppaZDAvNU+uokJYMa1VEM65LANsixZJ29LJWdw4MOwizJqHJrECn7UEyhN68+pr/RfQK1gy1o+vyAPWlnxPUmpIJrnb3Mo++Jdayf0Y2mJg5CHsjR0imrJ+n7nEjqDsS8sPUoHY8FrbV3JnC2/Vg50X42052Gtez1qRgeK1ENdiE4malO48Ypel9owD+oAxA5ryKRS6N+XOhzJyouCcT6WzQySNToYbAX8fAldQRUHOKMPfdcDfGC/Yaeu06nQY/vkpyNTtKdcK3cU1P6rCluwZ7kVN9ixD212jxJh/Q6OfVXB1wTSJmNOVOfe6q6V5cd/dVcKmaq6jmqFqyZVUmlTK+9Gbz8dv4b8WdIwGNNLdVdC5r7Nq1iKw04BO5oWED7wAyvATyZZ4K2zf0YgOAB4Hpc4IdPwX/QJgC2yb77dINWMeJY1XUSQ3otF/I1Nlqs9p6fOhiBIuJ6Q1xSnVhSqh1G/K/8/V50HI3u4dModIdr8s+SSggl5ywdRDwvppwSgIj0nhdcC3YiOSSk6D/heuFpZmfScZGK23PvOnxU0R9zRsdJ6C4/prQbuNZKgETvF37cRqC6JzR3iTrpp84LUjLEVKHOXhSnA5/l73dt1dY1YMsizIph5Q1cqQ4Z3jsi4A9aAujFtM5/NVV7SuVAtMpCfCO3jEqKoodUY+eZdh0U0qg0C3hXsclPXdA0CO/EgYT81r0YVwyhvJDSAymSq65/5i3MqVZHchpj6oQwRfApRfEZ12q1uVWnfIQn9DXyHlJWgXS9qOCcA2xa1mTegvF6xfhqPLYvQ8BG1JnN9vRgXm88eoK5E6K5g6WlLKIKfrOWWYH0V2AEMdB2HYV5/RzkArMZZK1kDQfmtHa/DlaCE1BKeZYFTw4gCy6OKaKUhLDfJSDoC+y187RO1ln/nlDDkHrjyto7p/r3tSDLgTX8MZpardJ8gf1GnHNKl0NjLzQCP0gZSHYCxH6NN9AX4TRcq+vOHQTcOikzkkEc5O9O2EujqSTY7nU9ddetP8D1Sq187WtG2SV1N8RUHRo5B7J3oIFuGBvghpNP2UTJ8AXIph5sNsEwysBOvF31tt7FX38GuJYjJMz/N2Hj9G94DfEE4MTKmeCi24jbf4MPQDMzA2hLrc8ZQDLwWVJFpiik2nJPKWMYxTCRwC90UPW42Y4pEi8J+NOttoO87gtsa8LMuwu/8W6DHv9jArjCWD4XYFHXap9SFpKNOOve3yrblgSwzSlDWBKIZqldV3AtIDpgv1xlxwh0g88yX6owlDsATNfqlGr2lZjk47hlh2MYZp/cUwc3A/bk0TiyrBALadeABMyWNsRHxVgW7tP6CP4x5TckzsDiDP/ApmZu3QVVYCpmdiF3mNd6379+8wgAePFw//9PRSBPj7Sff8S13l5JN43WhUPCCnr1pPL1x3Tjabqqfe85Ga+qxZywVwsO+fDf4npCUBddBCX4S+xJLnnXIJPBDJ3W2IDrZRjsAG1ZzehWFM5Ol6lEOGDPRTiSvMP1MJKWU0vKuIBrccwv0TT6HsXJRB2/qg4ZcMc94avAPLvi7jwH0v4EUA1yIzi12b3BkfmChhOcxYEtMBQn+BR/f1KUgrh30gvAM2KylDvcpnrJXy11O8g2LPxw/9WN/3Q+2/FwIAA8nc52dzx8a46j/ADGb8nIg+hzTMejyygecb00EynK5DFRJPR2SlFWW4gj9pt38o4/ZZyp8V3QNOrP8rtLAi5nSfuXhMxPqQ2o0lq5L6/RN+vNDTfOS2YE5sxExUHzWqz1/UkOJCev5QcxvDl9rksHyJxTOzWo1Z+L8X7h2MrfJgD2IgdlO6DTMDvQJmAxY8z7IqVEhPSG7LNlLqrTvx5b4wbsOhy2fYa9w+GmhUhwpk8Dsgt2BvJvMDN8HeMHgOPhwDdPTwYA36bxfy8ZQFrmYbge+lE9eDU2Sy07pYqWlN6XGyBTpGrKG1DHANCICwAAIABJREFUorp3xwQyarahgpaaXZjc0C8Twm+p17+k1uOSAMuxg37nrTq5R58XWA64Xpk1oL9VyFLnYJey+/XKmYOWFksCzsZdNN07rMwjUK0Ava5fYNvydFAnzu1vYwGLvx6LOO2zRFo/XmfhmYU6TwGsnZMtEzWYFZgN8K3DdBTQdk7CFn/Zk2MAZ4IXkicAlZUVYPFZYKDxgYvBSUDhhr7C483jo6mjeLi74+PTye7vjj8uB6BLPRwgyXTdu3QT5hq8x1fvIc+a0l5SDz1Hc2A/Vjt6loH0N0NKz5VGasI5iLLgSUA/XSyinyEvlIzHAXsdvdyjZyeqZ/1+pEyo15O31F4bxdmMHhnZKbGGBPAR19RndkqUoePEX/l/P8N+1oIC6sbsfkGbpK1UjT9S27QrWMl923ReEXiyjec2WLF4n3+7H2t1bMiOAF+nFibFD8Y5eEPwCURlG/QHyeqgg2cRhFmhdAENAN88PtnD/R1vG/+TwVA86vPh7m4BgG/b+L9XDECEPvMeuaHTtisJoNN6dOxEm9JpLWr0XqQtBlwLYWQZ7iz0gQTIZSGLg/ASMtd8TgARbwBkt/bVWyeK6mQdbxg6Ox2RPP0XdNuC65VWvcWZTCVLNvx87oHrkd4s13buALaztHnvpB04y3KYi9wXJ5KGFmzKHo9gXcFQr+/ZHEoBMbbf2x1gb5pDJyh0am5OhiCqf4pHsCkrsw0RVda6wDAZUNlSAANcBrxJgq331zslwWy79gaUN09PfLi7+07aB+P3aPy3vh49IozpZs2qNd0ecUKge9totdU3oz/uaqnVNiVAcMQ1E02HbALNz2KfC66VfHWIKQ+9ZCZbVuEdO05oxPUMPzvnqOQOSZKpztelt+ceCeCsnS7FjL2ysZ6Hgmv9Qp1VGL38oHRJqpk9+M90geoqjtLagTZgm8jTKc7ZMwPv2zdwzkuEsWXpvAB2n7KaCuIC8AyzhjHYpsTMwBssHIMZyAJiMthixsqmKbBwfwbXSeYv37yxlw8Pu6j++vHJWFcfYbBiIjLy43MASelHb2wV+DxKJ6BcgyhX+9drMs6sGsMElOWVTnkfoN7gY4qsNZUEB7mhQ7bqjP2iDG07LolfkFP2rI7bi9o1YQG5D5+/J/raf+u/Oxr12t+/tfBTgc4Re0ERdq6zGu0qPELuorSIunDK4C5b1D9hAwIHP5BZOgHuBJ2/szmfs6mDpDswKt0AcM2/k2MDtqF2fo5qnd0JPLa6H2eQT1wxGVqbFzDSMIAca+VstnIVwE0ifJW/y8a/plu2iokMLWmx8fHpifcpC3hXKfG+ZAB5Xjyj2hm9ZyKo6M3XW0KRQSpN1zVN1v76KMY7peg/CNimFFLiem5eF3aOHSeV62l00mslJOXORbkB9AHXwzRf5fkmMxjsgH/qCGpyojk7qamFutt+zH2ptV0f7soGiDPOswZlNQXngFB1FlsUFTwl8mq7GFg8dQ8uwcUAo6E4el/8sNw5BfDBSPUHatBp4OAjWzaygDzBcDHiQgMBG0FerLURLzRbTAOXraig+4HbNvtwf8fXbx4rQStW1utKkm8eH2fAGEb/TY3/O3UAHvmRUtkcfZWCe8Je2mtIafcxpeKWDG1ImUHcUJOk5wcB3HQxqEbevNvuksqLHJk1LdZBGaZU2TqOIBs9btT/GqWZHAuwFyDNNfsgZRg6HYRcIuSOAjqOOK/C0pq/8na7coSJA6SSjZixn/X6xiYOAic44p4yqXFF+4GLv9lIWRnOFfSlAaYO/7zjEjQHUVtmH9kKT815opI1Ps0iEb3Whg9UwKq16r2ytunDrfhHBbeZgNdvHq1HBnrxcM/Xbx5X1SMzq3HKekb/+HSy3xUkHL8Dw48UR2vnXl2ro6W9kVKtl8fkPHpqOz3ASrfx5sm4JaH8llDsPNY7dkg0yg0vnfN5a0596qTM6JyfHiEKuB4OYgfQDM28nvqu3WgF5v0EY8JNcru1ZpyC/ZVZmecwemQsICZX30XnHFap87MmgBK3HMzc9iLSIy9Ww1xp2UeP/N7DXx1O1PR1LdLX/R4tQyR4BnEiOaMh/4vBYORE4IiKNwQraLWRiDhvmB7Mmsho4A9vZQISmx3R38xKHz38Jt2B8TuK/irLlW/sEfvNL7FKS0doLd3U2uM94no0Vld4I0VmdQZaK48py8jiG6p2WzpEneAAHDoGYR1QbMb15F7tGGKO3ppi40bkzlN4Yfw1OYnyjm5Drxsy4noLkN0AKc1aey2/R+Y6FE/jdcdASU5sBHBpwh0Wr3PxQ1DHb67gMyRAdHBiD0G7EFxAVpidQFQzVG5AYwxznRvw1zgfLWLbCNaGQTTvFu9zNpiBrDQ7r4Bl4yYYYNUaplC5Lh5p00Jvs53ICgxWQVgsIDMzbzLm6P9kgSuozsDj05Pd3727RPguHECRiJ7ppaPUmLHv3bAX7VQ0e0k1clyoJRmHkof0Zs9AYMFepTY8v6a02p6ccb0/viRs4RF7tiESur2kthlwLWKasYGSUuzePH5+fpV0Py8Psbe09kqnxGCHOzB08JacGSzRupInDNw7s+J9fEs40A7EbCBfzBqsjkzHswt10Cum9aikKVsIXlwLIADAc0sWbAVvXcnnLGDuQq5twwu3oR6ag40VLH5cpRGAsPh0YuODkBMM57YtrBESXWGoNxexS//fPD5aUAsMtkT3QoRQ8ebxKfKBAbBCYnl8eqpmhXfHA7+K8X/XIKBJjT12+u4xIz9JBpCBtx6B5dKJPMHpPiaDunS6DkxknF55MHaAsixVXXHN9rNkQBXXYFjW7e8RmjTiTuk1SwdEVAmtXiuQuB63Reow9J6XU/isy48OB6GkC0Yf7KFE/oikGrXNHYPqJJw7HIIg8WjbVMlJi2/s2UhhraC/eK/fAFtAzJ6ix1zB3GYDeFnLOnNsh6gAz5RuT8P1cKmt9TcAPFfCiuEJVgjjugYgMhgHIm8af2QAD/f3fP3mMfgD6/OjN/jlm0dna7omwSo0YMVLvq8sPPhdO4C4YUPj7ygXM3T8HhJoZikCDh1iztyJaPl5WutnJaDIIu7Tjd/bLaj9bnUCY4efsKTj4o3UWuf9cymSOyM70lBSy8lciB7wZjf6+UxlBpNTy4AfOiAibgCLOUuAbdkJV1LPddYR/XQNGJZ4EwdedyVkBoGTv9fAbSNzfMLFHURgB09e2+vMwpnRqSAXggtaFHYtclY0HXBYUwWqMCyVLfV34KH465QNGmmfxcwWgvjyzZvBYGtJ8OrFA794/XoFBWut5dXLF8ubxyfPpprXfP34aCCKY20mvAkr1toGj08nAOD93bF+rw7AWVpj+jp00m/t/5d0EYdOGy1z0vUGP6ZIqFNpWVgzr7Im9rsES6fNqOBTZvlp+t0zFC1dhs7vxxsAHUQMMwN+WXCzoq+d/7bU33rZmnQKNhUbM+uUU9wu+e44s5PblTCe1iYxVc68XkpSO4ArQQ5+109S+9ONOF7zThz8HYALyGDtDV6Px9z/aZc5EAvABcTiWoALYJEpXABWcwdi0NWhkf7b2VP1pbX+bCttfA5BqNYgyGJts8iXr99UgvbF69cBoZQvXr/BUhcfY7Ar7CZ4CuZNRncmZmaDGfh0ahIJx8Ohfl8ZgBo80n/VyA6JlbakaGgd5h3Q3w5bcT0nwE49HzyCQ0q3dWvNGfvJvzFFdj3OJaX3eVffkG72XPfvampRzSmdzgBvdASI/oBPPjc9kHA9Zx2mJrAfCkIHOLy178BSJrF9Hm+D7TMOWxpOwLvEwVAuyOCGPpAcYDYIWq7n+iB8gwpQYfan/fmxM8ALGSQvVgCPbGPAixv6E4C5UZBxdtbgAuBEsDi9d/YyJ2iIbBuFbKHP/vrxm2cPh9bWI5s6Qbv8tYX03EEZfZLZ6OsGvbLQTK79afMEwfUY/H0LyVnHib8zByCDPr2bVkcsc787T6xVXC8I7fXLkdpVEWmnVAOVDoodRnwWox1wPYmYR3xVQiqDV8C1bHnWI9j10N3oS2LhWQeQy1RhdlLtnObntVtXoKBwNQpuazBk47/FIcjl0A743KZp6BHRitS3s/k2JUHZo20XPPrB+/dj+54zr4+nOgAajmA2YOK2AOTkOzsLV2GQtRw4Ebi4US4EHgEuzuSLmYDzNvGLGW0TUPXUf3GQ0HzGgD4gNHjsju3C8Zt5owcYSrHK6iqGjTokHRiaV3+ldTWt+sLSBcBQLKjLLjYAsLZmI0sxvK3x8G1mAJlrz2Sghj4FV7n/NYFqGmlH9PULmFhoOSqWBPaF8SpAeElGt2AvETYnwhE72UhO1SfsZ+uVkJOzE3VCWdobndq6vCWlz+AfUp1v6YYYOtH91uDSamzU69uQbsVYJC5sN/C6bbdFppIylMtVGdYK351OpH/QhZlXsGUxyuF4SeBNmyQ0A3lmEyORQGJonQJcvG04s3H9lw1AXC3SHA8YbOM8mO8FNOf4cOP+cfIuPqzYsLb12jrygsYsDLZB0JWrnB+YWdkIkVtp6rvICohafQuRxdZi20otkm/tCIzfQuTX1d5zauuVGzfokhhzS6f2Kx2Qr6SInzfY9KYCddz0khD7TLZZUgTMqWyPG683aJ7HDxonJLPRTTuQbMQS+Igb9fCSiES1g13cnDJMizZ6uAE6WcyutmcGF203L1v8RhwadTdaktxtzUxOc4j2IRVnMQxNp2/LJsR3uQ1aG+7Z+YfduTqyLQJZCI4G3GElDOmULypd3NOP+WIroail5kY7O9Yws4XixY9IBWWjMpnaEVn1DP9gsOofYjDYAsPM7e9VLbSY2dicB4/rBzNbrGkSzOYlxnaxIqnjUgkWQ324v//uQUAxfq2959TjZ+eGzpz/W4M0Q8cBWMooNNXO8/61Y6h6I57fgpqrodyJkygpxZaBlE3UM9BZ7GWo9TWXVAbhBicAySCXDqGndsA4zR6sA9jdAgXZKQuA65kNdkqsCGnqNMHrRaP6ORZsfAHz/nukDpS2n+MIq+IuGsHHogTPN7wvF7ECYDTgBYjKRj0eQUxu0BfARms04rjnJmqLuQGE0zrZa3hyPIBr4u7O1F+j2JYpnNp8AQfP0dvZ8c9hZq08sLUsK+ROSLZNM5K1ZQ820HByjkC7roZikgnwK24g/NZKAFH9yewzpPqXN5h3TG00k959jx5riT8wdCJmbnlluavlRuSzBCpaaidm4G/nxHxl9a21WHHeLwlk1DHkqdP7rp26v9xwXr0SyFyaqbectMdFyL9fbgCNvOp6kFfUXxOmJPevp5jM6N2utRtAbY9yLa0gJVoQhTZ+hpPnAoLjVnocHd0/EjjAcL+lL6zexbrz+r76uRp9sB/uIKqhDgQOxcqjG9/syX/cy5PXPHF/BUXPSFrBCv8FAFpcuAQN52AhOYCYrFgwDGfverTuQWMZ+qyErSQhK1ZB8KsKjn6rXQCzHVkJqW1WU2pdUmRmp/3WG2m1G6w5ShrGTgTMq6kXXMtk6/OzCk+eU6iZPeg3jK4NG3Etu72gP96bW229nr4yEIcOwQg3orWCtBXXCkqGvs5/SSDb4DejJs/7LG8b/1acg46uDx2C08apaHP93mBrhCADilsiPZKf29guFxHrqE7YWbaU2hHxZiiLDxuNzRj5wpd/rohcJY7mr1WbhNA6UETiYjHIxFAdMlTyAcBsxMgmA3SujSAwEj6FEPOAWzbjdYvfMy27cA4BJzMcQTRtAbNhXY9m60ahxVYMwOBlElcconKwYl9ZPOS7IAL1VHx7whHAtchmNkC7AbApA5Deysu1/YDr6bkl8QQuyQHoYk0tMQ7Yb95dsJfH1oUj+diHDr5wwF6SzFIHJHMQsq5B6bT7evz7IszAPEJdO+1Wu9FKBbaut910EHvnv9No8FR4y9K4y/iGDU1fIzsCNLP1tRjXbHAjIpsJR7vOP5dJqdSEObZ7jBPM7kmeQDy0t+BswD1beRBjxLM7h5g2PHmZMLvOXyFwNPpzYRe2lL+l3yZtT/8+ZoFpNNAmn0cYbC2bcFfJO1sx1U1EkGSxpi/mVGtr57Mh/wGaljabRAO+xxIgAYHsGOyC/aIM4nr4I8/S64CI1opZcOKSOgWG601A6CDUSOj/0LmxcSNjieWVeTw4O59bqPwiYF7LV816KT6TRl+eGsyiIpBa/1ZmkzMGdvCH3O1Y2BEOTe/dhDW3QbqC/samdj2bxr873JXEM3vUDQjgzE0ai/BRXyklQrWnif9aC6Mw1Eou5tfb5xHQQD0b2wQijmiafhOAO4KVLXUfQJxo1EnI4sZWADtbGxoyV/uZzLUUzWzm2u1BXR1IO/rqVj0YbeHKGlxbn8XMRjf0kWQFsbhZVcCq+4PifAQANsTQ0CadbMavsXtw/DYMPwGBGvEv2Itnal176VBYM15QExiY6/BdJE7OBJ33BK5HeLPSbum0MvV1yLaAYsb1kM7QAc3QSc0DQJzNbOw4y1Gi9y19wKETyYtMAJZeKdD5TAP6wz8rzsHra7t3Rht1l7xBKMJeZHfNithzJERpY7VoRDmsXH10uAZz6x6QTuoxVi5msMbsc7ouyLoZ4eQgn8rSn6wpAy0h3ukz/wsMJ9CmzVcbGK3GNrZzsvidZ0pui9EeXDwDMJ9SHsxa5kiA1laHWuvpu3Gb837aORhIVBqXQisVLMWKtVyiMTWNqyTKbP1g9+07gI7hBw4QfPtIoR+vLvJ1OjsnY9L2Sm7nZYLP0EljsxQ1O/yEXIpoljH0/tbJO3PCKZj6+sON0kjBxGqN0XbB9UgspYOgY9RTp8bX0V+kNmIvC7gF8u0cB7e+u37+8SoL4LrXL6J/sFZ317j1uWMyhiqJjjU6M1qBIeWNQjaaLTe570VwiGq+LcgakcdHtDk4LY9srL3B+/elbtuMhkbYQQP/DBNQz2xZSW2tNgzBwSdbidHoxBzjfQB7E2jhKhpKa9hKwcWImcS4LR2xVrJzc+KszXG0pSccWgvSdcHWQZ8GFFaQBhsqawVQCqzRkNs5ipmL+YfEAGBmlW0EUwdsZnEKIaN16ET74QYFOG/RGZPxZuO2TuYA7KWse5yDnoZeEfS8ptak1v4F1/P+kDRf+Q4HTcU3ZtrKyc9p9q30P6fXvPGZbgmpsuM4WpOda/TfSY05OWfYOcoGWlmn+5JBTTgpJ8Quwgks2CPni7f9jHFOmk34Si4bXZfPIz21o7S0NlqUQlZdiIPt5VBdnaz4exQQBzIEQdpnrWSg73cAltp6+xNaRPYMhEe0T6P6gxXGAtoQyCjadP8QWgGetpsrDhmBWqw4a8hLDx/4kTJI9w3WZmfVYFZ9zNAIFpiNrx8f64vvgwfwlrJgcTHHiHKqzjN0avI8M99bWKGPWYwv78EbsB/r3YlS4npLTkbaewh6TucPqSU1dnCHtVXYGF077f0sBtKT7oqMZ0ych150RwcP6E0h4kYG5o5oK5k8ja7eUh5S5rE5Wq7j8rmtKNT/1I5tRmcmnRBel0G1RUon3IXOQcP3LwQOzvlfPAMefbbfJ/js0iLnKsm5iDhHDW8EYCJxIjCgsjiLobqbGlYHZXZB25I0kCjWqMAjNbIDJwMm5w3AzKbG2t1TqH2WADBjw+1Ya62wpicYOoU+P+A9XLModWiwQ9CU0eYjYoFpBTg5dejpe3cAqSywFHl1W282+rxFJzuES6rvVfbZEkMw1709bYEcnYoY9oBt+aUaa3QERrQx5qN8HiUq6cqs2Q370mHB9Zh+2kmY0meyGwxG4rbSz3Cjz7+Jb3APIpo5yYZX8w4l1fQ9haFd3e83MwibvRW3ePQfuA8Aoxv3Sc5hG6ttKHz02edtCrDpClibDzivipvNbc/OJFKVqDk+MZV229SIR2vcALZeP1TNO74fYXawtcxgzIg8OBZAEIWGk7V5grKy9Zo3qT4oNJiDlul+jDLTx34c+MOKSgzNvtoWYrOmGe7tz8HMjl5ezDCMr988Hl483J+/NQeQSSQ9DCA9d0p1tXK+geuhkSwISWm/5Xo8R3l2GIO5vMgprwqR6qbcc+rpay3+AtvGmvj9iw6YtmBTC7qk+r3H4IMTiHQrb48F2Yv+Q8cI9fr2NvSa35v7TokPy7hh5IGitJnJVLO+dPAGaU9Ga31N85kc4NnbWGBE/ibhFeg/JRDM7dybSeuw4Si2jvMqE/TsmUTY40W6Ra7fF2IydvY1Qtwm8No9StD3CNhowIHGAuLz1iHA0YBPrPH8wUblPa2vTwYrECtRiqtEeHHsrPok3xJuymK6oDUPfbXZbky7wDA17QJc3CkUmaP4djKATl1a39YOjA+08757pVmt2a7qxA7ddcDt/QC3sICMduf1VWPCHdpUGPkKm1ZBIP4a8VVDYFLQzoG9eK0XaLr2F+znEBZxahrhD2L8k2QdWX8vR3p2yFJvawGGOG2MtEam7qg/e4CtDv9clRVUxuH+QoaoJ33EFilzY1MBsrmBfozz4Es3OHBj/HnGYIeWzjtTrxFvoucf3L7FU/5tfyFvji9PsNXR3YGlApxL8z4b2GxO2iFHbweyghdr4N+pEYBsaO1Fi889urKQ03lX/gIcV7BiNjt2ynis+p+0SlSaUwL96hUEbNgcAp1OHHtQ67pF+Zs6gA51lNpv1ixgm2xaHcGM/UaYQWiw5UaPnW+J3nNyEHmbEBPgl4G4XgZBIU5UwSouAO6c5PNSUPg1qtmKZTUj9jpfkO9VUfaALD99jfBryj91WIR2gyjVM3bNcnoTfOtrukEW25hmxT8Xr/CG/XDvbghLjD6kbJV70XT2mtiGP8uiT7648dJT/GGr0wMb4Gy788BdecMtotZwYG0AqGULuqKbm9sqtp4rI8CDkIcIcGQbuAnhktrGb7kAODh4OZvhQPLiAqADdsNaZlbWzGcVjeH272D1GcBYB9QWirS9gn4dilNsY8gQC1p/cHYGogui2GzEQsNieyGdb5QB9KbK2EnfcyswnvckkW65kQnkKAzst8rkLcGacmrZMKbsQdl3Ogab+euLsPq0e5CHXnTL8Og3hyVGYEntPia8gimlVtn0Cde6CbsxaKbuhKVePrfza+ivCluw1aahKAu5Xoasp8B4T25GdE1s2tGzbRtPqy6+UbGdW7Bt4V0HskSIe/KXDQrx2ehdcuyFP4Va6+z/ACVtNPDiEXK9l9qQHIyNewGuxBoUH9YBaJP/1QXAtA7iNmfQonn74QXEbLALwUeyDReFOE+DUdoIcMKldP25dyy4w4W89lgMLE4QG7wZWRk5WAtc1aP9Vj6bVWuZxvLyxcPyOzmAJA3VW/e03sSesvEGHqBrsSv6a6bRSWPnhFSHQCQEdGOHbrtSjmurv1alXrveUrtyDfwCTIkMhNTis5sp8bXWQV5Rxne0K4fkYNChFOuK7PYeLQVzzfptGtE2Us4VZVedlkXq3ngbKlc5bMQeKidjtG04PTrts/DUdx2cUMv1bmJ1UPDivfzZjc9Xf1lE++iBD96SOK28wJYJLFEC1NaP9/DZ6mD41h+vUiY380cjzgYbaZzi/nbWYaTRI4mzGeu2PWhtg1aCQ+wLW5l54KE5BTuCeAJ48L4cCbtvgB/OXppMti0vnQEM1uTGrLXzROHHAZoKW0pLJBYz40Z9XpHFAAzROm+g4yb1mxKBrNNzLp3af0dd7chHqU7Akph9SvMdkuGjU6eXBJqNGSCr2wLJlW1o++wCCaQrEvEvyRAnXA/hIDmGsZOyD52+PRLFObP1MvHIuBk5Vprt1m+Pz8805DNgNzLvhFXSJAXImVzU70oAyMOkOtQT5hiMt8Fltyv2i0GCvz/bmuYLONfAsnkT5Fz78miR2gLgGp3rH2ntJTb+eqZJb6ldvIsZa9oH/3izf/7Rnf3oM/XFST5tS3AzsqlFWbtYG7I5ObNvMFilEdYUgCuII41LayHWsQGYNnmm4U4AZuBA1zbgdkXCAw9NpjzK5xpAzOx5f22jfq0l6cnX4mWAOSuxeCBo7cE2X7DYV0j/uw6A162dgr48dw8XwI3fsYNCZyGQAX0tuZ4jWtPjynXU84B93TPbfiptxl4uLNo47ACQWVCkdGYEdEuROqOp04bUCcKx42TVmDXD2C8+pQNozctnBzOm0kNTfUjqjp6TTiBvylBovO426Az/kDIcP8c72a55dfK2Unsjks6rE2rRd3LeMNs1spOnAIUm6bNnn4n7sQAcQBx8gCfKFp8bwHEl6zbDJMyOK4gLl/Nqa71UfnwMbR8AI1tVbj7TPxCYrIGZkxkWoC6ADT5sNMIwGzjVCN3AYu3+G71EgrMVt5l+oDrAuHICCCwOENoqLmKotbJuP2Z99fIFv3z9xl6+eOBXdgAdpP/Wjrp8E5V3LDxRmaasypuXgmp9PyTcYABgtTKqOwUJn8QILrYf/5XNMiuAOePtQEnOWPY77tY1U91H3rNXOv30YYfI78/9eMXP30g2wbzLU4BhCbrbYCOy9luQ2XlzhzRvVN3VCfrwShUku16xNYM/KzMf3DvmSm0Dulz3ujSvkZBGxvpuBuEHszURj43OiyaZZcBSgw3LuCcxABwIvnAnMsPwROCBxmotaRy2oSAObGn56HlQEQJXcRZhO7+0wcCJjYMQWeDZacftuCtgJTQy2oBPq895gOHsidkC1AmwuQH9azYTydgsLdcFsKXWalbMZQENTpf2LJs1TuO7jL+XAdgNYsfvzAsSYz9hv3FHZbntRnTVG7PUyoxDzKluD702JP38vJwzb7TVNuUCH+k0W+u1yQ1+TKy8nB2ow8A7SDxBbx19LqAkMEhVfQuuNfqgWVPkj6pV5wV8oUeFfD53ACc3kC/16M1ggwNoawuTPbn21sef2ei6jsgj0P21xNscSmuPMgBGbivdmoifBSErDG9yiW7bSENNMqsKDuUONa7taLCzn9rJwYsLmigUw8l2AAAgAElEQVR/G9mNhJoBbcAnclm8AT9i0zwcgp3n7ckjzCaQBwIXa85vMbPY5WOgzUaWVR2g3V+y6M9OjdwDM8ek/LNU7wzEvsJq1rQBQobIzGL34WKGOJ/1iy9f26uXL766A5Do/670nu9I+Xs4QBjrU0rvF1yLVyKn+7VyQ/dtt0NgFAMdPT1eeP1aSO+nnYKeOElMjVXuJcZG/4duGsrahNoJmPQ4nOTRsiWzYUcN3XcfNNPozfqzQ2UO7IAe/epWasK4Ks7ItQlSLp2fvunqpYnGXeM/ayxw4/uuJkRRAFq4bfjdOhvtOrl2P+eml7ca92RtAYihRc3Rk5m1kyLsvCeCR8Aua2cj2oLma7/azMDgLMRLdBbacdjokp8ztl08F3d8zrpdr50Lm9johMM7bpngGeDMtiF4Jmttun5N7qvhFHbxDsnQjp2liZuEnkVzAg7iVbZJRDNgEclwak7omqXVzC4tE7D6wVcwfHT45+UdEf/WgAc69XOvnlQgrNRaBzbRQ30s/rMDyUI2yqOfpIJNIbaK/1Q1GiTjGDuOCLjeBJQxhiP3OoOq538U1tMoIJxHe3M8ghMaG2z0KD8mim8mFEUBF+KYxYGvTOutQr7pYTJBSre3+HHRqYEFKdD2x1GEyK/a/lGnV2wdgrXO5vbDCzYSzuoAuA0bZC1EC4279XPuCUeunuPi2e3czM2xYQHNx4XpQ0VcGqoPWzMSBx0l+JbgMEQK44cXvN74XINdd3lKGlyK7kabWrLQ57OxJZNNmdga32B0CTC2/j9oMXrcjL2SXMzsYrKIZp214jr7qzobFzNbPnz18mttCh7fEumtE/FVyurW34UuXk7pqxys72hbl3JkhtaM3cIP5l18kyyXzCPFY+pNq6JPb/ttZjaOWLXaZKKw0XSr1P5TmhVYSxePVJO1FD9Q+MGyMe2dUdzYpquvog8lUs/D1sK+Bi4Vvre9nDT39w42Kevtfc1k3KxTBlYB3nYCLdwWgw6CFVhG+LHp/FW0ZSBOewWJOnovO9qYizXthTgNS5O+Irn+zNt2LVNYAJ5puPN9AE+1QheLVpjRGs14dCSpuKa/ZwQIjn7U0sUHDBi4iNGGpuqDkcAR5B3YthAxfEfDoUBb78Ni4LzO92vaxDWbXczsspb8cY/6HIGce4KspRRps7N+XePvccV5g5aL1Ia7iqp1awFS6aA3gKZQBiqJHxB98FNKbaMGH6Q9h+RcKCSdir20l27rzRLgtdN92ADGJsu87FDsbW14rJ+K4ZaCJj29zc2ThSKVnTABsr/6a9upt51lAfuuCDk+Wco9puv17JYYmWGvNWDXXaAd+p9bvWB/CYl2GlzfnoNXGQPW8V/qfTWIMzv6oowj2mbdxQHAgYbRJ/4A2FAbT4CqIsQoBZtqLn0KdfRQ/8RNQXiypjs4AnZAU92hnyF3VOZtPquJS08v38rKijQc0bgOd45FXIxrG66VMJWByR1hdvbx5rZQtDmaA8HLqoXo+xKc2rtdbtciXPUBPEvw5y4fvnpV8Ts8xk76zrcY7vqcWoPcYQbbj9VaR9oq16+tZqEi3kUIPwrSHdDEHg7yXHVUd55iztgb2Si969opSQq2u1x/d9lS6XV/3DGlq6rlP2OTnMoz+IO8hzL6Bl5nWzXV1LssLG7GVu/tgDeDrX9EMWRb6/LdYp6udqBk7m9t/WaVZFUL2v6eGvHXZ8wNZ4Bn4V6CMjoqzfAYsxdEgfGwtfbsgLZzLyYrx8Z65GAOMtIC9ccZxOf+nOpIegMoicn90BnGe5cIq16P04xLdTrhJsiH4mJC1YiRoNFwaKidLc73P6BycLXhC4nJhU8OrgtQCY7WMoDi8l1Hby2eQU5tL8EKPpTWTnRO0Ar7gSUwgnbRlk6X5+s5gAAYZFUUcosJQK212lUbz27iBL3OgqLGF9cM0PFX515LiWu7suNe0nDb2jNr5qCGdPbU9B57Ge+dQ+K+9bYp/XCN9MsW3VeH5P1iGBs77mhbTZ9LpkmYfMVSeu1gXVlHcTp4iUSiUIgJxDiBcKvJF4Ns1eF+WGjF6XhTvkuIRJszNx1ZVSfM0NbPcxzMx9cEK9dVVi2zMrC0LAAncwGQkNkmeAkNPQOefAzY8REr23Wxh5ZFGK05khcAvmyDO6xOyz24w3mC8QhiMmCqqLWN6PLsJKhG+dn0CukLSb0bYgfPPBYv76Ym78XW2XEpM/8McV1Le1FOJKq1HlPbWdCygYPPAayFvh9DWxsGGXT2LoFt5dP6+OyLL+3rlALvmgVgrbXX0+dGS0eeEHmbvLXtaQeMFU/jJgxhS2qtnSRtPgkLD44Wn+Vz7PTquB/5NRlCGkS7PrEQLaifwQ580bYw2bKnyOIJbd9ckGEWNxgK5mBpzsF8dNSkr771/L2ATJtgmdLzXX4eAz3r1Gi9Iv2Yy0zZivxjVa0NAy3Cm7ftnSkTdBY195ZRtcz+jNiHZzvGp22Oh1yNP9Rw9rhEEIcGl/GetwhnoxCH6DW7DxLRAC40O7bsf8fWXAx4VYE3BF4DPBrXazUZ2wgvzYdsGmaAtWXZ3CfNMMVUrucuAxpdeGLwTbiBuQ30QyF557thzDS7JKaWibBJgTUG4p07k5Y5mk0W68qJ2qQDYERbLS4dlvrRB692xv5NQMCQ8jIz47Is9paefsYAeqXDTfZg3c8ahCdbvEXiLL2r1tyjtP/uBGcgyXsfaglOvwJ4kd14OgYzW/GHYWN5xfKJOm8ZgUUfXD/TpRFFVqOesQMLd86o+kJLA1bhzDUkcI+iR0oc++rVQPUkCoV3k3+uKdNfd0YnSZ4V+d9hhTriSwGgDNItiJ/RNvbgsuN1rEs8V23+EMHw1qrMYzXeQUR2rpnJxs5cZA8gCDzZNux0cedfVm58u/hjM0Y2jX7w6PP549r/b5/uUMGh2LrnL5Zw+u4CQyMKrctIBneiB4NuOWIhMbKBgUMDBfloQKnAYOQEWGHlDMNoZqPThCc/jsUFZp9KsULigLa6rIa8d2m7AaPrEue+klw+/vCD3zn1v5kB5KGeYRjCGSSgyq7/9PqHBftxW2PWybveHTA4qSFHzhGbQGiw+dTwF2Gc+Y43ScEDEbM1szi49nuOtgeEWg2rcw7syD2hqA3GWHcXn4BcRllZVdyxbSROrlpv6+Ftn61lU47kcVf3X4N2koBhPwqkxr11/rVluK6WW0fqqM7FKO3VbbpyxaW27M6FPbGRslZBiyp4QUvhnbMOWnGY7OLsxkW6BTq67fp5IXNlF4LRrr20Ot9etSWfMH/N0QU879A2Ai3cuhCTK3KUShSfi/bshoMPCBlt34bmJr09uvDIhetAGav3+weXDB88UxoBTiTPJO5dwqwU2gzDQvJYKxaXFT9ZYxMOPiq8kLRSSug3LAD48Ycf8JPPvrCPP3zFb80BRNQfhoHDsOFU8e9lWfbtQVMUeldDDmL4JlyDvEyiESvMlsQn19q8yBhpSan8uNGQXbbZGmfeVV0jBl5gOHoaGTLWF2nNHdabgisV9biVE+EkTM/XmVwzkXNTlUUai19T7xFNHCKku7kH+NYxUAAYLBie3Jp2mwjlVYsWtrUO/aoI7k8fFWsskwIzle7eNlDsJohcVKIR7LDp9zcDwrqSqrUubYvSFuIXu+6ORXZA29iB68abumUPoXfvCc36EXheMxLuVpFeHC/w88xFiGFH3zRUDLij4fUKRhBjTBO7NGlMWobT2e5RmrkWTzHa6Od2ciPmVmLRF3WsU5t+nxGNKYjBzAoMB7LOHrUerOEch3Y/cTCzyUpxijEPZnaSBRFVRu3xTY3/ygGo0X8Fhq/dqu+dzBPrl4sg0Ve77fwDDfK6RdpP7QYxG/wiRdYwC2gHyoI31NBrBynEjVB6NYPBbObmBI5oarAHX96QV5jLAAw9ZWyjpg4Itd1zba4z5ugGMxYx6rKi7B2VTIvGzjrveXWeo7VWehQsF4VoQONGA9IxYq/zbRX9lGF6ymeTiU8GZpAHfdxgw2ewcssadQMUfdRYti9ZvDbdEcX5KFh3+kUAoGxwshHgk99To0fnM9dpv5XUdgZYCJtZa3GE3pyX4TReX8SxCX0QhgPrWsod2hJPLJ7bleD6V7AYURpusGa3fvz2YOCJZo9eOIXm4eCU49BVGM1sIHGBcbQQi6GrEhFjbcd+lK5UlObGZgfzJ599bt9JCXA1EbMsFo7B/8tlqfspPVKiGHdswECw7ZpHAOk8cLvZd+2s4nFwr9Jr65DJqe10twuAe9/YOvnNtKL6rvdGH8iwnTSUeQuoWeIgyPbYYTQGKu9z6Lb4zQXACjfhjLq24bhbB172hXog413RpR4ivwvuSulNa7vKtjB6W7vt7aRhIwmsG7Yphp45IVUSBLoB+mZcC/nqnvZBKP7GLxefKhz8ho+jFZEXxnqwC3aS5OsU5AKzAUYL2W/C2gagFkknb2+0CEsf+W3v3Xr/7X50qW+r1ui3y9bR4WDAobY5AyCk4eijyVFEBpjYXuvQtAEwtfvPzjBcvOBka+txdPLQFPMVtZIVuIPZU3MGdiR4NtrUsALMBI5lfctGf7Z+y/67cQC9rGAYWjCel2i/BnROEyzA1vVQpMWGN9vSe0WyJbhfMxKdRlLXm2Hb9XYWSu3Zb8TYtxaS5JN7WRH+YBv8MQtJ69hM69HfxtaN4N1qBNwtK4mhEL8eNq5r3/btRq8113OyOp5dEXBNw8i6ekVZYeIj15O6pcamjkdXbMOuZMFaaUVQcYEqZQSvcI2tKxDHUxs9dwUHTYgMC3utQ65OIAaAuPYvmtEs7pTnYILSswZv6QXzqTqyf26oPWdPweuK9pjPC6zz83gCsfj038S2oSc0A0c/gyENtzgmOmybb2nmSH7DGtbYN/quwEMjKwFoHYjJYAWGoWkJuAiJgNQkXxFYCvBkZveignTXiEW8OB2wBDRs9k3n9L6iA3h7k3DN2a5UbshAl6k9bmPqFHBVihE4a1u2yfWGxpXmfN0YfTx7lM9yVgN3MuTc5gOa8bchonY2R4n6pUPQUSLQ4obvNzWrZBsRGUy4AwFibloG9pZxCyLruXaebUxxYDPKLiMzREFiPt7Zb9ZZOroVK9xFaK4sTCU0nb11u0Z5bMMFkdav+gB56IprJ2XlEEm7mYHHDK7v124IsngP/+xw6uQuL+r4EainrfyzOwcPZ0+VmhaE4cEavNpIRQ19H6N353VQ9cUjIHBvrcxaW5nbyDHG0pz9S3eqMaOANheCkRtfpfjg01zb5GCxlkHGxqGDS3udCI7mS0kJFmMbf+a3EP2/uQPYcve00LILGpQ13cQK1C3BAKvbOKvw2q/oqLsxVn/j2IUW0lGjx7ZRqMFw4/YhDExo7Zc2u01qza80UzH6dZx28jT2hG1DziTMwkX47iaOgNIfN9g1B1hL/6tU6Bq/35UGckOYNO+0u0CdFeBeOHRx8wnRzhodDDe8ddxaAMfifeoADpcdSNmMRKcBKZmUAolcAbiNkbe0LMGn8RraPobyEGOHHyyCy+CckmKwM1iDCHTybMJ3/7WMhFznnlsbznAyYGhiIy1ItMEMLm2cg6QDgIQJMY3RkqswTISNNNyDPHsD5Fw9A2wgIKIEkDV3RndG0WZ88s8FJwhZJScznLy7AV+b/MNnAOM48jLPtwaIVOSiCL+lePoNaSXtHQqlZdVnEkZbKKbEfKeadxNsbR0t63xB2+joctuMrT6js8pUxSdYf7QuhTi02ZilvlaNPdu4+Rfud/qFvHTRbKhj6B2lVZkd2LykCZAWr6uQQBod3dUPnvWsQqWBvDeFWzc22+sbBLPyrEa81tkUqlFEeK4zSNWpvtZGfz07MF+ctbaUbPYPdAFCS5+LBhdr2v+OsK9lCdqmHt57y2/09tyTM+x8MzAXg3PyW+3/hG3zk9K4T1xbt63xJ4ButIefGs3BqwOs1PYHAA9sRk+Ak1OOF9vkxxnjzn4sB2v37uQszdExKZeG2/E1jAb+9tPPys8/+rD+oBmA3PiVZLE1ZUectSxTPWyzLJw2sYhNL9pLhyh0dGbfNo6+6c53c0BqFFO9NER4la2O+fw7P6mj73zLKrz1RoLu0k8rv0BZkbO0EqN5PsgMfGjhjUqiYDJ67a0Q3SmM3VJP7n9XnBtRpfUfN6c5hz5zHi6igFENQum1ldyzOMy3E7T00m3ZMxJdwmoTJFFSQtTmi2ca9KhXN71/DG0GnhH524q5bXXYJZiD5jP6WCUAYADv3HmM1lD8i9d6x2ZAPLfsjfd+xHXtIDBS+7gYHIOUZbCRNHdgK4g8sOEBtREEefEgMzgGVf14zBcKF9cWHHzuP2ZXjiCOMA6tO+WgYQOaD4Bd3Mu3ksKFSaK9+51nAJd5tmkcbyYcU8sCzMumSD491ZWRYFv7+X7zrjTTsrWggqYuo7vU9VZrar4IwUbprg4q+ehmOJC2XCLEOUZstZhuu83bb4w7/rxd4DeSd872YpyGQG2L1Ld3Ah5y3fHSG5jIdf8NjWVes7BspfOu3YjNNdCc5LMbMOJ+2SqdtGKrZuHZ32/ezinM69Y3Qh2QGj6yAcmYrHHlfbBnZRY5CChDLlv3xI2xpffG6pqPMao8uDMt3hlqK8HICov1Xnwk7OQ7DasoJDXOfeMOeCeAd1KSlIbwWes2cO1CBU41+hEvDu4vRmti/qxnb4aEcvA9m1DJwRHv0VvGlawFbT34SXCSO/8sEwxvfBAo+BG+aOhKFSo2DH23DuBtxo80enYb3FpzJL1hlSWXlA4YoFyPWlxTVNZSYdzqUQs8INL9aY1CjbfuajM2bMDRSk025fdzczzcMAkuXompTEM4rWj70fGC0Zqnb+SjHVVH7bJD/Fe2Tq/3Q2Zege3wPyZwcQ8xFNu4FB7xOfs1ODX+Py0NU6E68d6d7aIqQiRDyHI7Z8b9R9tGlD3p4bLxETS7WiV6gnQ5gHZ2YqRVuOqRNdoxUBfvr8OVeMm6rvseYL50oy3WuGvCqmSbsGQFsThHywVTOASHwgU7qvP8/R7hwoqLN2Lp3a7ATg4x8chNfboFvNY5mNoglB0Jnlh5sNIo8L4TcCGsWHOcAzSz5tp6s99+8il+/vFH/MFKgPPlYgRwmKZ6uVz2a6jN2PCYFZtaB3BCJUWZcO2D7rb0TBvqvkOrgf3OgE1AYpWTcmCvcc4Hp3NuMuJc22LjOlPrz2MIgLRoEOZS9tlCGBiro8KB7M1t2aRVMdDF7+5xU92SWnwV2e4nABvAnRyEmHqmB9gOitl+ITO6rh+3nv7F2XjmtXrM6F+gG3UaqxLSDcFKk+bmHKPp0NZVt5ZZw2JWYw+J71hO6tm2lS1NcQGOxhAs3FLhkU0IxIf5OVjbOnTySGownI0h8OmcBB9Tbq1D3je5sHXJC/zaW+NVtSm9WGfmmUtIelVWeq8fhrZZ2Esi6sboA+K6O1OVYDXaIwPYa/fRsdGabSqNNuwqUryw6RFezDdP+VJQYL/Q5ofDAA7TxMvlYqvxeyu81T4rGzCQ9VXtxvYadjttO0eNR0kJdJNKFa744Gn34CO5AoIFr5+HHTnebSn2xK/LvRr6HDdy2bP3nHtgK21/kOmYwdaeOysY48ecsOeyr8QWiYemBfRNSaa1ebLn/gfhfWvFdMb2yY48WAOUKpGNTQVb59QtCJqtL54UrsM+nYl0YxNeoSg/+6iyDGHFzoKZZgPAxTYUHBspy/X/2yiubIqiNedglxalXVCDXnJ6Ol0Ns9EuTbyzTo6mhs7gGDwGA9sCgDaNO7Z7ys5swh5LmzVw1Z6WMTimYSVWkhWzAF9G1wUeQQ6N97qNmTtuMfu5vyPxsrKezKzNLVjDZUg8CgMyOh9Bw+YP6gDyozZkxNFuc0rwWv+phNQmxskVXjdne40i4rGODCcuvGG3uQVPkep7g74t8zSbhEc3mNkOEDOZ9XYs4m6VIOOKwN77BtY4hosPjFRpvAWvYA7yj7/+1HbD28n31w/Kg4ypPb6F2GXSFtjr/rDPxe75EdtVAk+xv15agzE0YwC+xH58uDpg2CTX2RZPOIedTjKgSJmRewWmQTo+JiBjMBAbf4Neum3TRkU4CzGxN7RxYLtgTRtw8nS8bWk2vmm2z6OZnSu4FNjnXua98hr7QnJ0XcfqTMK4bJMHCZ9WDBDVPzc5e5lxNovuCReDWWVd6kpxD7CyNnCc6+ITCyxChqXg+pFHAi8CPPRjmn134CnmWYy+vfkb4oDfigOYponnywVSrGHr/kQMlUWyW0q9bKCUVef7Dz5kUvzTF5mGW5dguGIqDbjXoR43vnsYHlwYw/coNh71NjiCwbbJv+hxT7x2MINMysfs/G5E16n4gyjEVmciBqvrji0nXjyUB2xtq9rcO3erdCYxeqqgHbV/bkV/AJEV10tQThvmgYsfUJQAoVMfbEqKpBWdCk7sNw0FNbzAdvRV531h2EQ32kwGXeSiyd+t7bJI41eH0GzLQt7I9mWlSXmBYyMQ4txGbXngOsncOhkkZ6NwWNqtdmEDQCxuahJPbOVeaACgAXkcWq0bje5W+vnnhndgBp8XmddjbENrZ1ZcXKbceQF8AWIOumX7Py6gzRU8t/FmDmal2g5a+4EzgMM08XQ+2xoLTPrT61DQSuXVKMFtPt759a32ioGfKBfmEGx0ckoB8QGBj1oNFag+m5YcODQKR0zgeX27iVFEehvI/YGbhFcczxGt7z2wkTSmlvL7Jtm2YbbINttV9loGUIKsdE/YFP2q1Y7Zt1sDrgeM8zNMWFc5Etj+Lx2isG3KjtGqXYS69YWn6K6wi8cVt4lptG0+PkhPxmuR05W9qbwVAUsp0u1VOj7V7Wgx4+xGOig87HDbAcazlxe1dXjMgTqfEzAstkV1WhvHHVzt18+9kRuYC79XBhpWvT1vFrqX5xOrNdagoboUWczpu6BL29nYoJ5SnHMSYowws4HACRVLuy94duITK+pdacnxAthEcCyNNX5uOAAvhD0ZMdNorQ9o9td/+wl++bOP+YM4gNP5bMfDgafz2aT5qzefGIbvOt7NApgy1riOg7a7eFsI2mrrAJDOAD8k8fsAPoThhSP+cY9575qxbG1dfmGNXKF9//0K7LZI485Bp8EJNgOApbZtsZUyI9+ietMlhM9vY9P3D/BydFyjND05u16nmS09CwDcklxNhs8kxWJcP/+2gdeCGcwZG1MnWnkXi/0NsX12n7oP2HQTtyYFdwmJMSTH9qLt2iqMtl8RUHAlgJDqGw1mDQREs7Zl+wWqQzX0dixq5dTEPeyE2K7b0MYjtgnOUP6lC2yGxNssldHsCkBAjaUm9D2FxkY0asuV2zpxUIhcxSnAxVr93k46+cimAfim8Rrs5OIf0WqdDHjg6t45e/+/gjab4Q2BEyvHUlDtamzke3YAx8NhLzedh163AZ0iAyLC9eduxx13bSBGkHwA+QFgD84KWwA8gPYLGF+AOPrYsblo5km20XC7LDaS1Vc37bbvRjkCgq/crEbvEoQ4BGxVBKZKaQ87Ftn/x92bd8l2XcedEeferHrvASBFDSQtumWJpuVu2e7v/zl68Oq25aFtWRZBggPwhqrMe3f0Hzv2PicLgCw1CYFqrcUlgnivhsy85+wh4hfzgZw24uw1PatbHmzeJ3Sut7u+thlgX6fCV3uyV9RwMwFmf3tlrpjKf69lG/PkBzmmViDDOhYT13kHHSjfx5xlbgvlB76FuWxYl3QnzkO6Y8O5+bU5Fz1IR6TKu3w/1M+swWR6O8LuwNfL58h4Ll1EBII7iCeiufpbPXtlSMo+n4fU3JNgOiZv6X8aV3P5brZ9GyvgQXLGhF9sLvLGgtd0reo9EGfqSnILw1Qq3rxSPUPI5C/wMRSZ/pN1UkD4QPI9pFNTHq5vvQXgl9vVIt7oa6XCX1beCffhF9vSl34C6HtWTvWEX8LHyaCv944396dPbhlu8/cs2e+swBdx0oa5bXjjyWzJmMsr0FTOwoXl6sriloSC7Ow894r6zu0CVxrw15kAvqLSX1/T+xPk66cF98QRGcPeh7EW9V39nZsPgxOpWrsuGoPQi3iyudGY97zL31WwYy4j20vBxG7FV8RL1Tr0ZSCIfQA1sc8nIif8DPtiEiZLnApt5eGPFAY9eFhZg7eTlQ3JlOcu3z8GETHFayehw7/1Uc7H8jg4mCQa/JKnbZmHhm2sGfOV0uqnQDwTPAN6pjHfUf1Z3hGR7Y8urnBuEF6l/lDCwDsWOdmRwPwNnAG/eQvw/MzHx0f1GncCr14ohe/29y/58PWJHSWF7PIaeA3po0rqofDoPfsA8JrQG90dGtoyaw2PImrAU2DJ3dP9x9W8wlwvHUgDye8t/oD9RSc+mIES4MRGoVoFqiWrJQdtbLmjuQ5orQy+PmeNX6UHWmcX6kbibsz6Qp5VhXRJfGN5gH37c7eLL5by+rTIh3M0w/DIabxYDW5+69eEo2I6mtqsm+bat63VmdGRh3Zbq1NE1JZvf74PFCyUDAibHLMlxQB5RaHEhUdJr8UeJkcixXHzTf9sE9rhVdtw9MYzyYfZAiiIupVB5c/wRI72SCgHp7vEIHSKeFSZfMRHQXuKBhWWIGeEufRM4mD2/izlbCh2kie7sMJAzjsecxNFUXgUcfEtsMObim+tBbi/cXRHu7jTsCybLt2bLuaswPt1p6YqVzb6vvv83STWBz/Qu8rRl2u6Bj4CMrSCz8sB5DcGwwO6R9z3rG/KmQjc4b2mtj3XNiVXvSh3tJtXWq8WKMfmX+qS0AkME2jKPjz4tWW+7mQ8uKOC1b9oPm8sCoKXTIUayRzo3IRmkTnCKgM6c6iEkxPCcS7vz+khVSVoFAxzRpj3LyMo5axtxNJUQ9YMcuM094DAiIRlyHLq2gSpvmUOhZuH4pmBtqn70MvqZHg4SEM4nD5M+/I736IAACAASURBVA6GSNzmTJmn53YfSr/mlzg5fYrKKXhylHcsG60bC7KeZflmI9LI1h51sB5KYMYto8KNFYcR7iFx4Go14WU5+l9BCCYL6iLwI0gfgXyrUIzxm+0Bf+MD4NXj44tEimZUL07RxtQuUvhW0JYOu9Jzai7wIOn3IH4PxHd8c16a3JOBoU5clSAWDbi8COEfhjVNwVQa7gJeuVS9FEtApglNhSA2TiWh5ckc3n6dAB5zKIjL3eCvbjHLDJaHaq7HvroH+PI/f9k2VI5Cv5wRnROXy6nhw/hEr8VUw9TgPa3n5i7yWN8Y1OpTPcTknAuQy5u310oNwEViOuXEFgI5E289+DVZEajqN9ew6vBRzJ7at/jMJLTRiqek3eiuB6T2fq81ckCl/COzwrhReJ+JO2oTlErU45Rg5gyi0Wch3cysDNuJr6z1ZQaADJe9I8CD+TOEpNuota8aXRYizvw6LO+Ii6CODYslMGdvaXzgAQPPhN6C/AjSa5LXBTv+7c8AtAzyK+DElWvx7l5sg7AeG03xTS+33gB4kzTVLsfh/voBtcOv3fB885W89yLUSC/CPzZJH3MKhB69h1yThio7gD6YNuVNN/xL7C+u66LlbMv849ULf0Qsqput4WZf0ejfX/wvFMLzO0bjt6f7p2PCZtvV4SCjuP25jWKReMqZV3587xcnSWiJIkt2YK4Ka/e9+2DeFmHygs7GluEnKt5DaKbujDlL6epGFjnm6pel6stZTsoBSwREQLrkNF0PGTLTpbMLgLrpeaQMmQeJw8Shctdds3unSF4V2EkdobZDuwJAWK5cFulzzj4A6wcuriQukkYNwZNtiXOQCunkSNZAvh/lYOTV24jNgNBXho3k7x76HoaeRuCXGNxTD9D26W/3AJC+bOKfSi1CL90vurvbNHPZ8ADoIwDf9epvmz5oPQp89CDwQekA2xYBzxZ5ih7LHv/xbs2X2wQqoSAX35g7tajYPESqcnSZ9I/JrWIsarUyfQTzAPEbizLt1+oxNPf/+0slzktCiPQl81NUGOZic365Jj+boefhnoRH/2y3hpfmSXag7hfVpH/Bbi2KzQW8ksEXBUhRb0KW7VrpBljrsLHs7MtgI8M3py4kISDVf3u2ImROX895kEO/CSvV3EqI7VI0WITO/0uD2PQnJDH45hQhQbj59h2AniKrvkahc+ZVbuZPhFURR/r98QTgNcgbpIOwpj9bHDKJvu982EjKNsCH+sVr61cNPs3P0UOmH6kIxoqIX45t+ygvR/y6HqFPf/4Lfv8Pf1/f2gHQjzCxwqz9WW9JlZaSf7kBezoQADfHRL0C9JhwCoT3rK8ovbbSb3eb8LBGJYstTZ1KQ+KSO+BCT2PP0M9kuVHyw8iDTafVWQKT0vyXbNW984P/OZL7lpJizYfPgI5KGuoWoMMdlh723hhw/zaW6elcUpKnO0/96LG5efeBbbtvLkE58Cuv/QLlHHeWgnmLq9h6lkvP3IX5d9r84qWBwZ7knSSULbKqqmS88PqXRDDmKtlgjFz3TbxatlinMULDt+jOHACmFz+lvmC6B2Xm3pEVj5afswae1VrpdP0TNi6dFE8LFI5WJM7U3yBwU1Kl30F67c/BaadxqgO9IhSbJ+gChR6C5+fRr9YrgB+TCBBv0jGItzn10UWbHiiOu1TIb70CqDpAvIuiRmXK+4ibg8AemS1TDGrub1XhDWOqCHFRm3t6CPjoXfKONFFcczKaqKhFLl9CjldmtJ9eCe4elYs5VV1lsstmoR+Oh8VSy6lPb07P2WTi/rDTgIg7NyMhjV55fClMaa2gZkKQJnGlosTuFZcpSqOmhqKFzFHJxWq5rx1muJVZax1iAt6ilLaTOnBPaRoEbq6Lt8Wl6MpEc4tQVlrnCFT1wCWtOJ8Hl9nTvHiU/t9WxcPiobBEOBOca/6Q7/sTVQImbfnPLSIrkjCWw9SCHikWW7KEwym9p3MVUp1IXVg4s6yeTqcQP5C8+qDYUq/fgl4BupmxcHOYjX9X7CG94RxY7sbV1mHy4C3VB6RX88TmfEi/wj/4o9/Xt3wA5Pf/6PWr+PDhidJdWnDhwWXjRX+IuN50eUBsa6mcp4J2Eo+SKwLgQdHbgKkdKLgDyzzCkw1V4InaQbNP/Jsn//vS4455y7frb5W3nrlGbAvsQw6QeDh+emgOBCNJMM3cP/KhmbXyChfTvY4vlnGAKrmGcxAm3XP1tvta7K6h4LKR2Z2DULf7cR/bvWDDlIDMiqTqc6RR6PkzjizROzRV6cQL3Y8766SjUVnnOtHgtERufvjKPGZoRv1OrAixgmzCrP7NX+1q+MZtfq4Ao+PDycFhp53HEU4Ozq8/IB3Z8vBWgRy1VrVOwaGkkmYU3Enwg9H0I9erlqPPp+QEeaSEOFWWJLYI7bki5sd+f9wy6QryVbEzlDgzOdfizJaF+p0QAtXU792HD7wnfKiBtJK+HDutJtaIvjk8eNtjRo2buQ5Gquoecj7TPPsSnodPWEdMazh5SNWP+Q1zVZLeARUuTE32qU52xx1oxHCPhFBudhdu2dKk2ERz777XByVvf24+XNShF/zSAJCrUH+OEOrBVSUiLTFbLbE9azzhSutc9/K4S+rhNUtS3TLUw2GbtS/JmOxIM5XtrvcCJN1ZUectaKktzkRk66r5BCSKWybzCjuo2wtHdHHaC+FdkYdblc3zHCydQFN4mAetYA6ARUQCxYopu1opeqp1JjJvoEM+Kna7NARRGolFtVoKw+Hf7siQVN4WfUixIMOfzYyk8EagJ605izggvdEcQF9rjhLSB0CbZIk28ZxqQt7U/q7/70Kg8dttAWYstLqyK7tYLKTpe834XGsX/z/DGjz9LRVf7e4vki6l18eKpMrb9AH3KG868nleIZZ3Ko0jgZ4ai+bMDwc+Ol+uh3jr5mF4S53rKvVn8zR6CkyHMyflaA0ZLSkuFqvhnKjmC6ZIwo4qcmhLOx+3ZYCS/ap4+Ht7b8/wP8t5eTVYC0/LbwRPQieFIHhQOgkctNqNVGbX5bN5OiGYL7il5zyDUl0Y0oMqKmu6AvdU0XWZ3hkCuu8Zi9p7b3xWq+246AtKoizN6l1aoKUUn/OhSddd0nZwpQ+i4kL4rysrRRz1mWJHgHFyEvPPc1GSBsmD097VGRLWjXAmZS0mOacWefLfCVFpaEqEukJHhN5BegvgHckvsoXAe7ex+qopwE9//hn/QSsALnX7R29e6937D/NuYAeGaMJltDSJGoZAnHma5qBpkcDsqECFtHVe3EHuKFBilnXTT4IyaSxkX7XS7YHSQ/5A3Bfu4DDUY3N/6112AypKS1AT6NG8/w7Z7BtwzOANDPZtdBfFVcOEAd3ppESvyuaUlOEjLiuK/O1i5gyveRxrwpImI9H8fn+oK366zHkzeZblA6h05NK6981YDstV26AXClD1wGz+uVPEsD8gpqXxLu2cadMTlo+IU1Y1uBAOHUhVzYGJRriBCoKHAaMV817J0se6WZHjt92anfJDWxuYGYmk1nX4tTn7f8sq9lw+w9ti7yiClLzdWEJI83KpJlBSbQbIjKX/gsQB6YPIzwm8J/Frgp8J+MAJLf3S8/iDP/wDfQszAFIQ37173zYKdCpOs/5YlFr2h0zngtk+kICHK4BbTD/BpfDKxn4VQ14UDqe1PpU33xPc4eXYZQnlfkwqTCKfWs1W9t37VzMHLe71rO6qEv/ietsy324XttndLzpza9D9QLLLSvHy1Qqgrt+rOhml4b+bXKu18QOrn3JRMPo1OUEdEAfIDyz3X/7LIy2w9eG8QwzGnIv06FYtzqmfMbztzR52hoxMyka9RzX1KLY+W6wFjlTNvpBCiGfKOhwll29CDXWXPorhScduLiSX14QQdqaNeKlYowRPpearGU4s1Vpk+69qHThl5IwZLS9vNXSb21B4aMwT5CVS8feEmX94I7kpdBH0vsRVkS2Fx1l6HuRtjPEZ8uF/n8lB+toK4FuZAUwXwEvELXvSW9yfykBfhndTUMr0pVubHy77s5dVbC4p/MZ04XEyq4PTevHdp/GDraeXTITBo92AlmzqAZm+cuI+rJKL/n7k6V3cwAkIVQ8KaYmw1tXd1rNPrEm8ult92v7AHvjdo9BqhagS7PiTdWuBkV5kFzTwtBR0mWHoSez78rp3iEmGaGoeUms8geq9wkvf/2KYqlNhs534Yc4ptNKBYnH9LjkR9dSXy1Jyqm8ICFIjYaV9qByLsLw0SQM5tFsov9lyGKqZF424OwT2BHFmLPfSg8hO+3wFzg5QlBIQwkWNKZyiNr9SE6OWn72bd/glIz4xbZIxhMNDl1dJQtJtcZfePFC8Wiz1DuQvBPx6EG9tCT6/tPD9Vg+A9nu1xGdpae5y5moAZt+3tk7RUUNAPLXVEzsFNqOflcqwwm7Vvr/soccMv/CHS5GTXXbUt1V+3JP2I/P0MdYJlD/AD8vEe9x7A3r1tzLwwj6D8mm79E5hjXrd3+u0MVu/ls4ufS97Pe4Z6+Hr+VxcQXwhE+5JmbeGFs/hluYVFRFjBnvc23mnnK9+ftLiIg1MgEqDOuppIXFKeDU5DFwj4bkkBXdfKC3l+Gx3OmexZ4g5BEXiwDRdz/I2vfmgc3OCnpSnnNsCnrFcSug5RnKGVnf2YEmRpbkS1vIZYB/K9XrWXKnE8GddEDXE9i25C3jOv8cnEO9zbQmrGbED/JAEI1xJvgfwKwDvEy1HWM8RFPXHP/ijb38LsKKJClj78ccf6e2799s0+PU+m95LV9Q3vBO/MBV6nvTjatvjc6oDmfbM7BBPD7PCn7ObG62TM3qLRotdrBvw5B5Q3eRWz/jhr8FUzwS8bx9yAKjTTiq8pAZStvtyX9RphR2rDUBdV1v77/MmOrq3z3UFOX1VlZnn3lv1v4XufFhe0+eQORmMHGfuuBKO8lVwDi1NOGZ1E8uactP0/y9kpznIrdp9Ofp9ONdmoVV/59zOFMKrS/Pa4Aj23HYsGFaNeW0/W99gypPCMSJb8gsqVwQXSDdVddeR8/30O8aNxdjnMmeB7oaOCleJa7pSgLhCuqpdfDCXgtvCdKnXegjaFdpG/ry/Bnkj+Su3jhqDkPRm0StsBJ5JXAl8gazgagakP/7h/cP/3z/9Of/J9/9Q//AHwLyJxnc+/vgEgC/evhtTR16DJnat5X4znXLEI1Lld0HGKn3kvp+eWD/73z0gMV1WYwm+UasSGJgYaU+t11DFuEjYLdUsMYuaXEuu8JLQ/Q2tigbHPXTLuxgtIZus/WcNrap8jeXBLb9uTYqjzDyLGNgq3pb69yTaRhOz911yM33iUQ9fPbg0Q3+ez8N/zKsszey+2pvMv3uu/gev8+s15iIDe/mzNwjTj+6REdydN6hF7ySsK5Ei39bXTP/B2WejOr6h0noGq2zinMRL3KxE3zwDmTe4dBmDT1Faqzkr2LJB0cO0D/c2o1eDyeezRXmimjaVdTKrnsM/yqMpwTugiOBrEtcxyrWqlrCTvBlnz/QH4LR2owCy+jov6d/n4f87HQCfv31HAPjOxx/pa/79+IrMenzx7t2ao14PBdUyTNCf/xD0fQifdCR3RiXtAC+WUV5Tuaaiqoxy4uVNzSN3vNpr0u2+Vbk1wBD06MHdbkDkWPQAJQYhX6wpcyjEZVhoBVoeZcWQ4xQh9WCxCEJvsCjfPBPzyiox1lwm+JqgjpexaFggHgFPxeoh1X0yciy96uosHn0YZHux2Z8vAwacZb/Yn9fUIZW2f73wfQjMTIHdZf3m98cL8FyvUjg64lIrDi4dCpUitKjk+EIWObNCZq5Z5K4foTnLqSxvdZx8x3pXM5ZKmkYrli+vB7RApOT7sPimOsQB4IMpwarpfUCbzUy5KRKPDKFJgZPfhBHCg8/cTxTb56QeAF2RkuPD/bOU1e3P/Wjtyg2ZOw5+tXT0t9kC/PqLtz1c+vztO66HwOdv37K9di6Vqnf+/O3bAUCffPxRrIeIHWHVA4zujSq00/nu07uvS1RIR57+oRyW5IouNdnPAE6FTptcwi/RXgrERceOvP21+aGuHvwoocoy4d3nRqCjy85JuOlsvlWMU6u0UTcR1ZHYS0LwemC6VJ5xYlzKbc3UHY4l0msWxlNoth4YqDXd8gk5NQNRIOihnMr27QSAc41xWXP+8DIzcRk3Tkl1lqsgHpeusLDXrAqKnfFQJT7XQWAXGrbaNnI8HzDQsl5gcSxMK4UqoiQFP/W1Z7pP8xKYD5TKP2JZQJSwQC1HTgdkGYyYLsUdvc6kfCl0zkBq1rS5SdrVNCbdMDMXGNJlZGZgJNOi3fMg8DnJX4J4B+G7ft2uSy4jvtEDoJkSFol9/vYtZwP55byJNbdOUj/4uKfwcrldYE/0E5KYe2r2qhugV0jQBq2+C03p6/Nyt139Ha5KUEfhmcWpAbiggB4qHWylAecJuyzQczAYqj6uHsBFblv6LnCtIpZp+g6pwi7dEuBuTFqGIVeet94m5NDN0emAf/byQxRavGQPPXjE3d7ZUskpr9v6QRH23ktnGAdtjT0xybstP0Zl2JVcG+3nXzVBpx/U2gA0AdqosNNjwZsrMrvzqFUU1toNcZblyxK+9yldpJTVwBsm3FVsqZwXZ4hsx2pxDvemG+vs3AarQrPqRMV4laYAk3iXA0brkw//TKeqNZM2pdpoN67M6kXebC/fPT/4kPkG7AOC5FsCnxIMpUr2Pcl33hpAv2EoyP/4ABDxnU+WW/+Lt7xTbKFmTz08lpYkO00QSEVUjuU8GK3uAt8D+ljC99zjq8bAyJ3/K6uldrYupUUX9UjezKE9/DxeIg+R0Xnr+bZdOhtwVvy77+tTs3ROsUd+32GjxtbSYGoiPzTTWjwM2dBTT/kG8wyEzOG+GDPyr9TTLEzU7JHJvZJwJZKjbi/GhGzUlL7cjiovhjwYXF3DtQ0pivHR1YkKZc4D6gTfaaGdZOCU4tYgdNYgQeA5Qo/r3t9g7WqBGgU+/6bU7v6yKqqFQ1pV5VxChyXdwyjVgS66t0opqc6W7y3+kqt/Jma0eK+lR8eZWzXph9VBsDyWw1HLA7C7eKAx8qGsTrf2xkgcg08S9uJJjrz9G7pK4p0PgfeeSx2QvsDgc7eB6sCcb7YCcBvQV9x3P/n4S/iaX3/xBe8AFitbZlqw6s5kl3e9Q9eA8MrgT0Bl2a29qB797x9BPeZBID8kRoez7bXDAIWMhBKvnBnr+6IKfJggEI38njXE47ko2oZbgybpaBHn3EX63AVcUiXOcevayrjZGy8jeDZ++5YtCY+Foht+mJ1ll4KX6QHQaCZ9B26mNEdf5vXXoVUkmWGOPqvk91i+jC8rxJxtg51j3BtYicRaD5oEZFBtAw6LrZy4Ez2rVy/O/NCqhrFYHAr1AC1gU/h9QzQtel6MK4fyqOukD/r854J3aFYD2oWXrY/Guq6svMf8zOXXaov1XHlSxKOyXamBc9mZT7c8Rz0ijhKjMwTPMXAF8BaZBhQkP3h+1e3Y//RPfvAbpwP/rV6A737nkx5NffeTj/Xy4f/V5190S/B73/lEPflcZaAzc25UrHMUziuLhO9J+BNB3/VR8QrCd5FSyDeQHrOsx6vcMTdxdnP92MBPtYEDtdtvE4zyVId/hs0Ghcxsy8vn0iupGUntoMY+CNIOqh6MzRK53QZpvnHfFKm3Z63dVLMMcE3nEZvck1/stjDz0Ya86R/MeCromuUgjgXlvYaUdA7RFDC19nzgPiy1Xi9K2vwgGLOmsUp+p7UjTTlCegYAnq3cJCrF92rJKnxYX+spRztGVACvqAGmPN1PW8RyqOXBUS/9GWmYWV/92mYo4o47FR5WHt46nbinp1e1cc6v0X972Od+r2XJfz8hqaoqJ7UH8iJ02Y6UFuEE+WuSvyT5FoAilK87tOWCj08E3k4Ngo6kGk8V5X/97z/lN1wBfPnG/9XnX/D3fDC8/P+z3H2ZadPXiEUsJV3lBuG1qEdWKkvW5Q9ZDeBRwGslZGE3ucfqO55OXRnpxWbhv03j1V7EBa8Lj1wfSt0GijW1j3u3fVuV66EMCQ+c5hYuA7ViCIbtn0WvKdTTvMHvVl7URKZyJQXnUI2tpEvoiTBy68eoZphuBWY11VZd992lJO1cRS4GmrLbXiqyRsAFIcrILObBC2rir6YMOPtlAftQUn9VA9WctsNIa9p3MIWFtMdganFock89xaHVViA/R56ycUKQw0VlvkfZSp0ZN85IT0DnQAZ7NeumzIkJTavLsprLwLaa3aNIl6XlmGWG6q+PdWtD4p0mFYg5C7BZi3gi8Jbk5wSf6p1nkYay9H8Cx7EYhepzGh7LjT/54x/+w6cD/15XBV/tCDKkoILlZ4BGlVzpBa8X7ztJ1tGmxdKYM2m9CeITCA+uAR/6QlPv5QeQHPd5OkuZq96JMOx1WX/aypdfvbKfehbDTgJxsQQtDAsd/sBffFAMUyPKmTdY9QN1UthaDDipQIutvi8NE3pZMuitPnAqOjEZUuwQ3Is24vtU9tenqZ3NX0CBNxcCs+bhVZuKcTfwyRsmf+8OPAUtyNo8X9ltV2UDxGCuXq5cLyCfsqhnYrvnrbnE8BWDsGooRfR4gcp2nQtlMrhEB2nxGGjFyrk6rF+JDTqRb2pZY5xRYu9TzouXMrZV0943fhh2kogyVd5kfb4Y7WrqUBVzvLSROdwjcc32js85+0JKfkt7QP6KHP9lUVrdvK2oO6QNSv/lr/9m/Mkf/zD+QQ+A/6Ep0HXaKoyYJZgiFX66GarxkW/5ygJ8wIqISkXU5j6KRK1Vch0CsJDUw0O5keueXEnl0K5OYU/w7c/tMp7rITUvA5fVFwc0PCxTeDpzMBwf3SUmwtHf9bBPV+KkAS3W54WGckRdwmpWwDnEW64sBBJPTStSNyVpA06Z67lkrV8WVlRNo8ei8+e03vnWK9ipHFYR8YrkTSlJffTPvluaerYJZq5udbduzHXcHLrdyRHa76B5hWJ1iXKJMeSCTDkLgMHpjfCG0EgK1vpzcSLkO9GZh/N/46qMqsSqEvCsho1yhVKhVAXSFmUhIitRLKASQHqU4Si5PdAB8QMHb4A+tKDLFCtPEGS7L0g+Scp5yZythStpSdA/+9EP4x+8Avi7WAJd3q8IiS3yA/gK0kcAPs+deryB8N1a4flDFS21zV9vBCoIoZJoCRJ77WenRHVy9xDYVaQfOcQzRbXlPFxuyCWcawp8qv7bpk6++YB1V9wnHbGZcQ/gAuVpwUutMCpJimdHaJk4vDwvpx+UE+BVwvP0M/hUyK/rw2VBh8303in+cS7hNL7kgxRoF2Fr5cNK7W5BclilPFhslyaeh/Be4BDxKg8Y3QQ8spHs82BYy/Y1EPXL4xPiBQegDrwO8VxeQ2YrxFPlFRGj/0Z5KFSeBzWLmVooQ1P9qSQBB40IazhB/hmNQs5PV6T2acaSvSxCbm265QrLuY8MBeGTNy0EtJlg/QTybUjbAF6ReOsP/HJxcDFY/uYbgN/qAfDLHAhy0n81/MBskNLDL/6BWmATbyB8nKBPbAIf7Bt6UwO9+fT0Se3VmShx0LuHvLnkXlpKy6vKJrYD2iOrhM2T1jAE+px1S/dX+0RwcQm81CZpMM+Akb+flnDGu9TOotF0LoAf5M2VurRkkvk9PcDKzbMDr7UDujHnGLumhLkswrW33jMlk96nszQOJfuVQlsz+eZPuqDUQGvntons6EOrkA+7C7xjGp6yWuLg1ZOLza97eIjPadJ6YcbxE1y6aa1pxirvsM45sEzajz9mx7yre50azN4/VKDSDBYN/95aImw1s2mzO+jNUkYHH0lHWtoVrBO/+j3zcCH1qFIPZvX4YJv1jcCJwW3kbOc6iA8APnRUmb0CgN7k9+KOEkxN5+NdkOrvzAHwy19/XiVkW0ZZarj5YXol6DXA15C+42HfG9yHTD7UTepEm9MVxYOKrS5DHahttvSAA0LOMmO4Ati8s3+NFdqRctXivO99EMx2pXHW9AAHXRXE4LyoRppHOzRzjdzeZx6A1YnQyVxVwQ90Vw3TNGz6UK4FjwUv0z+HZq9/eoZS68/NK8FtiSenwI3Syhgc9Jai4htUIR828/jWHClOaTT60fh01pakhoOd3Vd53OeYQUZ3CWe2gdawTB2cu1gNWHuGOTSxOMrNW20MxNyY9OaxKUtUdOBocRiOadbygZPzmrB5aThh1AM5uu1QmaCkXM/W57U+E7vNZilUDFwkfeS480vxHxIFz2H70pHtAM9kOnizJTxjpNqvsfBsmjTmhmumK/0uVABjDrj4JZ8gc+xbH8xPaF1+pN02AG6kniVW3JODF/Ee4i5qR8ZDHVZNLay7fl2itgKCXmd0GHZAFR1eqTUl0gn3cHaAF7IaOybZeE9Pwt0bsGEp7HXvgeDSHJQar8ciI7XqcsT4sRoPppEHJR3dmnaVvfmjcw4MUClUGQtKsUOxNwDFKwPNlejATErepsNIVUGYpZ9yXpt2EDVAo0NZUgZ768gz9KZDkM4g10CDsbQbhcUZlZCT+/OGWiYxr9x+6u3R6aFbePdu/b01/ywcXFdLAU8U2VWS7NV3JHqKrT4IOhA4laaok+RhFNq5dIWOJ8fNuLrSdth0Fbs/LNatxGWRTXsGoJDwGAPPFN6Q+EDiC4o3Ek9eBb4XcIyB6+C4wgGjWFyPs9Dhul36dg+AX/zq14uxmmWTtXG2S7C+GCC9EvSd+jALuBgH/NArurRzbcgP4g3CM4q0w7lqWyRoMnNtE/TAdAs++IbeKWqqfzG8IixOY72Iew3SOaGT3g5QVi2ur9cohxPwMg8ldd2cg7dA4qVrKHZwMv7XIQSzTeBiAMrY8/aeY2HLzSHL7un75pGaW507hHfr8mX/usIshPzZhj/kk+NXzMm87k8bXkBkusczlAAAIABJREFUGKaFN1wcl5F2bQaki2/+yjOoQA61KNBDQ+sEuGglMMVUbZA6SqCVuO7U95e70qV0MglDvfIstWCqPHNNnds/xtJmHha0nB5MHvefA4Vqpco+Rq2bcupSahYyezJ/99ro5GeVpAKPGLohAz/gPMsvlDbfa2YA8sn9yGUlO3O2mB2p/p//6q/5p//0j/VtVwAVnwWvaDnllg3P3AF8LOljZVzzGwofec0VkcPBTGqhTmDsIq4ULoSePWx75Zt7ZAClxnJ7VODEA4GLah0FDCVyqybyFsPcudmiNfaaQQss42Kil6pR35dtPkAqmFRaTkZcK3tAHoXDwtylu+zGrYqKyg5kzgjQ7MNEXW/sxOFmwFinblCGpc8Gfj7cL2YXk5ANLc7rUw0Pp8yeKZnNykxMC2q3REasZ3uRltWbV6SPixDpmBjuPgAzAKN8rFrtv317nH1EzeGLfOsf1u475LOqK95UZi0iolFk/cyozUiZ/Xf4LX4udgf7BeDNfoWSPp8r0brUpjU4nIxZD2tCFfc2il/oCvOSvELdyLEpMEC8wsYHSReSzwQOkjdRZ4ReDTIighzjSPegtjFGLCYSYoJcvp0D4LNf/YrzRoWWG7NGc1ZPcVOuqR4EfQzpO5C+J/C1P8EXKF4DvCD7sScybhRvIp4WB10vzjINRhvz1Pct1vOCzeWY8d8a6Qnn8DBrc9KLsc5OZ228OFenhzX2TmvNuURHlU381DLy78CHaev0jRINr1x1+zkjOQufWjZm23QfKOyRqTOYGYfaHGKZ7YXMkm+riwp0UjmEczbSH5yW6PKeKpTGIDZzr+cYm1+jww/VNmc0DhCZ1VRUbEEl/3i9aXjPmuTbvX+SiCshIPUNN0x5gw9QnZbvV2RXnIuUsmlE0zxwpnuwd/OuDtoFnJtWzrHgEq+mWpOaXFW/m70RnKPLiVWR7hOaYQ3CBsQDOfaFEPRa1Bt7YVLPkXqBLBgidtiIMvEKdxF7384M4Oe//DX9ItCl/piLlxQCLdNzSPokK4D4LsTvhfQxEK88tS/jRD14lwad2sJpN9kAuVdar3Pj9gZBhjaAm2PDCxyyQRj+O32L1XrQxdxYUFQ0oG/NxwPNbzPyqn7PZfet6WpLtPbpRBmkaKdExu0KnA+kWwPHQpNLSemdcgegepjkXbWZdapQE0HCI6aXPzj7+w2Jxd7RBGbdyHFaYMQckMXFg7Ji6h2ptY8d4C2gix1xaH2EU4TX8h5LnmAh0uWhsA/J5VZuMVCu1+hd7Jp1kKW549F4LBXfua75VtVVhxSGIhK9dSSLoIbLE1L5IriSy74NnTKc/f+ZGjVDZ+TUA+tGHArz6LZlWz5jyOCRShnmaZfgqxC+C+kc5M1giNFeiGV66f3tufyO+vH/9KNvawio9TYixKGZSQUk3ZUgffPjAdL3IPxeKB6s73/lefBHls1udlZ9sFTz4jJ8CbjQ4eFX0luzG77MMk2ktDt5Zqsc+1qxmPvlm3LRtpdoiFNHoCWr8IWtKepgmkYdzX7W3MKeZs/vMQk++YMUyaeSjQ6Xj3sFkHjldvFwZQixcTIWmS0CTcVzTFa+VCdrBSj3ssTmU3monY1h0RKNq+azf+aaBWz5VvDG6rHzEMRIIdYtgSl34I7TH9Ez6UaqYjzlyTSJN/mGardgbUVUJKC7ZkvT7+BbuSK3S4LOFepFtvlnSplLQnu6BdPK0116seE+K5ycbNmvxtKbVCtm51/9OW2qAW2+DsOW68p2PCQcIlP1GNhBvOHgW+Zz8tQHesRZ07OsALD6RwRA//G//Lfx4z/50T+cEvDnv/wVl/V14566Ny+DT63rs1//GMJ3JX0SwhtJ3wnhO4PYLTx5wuzZCfCJqxmj9tn5Odrnw8AgZFBk/l1fr/uabCnhkgMjErmG8w9YWXIc07WHPT9cqat35bXZ+rqq3XKXLsUd5IM1B+Ba4kbq6p0clIdheQ0qrqrMJTbfpE8cMzZ9F2Smodd5ObG2SrYDUkZPqSe9ZsaDN9jSV0xgoxBgUOTI1967+5SsQnmgnlbZhfuF54AWmq5LczF5/HPurwSZ9uF0QTtycZLl6ARCjIXhrQUXXqnCtOPzUK8wDRFpE44/FUvCSG6TeLU/IAeS9CHlSDWv/gaBEVU3tEnqvjpYZMdr6VCmuLG4X7eah2QMGa5EV3uxpOfuZgLYHaJTU3VaYqcUErnimFjp3xwJ8nc+AH72i19yQTRV/4vlMLi3/+Tq7hHga0GPEr4j6CMJbwC8ThoDz3yIs/Rx0glrdWtr/qXXR/WfnOxWqZ/BIQZqlv5/cTuqctyYJGBmUm0550rpp83l1sWjNltA04xRZXgCRRr8ETZx1HrtlDhYU3F0YGULdlrf38Ib7X6YC/5XKcS4oyMlS+BMbT3J0vIvr5kP3H7A5i+erU5Mlv0e8MPU7rMUSnXASuSHjXOidtUyJODMJthm7dwY7WPy88V79RrVcd5WQro9r9TiqWi2cciMiVOIw8ZIsW3JBepQyhxnd7zoa1Rty5H4sGZUMv0g6ZS08qrSixrBbtBqVJw6JvN/X3QaR8bXa/OFVkPak9AVHDdkNNlhWE2+ngqOlGVsHtBqSkKskerZTvtZCPxWeCB/+wHws1/8kn/0+9/Tzz77JVc3+bJi0t3KCNXnYmS2DTYoHiR9IukR0puQPpb02vy54tFvDm88SmMP4Ih0/2VpJTxIeOXd/AOCO+uJTBXs5llEfv/88J4ud31AqFmEWjL/qlfWBD8P22xTsjJ38iNvuc6aH1BltPXSaihw8UL0NJl2V84nWM7Bfiy7Qnd2YQ2uA4XYGla7zUixvAN2D5wumDFTUUMpLUapEQuFP113V5ZagTx0xs6R/LpwJFi56OTYLI5i7Vk0RD4tRqDhNZyygkjiLnvXp5PTNhtOdYgpAlN4qLfVmYUyYk34zFHRa2T1wrz6Jo51J6UWiFo+D1CZF1i35klhi7RVF3KtxAS7P8MBJTCk2g9/XlNSnT/vSWpXIIR47W844O+Vgkwc3ojclBCYG6nnBexpQRc0yOfKkPS0lhxzsKp7Bop+G3LA/W97+CXhZ5/9gtNg9lLwcncgVDVkO3O3VQ/58MrGmuKmi5AuIs9hV5bLIUxba2q0na7ykXf7rxHYSO0iRkQmxeSXU2muNXk93uV32ZgrroKNcFEiMluCFLuoCdUWnDSietfMvj7Zxh/Qg8ENzRywVJe4QJG/j/thrjHh3dqo1XxcT/gUNQ+EBtmk4wuyVy+zSSjXptSKKVN14QLIZ1hjwVnGhi/OoyPPcsNwzvc0Ja9KWEluR6JSHZl4L9kAmgdMeNgVmYHBqmaq0Nngg7RwIPZiFwSFmfa7Vt8ObauoVOLWBXg5H6Mcl60fcN9e1N4WJubMyuGxBoqMCq9d1mubCdzp1vMwL+EmPe48sfgBKoXa7djVNCE7AHEF+CTgtoR6HK4WzzI81e88xmC3NndGz7v82G+oAhDWGqooPi2L+gqRyajKwLJV33ZVxleQBp9JXQrs4bAnEfyQVmE/yMJIt5vFPcIWaQB644guIjAsPLMvwOub/BozM9ArGyk2g+M2o7CnP76D3KXVwTjhD3P/6kFe8Wt20HJN6bHcd34SdoKXus3qc8z0hF/XVY6knROHvamR4s2rbubaohzebQkudDkXdZAm9EyVRYcm3ABXEK8oPcCrJwttBqgDs+26JawmBpizl15vztdo90T+6s/NkXoCebugccfeSJFUDSkiOhVJU1IuTZzZ3fStgR+xWry7lFAZFEIGgR4RGqSjtaXaSCiSUryJOCtaFIthqOlAHix7STtyVZfzCx/EW85ocCabAhcrkw8IR8IPdCPxzMn8O12JhWHZmy+W0HQqFLR2tUqsWZffDA/g089+UYijUVbK1abmYUQz8KU+lbl448YyKDw7mzP/8hdQPCb2GMfMq0dFO+XwZ1L5M3xxJvEm2584oiKkql8mrxm/xlETcn96Kj/et00Ny/zGJgRj88y6Xvh4IXceDiYNzjK7psz1wFQp768Tm6fOZ37CWQdk9u/pAq748d2DpFGDv5JX5u/djS2nz4C1XhdT6HLxB2yDsIvGSUmXNGXh2g6rtMUf+bBpUyK7kxtIPhcDz7kLZw5Iw/iyJeRU1tY7nr1Uea6uPC8J9fwmq4UqTIQZBrxrBg3IKTtq+7TL92b73CvOm+qbYpsa0rf1V60mRbAQcCE8+Il7LrNQN+HNMKyPDJ6AcTXQFJA2QhECQ1N5BPB50BVU2n1vBN4z/f9nxZ2T+ADwHYAvOJ2kL1O01uEjl4c/8E21AN//g9/Xp5/9Yt3n1sxydMKVKTLUjHmee+C0+6Uyi88Angi9J/AEcRi0+Gyb5AcQhzLRNRR6zUGHK2aKr1dijwp8olS8GZSJR7u2cqDI9nR7i8SKDtsMJNy8fsPMfkeFdaYAJEtlchpqguU4TDbhlomzvC0ef2lkleA/hzJEeawwaiDkpt/DZqVKLLCTHClwwoNvnt0Cmq2DsAZPO/pq8LZbsXcDEeK49bzcLhUXbmb1Nz9j2DP5VqHXppgcBJ4hXnzX7BSulvPWobUN4gNnuq0s+T3ItOJa7nxrsrYZiuzPErlUIvbpy8GkOj392/JQLyK105KlsxkkXUDUpqUnZ3dryUpKWtqeXYHhBKEHw2fCKe5+7qPmM1fDV09yvFeyEj5U9oRYWZOKCi1xWxOZ+IOb/84zgGeAV6EFYgfA9wQ/G+Q7AE92kLYVnVxt6b0yXkEl31wL8KLBeGl4WTc2Y+kV2e1CvtEVevge5OeE3iiclpqrmGDhlrOn3NIJqAFDLQLYmHKxXZPzt3nauiV0gidZkCzlbUuIaaphDpNq8m+giO7HRix6HnFkCZ63eqkHUX1sEmHg0s+UX16QN7TVhwwrElFKqQm6WKql7AIvErawdkFVbno9VDZQkifq4X/B53dJu3W09YK6JnkqYq8VJRdoqhK+/eTtyNEI8+CZj0XlBfB5MUHR4qaqxB6Q2o1bVwmZQRjMVW8w9RiXvLV0saT2dK/mLAItOQusA9LbgsjA16wWh98/yhuZ+3wAzb/qD4TmZmrk1w40xi0/a1796vAh1Fl/vqRu/ow8W5x0y44Sj74Iaqa1eXPknECGQS5H+g10hvBMMhQ6xsZfk/iF9Sf1uR9VtriywgtT0ExFxDcoBQ7phSfENPW7PHiBL1wplalLWWydH4a3AN7lba/3qfEnxNnHNZCyy2wS5A5piwwN2dThDLhUh0tbctWDHobVf7sYZXddE22vQAtOzwylSGeaMwNqO1BKw3pT9rkBw2bd/pG9uwZyUPnoYd2WbR9GkISj3JIeY3wYGnnyaJnoRbleHAIurBWnl/GRVQ8XqSstMOECiNg88zPqmxE5r7h6f/7KlcXVLichcNNc0w1DM89l3nx6RXrkcJQNplTKt5/S6soz8xl49a1/o6f0lXPjYedTqy8n8JLN8OpbuC+7KFy4P4MZj86pz5eCCz24/p7XPo0O2azOiBrpltfDQ96AGCIPJn8hLN+2yYg3wzzcv6tYkCebcl1DzJbDH8C4qudheOLgrwlcB8cvyfGZq4MSfmHRlgzNyyI050/zneM31AIAwA/+8A8EQD/9+S/GkvWtxj+zxgS5LiLvT6Ps8RBpvOATqacIHQCevMM9UYk9tWpziKe3ABcPHncXtcOfggpuvDhk4vTPNdJrXX0rT04nmIoCy2nXHbl6Wig8wtmy6yxmIgd5GPYXjMWSVdkCJdzYOkxSTUFu4Y5CzA9P7ZjrJ1F97Ywqz5J19zs+FpUglYeOD73SK1rMlLeqLIUxhyEjswHsYZ8B2fl8z8oEgWORC2+lgvNkwQIiXpU23KufGId+yMNAXgVVcIaJxROOZwruBzc/jwtOffK9MuyiNPZatFynBwSnh663+vz5A1irvHTsTXRO1pSRykumcWmxLlu048IxaeG4kXg2CORWqkizQ58sI77ZlBIgnr1ill0I48WC7Aro6rf6ljBQvh/kpyQ/I/HhxTY/DC6pce9YgCfLJiPXo3/+Z//sm7cDE3Mqm9RLE121BNOPXL56gu+6F1KWig8EryHcSH7IMoePhmvOfrZKsXzAdudA7xnjrYcM98SWceHcQD3nCqVCNUy4ynDN4T779H79hixBD5Gbg4OrjLU2KBN3NLF1NYUd/lkHxZEILQaInTPBdwnKSnegVjtvIJhLqgeQT1XmZSaxkeTChfQePBxYyvaVX9JQpIMzHpxzBtE38s0/fSrucjK3QXFZ3LF2JUhLy3b4ly56sHQ3hLIIJkU8waxabjkzyP14bRoK8LNMrH1mKIwfe1J6CCpY1J1tbrxzp199P7RAT5WtS8O4io483P53lmCtaSO65bOyz5ufZVNRYidmpXpTk0lbanza2AU2j4BWE6ZeRa5Il6AXpy7hbQ5g8VSy9EFcB/mrfBa6bD7Xtb5mYO2xiP5ibqzuVXjf2AHw6c8/48LF0pIhNxZdUJ8D6MilGGq9NW4CbiQy41wd+7wZkQwlQLHiuHPazsoT0KNCj163ERkK4nidhs3JcVrliju63xXDOYEhmiGQ9KDHiTDQITCYH6ptcXDthowUXCR99NIYWR7uxpKVFSLSoBO7L6MBKkY6zoqqWzcHs3TlZptuDihTE5obhHybdx9sWuLIHYCBxxUb5UOlqOfPcMa9wbWedWBLrX9rBzqwIu2/us2pN1W9es4WRNuNh3fbRA1OE8WFxaxz9LB1Bo6eHkA6W08+lWbYRcq85/S/Vn7+0ByWJNdgch0VrMIHSVj7ZHTMt23ZmoaiMG/w9GuXph/xsPY27cj5WT18WJ4+4Q6vYE6vOXYP+G4Enwm+HRyfgnhn628k+KO1Lu0vuNNuLLrJKYK4i9cTAPy7//T/8M//7J/9dmcAf/Ozz/jDP/oDAcD3//AP9Dc/+0wrhqQ8VuXoIpfIKFXv0hru4sPcJLyD8AZcII35b1/7gBum+L5W4TZzwryLujBv8IccOlH5QUVZKA8gLswp64MVemf61ltfXTdzctyyEpBLs9Mb50gRTDzMCC0gNwdEoJOFpHXilL/ADdOSNJLenw9BZPJOjBSFPPkqHq1YcU8dtlEvK8diY+94+ZEoR18dPUaPBwLuxw+Qj/m7RnLyU8kITpel0WDYJLx2Qm0JZYefmqugGOBIBHpsxHiumze/Tvb9EG6G7YZrwJidY0Wk80ZiV+TMJ29TmTqU2LRF1Bu1YgR0jXrYUgCWz15VSaEt1kn5YsntfIayZSs2u/PkA+skdIRaGnJ6OG2Og5LglA+tN0A9Dwrvja4s3QNxDuAdyV+Nwf8K4G2GlDbl6Bn3EUZTEzNdvzEH6mU8mzbZP//xn34za8B6+DFdLyulyTANE2tYAo/5orP0quSZdZmTUBLg+LZwVF4FbouiaYh4hGITOGwjfUhIKC/Vi+eHKyqRO5iBoAR5Ul2uQgnKiEoR5sxeGxAe2gzWkWK0Gahu8trlc/P7tokarNlj3u9nIX99MJ4s/v3ACWBDJCCizCjhaKxsh7V7LTr8cdqmFl6F7jrQIFAFMM5Z9PCIjBgcAR21s/bhtENxKXBIdWgEPpSd2r31g1uTQ0lsvvmlORMLjguk88yD99aVCDGpqVT/Y2TFEN50qj8/s49d6OU4lSvPpvYuwRw5kVcxAPyApJi5FH+VEDBSqstJHZpeP3ojUGg+lXLRsuWT4InBpzzoTRcmg95SeX0Xkq4Zd4ZYSMlq5j945lCUB3Pm8XMAH0ge3vNvphbDleZAORU764VL2nG7T+F8xd4A/l//4T8TAP7nf/6n3ywQRGptHdaqKiVXnNLzySnDssqDT9NbJgBr9355MBHIka47XK372iU+JFeND+6xtoxZ1obEOg0WEKLDHTPfL2pFporw1qX2yBHaLV5Krl9QGdJQWY7wjdzQkNbbNaxWHbYbTjAc6gSfxF+5R39m2m4vpDPpA0wAzYhyN9pGXadnzMWuliBVnBYfyblxEdJhlGcN7iIpSbiipuZZpj47Gt3DOQ8GLaMd+bo8prEqarb1aF6hISAcOfxrc0sfPoCe3TrlyCYHime+PLSQh2u8+KgwTis0a3hXL2HBWSKHjjykkNd/cy6RRGfOlZ8uBQPR1A4K7NTBIgVZu5BlPcinlnPLKtVEm1dmmZOa6yFVwUOvNhyfEJ4Hx69IfXBmwjXzAnNGkiix2DjGyXXDrsqM7Inni0F7exxZQ4nf9GH/zezAWt2H6mzvSmjxTQuflBWrHQA3r66uOaTSM8jN78zpuORXADZjlZWRYR3ucSBvylPQxcXh4Q41o5dzFeeDoPmea/6gB4gpOvbZegAcTG32qO0Twc1BlhpihPtBUKXQ23zq3+1J2XbWO44Ow+L7AHci15pzbapN/n6qOC2v71zJVIDlKY6xdB2bqcmVxJS3aSbbj55O5w93XdZLdXMGgDilB3vv4dXjgYSunoAigo7UMkQ0a5Cj0FhJqcjh37Jw3yZJCbHgfpeMAB5++HfTh8qIc64rwgaBTm+BEtBBLi3RLrauI7ceWSAWtM+ICj4n3E1gOvOeCxRqpWOkPdtlfiRmTDYvKW3EQqb7KKGoOkC8J/U5gA+W+d40w04GSTMSOzSmDqVz8R2sZ8Lcp3Oikn/rT/7f4wAoowuL9NklYCQWvxNnpEoCKs9nIdzrQ3XknjgHdBWk6NLpEsHDPovKXmNAl7IWTiAiycR5nYaBnGavUdJHJK+K9YFqS6+XjjxyR5tKt1SxYbMxr9j8VceGGQGHtxBtdRdxpAMoWfUtGQ6NSi1iyY3R6TT7GjfA5tSFTTzN/d8WH/+Z9aEd77SikeXBMHmItRZDseYqhvhVWmW8Hh05ONSpfQqavI+3GSuaG+AwQs5gjZEH4uHXLiCeQZ1LFFxBsrai9aqISCqhlU7MtR3UD0imJFOKzk+3rDZFty1DrmF4QUGGdQc7h0NcmzYMqeK003p9ML0QFTUaYIaWWoJ+mt68pg33sNTf+2CW92+XGKyRq2wdufWaeQdYsFB+2vepSG3df0gdVVAQM/0vP/nTb+r5/zu0AHMOiWmv5Lq8XGObiSlVIl5AC03XrWHHMwollgO9twBeA/yu27etifLkFdTFe1Vw+rTNiqQVevmgR+i1v5+FNZ4fuJQjMTxn8Baod/JbViI9MR5IUkshrLZlT0iIF1DXev+dHV5Vwn4fGCnbjnlx31cy2QOI01kCGxRHQ01Y2QUtZ6Unx7G8J/UQ2CqhbRBH5NzjiTmUKolvDOiqM9dwld7bCAxUlorbrESCWZHfbACZz3Euw1DQaZwdg5Tvf3QX7k25dQznEpe9te9CGD7fFXnoJcvfugI/GUdzf3oq6ojulM4+a5KEfcvq9MNcIZ+HkeC32mhB4S0AnisFaIkwTdiL3P7lJ/2aoJFKf2+Axdno9ZQBl7Vg86u85Ej0kJlYNgGFpW1NwDf4f/vfofS/l/++0CB691Qdl+sF6kVeXFFNzmWPkcO5/CrPULwGdaP0rNCN0Ct/y5vb1cPzhNGDQ9bNEZS42+rrfS/2lM5qWLaweQFxzlWSguIeKeo5fcP7psRu6MiWm4V2FZH2FoA6ktY7xLkm3fPvVyLPWt8lW9+HSQdqZBuS68Ym07iqGex0qm1RhYPAGap0ZI6FQUfrLy7AeOu11bWSgKN0B2c85FprVEqRD1KdHgjWU3y46a/bM/pD29Nqj9nykxCLhuCcN5lWsMeAcPVkOypQJEBnP2b/TchW2ly7pR+/cGguw7PxH0v4WjixqdoP+Rl+Xsxdt1bWJS0oZugow4KCmyXdWsJnT5sTDuPFMzGIVWWUFmbRxU5mwhxKFqxGhsJAMbmPrfSsj834t3/5n/QXP/kzfTsHAFeEswkcs5fTkmtfSrgs9eZ0XTMo4w5tuvkN2kRdct/BMzW5+ADxIukVMzhz23IYc7NHYnePvNvDPxaK1GkqrucDfdMx6Tcs8g4hXIJejPlrKWmMr0FcMuwTBSJtz39rM7LNeCKCTpslQpdVr88FNV7Kw0Zlp6Bt9xkbpJ6ZCTMGfeJ6Rnr8q/VSOdZm9mWIMRb4ZEjcDfUIZyXfUhhEQvEqmm6LPdXC9Vjx4Aw+nLbYtAmruu/CcvswIIiBcH5BimQCrbFr01WtklWvg6YLMF4UizXIPBLImlFfULon3QaEFYEnjXq3iraizU+R4S3E4QNoMG/uYieGD8jqam8L3yvtwiX0Kuox8ewYt6dSC6Jhn4hIlp+YrZqmwq89Mwu1GELEKrnu4E92+/o7UQGssU3pJJ0N41rq965X3Zu2XKN0/JQWx5tvxER35x98IvA6ciBDIYLkxSfomSpBfQD5YPTURYWBzBinPW9E7+9TSrwVopMIDIxbviHDzL2M0QpoZyGzM4lnh7RH5rQNCgdG5vcxP1A10U/fQK+a6twfvrxrgNHeoM3ymJshpcOzgIPAUzjPsPjKWZ3LhwdPtyrp32eabPzaPif5NjVwgdica2fJsjzwkxxVxcjcAQdv6KjNRLkckQPd0w8Pe1U188oYBqr607tVbp+FLyi6EjOj8ObGvpiMobIKE4eBZOXcfvZBf3rff3C2AS1q9C1q01fu4qNWVflwHh5V+fds/0Gs1NF2JzoTFNQto8BwmAscHCOTkXL1V5VcyXjPtXXOgmBU2x/lWjRw1O0+tVQHMzhFzaXQt3oA/JPv/6H++qc/Ww+EWt+wPtbEOhGv3XsnmbCY95aIbgvwVctiuFl4Vqk9W6C9gXguKORswfGcEVpd9g6Jm9Na95Jz2nYXEdjcj41Q7CPGwIjBHHhd8oPOSyjKR39BKNN2CigCbYxOPg5LeQ3rZA1Ke0KYac7FRGgnv9kIGLSVNEMpOWwlvZH4EMJHDrKJWeGAqaArymwMOx1TKZgtSSB4epNxGeJpxNqzoF3MQ9IbiFjApYnJStwywHiDAAAgAElEQVTWsHbeBVGUMH0Uto1pTrpFqf5mDJkfUEa5Lj3IcTxXL1WL0xfuJsLVw3B/f5qg4/hvyj6GM8VJPhq1SGfDw3fyzF6dww9oW7/LX+zaLDzSKBkv0p1IJcSzh1Ag9ISM9j5sDNps8c2fLxQYo8a7Zzq+5u23EI2b+MEF1PIXP/mx/u1f/kct/50S8K/+xY+Pb/UA+OtPf8Zl1w7O018NhWwEmHFgExVQXBoHVapcWynXFYcR4RcvXi33lCgdSpPJhnrLwKuVfTSV5wrhkYwRoSUPwLdSoq24qP6QMeW8yIt61GAtb/FN0iXLfu2LCmqAMShGrQBDGp4Obbn21ChlpNTzr4Ggh1MSJ9A0phS15Z9lKkqLtNr8MWZl1XjtYnpc3d9fzGEsgpHNT6z8+XeSPi5AS6ZuhG2mljKIQ2XSckNgd81ZhoE8itI5ubCK6v01fIFXD3Yzj02RICHbSbxLqI3B1RsIRqR/ow8JS3A9wJOgQ3mY2W9fmvvk+ymrwUG21Pzk4lGdPnxXp20XgLMae6p8FBBUpTLN1Kpngh/8dZ4np08HwVsOCSNwFx7MWPZ6wj2JXAL0Fz/5sf7tv/+PrAe/nru/+MmP9X/++/9w/m60AFMhs/B/TaGpuOVEy9Vua7L4ss6unfxmNvoVwEel/9dEndaJ6A+1bqwknuYLNJLsBHRxkOVDYqbSZHOmCrCSfYc860+WIAJDN6U3m6mn1wZwj4gHr+FGHh7J6KM3Ah42nVTcRt5WBpL2jrHy6ItGvC8x4KVHuEycHHPQlfLph0kH0+tpuW1uwNalRaK3ToDPCa3QI9HC60ACJipn4Z0dh7ewEy+HquMmaGQ4ZhIwIm/2+m3C7j6WM5HAqaiSynsUtX37zAmWhnvym+czpxlv7NI7/T8H54MxIdCd2KEjpcUmGac2/2CV/56y5uvPWw1WzXM56tD1dwy3MXUkHBVOuMBZZm6jD0/Tqg6QT14D32YLgcOhnlevuO/SegdHfP0yDfqLn/xZ//u/+Bc//soy/1/9i38e3/oB8Mc/+CP99U9/tiSh1bG/hGR7bbQ4FrxKWuaZVuRBpVupwQhvSAHQykIXwTPyDx8euNI78AJEbpaqpuVY2M8Zlb2zQj4Kx5G97RgY13RngVkaa4/ARYgLcwq+Jx9ew3LNLRJOMthTYGwnmuS+uahkSBzB4vmVKQeGfay/18OoEhjYk3Krw8IYZ/zVOlF3ARkpdK548YysIvmFV2iPwDgp3DDwfqTv4BTwypuOQ7bFKrBniEmoLfO1NrMZIBtYe/QcbZbk5WQoIFrfUALmFVNuzWuHgnZgJys3krpppvrWOtYBnTqZENUjdQQq3l7JhPoj6R/fNlpU7PjVUqqxqA2X8EapsxIms7EMS0ff/An0uPn9i7zpKBN8rs520ESZgxxDvftwAbIszuObmuh/s0rAiZPCkpm4AhS1MN05qUaLk8l9ol3DSmSSLlBCGEyq2dIyqguBTYEbwAelW+joIWO5OIWrHWo3TKpr5uW5n6xstVzt4NnleNF7d+SkfzeDbrBKycnl39QfropsYj7wg6Bii/4DGsuHmQsgolZBo14KDZwj/XYPHDxSlDMBesAiBncyDLv8zHQZpGb9sCf9MLPvGMmaC7enDw5MTUNPkoUOtQDP67u5tB3hIaG7vs3luZy6dOusQ/s4cnVZCVaqAV89NJvjxBvy4cOoLsdzUciexkrf/L/fmJN9eiBnMReOKfOthw3WgilYc5FKYW6v+ird7jDbUzlvLl3/zQEiz65Ursstfljq/eQUKBY5unz7nLq9mNHYOez7XXr4/84HgBYT2o9++H39t7/5dLI12npV2gwtMdze0xOHXX/OkfNOdWrdS6V1uiBzFjxvnIoogLwKelwCJuuEOTzNvqoCQySR4/SHvr5ClvHiroFDod3uwa0BH50opI1gypF7VNBVylnY4wjnICyjW1NpB2dipCOwsBt5c+aDSGnwTAIPh+OyHgu2aRFTleIXd/43u/lF4mTgphxAPHmv/tplcxptHFmNXFFdpqItCThWXpq6Nou44lAvnhrr/8uXH4cfloqrOZNvWIGbUDLtBJfouUU0xWiagzphKQernrrbehuEbh4pPftrnpHX96hRhtZwFnaM2J191nqBzgtg/+lmL1eE1w3mHIh8Lh2EyGuaqVhcwOdeevt7jzHUdp35USisF/7V15T6v/MHwI9+kA/9j374fS0KhxY9NP217YovAGHCMnHOmU855/xKVeqsNzs8ATwjdInJYrsADARuYnPzKtyC8GehRzDkmO7JhaUlXDh4S0IO9zSFseK4LKrJG+1+6uFDxAkEgSqF28/BQnItpc9YfPx+1cKmGm4sw4lL4pyk4DRDL3IYmpl2iLxtWDcOGcgE5ZPUkUE+OTkXtCnwCtAW0mtMnwYgnJ7Yhy9GLe5D9a0lMTwbM/TjZqDpbVGCDbsaj2WPDTKrf0U4sKneqyY+Xxe89wzTEg/PfUpafaZQpwVAJUPs2K1OVfbQL0q3oxk37lXKaXCJdwd+F8aogNWwcu8UcOSar+PIT1biM/EE4cmgNkd21SXZJsRaEa/hOb9zD//fS2hQD/9/++mn/Kf5393nqOyMQY5zjS+uU7gGZd4AnG4ATAxisOSTqQvJUMYUXbz3jZAfbEWRU67sF1hQaMciu44cPw8FdnNjtinE1hYIJoTk3LN3VspT8xrcjB73anHmVPlNZlTisDqFjlJGSwHYRG3yAE9M6IN/Lji8YqSCR8xeQJDicqaWQAogIvay0UcWlU8A3kK6geMK8apse6Bo449qih+KjyL0cYQeQ/FwRmxUKfl45m2Xty39H7/2Q53unQAUkkeW3+mCzKEhT1FHSFdTfIKZpHNYbdA56/lrONVY6gW+3w//HDwmlFOn3/ebqFb2KfFgwRyCusrB2RmLwpnfoFOAI629uLoq8Nf2LZ/KwgPAewBPoG7Ky+agdLA7N+afGzhAXM0hPKWebUW6yVYy9jrzWxqEr/m//+Pf/QcCwP/+7/6Sv6MzgHz4IeCvfvrpWAAgGYWc5dO2WARrWg/eZwdGuV+TGdBQRkE8SD5L0Xny7vFOz45y0JxS3Vg7EHPzhSzxh9hI33QEciILFHplf3Wt55StShlRSrSk3VEh7X0soFHYQSzEhq5Cuu+7WBdsoZCi9N8OwfBOWIzgzoErlMPAtI+KAJ4j8DgGBEUNO2kGQpA8HLx5SdKuTttXrxJe2Ts0fEC6bRb68QO6HVsCMZQWa/vr8+s3bt1DOEKI0+pKzF17bgB6NcwwQt0XssFA5K2KMW+QTk/8S7t/er1WUVxZUZg8ZCWVf9W8OPz1PP1vJVaAK/1ZxonRBi9R6nXe0YstOwO9joyEzAjMDIcrHXjChnQiKm9kCQ5dKdqmEP3tBcC//vN/LgD4N3/+E/1OVgDVCjR3SSv0sX5BuUebjhAP1fJDXQEii3QK5b/Or+HbpN4ACNKtYl584jcqWdTNZcNRk/EcoOm2pOEwFg+zM11TdKRuB60oCZNp0vsSnlPUDSdhV+SwMFysVMlfuoiucrLE9n6Uy1owUv6phF0I5yVZ/xUwoVH9r4BDkcz/9lbkD3pAuklhrwPOyHkGlZXPCfC5rJiZi5e3H4QbhBuzjL3abm1hkddp4i2pQiyW/TOBt07+eUJXDCYPTcfnze/fkda9qJY4IB6SrjnvwAniWdItKUS4Rr73z7nvV3htmVsLKRHlsgIkh26GdyLttmR9FqLXdfn1b0Ic9pT0g53VJ67+TyoEB671d5Xwk1t+L16zUsjcQ89kTkyfwYIv07L7mtuHf7082HXb/yPbAgB/9Tefrgkl9xml7UtnIRWrOc4nwRDIogrVv1Nx3lNd+yr71QR6IqOmhxOuTvcQJt/gQOAxefe5kY9QJ6ZkWIVemR2ftNXOm+OuhGqkQiwfmi1dgmVEyb7Vq8gQeqDFOSDzfIPGiqPz71ja75He+a1WVYaaMLl8ekgjlGjnn2rinLqAYF7cCS9RMhPsYQ/rK4hQDJJHZ2uRz5Jeh92RPhzDQpoajh016mtw11TGBtrGqhrMFYvfjyGGw18HOW4tv0kF4mZIwmkdxuYePRy9Woq6w738LVeqGRKaJX/PFYCK1Z5F9chCLcNg7P8vqo7mvMk9Wx5se1aXLQGutezNkJlDdRCWkhDNPoiar+RBkqGiI6lXsUqKe+TLrpCjbveXt/0/qhkAALj3xz/94fejJ6kvWuQUeXdunkDr7Ms40nPBIsSIUlwqKsu+7W5CUbdzBltIwu5bt/r/0QyVKkqyi2YojuXNRkgRxBlJqGWYjZu0IJRYyQovnCZU3bIsr2WuMt895bS7NeouEjIBSNG2iYhIg0LkKO+sUUekarFiwR0J5hcuMHzz3EKVsaMKq5DLhz1/ktTKe5zKkPZQPEp6MAM/tezNxcJpcs9RtyGoA9RB4mSCS90nZ8w3cn3qXIB038WUQFc7P87QngGlPQsfgpjj2ayvU4oc5bN3hoCqhY7FL2/FoxOj1UiskJQQT+/l63eZt7p1FUKwDTt4dvURbjesotSZKcBJmQZxQ2Lm3Jbw7LZgZgKoswm/HJqjpT3Wv/7zrxfz/G//91/yH1UFUL/hX/3Np1xtjbX706oTRGn/2755sfBnW/PP2iJqB5wjkzYbexqxPGPx0mXj42Wo1INhTzgmGdbP/J5rO8fKVk4oOlNjuIfL3pWGgWauX/mcghjFAthROO4cfNWq7FCzHKFh3ICPpBipSYioXfEUltT6OsM16Fa5o7GZwp3sbW2W4bZg2dPqTApRztX+QB5ViuXPYMCJcEsLNYZ9BSPjuHjE4rblyECRPJNiI8bV7spCrSX7K7gVCSiSrOzAUF5z6DY+uOmuLcGZQI0sSyyt1lKGdJLKsgSuFu1YXj+wL4ysaKxajLmNqFu9UoT4hEkTqaGytyqZbaBKiHIWInOuchI54JQQYzDuhEVzvlUzlfg3//Inf6uU93/9lz/RP7oD4Ec//L58AJRarHIbZ2ruJGzUnyMmijk981Nks8Rkt20yw0GyhCTSPXjamFOZfI+oJKGUGIPULU6dZt6NhbyTjo8MhGYaX3iC2iJQ4Z3JN0+Gf5WJ25T4xln0o0Zcpf5b7ZFW788jEjBRyjcPq/IgcCX91MGkFW5SBvAU2VysqT8SHqpgY6I6nficJ2LCKutQa8pmbVmyrzqNR/drzgPUbmHTkUw7yNqAIMb7zG2sqLGQpDDANCYtNmX35DZcJVwgnEEdudtXcgVqxmB0WxBp2y0PfF4Qxg5mSVVBmv7vNycP+XBVCHc283uxUdKg4dcfKUFPihDbGGTAZ8IH3UahYshA8EbwUDrKBEB++Ev6O9Yqc5n4/06u/X7jA6DFN6os7bYAL0pnlaSzIKHlBjw9tVY73HJKPt+3nOzWg3/OKTprNnDJrxucNZdCKSt9tLpwA3BlWnMuNjE5oScGOZQcOUrU7gQNMfPnNqdZyqVikYQ2ZAvR+XpWx40KtLPmoEg5Y7m9pMnEN1xSHBxX9/Gik3lLhOQd+xm5oiTA4YUz86aOrYdRVidWLLvA3aPwkWlkhAdvicYSyJEHw2QEasGaUZxT8Cf//FvKd6uSqnSiOGree0aIqbs3oow0T5/IQWRVDQFE/sm86MtZdxRYA8w/bzlPvQe3wvp2BWBJdRTqfIK1Y0lUd2WJYEqVj/TtWNNvlyNny1NbzKMHz4oTQIwJCV3CU1oJ+CV2//8vD4AFD7KOAtnIs5lfOJVSd3psLroOlW331D0mnI1hmAOdDcBImi0jWnJqgyqUJiLCfHs8UHyyqWcYyRURGmOwNAxHQE7Z5elGJtIoxN2Em44Ln8lh8/eR1ipGLf9lwiDrF60h31nOKacBG2wxveRR+PPQKMmxD90tq2VsQAZX1FbmJIaDTWQS7Vx9zM37MKgCFE6PrG9E2XpH2DtR6bc3ndo4+M6Kmj33WhxiViVYBm4kjkHeIFzthz5FnoysBExgC7GVjJVydM6erOk6+/TbywGdeTmkKUljkkFdYRbBOtuBSnAKtwk364SvBvdc/fIEC83mH9rvmwfROCrdDasnYz78pSUkAP2bf/mTwD+i//t7HwAu//u+ZgUzlDIvy9tI2gYFJndd/nBm3BEuy96g0nYK6a1Zoq79bFt2xxKsMaSuRk5rsq+mxm52He79jewBz55Oqq81U2zCWgTs5v9ZK2+5UDh+Kz9UjDTkm3xktRm4uyA4PR4QyP+3vS/tkqu8rt773KpuCRKvZGW9MWDQjCTASYz9/39CnJFBIDQjiTgmDJK6q+69Z78fzjnPfapaOA4GbEQXi6W5u4ZnOGefPQzhHRgZADkN8PTemxR+eodmHRtNTV1FgKvMuYxrLSXRbGYsvmJskM7MpngImpOC7VSKWuJYLfefieQUebyack4+ZBiJm3Fbnvydeo+SxkahRSPW1qhtzvj3KNuDhBNhg5SxgLvCTdIPotlwxSgux77y9H5Q6h7K13EqTzg2eW/6CqaTDxdH4WkB7ZQkqPIMzPcpuBojUsWnivlunAVOfM7tXnH0OaoWfmSP//MBUJOAev0PHn9mjbCjZs4htrhGIBHXw7wx2sEtaYkJy1tWmQPAlBpnwJtlqZomirFACy+IcVQq9QPmNQIbl16GcYZrlSLUVj7WTZouLgNT/qrIjC+/vpWHMdSQV9PMoJRXr8kM+gi8Alx5LKQcP+W0o0g5ORzJUin73zYepWfjYxljRYCKEdekGYNZ2Hi5y8kMGGlSrJyiOAYik4BYppsa04J9k+/NWIdezLh9S7MtgxEngSu5v8wYsR7lVMViBMZKQ05ikkrg5Ahn5TFRiRWAp2gKnSJlpwZ/8e1XuAfZKCl68cIy4kDNKK88/RbMxEuW6trxVVAz/4ifz8FmhOdkZcp8v7mlDKpYgyzrMDeyz3vovBtaem9xmAv40z9ef/PFPwCiCvisQsCX8OU4/eb0kC8KraIHzIDO5qq7ZE8nEeVMbpTDpAZHHxz9MRm3ORhmEAeKsMtU/iluzQgT6WXXYSEtXzVNfRxSBwCOFFwAT8wAElZGplklDuoyZVYCWnzchwoeBcySqQgsUVpTjdDroFCqxlrgI2C2BFBYSW3SN8Y8rbdIVlDGOsg+WMmUrQJnh49BR2SGkTooTF4BZcshMGaG9pAcd3dpsNh0DnK0SG3e5G22GcyOA8xUWKGHEGEGJfdIMW49YKDtZsaj1IJN6fuQlubN1LBzzNEivxWVWMXcEckTvIxKCcScX7f0Ct48EuNrDgVsBrYRFOM0T80qr/wK07s/Kq2oJsTZBR+sUy22+PKa3BbYvcBhwo/v1v+TD4DdKEB0tulNWu458qcWwvBIcR2zV6x6BWe8uUiff/XuQSY0j7m1Fm9BZsjDAHBIB3tGKGmL17Ik4c2No+shBFI4BleOZgFV7hH6OUWkNGyhkqpyByo/cArfQK+kgaQ7c4lzKquyUCqGXUDGXgk+iYK5NTueJk5F+u82cCF9eFI8YQofQzF4tmVlW6JrlbPxQp7Zxihe5okmurCm4Xh2Xxt5bLTjULjhGGquyyW9dYErteTk9iHPNQJmOOfE3R39c4i5cuTHBgVhbthJD7WhiEUqTMC5iMc8/83MCgqJ60aJ8nMZH6oyBDxZee4VMxa26+UsnSlGHLMenUgGaSsdu3YukgX9buKPPfHnj/bxrVxHX3/l7yUBr7/y87YouMMN7D7bRvOli5gVaSojwxxSywoG4eGWI2H2SsyNXnQl11rSyx4El1W57MVN51WhrcOjr5UA7u5UeNcJEco4Ywm1VLrsbgFsjDjyuG0mwUe12yyEoFJspmApaU6pW74KuRjVrZraVAWOeVhWyZveNuyIixhkeRKqzG6SsTJn3Fnc6hHuUb2uz451IpGRf+AqdeUGzTYr+alcFjAhl2sNaQzCk7YCjkE+VaQ4bzIcpJyMt1E0+JChJxWEMIVRCMeY/3ObpJ1xYTVq8njPtxEBFyCeMS2/AoAbQzKeWXxRJc2eRJ/CNFJW5InKq1R6rPeYxfeoSO+Kf8MmRT8jpE2K0KYkfE3B8w/eiVr6XtfnF9976fH1D9eueJb8P9ry/0+oAGKn33/02RIOtZi5YqFZNgS9/s2Ui3f23DXBs/V1Blh4mnuw3GarFcigDQIpdIlxYJ40TFUdtuGKQ8bXIxvLLk6KKe9JShhgzb04M7Ua82Qs+m8M/iL6meoZX0vKixb651RYRv567toUlGgmSDc25pU5lIeCx4G3M11hs4vFlCwetzi40k/VDzKidGaEC8+g6JFvOCa5CuU3mM8jR4A8Jvg0LMT4NYTRwEHl8S8NqeBYZ9oD8kCKkNMorTfRIXHycPGZ1Ag64ZeXuWtTCnRi3g5sw/IbEyOVuGy7vLOi97QRmDsWpOVsPgE+jVXxNcoHSo6rtO7CuPT/nAHNLrrFezadnNu3CK+e0v7ckK4f68b/kyoAAHj91Z938YzEG6/+vDdEXIgSXdBhVlZT2juVmitQ+Sw7EwQ8owzCRGzgdZb2h7kIzkh+VvLDopjGXFhJIMIs6YDEM4b6rMZErYZLEX4KYVTRu6EgqygppRglvudUN79KSaeUpaaSR2G8Hf+FeZf73GijoVEXtnBugsK8KMjz75dOz/N/SJrjjzS38jRuSg+/+0D2047bQhnpQ8pm1iiBEDS5q/wXR4HPzHhEYsPQ3G/yg5pdmj2qsKxVcAziWNQG1CYZkOk9EP1xegIoZ+2bBPA2SbMtt6djhLCoQMi01OKU/fhcBUuSDebUlI+p5lMqSCtnYgY5KqrJiUEH3rb5ffybOQ4ZerUBMWkJgU8FirZRdbaw3vIId13Df8y3/XdaAewfhvcfPm7BwTumoKQn3TMNNlgfzjHEwwh7rvFV9u+Rr7Zy6CUJB5EF4AcCzB0HMf6jRViojmPxa1W3sLvOWPTvB9lgirBZ8iEBKJLhHR9ElyQLET7POFu2g0XLbRHOQWfWkn6Th00KDeUyxhjJlKS5xEfH8qurjO8sf0uqWyggm+1YhoqiOfyqhqYuhJSBxLQahkfz7H9Lzf9P0hSq26j1c05oGXA5g5pK3mphub0FtAn+BBc7x3BwKhOPIjBtQYrC1sNLMScyrN6+QLMJwBbkpsakSNEOl1t5zoTesZR4i5hDc5ZomUuA0Ru8kZLgzPdLeUaO5ziC5ekv5LhvCm/BdPhNfUH9fvILylYsCSo75f/i6KN9X8/TAwBvvPpzPXj8GavRzQaqPNZbOxDEipizihiSqDEKqQMvXfcy9/eI6Ibn/H8t8FCVAxC3/jrtxlYBsMlFzXAcoIIhVT0mZ8lXZjwO84xyieIM+jp5gCb3w1yMg1y0sq+qKCkHaDSk/EzQnF+PuYHnIM9xpCWGxwyQAotokOm5nMLIpIF4g6BtzNS1ijKbU1ZZ3rwQIkTAc5R1TPJ3DHrsS/AYiUZFHuy+YCyAgq8MtgnxC48i0UhHhG1QpBgVgAsPazKN3QGekw8X5IeBuoc3Y/D6bWS4IhwT3EQ8tpTWCTGTj7HfJm/0OSsZLUggpgRP5hJkLYlSXJ5bvMkpu2LmKwatfJEEhxtxTD3oGSIwcyfumzsZfa5dOq8a1bfxQYi/YHefH/wACEDw50LiAV0LpTBtkAAdoLMOa4SJaEyPAB3mh1AWYVOCPbOks5laYWnWl1pOrUlOcD/jM86KMItboSgIinFhCIwgWXTyPIPFCNMArXyG0ejuGa+VybkgDgroCzlsRH4l8DsZuVI8d8StL1OEa1j29jEe8zbLTrUfyworbbo0V8RyyJSRNvk+ZF7fNunXjhpZEQ5qa2a/o9nnK/LrONL8bySt3bFqdIOkXEemAsPM0viM5AbkExDPwkm9JXYQbbTGun3ncgtK/KOUhAToFn55lYxznI5Oasq7CvQIYM4XX//WKnpDX2LKkpMFjEkjKC+DiH5Tgcn1PBZzmLiH6NEqUIwWygX4YJzVNn9bS9wLut3v89Vcn/DiPVbf1Rd649U4CO49fJzASY2mOHeinxWgLcO4M4kc4f8eCC1mBn98BHFQM2rKz6Q4aCX3FcDZZ51J2uE6HC8X27FcICKwjjXKNV1yaKbBLNDqDAmBLQwuApH3V9zPpAJr5YsSjaRhjmz0FZPXL+eMuC1ngdMQBxBocJAj5GsPpfS0GCrTcoaoYi0imEZTTBVBi41m8mijXDITx2E9fLperd4LEA+2HoavnPw7l79shsPAUbCGYBZA2IbEE4DP8v9jgJvUWcxZXc2pD1hH/82p4snTCnlVPUmQpygwHHKVQR6V6pN9ujdiEDAJHBn5PSWrnTv3Uc8R3RTTkbJN1xS6C2Y1UG1DCnJizXQsPCYdurCaaDkGs7kxAtmg/h2/Pi4K17rIlvjyPYTw9ADoHvcffcY6AFpIYKUK954BVVJFSTgKOMwRzFbASxn2PQUxI5xpgDDNUCU0kQojkOaZbeGsh7Moj/bAz6MsZPoCxlhqBRGOmDpwiTeYE3NbsWws49ZGmHngMGbJQTgRfMog0DEhTlP01HWzWKhdNLrDLRb0KsJLqDDt1IoMcU3lKjV2pDBY9OESjEHagUnYkJhhPB7Ih0b+LpfkAcnf22DPKL6EOHxelnTgLg42jF4BFsLx4suYcWsRmrpNv6zm6pul91H2dSUwXOforXT2RwCPMgPOm6NT5ETNufFDakvMYj4PVzExvKjJUWU0K++pIshZ6j40ff8UCeIcGWGdXYO+gM6V32hmc1KpE6w5WcYXR6P+sGMX1qQJP3bSz/daAbRK4LVXBED3Hz22LPtLBVYcdWuVfMy1lTftpEUYEnCXYXTPBRHIvtUYL803ViAsSCoaLKLDNgg77FXCZiytalIOHI51K+iEqeGWu0bHq25hTNwhf6VOYMm336RPRxFoUmQECyvtIMewiD4x9bC06TJKY/emixoAACAASURBVMRr6VhhpGsOTplKnDHMTDBOqxX5FWm/TwrrKmW9M0SmivFoJp+S0pBzniH0GBB0kD39JnBErhhz/MTSOCetk+XaXO2HdtifTP6EngVC30p7T85+JOvmjD17ci/Kb773wRKlKsQz/m6rAMJ01jPyLPz7EzeoSC81UxB1c3rGxmfRsufE97zbw+VpUZ9bU5d6u8k6ZTukX7119fQA+EPl//1Hj5kjwcUfqDVVrAVUIMyYHoARAR19+QjwAJSTOMpCfMovso7Rm1bNEgwJwIFrgtskp7uALYxn4JpBrnxJkQEimCSYhbEp4gDKwEg1JhwHmAYsfvMWfnryDOickq47p0pxXWSXPCTSMQdT5vC5HAONI6NHPZbrgOkanIfcEQbQHRGLnilciW1sKiCFZr8H7VlkGshyJs6llIYshDWzJFMD0TXEyI1SyIkrrPWsGY8hbNKlB7lxVzk+dfY3cYh4RgJHLSW3VQQsEC+pMz6F6UjiEIEPTMluFIDjzDtL3hHaODG4+ZgRTK/EUpStAieQW7i7pNmMjiWOuwSpcz/W73YzslLc2fxa2H2d810DA1/Ix3daAbzx6ivLB0D2B7KHFpWTSwcB0PiQN8To0DGggzKiryz3TIkZXVoXh4CkyUM7oJwewGNkBWKlUoBRcoblWJLw5yAPVZiRgdBh6sSVfHO2wRtKxhMzQyndggMwe0ZoyMQceoy3tpEXz6nyzeL2V8SMiZbjRU+SjkhsI2Iv2IWWvHWECCgtuiOMItHw0WBPFIagB1lZeHwpxtybTUobR0qu64jLxhTGQRqS4TilahLuotHCe3ChSmyx+ByWT3iAhOGss0nf/mkZaDJstbIHT5L0tCTkwKKaSVCv5u/pq5h+Ch5jQ00xRbByCJ7TxzFeqwc3Ig06vNGho48oJ+a+N2CNqfKTRRcgUj+w9GyA/FdvXXW8wI/V9/WF33j157ofgCAy+HFOznuSfTiFRBbHBA4U5ftEKSShrjncYDhFdl5EQQk4Q/II0BlET2wi17XoUxw2QJmdHfFOZ1Cc8AoLTRejcLVoYB/QmWLG3LsZEOZsnZXbx7jdVeY2aaCR0ldgdJ/P5rgMDo+BvLgy0mefLRV4SK+rGRhGgwYxfQ3Cc28Q9YwgSR6R+DKTgQ4ljayaPDj4Bzmft73eOdhskWM4Raw55+ITlIOy5FvKPAk6Q6gsC/hDGnuW+y5GAE+TjOMR3hny3ujNuUVNEBptJNyRwxqsxooNNppaqAzTzz/TgFNy7mmIOgnacAnjjGRhsxrWF8TKyvypyq+Ppe98BFh04qwTyz0OL/rm/14PgPsPHxMAz732it97+NjLNitFN6RhktNiKsCNlg29lnBAo8u1orSJkEoxiT1bAIcEt6QOXFylkEXuCGIRWcDQYTgBp96fXIIKE/DxSIFVinZTL1OxZkmGKTFblI0zgAMIm6KfxqGFKcr/Bn8iwcwB8K2FQcVE6TCxqAC92OyrCM0rGsOXP9iPYqUD1TMPPcPk8pXRLFuWFRbHIUJaZ3BqFiiQERtEDPtKrgDRhDWoANViTPhM0rMwI8FLWLwSMm6LJseE0MZvcqyYXAs5w0bc89+NGSU2eb6PkXLEVbmTFDU6GXyJIyaxJ1yc5/LxL1UjoTmoxWwGIoKo2Q0QzKzqTisqdZc+XWltps5lOKsapiLRy7rkXz/4iC9i3//DVACvvaL7Dx/v/7YzAuMq/GIEcJT5fOXJPlLY5NG7EbjOVNFJwFHFYFf0KhdtsQ1l7xlc8yjrRU+/gBnCykpVnvHZaI4PGpXegATHsChnjv14SGGcAbfYYEf5jT1prGOy23wZeeElefIK4lgZU2n3TI4hjUlM0srIr0JxB7cYz5mFKdE6b3DEwYDJiCOjfT6YPU7Pg5+FjLq5Lh1Gnl4YaOQoZvZI9J1Ce5/ahhaEiQ3JZ2b8OrJE/azCPTHL6Pb8QQadN4lGY7L8NjGkAJBW3h4eBGOQgOiSDlPxNTbfvxy8Zt89da8hf7/ovpioOgQ4uSeIWPVCBpkAoZlGf9UTNOM8z25m5h2OP7SBlWpMzTg4QruQdm+YTw+Ab/G49+gxJeD+w8fD0kOiVwiqgwnSnx0RwEBus0ysG2oLFc8zhR6BJRwB2gg4k5tqJjiU6w7TNiuy6NJdmAy/vfg+Fn1z5gQsKRYWB1KaeoRvfUVee1JOZxCTtQQaCcZRwhqShfOILAU5Q/M5TCsyVTQ98VSuFYwzkVUFOcLMCT822AhGPh4HfmXkMYgtyS9IPqHLXf53lYxc51lejlPmBawJHcV7bpvMcW4qTYsIts/TI/8MhJdqQhI2AMooLtuSOio6dxJxQuRFycBNorBObxOgUl+OoVVgJRHERd+I4BUU2g7lOty9ePxq9N02n282rFT5AexCfQoSwwBwnqUWtwZBNlgvWkNWUHnotarqtAX4Vg8t45hmBlH9dYBqtuTeR5oLiY3AowWMwSGFZ4A84kJqnI9VYt6DIr7riEZ4GIoYiBXT0oniYQRG5o0vHcToMLIH2G4tet54E4B1lqUDkoXIFocZQSIwzAb2MZMTUlDj0l/nSiznmrQODsTcwmnH3HXIyCgbTXQan3a3tsjhyCKUc0PWzJszM7mHxNMhZLBrCX+VZfRUA4GI/JUzqiwj7SgPsGPCjhi368ZoX5D8AtDLcr0saAViy0w6yojsDaGNhC3D5q2Q/4otnwSMzS6j+SQXvR7F/bfEZeP9Z0VrlkdjTIwqeisTed2T058Af34YrEMPC428YXpWvIqgMYudm98MNnPINFTtAl4XMrD99r0PBUC/fue6Tg+A/8PjXPIB7j18TOEE80JmdPe0f3JOWerOBmw9NnYsMMIJM0kDqZXICa4jEocRO8Y5R/cHrL6d5UQUJTRzXOgBaqXTDEhy5oI85b9B0mKrtyaiVEdSggEzTi6tEijLBCA+aUdBkJzSQgtzHEqcu0JoAjTEgSczcDbjkyRITUVnTobdNg5HPiGwzTDajcvdZCPBycDP59gYhwghFQlWht0QvsI8Ejz0A+Bx9vBHJJ+Y8X9AfO2z/hrSmbQbd0bpHVJe4sjCMWheqMBpo+ZpqhnGX5OFmo7LxCX67kxbKhkvKkAkoBn3OPyag3GyvjR7WPiWoSxbNH2U/mkMWyCN2v1f8moWDyF+3xPmm7Nl4ECzcBuWOkKg2JUTpxXAt3/UVVCncsrTmVE6dKdGimMk9saYx4CtU+s8uLfhX89tpo95ehAc0PAM4iz530ayDYfSGmTwtSOkxTBpCOtvSq6B5FEkF7EUYomeR/RfxmjVWCgAxviqZqS5a8Ug+xxnj3wYtB3bpmN6jRazwuEW0febxNnMtmlvVofdJg9BKiOzst8+iigzjqQdE3xKs68QGXYTzf7b3DcOviz4zyCdTSpf8uRDl0/YUQKmSOBvwzAA+TpJRZUSNjGtw/IW3ma81oa08koYUaEszd6sTVA8zkRORb3IrIAA2nKU10jFGepcrkJp2lkR0jWTN3WBmzseAKK5vKTtlu5SZZxaVeasZgRqm+SQTGHBqFnNnKrK/nj/fv3OtVMQ8E/BAc69+orfe/jYmm1Gs//KqUBzeMU2M+LWKfTYQDoTYI2c4DOLnTko4n2mjBzcmvF/3LkRdBbQ2sFDSS9HyW5j2M8lUUQyCiNjdmzk8KScc9JOq5DpuUlFhUHkcbD1ot8kgMGCd8Cwwl5FaK6nI24IjvIwCRdeaJIHKBX0W8yAPYsNRU8JMyKKG1sQI4iR1swzZpJPSH5G4kuCz0iMDo40GwfpeJ6x9ljIZpEnKCZ6TvKpkZ+HqQa2jN7/awmbFOx8BehZCqHcAhPYpiPuFrAuUixixBRZfqnTd4vqgeHrryb/HRBR3wcx1wgcJdWRS+SZC2pNeiVvM+3Hm3dFtRRlArPKzTqw1HoM3kV6t1s32h2D3uhnGMDnIEWcwWDWmY3G490XtOz/wQ6AcwsxqE5xFvOKGfKWZd9IyBSJQTEoEMzQPP0DSCO3Bj0VeCbQfgtGHfnMBn4NaOWulw36GYCtg6EGjJtoYCx0ZPVhMOb4C1MQdbSOmzjwe5LHkAYZViYcVqMZYyOZwNVAbtx1RkkZgNnWwmRiRbNtYQ9GbjOkmwB9CFKUGTGRNrnKERA1lhtZGzgsrGJKIm052Bckv2S4BJkRRwoy0SHII7Y2nNualzP4+l+B+JKwmcRRjBSjggqaLv97MPsruf4ux6Yblnw3JMfTkrCLjQebf2IfwskMP2mvJfIaMtBkzIHqkF5/QwYyZWBIEi5bhJgiI1HF+CypZ1MlsoWyNCNZpi+kl9t0YTw1FVrlezwkJdkHs2ox/N13rjkA/Mt7HxI/gccP0QIUHoB7nz6yvIUdEHNmO2dmYFYCOmq0FWEFC8E5hAi7pG0QQRObdND4GuRx2wzGZ4K+kPCzQX4oYeXC30g6Q+MWLVQSK4LHMExs7WoGlwoGi00jcJ0n1rMMtxgs4UABB+kRMEI4C2JD4QBmzkhAGiEMsOAhWHDu1wlCHZtZGWjOqbQbso3ZJLPNc+y5TW3+MYkxUoRwjAoQCX3FSOgpiXXM50tAjTG/3jGMn5P8GuRR6A+aOq6GqUckPwujUpyNKoRV3jupycgpTUIiXTn0Q6XPt5QCp4S3GW0oTTfSA6mh6/Xe11g4nSVogV0WkCwQNJcXNYvlRBxVVgY+pjVcVAu0LCSGxgqM44IGzm14kPFgmf6rn9Lt/4MdAP3EttJEWqprbAhnm5MzE4X5NE2zRtJmQesA8zDA8CTJQEDJQ4nJgjJrsT70RBgGSH9N95niKkvAY6O5oLNJEEorfsxpyxPs3LhXPFFqS8ffIpQMOS9ew+J2IvhExGHKZxOIj0CP1D8Q4DSAa1T1I2Aw+4LGZ+7+N7nY11HaRzR6uPiEjj6qAn5J4mlaX1ckeaDwtCcW1qBnQ4/N3Kh8auQTkF8beazSZghTWCDYDAaf2N2+MvPDnLXX4ZQcAm5TnjsnzdmTWlsJSB606QXzXbz0ot1bSPaL/LGab6Ij5JCSu0UeZEH0qdPk0tenx0IDAAVfYyFzrTrsKT1b6r0MU5JhsOZJIP0k9vyf5wCoaUB1ce1MIAPkJQeAI6h1gl9GcFO3g5GT4jQ/JGisEAcuivJwB02HIXAbMlnMsOGI0DoP/ODVOzaZQjyFoXf4zOdzKteelpUX2QYNFXSRQ5pmDpH3iZUU5icoW/NmlapBbd7MFaDZMo7cDL8z4+9J+x9E2MlfKR2NGMq6srQazfiVmX0G8Gnq3UsUNTAqIycw0uyrtEzf5ujxOKoCjRnBPRst+PgwV1dLR1nMJxmkMcTEFnNYbMEBjsZK04V3W927dOictGsh1nKh/zWJTUXAtQiJAhLb2HgZG4UFe5nO1eegFHo52Ki+ylFeey6Z+TgDGI0c43DVZLTgFpDzu29fc/wEHz/YAXDutVd07+FjdDJcYY8clCahYybfHoSrbM6O8+IgdAxmDBm5ojSnUyzSdmpqti7EEUQbiFUgyxlwKZgbn0D+EsAhhSYDwY2AdS50sQOEVPO+pKVacNLPViwVoxxHbHAIYqoW5aAREVOeO4BIPcFA45cgnxjxNAAtvBxYBOeFqRqZe0b7HMBXCBXeEAdlTDoyHHTbXaYZd6aRtA2AsOymZqNNaFz6JpVreYaSNggugKX8Z8y5f00rMsFTWohHqYcOg3imm3CbAC/nRFsBviwD1vubVZaKFuxpkGBcnJitvY/IhGnC0txFyjwBtNzF4g1QJKaQlftcEeXJuxB+oo8fHOjISqAkmEnuw6G7D+l4syawClIPXlYoAQ/DG1CHiR8ahFVO+rxKy9Stz6xaMTzou8WN0dOIQ8JZSAcCDvLrIfnzQ30d7ESeQJlMs0UYh4TqLu61VS7kIUd/pXc/XI47N4VkuFlMk9gY7AvEaK42xGGNIqNHBqMywtP0ut9ki+QRTlJXps1dVEWx7eZFnRdTBLNoC2rWvYC0qrh289nXAs7m3rQw82CXiCt25h2943PV2cUL7g6HNqPfceEpULhz4Wy9v5fRa2xydRmANQUYQjOhIYVTERYjrFtUb3y1TQipeBSsULnRtgkO/2Rv/x+kArj/6DMK6icCzWo3F8YAYDYzuHvQRzPKKRxwktQmrkkcpyMNKwGGTWOksJUOooAT6QO0TI7SapcbhjvPnIq7lw0cFF6AbokFJGBUcdCNMkraVEGdAC297I3gkK4/3mbJYYAalYGMDAOT4gVs8rlUeOYqOAD8MrdRBp3mURaYQBpYMpHxqJa4pPkkbgGXw0lOYUeWJCvjxGVOn410HSTLZqWRcj1jyKuRrkWekeVA2IaVr1akc8YYDe6RYYqW51gju95tt/3QVwPGzo03N/CMUP4I2JfsNolyRM/nMpCDcbM3A8+RJVmOtGKptYma3n37+k/29v+z0pzuPnxUacD1PNaxSX0dZA6tARwIOJM37GGOblbLAmE1lV1eW8sXEJujgww7jhAckwhyRsV7z6x4NSIMmBqCsPRqNxzHjLJic/FvAsOGcjiW2CghtKpoVtrhfDQijEyL225cnG/Z9AJor01VEnO56aq6WXZURnPFbN4mhFlG3fpzR5Ev9E2dJt7S9nwAaQDMfbag8pjmQOaZ9T8sxmfYCc4Idl2i82WCWuA/uOO4vTgPUU25B6TBSr4uVnlfkuSWCOWNBwAW27MLja3XOZO2tZCFHwmYBuMIcH737WsTfuKPP9sBcO/h4yGXhXXzWvMw/Vwpeua1pHUCfxVZXfl/Q7luLyGbzBTYKGm1tANVykdst1qk35lIIuIqn8uckWEzoalZUYeU1vKgsbTh7liOYgtDqfIfcHkFlgBYEpDrdpoSlS7wqpx7fM95mkmNZft57Z74mvWXLf4sY7RDgVc3fx4AKJVbd5OqHWBp55N+GRm+1pyAWy1VxBr15X0FpKY5a4o+F6xv8dNj97WaVRHVdVqJHVa2YqXOMfGIChkdIvAk31e1aHQDG2nI23hZOCKxDfZlMQJPcvz/+T8/IAD85pdv6fQA+N5u/8ddewbLE9sA0cMr3/K2X2eZvk7JcC34dQcosbt+lYBQiUlmCVWml9210vdvKOGPhMPg6nCTl/iUB8TY3GfTgjQjs1HO31hsp6bc/FNTpHQDMFrCEu622M8JedOmIWWjTLMl0hCVytnUNexqi1z0A9qsvaqSNAIJ6u6Mcuqtsr1t+PYcLQ/RhO3yFo0pi1Wps2eh3SdDt4PC3QlmvLlaPkKXQnWiBeh+s68Ki+MfBUdVH/l9SvU5ZDS6STtyEy8j0/x/K2E04wbA+Ot3rjtOHz8wDyAf5197RXcfPqYWiLauCKeF6WaIwjkn6SVinl1rEkXssCQUQJVF1LIDCpxKy6v4oxgFZRpsjhURN4SOy/Ejgb7cPBzzUMlalcUbCPdNLa40WWqW+q8Q6OaHWiAfaQunPe1Kc9MY1XL8qsNhN2hL4cvuXD2R+5ZTWDB6ZNxbJheVy2/uLwbomU1MPN+W+KulJA9GZvYgu5GF3Zy/sJZ6Rmz+YW2I0eI9ckbQCDvfcC31uZyyKklSnY2u3enYpGEDxzYgSNAycyhIxOhT+Emj/n8xLQAA3P30EXc/dll45Ycs011D8LoxKKi8KwGrmgL05TOWFcm2tYRKtZnQXG+bp1xq+ssoowwgVHZgUx4+vZip5tCVWEuB5T7bl9aL40znPFMpP/lj97xVzl7k8rmE/4C3fjZH9TSeQFPFBktGDpFsWFiGXVBm51eEnX2gk1Za9RdWWWn1OZLam5CwQ0CqDehu+Z38eLTqIHr2uQa8WEI6+ooiMk8Df7AOv6gI+VX/GtJjolyEy6YcEGYz24LYnt7+f+YKoFUCv3hV/UGQ67ktLrNI2kh5b6bGhLw3Y6OsZ33lLL4mQEo2XEF089ISBGEmR0ueLH432pxlsXcbbNprd0Wak8uvuwNiybA7YYCSpNPsP1Bhnwvqrb35dqReN81US0puvbQWf5sZhJvFnkrns8gUjFbA37p8UThZbrfH+zdvs5vRI5+DdZl4fXAGl7HlyRtlqHZHwBzZqw24ZxB22hiCO/YdHaSw8Pux9P4tcb05QhXKwBBZYG/zt8/HzOYKfDl97H7IfymFSI7amCMaOMnRzKq0HjPLfctyxcmU2VCqpVVVzHmnSM5ViyNHS67FBsSY7LApZLfBDfdgs3lbaEG0WSRqkWTszfFaLUfPk522GFAXDUbSDkym3nKa7Ttdu3S+9e/XLp0fF9S+9bAzaTnGyyzElLgKCmfcjNtW5C6O7ppd2t/83aa/xfc/vkUAePvKRamP2IpJRvNyTAlwGHTwmz7FNtKvkWBV/KH5X6b9uaPLbLwgkx1Pbi1DAlRrl5u4WXZF4m98lpH5wvo6SxthZhP2uP6nj7+ACmCpBF6pSqAtpBCkLKUkjSkXbZzzOVSoaRYSffeoUBGyrZm4DbJVpnuTfCrINoR6L+hFEs9mO2VmdZu0eTYXhkF/rTaKqhZGnleJn97idVMRhK5dOq8bt+7ixq27vc1Vxasl2QZWFUMZ64ZWSszDsS97JUhvXb74v952b1+5pOf0g57A7JDnctZg7fUWk7fDNhYcpg0rJFhOP9UCo4F5nr3ZBXFhamBp3zq2IIuanTiRKs+vbEGKhDQUcOqexZhRiZ+qO5TaafzP733I37xz/Sd/IPxFVAD3cioQLQHRQeRhzZ2MNiMnI2dr8c6YBc20sKGO/2OUF8Ahx4qGFjBKGi0MN8L9dUkxx0Ii6lFkc7VFQ+VIqfrMKLUL4kq8OzyoGiLvaiEDaoJf7XLh2t67fumCrl+6oBu37vL6pfO6dulCEJqkqdUOEZo6ApiMtuESrDoRmK9fvjD/MZu/Hh/cvN224NtvXmpDO+Q4VbugWcsZiGiupdaJyigcfLVULWlJXpX8nhhEy3/VAZVFUA4ClZ+n19/wZYTbPy8PuMTdjG5mlYzaKKdlv16bnjh9/EW/D3cePBp2Bl+S5foZ8hYaMtE3TYIw7PWk7fpJ0wmW0eSiPwH6srddQ2bu7kwUXTtMm0bO6Zp2oneb7T0QbElFqjpX/ddp/+r6pQt/8Db68NYddn259uByXb984Vv3t+9/fIu1+evx3sefZGQ5mFiLsOAT3o8B915zXdT9+HKnR+i/j7vMSJ9nL/ekUji2PqB7UyOboVVX7XNWN1Xon5NDcDMb0w1o+vXprf/jOACWg+ChdZ82FzOIZgnFOgiyLt2pO3cWxkJ3xd7925yncnbcl+/9gtPSyu9OBZYIud15ef3A5+Bv1/6XTX/iEPjkzonP6/rlC9/bgv7Pjz4pU40qxYuzUU66jZxUE4DuAOg/NnTcAnUJTK29z2mH9Wk+jt3J/nMOHEIw733/e8RWimDQqJgcgP/ml2+dAoF/aRjAH3pceP01B4DbDx42f77asLkILQEwy6Ywc2fLELc76Er226+o1rx29PJmIdUcJgvZ586m70di/cVeCrisHq5ePP+dbNLvc7P/gUcFoJaHQ9TSnZ6g2+PuxXzodPh5xC5bviM85aciEu7uVe5xD18RF0LUAlYq5zfJjdZCNsrIMCs2ZGtHTrf8j+wAAE7cAHnah6vYchEUUR2s+E9GHB/7SnKnXl149Xs3C7GAgSe/v3r64YmGvi1bfVcb/89WHhJ4583Leu/jW6k5XiYd7G94LnRe4kQc/M7p2CsBOlCRBGlhFW11ulctMFhwueZ5ZoqO5B4fneQBES6szBwhm4oKXZv/p0LvfSEPgIuvv6Y7Dx5CHQU2K8kC2ljZ29jtQWc2k46+50/leliL97mA6m42dYz58qmvhWY5mur0TA271otw17zz5mX1nTh3y/B+P9ctXz367huiRSvEE4BLfYfozkpghBMHhTCYsdJj6wAeIv9c7lHt5a1fJ/5M8nTTvygVwIXXX2u36+0HD3nx9dd0+362Bo0I0lxgqw+ofmHGSRYcwyCiFrOW9rNb7FU9XL143j+6fdc6Snqj8NU//GNu/Ru37vLapW9XHXxw83ZPvMVbVy5+7wt8zy+/v83JcnkuklTH6UjwEL0wH/1UUOJSmXHvcNkHFsHO8WcXBwA4DEONL8HF5EMA5lPg70cMAv6xj1v3Py0Oeicw067ybOlN5R6Ssyvn3/Cbd+8PmfPHuq6uXjjnAPDR7bsFdHXanmoxlsW4v/FvBGp/Aui7cesOQeLat2wPPvjk9h/8zHrSz/s3b3F/1v/tAcGb/OXVK0pg8LmXubrJC5YSgXunLps2UDqxkZ/T7tEbRaj7AMh+DVt3UKnr9083/4t+ANy6/ykvvfGL9iF/cu8BL597fefXu2tn9zVfOf+Gf3znPt+88IY+vnO/W4RR9V69cM4/unOXVy+c10e379rVi+f9xq07WWUQ33ST1y1/49bd9v32f13f6ZsOgx711/4oXrs75/uqBP7zo0/4y6uX+43f8IHucKVOYv6dB0DqAdSZeaj/F+119b/WQqSs2f8OB9H2qjTDLv8Ap5z/F/QAuHX/U/Z1Yn8A/DGPm3fvG7re8s0L53Tz7n1KQBwE93belzcvnNNHt++xc/5oVLirF/tNLVy7dEE3omrAtfqzRnHnN2Kb+5XCB93mPzm3xC4FsaJ2S+LH3UrguzgA+l+zmFAA/uHqZf3HjZvhukty7ya2DoC1HWBQLXJ99whoE4N2AOzP9/uXPGjXyrcRg043/wt4ANx58LDd5hffaHhAlP+JNl1643W/de8BL2UV8Mm9B3b53Ot/cDF0N38/ttebF87p4zv3uEPQ7Vbi1Yvn9dHtu+3Pqxq4cfsu97IQ2y2/UwFkVfDhJ3fYj/jq11UBaAdwxw7C+Nbli/rgk9vcd7R++8pFvX/zFncxusWv+503v5vW4N8//Lj8Ottg5B+uXVH35/3sv1UG3Nu0jTTURUa3g+L5i5Xe+SR0VkN693Tzv7gVVSx3CgAABABJREFUwJ0HD3dhXfUGw7uXY6Fll869rmoNPrl7n5fPv6G9ioBXzrcWAG9eeEMf3Y4q4OrFc+3v1u9908Us6Bs3eo9FPPdzKM+BfDVvXb7YDoa+72epCXu3kf2f/RFb+7s6AOrxHzduNtv3qkb+6fpVxQHRvPzZZqjasxdZwNbu7dwnFO2MdNn1IjsORe++fe2073+RDoA7Dx5xz3xqKalziexUBPc+pXaIfvEyL5072SrcvHuf+xv0zQux6asV0In6exf6+sYe/tYdXv8j2H67N/5uqxAHwJ3mAdBTfvsKYb/kf//jW3szuuUlfNeb/2RFEBvzH7MS+PcbNxd2n/vOc8p2gvvHWL/TF8XwCRMR9a3F6cZ/AQ+A9AqgGuVWuPCL3fK/XsTFDgu4ff9TFj5QB0IPDu5v/OcdAvtYgHau12VLXe1u/b012/5WHQT9ofDhrTtcUhO5UyFo7zp/68pS6rMj4Lx1+aLaaBDPnwK8d/PWgpkoDoD3Pg5Qb5n1f7fVQLUB//7hx/zH628KAP7tg4+5i2PqG9ejfLF3cRd+88vr+u2S13eC99+j/fX3TicAP/ID4O6njwyL6ebuPZyEIAG6mPyA2/cfsiqBW/c+bYvt0hu/0Cf3HrTXGq3AA/Zd/ZW9tqBvB6oa2JsmPKfkjvV47dJ5pXinPdVrzzkAOgkwvrldqIljR4xXB/xlmdz5BLUJwds5GSjFX/9773284APfZ0Ww//jXDz7ir966quf9fL9N6jQFbTP/9mRo54kD4PTxIz4AShrcAz17gFGNlEqQrgvpLJR6AexoSJ5z01w+97qq749KIKE1LRu+pgINhNOCB+xhAW3BPm8kGJscuH7pvD68dZe7WhidGHyj49P2H9P1S+eXCiDJR29d6W5/nRwFvt+kvrvt0FtXLqoUgN9nJfB/PRD+LduHf8qK4bfvfchfv7Nz8++0dP0KPi3/X5AD4MGjz0zoQiN3dbZh/93onSJEX6qBkP1qT0X2vFbgk7sPKnUWl8+/rm9qCcrQh9ybvHEHvNIeGggSy4iQz6lZu8Pl+qXs/9m1Ct1kIFoLf+5HdgIkRKSCvH3lkurmf97BIClbgVs7vF2SrUr4IR7/9uHHrA3/TY9/ef8G3337mv7l/Ruszd7//HQb/8gPgE8f/xcF4PVX/l73H33GEn+5dubAXQXQQj+oSHUlEcrBOw8esqMMtxFhcQWKOHTr3oMdkKzwgZt37jeP+oUTsDvU094Bwf/97eXVi8EsvHF7wQl6fKAOgP1v0NDzhWOPaonS+Uc7hKGg16rTLeaYbJE71ntakUrVxpDLLO+74hH0G7zHA76zCuL9G/zVNxwCv33vQ/bCrec9fuqtw/8HPnCpb7whAMsAAAAASUVORK5CYII=\"\n\n/***/ },\n/* 49 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__.p + \"image/grass.jpg\"\n\n/***/ },\n/* 50 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__.p + \"image/metal-floor.jpg\"\n\n/***/ },\n/* 51 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__.p + \"image/metal.jpg\"\n\n/***/ },\n/* 52 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__.p + \"image/stone.jpg\"\n\n/***/ },\n/* 53 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__.p + \"image/tiles.jpg\"\n\n/***/ },\n/* 54 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__.p + \"image/weathered-wood.jpg\"\n\n/***/ },\n/* 55 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__.p + \"image/wood.jpg\"\n\n/***/ },\n/* 56 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tmodule.exports = function (fn) {\n\t\tif (typeof fn !== 'function') throw new TypeError(fn + \" is not a function\");\n\t\treturn fn;\n\t};\n\n\n/***/ },\n/* 57 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * lodash 3.1.0 (Custom Build) <https://lodash.com/>\n\t * Build: `lodash modern modularize exports=\"npm\" -o ./`\n\t * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>\n\t * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n\t * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n\t * Available under MIT license <https://lodash.com/license>\n\t */\n\tvar bindCallback = __webpack_require__(73),\n\t    isIterateeCall = __webpack_require__(75),\n\t    restParam = __webpack_require__(74);\n\t\n\t/**\n\t * Creates a function that assigns properties of source object(s) to a given\n\t * destination object.\n\t *\n\t * **Note:** This function is used to create `_.assign`, `_.defaults`, and `_.merge`.\n\t *\n\t * @private\n\t * @param {Function} assigner The function to assign values.\n\t * @returns {Function} Returns the new assigner function.\n\t */\n\tfunction createAssigner(assigner) {\n\t  return restParam(function(object, sources) {\n\t    var index = -1,\n\t        length = object == null ? 0 : sources.length,\n\t        customizer = length > 2 && sources[length - 2],\n\t        guard = length > 2 && sources[2],\n\t        thisArg = length > 1 && sources[length - 1];\n\t\n\t    if (typeof customizer == 'function') {\n\t      customizer = bindCallback(customizer, thisArg, 5);\n\t      length -= 2;\n\t    } else {\n\t      customizer = typeof thisArg == 'function' ? thisArg : null;\n\t      length -= (customizer ? 1 : 0);\n\t    }\n\t    if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n\t      customizer = length < 3 ? null : customizer;\n\t      length = 1;\n\t    }\n\t    while (++index < length) {\n\t      var source = sources[index];\n\t      if (source) {\n\t        assigner(object, source, customizer);\n\t      }\n\t    }\n\t    return object;\n\t  });\n\t}\n\t\n\tmodule.exports = createAssigner;\n\n\n/***/ },\n/* 58 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * lodash 3.0.2 (Custom Build) <https://lodash.com/>\n\t * Build: `lodash modern modularize exports=\"npm\" -o ./`\n\t * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>\n\t * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n\t * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n\t * Available under MIT license <https://lodash.com/license>\n\t */\n\t\n\t/** `Object#toString` result references. */\n\tvar funcTag = '[object Function]';\n\t\n\t/**\n\t * Used to match `RegExp` [special characters](http://www.regular-expressions.info/characters.html#special).\n\t * In addition to special characters the forward slash is escaped to allow for\n\t * easier `eval` use and `Function` compilation.\n\t */\n\tvar reRegExpChars = /[.*+?^${}()|[\\]\\/\\\\]/g,\n\t    reHasRegExpChars = RegExp(reRegExpChars.source);\n\t\n\t/** Used to detect host constructors (Safari > 5). */\n\tvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\t\n\t/**\n\t * Converts `value` to a string if it is not one. An empty string is returned\n\t * for `null` or `undefined` values.\n\t *\n\t * @private\n\t * @param {*} value The value to process.\n\t * @returns {string} Returns the string.\n\t */\n\tfunction baseToString(value) {\n\t  if (typeof value == 'string') {\n\t    return value;\n\t  }\n\t  return value == null ? '' : (value + '');\n\t}\n\t\n\t/**\n\t * Checks if `value` is object-like.\n\t *\n\t * @private\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n\t */\n\tfunction isObjectLike(value) {\n\t  return !!value && typeof value == 'object';\n\t}\n\t\n\t/** Used for native method references. */\n\tvar objectProto = Object.prototype;\n\t\n\t/** Used to resolve the decompiled source of functions. */\n\tvar fnToString = Function.prototype.toString;\n\t\n\t/**\n\t * Used to resolve the [`toStringTag`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)\n\t * of values.\n\t */\n\tvar objToString = objectProto.toString;\n\t\n\t/** Used to detect if a method is native. */\n\tvar reIsNative = RegExp('^' +\n\t  escapeRegExp(objToString)\n\t  .replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n\t);\n\t\n\t/**\n\t * Checks if `value` is a native function.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @category Lang\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is a native function, else `false`.\n\t * @example\n\t *\n\t * _.isNative(Array.prototype.push);\n\t * // => true\n\t *\n\t * _.isNative(_);\n\t * // => false\n\t */\n\tfunction isNative(value) {\n\t  if (value == null) {\n\t    return false;\n\t  }\n\t  if (objToString.call(value) == funcTag) {\n\t    return reIsNative.test(fnToString.call(value));\n\t  }\n\t  return isObjectLike(value) && reIsHostCtor.test(value);\n\t}\n\t\n\t/**\n\t * Escapes the `RegExp` special characters \"\\\", \"/\", \"^\", \"$\", \".\", \"|\", \"?\",\n\t * \"*\", \"+\", \"(\", \")\", \"[\", \"]\", \"{\" and \"}\" in `string`.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @category String\n\t * @param {string} [string=''] The string to escape.\n\t * @returns {string} Returns the escaped string.\n\t * @example\n\t *\n\t * _.escapeRegExp('[lodash](https://lodash.com/)');\n\t * // => '\\[lodash\\]\\(https:\\/\\/lodash\\.com\\/\\)'\n\t */\n\tfunction escapeRegExp(string) {\n\t  string = baseToString(string);\n\t  return (string && reHasRegExpChars.test(string))\n\t    ? string.replace(reRegExpChars, '\\\\$&')\n\t    : string;\n\t}\n\t\n\tmodule.exports = isNative;\n\n\n/***/ },\n/* 59 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * lodash 3.1.0 (Custom Build) <https://lodash.com/>\n\t * Build: `lodash modern modularize exports=\"npm\" -o ./`\n\t * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>\n\t * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n\t * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n\t * Available under MIT license <https://lodash.com/license>\n\t */\n\tvar baseCopy = __webpack_require__(77),\n\t    isNative = __webpack_require__(58),\n\t    keys = __webpack_require__(60);\n\t\n\t/** Native method references. */\n\tvar getOwnPropertySymbols = isNative(getOwnPropertySymbols = Object.getOwnPropertySymbols) && getOwnPropertySymbols,\n\t    preventExtensions = isNative(Object.preventExtensions = Object.preventExtensions) && preventExtensions;\n\t\n\t/** Used as `baseAssign`. */\n\tvar nativeAssign = (function() {\n\t  // Avoid `Object.assign` in Firefox 34-37 which have an early implementation\n\t  // with a now defunct try/catch behavior. See https://bugzilla.mozilla.org/show_bug.cgi?id=1103344\n\t  // for more details.\n\t  //\n\t  // Use `Object.preventExtensions` on a plain object instead of simply using\n\t  // `Object('x')` because Chrome and IE fail to throw an error when attempting\n\t  // to assign values to readonly indexes of strings in strict mode.\n\t  var object = { '1': 0 },\n\t      func = preventExtensions && isNative(func = Object.assign) && func;\n\t\n\t  try { func(preventExtensions(object), 'xo'); } catch(e) {}\n\t  return !object[1] && func;\n\t}());\n\t\n\t/**\n\t * The base implementation of `_.assign` without support for argument juggling,\n\t * multiple sources, and `customizer` functions.\n\t *\n\t * @private\n\t * @param {Object} object The destination object.\n\t * @param {Object} source The source object.\n\t * @returns {Object} Returns `object`.\n\t */\n\tvar baseAssign = nativeAssign || function(object, source) {\n\t  return source == null\n\t    ? object\n\t    : baseCopy(source, getSymbols(source), baseCopy(source, keys(source), object));\n\t};\n\t\n\t/**\n\t * Creates an array of the own symbols of `object`.\n\t *\n\t * @private\n\t * @param {Object} object The object to query.\n\t * @returns {Array} Returns the array of symbols.\n\t */\n\tvar getSymbols = !getOwnPropertySymbols ? constant([]) : function(object) {\n\t  return getOwnPropertySymbols(toObject(object));\n\t};\n\t\n\t/**\n\t * Converts `value` to an object if it is not one.\n\t *\n\t * @private\n\t * @param {*} value The value to process.\n\t * @returns {Object} Returns the object.\n\t */\n\tfunction toObject(value) {\n\t  return isObject(value) ? value : Object(value);\n\t}\n\t\n\t/**\n\t * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.\n\t * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n\t *\n\t * @static\n\t * @memberOf _\n\t * @category Lang\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n\t * @example\n\t *\n\t * _.isObject({});\n\t * // => true\n\t *\n\t * _.isObject([1, 2, 3]);\n\t * // => true\n\t *\n\t * _.isObject(1);\n\t * // => false\n\t */\n\tfunction isObject(value) {\n\t  // Avoid a V8 JIT bug in Chrome 19-20.\n\t  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n\t  var type = typeof value;\n\t  return type == 'function' || (!!value && type == 'object');\n\t}\n\t\n\t/**\n\t * Creates a function that returns `value`.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @category Utility\n\t * @param {*} value The value to return from the new function.\n\t * @returns {Function} Returns the new function.\n\t * @example\n\t *\n\t * var object = { 'user': 'fred' };\n\t * var getter = _.constant(object);\n\t *\n\t * getter() === object;\n\t * // => true\n\t */\n\tfunction constant(value) {\n\t  return function() {\n\t    return value;\n\t  };\n\t}\n\t\n\tmodule.exports = baseAssign;\n\n\n/***/ },\n/* 60 */\n[86, 76, 78, 58],\n/* 61 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * lodash 3.0.3 (Custom Build) <https://lodash.com/>\n\t * Build: `lodash modern modularize exports=\"npm\" -o ./`\n\t * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>\n\t * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n\t * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n\t * Available under MIT license <https://lodash.com/license>\n\t */\n\tvar keys = __webpack_require__(79);\n\t\n\t/**\n\t * Used as the [maximum length](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.max_safe_integer)\n\t * of an array-like value.\n\t */\n\tvar MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;\n\t\n\t/**\n\t * The base implementation of `_.forEach` without support for callback\n\t * shorthands and `this` binding.\n\t *\n\t * @private\n\t * @param {Array|Object|string} collection The collection to iterate over.\n\t * @param {Function} iteratee The function invoked per iteration.\n\t * @returns {Array|Object|string} Returns `collection`.\n\t */\n\tvar baseEach = createBaseEach(baseForOwn);\n\t\n\t/**\n\t * The base implementation of `baseForIn` and `baseForOwn` which iterates\n\t * over `object` properties returned by `keysFunc` invoking `iteratee` for\n\t * each property. Iteratee functions may exit iteration early by explicitly\n\t * returning `false`.\n\t *\n\t * @private\n\t * @param {Object} object The object to iterate over.\n\t * @param {Function} iteratee The function invoked per iteration.\n\t * @param {Function} keysFunc The function to get the keys of `object`.\n\t * @returns {Object} Returns `object`.\n\t */\n\tvar baseFor = createBaseFor();\n\t\n\t/**\n\t * The base implementation of `_.forOwn` without support for callback\n\t * shorthands and `this` binding.\n\t *\n\t * @private\n\t * @param {Object} object The object to iterate over.\n\t * @param {Function} iteratee The function invoked per iteration.\n\t * @returns {Object} Returns `object`.\n\t */\n\tfunction baseForOwn(object, iteratee) {\n\t  return baseFor(object, iteratee, keys);\n\t}\n\t\n\t/**\n\t * The base implementation of `_.property` without support for deep paths.\n\t *\n\t * @private\n\t * @param {string} key The key of the property to get.\n\t * @returns {Function} Returns the new function.\n\t */\n\tfunction baseProperty(key) {\n\t  return function(object) {\n\t    return object == null ? undefined : object[key];\n\t  };\n\t}\n\t\n\t/**\n\t * Creates a `baseEach` or `baseEachRight` function.\n\t *\n\t * @private\n\t * @param {Function} eachFunc The function to iterate over a collection.\n\t * @param {boolean} [fromRight] Specify iterating from right to left.\n\t * @returns {Function} Returns the new base function.\n\t */\n\tfunction createBaseEach(eachFunc, fromRight) {\n\t  return function(collection, iteratee) {\n\t    var length = collection ? getLength(collection) : 0;\n\t    if (!isLength(length)) {\n\t      return eachFunc(collection, iteratee);\n\t    }\n\t    var index = fromRight ? length : -1,\n\t        iterable = toObject(collection);\n\t\n\t    while ((fromRight ? index-- : ++index < length)) {\n\t      if (iteratee(iterable[index], index, iterable) === false) {\n\t        break;\n\t      }\n\t    }\n\t    return collection;\n\t  };\n\t}\n\t\n\t/**\n\t * Creates a base function for `_.forIn` or `_.forInRight`.\n\t *\n\t * @private\n\t * @param {boolean} [fromRight] Specify iterating from right to left.\n\t * @returns {Function} Returns the new base function.\n\t */\n\tfunction createBaseFor(fromRight) {\n\t  return function(object, iteratee, keysFunc) {\n\t    var iterable = toObject(object),\n\t        props = keysFunc(object),\n\t        length = props.length,\n\t        index = fromRight ? length : -1;\n\t\n\t    while ((fromRight ? index-- : ++index < length)) {\n\t      var key = props[index];\n\t      if (iteratee(iterable[key], key, iterable) === false) {\n\t        break;\n\t      }\n\t    }\n\t    return object;\n\t  };\n\t}\n\t\n\t/**\n\t * Gets the \"length\" property value of `object`.\n\t *\n\t * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)\n\t * in Safari on iOS 8.1 ARM64.\n\t *\n\t * @private\n\t * @param {Object} object The object to query.\n\t * @returns {*} Returns the \"length\" value.\n\t */\n\tvar getLength = baseProperty('length');\n\t\n\t/**\n\t * Checks if `value` is a valid array-like length.\n\t *\n\t * **Note:** This function is based on [`ToLength`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength).\n\t *\n\t * @private\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n\t */\n\tfunction isLength(value) {\n\t  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n\t}\n\t\n\t/**\n\t * Converts `value` to an object if it is not one.\n\t *\n\t * @private\n\t * @param {*} value The value to process.\n\t * @returns {Object} Returns the object.\n\t */\n\tfunction toObject(value) {\n\t  return isObject(value) ? value : Object(value);\n\t}\n\t\n\t/**\n\t * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.\n\t * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n\t *\n\t * @static\n\t * @memberOf _\n\t * @category Lang\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n\t * @example\n\t *\n\t * _.isObject({});\n\t * // => true\n\t *\n\t * _.isObject([1, 2, 3]);\n\t * // => true\n\t *\n\t * _.isObject(1);\n\t * // => false\n\t */\n\tfunction isObject(value) {\n\t  // Avoid a V8 JIT bug in Chrome 19-20.\n\t  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n\t  var type = typeof value;\n\t  return type == 'function' || (!!value && type == 'object');\n\t}\n\t\n\tmodule.exports = baseEach;\n\n\n/***/ },\n/* 62 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * lodash 3.0.0 (Custom Build) <https://lodash.com/>\n\t * Build: `lodash modern modularize exports=\"npm\" -o ./`\n\t * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>\n\t * Based on Underscore.js 1.7.0 <http://underscorejs.org/LICENSE>\n\t * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n\t * Available under MIT license <https://lodash.com/license>\n\t */\n\t\n\t/**\n\t * A specialized version of `_.forEach` for arrays without support for callback\n\t * shorthands or `this` binding.\n\t *\n\t * @private\n\t * @param {Array} array The array to iterate over.\n\t * @param {Function} iteratee The function invoked per iteration.\n\t * @returns {Array} Returns `array`.\n\t */\n\tfunction arrayEach(array, iteratee) {\n\t  var index = -1,\n\t      length = array.length;\n\t\n\t  while (++index < length) {\n\t    if (iteratee(array[index], index, array) === false) {\n\t      break;\n\t    }\n\t  }\n\t  return array;\n\t}\n\t\n\tmodule.exports = arrayEach;\n\n\n/***/ },\n/* 63 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * lodash 3.0.1 (Custom Build) <https://lodash.com/>\n\t * Build: `lodash modern modularize exports=\"npm\" -o ./`\n\t * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>\n\t * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n\t * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n\t * Available under MIT license <https://lodash.com/license>\n\t */\n\t\n\t/**\n\t * A specialized version of `baseCallback` which only supports `this` binding\n\t * and specifying the number of arguments to provide to `func`.\n\t *\n\t * @private\n\t * @param {Function} func The function to bind.\n\t * @param {*} thisArg The `this` binding of `func`.\n\t * @param {number} [argCount] The number of arguments to provide to `func`.\n\t * @returns {Function} Returns the callback.\n\t */\n\tfunction bindCallback(func, thisArg, argCount) {\n\t  if (typeof func != 'function') {\n\t    return identity;\n\t  }\n\t  if (thisArg === undefined) {\n\t    return func;\n\t  }\n\t  switch (argCount) {\n\t    case 1: return function(value) {\n\t      return func.call(thisArg, value);\n\t    };\n\t    case 3: return function(value, index, collection) {\n\t      return func.call(thisArg, value, index, collection);\n\t    };\n\t    case 4: return function(accumulator, value, index, collection) {\n\t      return func.call(thisArg, accumulator, value, index, collection);\n\t    };\n\t    case 5: return function(value, other, key, object, source) {\n\t      return func.call(thisArg, value, other, key, object, source);\n\t    };\n\t  }\n\t  return function() {\n\t    return func.apply(thisArg, arguments);\n\t  };\n\t}\n\t\n\t/**\n\t * This method returns the first argument provided to it.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @category Utility\n\t * @param {*} value Any value.\n\t * @returns {*} Returns `value`.\n\t * @example\n\t *\n\t * var object = { 'user': 'fred' };\n\t *\n\t * _.identity(object) === object;\n\t * // => true\n\t */\n\tfunction identity(value) {\n\t  return value;\n\t}\n\t\n\tmodule.exports = bindCallback;\n\n\n/***/ },\n/* 64 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * lodash 3.0.2 (Custom Build) <https://lodash.com/>\n\t * Build: `lodash modern modularize exports=\"npm\" -o ./`\n\t * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>\n\t * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n\t * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n\t * Available under MIT license <https://lodash.com/license>\n\t */\n\t\n\t/** `Object#toString` result references. */\n\tvar arrayTag = '[object Array]',\n\t    funcTag = '[object Function]';\n\t\n\t/**\n\t * Used to match `RegExp` [special characters](http://www.regular-expressions.info/characters.html#special).\n\t * In addition to special characters the forward slash is escaped to allow for\n\t * easier `eval` use and `Function` compilation.\n\t */\n\tvar reRegExpChars = /[.*+?^${}()|[\\]\\/\\\\]/g,\n\t    reHasRegExpChars = RegExp(reRegExpChars.source);\n\t\n\t/** Used to detect host constructors (Safari > 5). */\n\tvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\t\n\t/**\n\t * Converts `value` to a string if it is not one. An empty string is returned\n\t * for `null` or `undefined` values.\n\t *\n\t * @private\n\t * @param {*} value The value to process.\n\t * @returns {string} Returns the string.\n\t */\n\tfunction baseToString(value) {\n\t  if (typeof value == 'string') {\n\t    return value;\n\t  }\n\t  return value == null ? '' : (value + '');\n\t}\n\t\n\t/**\n\t * Checks if `value` is object-like.\n\t *\n\t * @private\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n\t */\n\tfunction isObjectLike(value) {\n\t  return !!value && typeof value == 'object';\n\t}\n\t\n\t/** Used for native method references. */\n\tvar objectProto = Object.prototype;\n\t\n\t/** Used to resolve the decompiled source of functions. */\n\tvar fnToString = Function.prototype.toString;\n\t\n\t/**\n\t * Used to resolve the [`toStringTag`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)\n\t * of values.\n\t */\n\tvar objToString = objectProto.toString;\n\t\n\t/** Used to detect if a method is native. */\n\tvar reIsNative = RegExp('^' +\n\t  escapeRegExp(objToString)\n\t  .replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n\t);\n\t\n\t/* Native method references for those with the same name as other `lodash` methods. */\n\tvar nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray;\n\t\n\t/**\n\t * Used as the [maximum length](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.max_safe_integer)\n\t * of an array-like value.\n\t */\n\tvar MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;\n\t\n\t/**\n\t * Checks if `value` is a valid array-like length.\n\t *\n\t * **Note:** This function is based on [`ToLength`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength).\n\t *\n\t * @private\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n\t */\n\tfunction isLength(value) {\n\t  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n\t}\n\t\n\t/**\n\t * Checks if `value` is classified as an `Array` object.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @category Lang\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n\t * @example\n\t *\n\t * _.isArray([1, 2, 3]);\n\t * // => true\n\t *\n\t * _.isArray(function() { return arguments; }());\n\t * // => false\n\t */\n\tvar isArray = nativeIsArray || function(value) {\n\t  return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;\n\t};\n\t\n\t/**\n\t * Checks if `value` is a native function.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @category Lang\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is a native function, else `false`.\n\t * @example\n\t *\n\t * _.isNative(Array.prototype.push);\n\t * // => true\n\t *\n\t * _.isNative(_);\n\t * // => false\n\t */\n\tfunction isNative(value) {\n\t  if (value == null) {\n\t    return false;\n\t  }\n\t  if (objToString.call(value) == funcTag) {\n\t    return reIsNative.test(fnToString.call(value));\n\t  }\n\t  return isObjectLike(value) && reIsHostCtor.test(value);\n\t}\n\t\n\t/**\n\t * Escapes the `RegExp` special characters \"\\\", \"/\", \"^\", \"$\", \".\", \"|\", \"?\",\n\t * \"*\", \"+\", \"(\", \")\", \"[\", \"]\", \"{\" and \"}\" in `string`.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @category String\n\t * @param {string} [string=''] The string to escape.\n\t * @returns {string} Returns the escaped string.\n\t * @example\n\t *\n\t * _.escapeRegExp('[lodash](https://lodash.com/)');\n\t * // => '\\[lodash\\]\\(https:\\/\\/lodash\\.com\\/\\)'\n\t */\n\tfunction escapeRegExp(string) {\n\t  string = baseToString(string);\n\t  return (string && reHasRegExpChars.test(string))\n\t    ? string.replace(reRegExpChars, '\\\\$&')\n\t    : string;\n\t}\n\t\n\tmodule.exports = isArray;\n\n\n/***/ },\n/* 65 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar forEach = Array.prototype.forEach, create = Object.create;\n\t\n\tvar process = function (src, obj) {\n\t\tvar key;\n\t\tfor (key in src) obj[key] = src[key];\n\t};\n\t\n\tmodule.exports = function (options/*, â¦options*/) {\n\t\tvar result = create(null);\n\t\tforEach.call(arguments, function (options) {\n\t\t\tif (options == null) return;\n\t\t\tprocess(Object(options), result);\n\t\t});\n\t\treturn result;\n\t};\n\n\n/***/ },\n/* 66 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// Deprecated\n\t\n\t'use strict';\n\t\n\tmodule.exports = function (obj) { return typeof obj === 'function'; };\n\n\n/***/ },\n/* 67 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tmodule.exports = __webpack_require__(69)()\n\t\t? Object.assign\n\t\t: __webpack_require__(70);\n\n\n/***/ },\n/* 68 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tmodule.exports = __webpack_require__(71)()\n\t\t? String.prototype.contains\n\t\t: __webpack_require__(72);\n\n\n/***/ },\n/* 69 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tmodule.exports = function () {\n\t\tvar assign = Object.assign, obj;\n\t\tif (typeof assign !== 'function') return false;\n\t\tobj = { foo: 'raz' };\n\t\tassign(obj, { bar: 'dwa' }, { trzy: 'trzy' });\n\t\treturn (obj.foo + obj.bar + obj.trzy) === 'razdwatrzy';\n\t};\n\n\n/***/ },\n/* 70 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar keys  = __webpack_require__(81)\n\t  , value = __webpack_require__(80)\n\t\n\t  , max = Math.max;\n\t\n\tmodule.exports = function (dest, src/*, â¦srcn*/) {\n\t\tvar error, i, l = max(arguments.length, 2), assign;\n\t\tdest = Object(value(dest));\n\t\tassign = function (key) {\n\t\t\ttry { dest[key] = src[key]; } catch (e) {\n\t\t\t\tif (!error) error = e;\n\t\t\t}\n\t\t};\n\t\tfor (i = 1; i < l; ++i) {\n\t\t\tsrc = arguments[i];\n\t\t\tkeys(src).forEach(assign);\n\t\t}\n\t\tif (error !== undefined) throw error;\n\t\treturn dest;\n\t};\n\n\n/***/ },\n/* 71 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar str = 'razdwatrzy';\n\t\n\tmodule.exports = function () {\n\t\tif (typeof str.contains !== 'function') return false;\n\t\treturn ((str.contains('dwa') === true) && (str.contains('foo') === false));\n\t};\n\n\n/***/ },\n/* 72 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar indexOf = String.prototype.indexOf;\n\t\n\tmodule.exports = function (searchString/*, position*/) {\n\t\treturn indexOf.call(this, searchString, arguments[1]) > -1;\n\t};\n\n\n/***/ },\n/* 73 */\n63,\n/* 74 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * lodash 3.6.1 (Custom Build) <https://lodash.com/>\n\t * Build: `lodash modern modularize exports=\"npm\" -o ./`\n\t * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>\n\t * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n\t * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n\t * Available under MIT license <https://lodash.com/license>\n\t */\n\t\n\t/** Used as the `TypeError` message for \"Functions\" methods. */\n\tvar FUNC_ERROR_TEXT = 'Expected a function';\n\t\n\t/* Native method references for those with the same name as other `lodash` methods. */\n\tvar nativeMax = Math.max;\n\t\n\t/**\n\t * Creates a function that invokes `func` with the `this` binding of the\n\t * created function and arguments from `start` and beyond provided as an array.\n\t *\n\t * **Note:** This method is based on the [rest parameter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters).\n\t *\n\t * @static\n\t * @memberOf _\n\t * @category Function\n\t * @param {Function} func The function to apply a rest parameter to.\n\t * @param {number} [start=func.length-1] The start position of the rest parameter.\n\t * @returns {Function} Returns the new function.\n\t * @example\n\t *\n\t * var say = _.restParam(function(what, names) {\n\t *   return what + ' ' + _.initial(names).join(', ') +\n\t *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);\n\t * });\n\t *\n\t * say('hello', 'fred', 'barney', 'pebbles');\n\t * // => 'hello fred, barney, & pebbles'\n\t */\n\tfunction restParam(func, start) {\n\t  if (typeof func != 'function') {\n\t    throw new TypeError(FUNC_ERROR_TEXT);\n\t  }\n\t  start = nativeMax(start === undefined ? (func.length - 1) : (+start || 0), 0);\n\t  return function() {\n\t    var args = arguments,\n\t        index = -1,\n\t        length = nativeMax(args.length - start, 0),\n\t        rest = Array(length);\n\t\n\t    while (++index < length) {\n\t      rest[index] = args[start + index];\n\t    }\n\t    switch (start) {\n\t      case 0: return func.call(this, rest);\n\t      case 1: return func.call(this, args[0], rest);\n\t      case 2: return func.call(this, args[0], args[1], rest);\n\t    }\n\t    var otherArgs = Array(start + 1);\n\t    index = -1;\n\t    while (++index < start) {\n\t      otherArgs[index] = args[index];\n\t    }\n\t    otherArgs[start] = rest;\n\t    return func.apply(this, otherArgs);\n\t  };\n\t}\n\t\n\tmodule.exports = restParam;\n\n\n/***/ },\n/* 75 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * lodash 3.0.6 (Custom Build) <https://lodash.com/>\n\t * Build: `lodash modern modularize exports=\"npm\" -o ./`\n\t * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>\n\t * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n\t * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n\t * Available under MIT license <https://lodash.com/license>\n\t */\n\t\n\t/**\n\t * Used as the [maximum length](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.max_safe_integer)\n\t * of an array-like value.\n\t */\n\tvar MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;\n\t\n\t/**\n\t * The base implementation of `_.property` without support for deep paths.\n\t *\n\t * @private\n\t * @param {string} key The key of the property to get.\n\t * @returns {Function} Returns the new function.\n\t */\n\tfunction baseProperty(key) {\n\t  return function(object) {\n\t    return object == null ? undefined : object[key];\n\t  };\n\t}\n\t\n\t/**\n\t * Gets the \"length\" property value of `object`.\n\t *\n\t * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)\n\t * in Safari on iOS 8.1 ARM64.\n\t *\n\t * @private\n\t * @param {Object} object The object to query.\n\t * @returns {*} Returns the \"length\" value.\n\t */\n\tvar getLength = baseProperty('length');\n\t\n\t/**\n\t * Checks if `value` is a valid array-like index.\n\t *\n\t * @private\n\t * @param {*} value The value to check.\n\t * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n\t * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n\t */\n\tfunction isIndex(value, length) {\n\t  value = +value;\n\t  length = length == null ? MAX_SAFE_INTEGER : length;\n\t  return value > -1 && value % 1 == 0 && value < length;\n\t}\n\t\n\t/**\n\t * Checks if the provided arguments are from an iteratee call.\n\t *\n\t * @private\n\t * @param {*} value The potential iteratee value argument.\n\t * @param {*} index The potential iteratee index or key argument.\n\t * @param {*} object The potential iteratee object argument.\n\t * @returns {boolean} Returns `true` if the arguments are from an iteratee call, else `false`.\n\t */\n\tfunction isIterateeCall(value, index, object) {\n\t  if (!isObject(object)) {\n\t    return false;\n\t  }\n\t  var type = typeof index;\n\t  if (type == 'number') {\n\t    var length = getLength(object),\n\t        prereq = isLength(length) && isIndex(index, length);\n\t  } else {\n\t    prereq = type == 'string' && index in object;\n\t  }\n\t  if (prereq) {\n\t    var other = object[index];\n\t    return value === value ? (value === other) : (other !== other);\n\t  }\n\t  return false;\n\t}\n\t\n\t/**\n\t * Checks if `value` is a valid array-like length.\n\t *\n\t * **Note:** This function is based on [`ToLength`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength).\n\t *\n\t * @private\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n\t */\n\tfunction isLength(value) {\n\t  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n\t}\n\t\n\t/**\n\t * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.\n\t * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n\t *\n\t * @static\n\t * @memberOf _\n\t * @category Lang\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n\t * @example\n\t *\n\t * _.isObject({});\n\t * // => true\n\t *\n\t * _.isObject([1, 2, 3]);\n\t * // => true\n\t *\n\t * _.isObject(1);\n\t * // => false\n\t */\n\tfunction isObject(value) {\n\t  // Avoid a V8 JIT bug in Chrome 19-20.\n\t  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n\t  var type = typeof value;\n\t  return type == 'function' || (!!value && type == 'object');\n\t}\n\t\n\tmodule.exports = isIterateeCall;\n\n\n/***/ },\n/* 76 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * lodash 3.0.1 (Custom Build) <https://lodash.com/>\n\t * Build: `lodash modern modularize exports=\"npm\" -o ./`\n\t * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>\n\t * Based on Underscore.js 1.8.2 <http://underscorejs.org/LICENSE>\n\t * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n\t * Available under MIT license <https://lodash.com/license>\n\t */\n\t\n\t/** `Object#toString` result references. */\n\tvar argsTag = '[object Arguments]';\n\t\n\t/**\n\t * Checks if `value` is object-like.\n\t *\n\t * @private\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n\t */\n\tfunction isObjectLike(value) {\n\t  return !!value && typeof value == 'object';\n\t}\n\t\n\t/** Used for native method references. */\n\tvar objectProto = Object.prototype;\n\t\n\t/**\n\t * Used to resolve the [`toStringTag`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)\n\t * of values.\n\t */\n\tvar objToString = objectProto.toString;\n\t\n\t/**\n\t * Used as the [maximum length](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.max_safe_integer)\n\t * of an array-like value.\n\t */\n\tvar MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;\n\t\n\t/**\n\t * Checks if `value` is a valid array-like length.\n\t *\n\t * **Note:** This function is based on [`ToLength`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength).\n\t *\n\t * @private\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n\t */\n\tfunction isLength(value) {\n\t  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n\t}\n\t\n\t/**\n\t * Checks if `value` is classified as an `arguments` object.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @category Lang\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n\t * @example\n\t *\n\t * _.isArguments(function() { return arguments; }());\n\t * // => true\n\t *\n\t * _.isArguments([1, 2, 3]);\n\t * // => false\n\t */\n\tfunction isArguments(value) {\n\t  var length = isObjectLike(value) ? value.length : undefined;\n\t  return isLength(length) && objToString.call(value) == argsTag;\n\t}\n\t\n\tmodule.exports = isArguments;\n\n\n/***/ },\n/* 77 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * lodash 3.0.1 (Custom Build) <https://lodash.com/>\n\t * Build: `lodash modern modularize exports=\"npm\" -o ./`\n\t * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>\n\t * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n\t * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n\t * Available under MIT license <https://lodash.com/license>\n\t */\n\t\n\t/**\n\t * Copies properties of `source` to `object`.\n\t *\n\t * @private\n\t * @param {Object} source The object to copy properties from.\n\t * @param {Array} props The property names to copy.\n\t * @param {Object} [object={}] The object to copy properties to.\n\t * @returns {Object} Returns `object`.\n\t */\n\tfunction baseCopy(source, props, object) {\n\t  object || (object = {});\n\t\n\t  var index = -1,\n\t      length = props.length;\n\t\n\t  while (++index < length) {\n\t    var key = props[index];\n\t    object[key] = source[key];\n\t  }\n\t  return object;\n\t}\n\t\n\tmodule.exports = baseCopy;\n\n\n/***/ },\n/* 78 */\n64,\n/* 79 */\n[86, 85, 64, 84],\n/* 80 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tmodule.exports = function (value) {\n\t\tif (value == null) throw new TypeError(\"Cannot use null or undefined\");\n\t\treturn value;\n\t};\n\n\n/***/ },\n/* 81 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tmodule.exports = __webpack_require__(82)()\n\t\t? Object.keys\n\t\t: __webpack_require__(83);\n\n\n/***/ },\n/* 82 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tmodule.exports = function () {\n\t\ttry {\n\t\t\tObject.keys('primitive');\n\t\t\treturn true;\n\t\t} catch (e) { return false; }\n\t};\n\n\n/***/ },\n/* 83 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar keys = Object.keys;\n\t\n\tmodule.exports = function (object) {\n\t\treturn keys(object == null ? object : Object(object));\n\t};\n\n\n/***/ },\n/* 84 */\n58,\n/* 85 */\n76,\n/* 86 */\n/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__, __webpack_module_template_argument_1__, __webpack_module_template_argument_2__) {\n\n\t/**\n\t * lodash 3.0.6 (Custom Build) <https://lodash.com/>\n\t * Build: `lodash modern modularize exports=\"npm\" -o ./`\n\t * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>\n\t * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n\t * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n\t * Available under MIT license <https://lodash.com/license>\n\t */\n\tvar isArguments = __webpack_require__(__webpack_module_template_argument_0__),\n\t    isArray = __webpack_require__(__webpack_module_template_argument_1__),\n\t    isNative = __webpack_require__(__webpack_module_template_argument_2__);\n\t\n\t/** Used for native method references. */\n\tvar objectProto = Object.prototype;\n\t\n\t/** Used to check objects for own properties. */\n\tvar hasOwnProperty = objectProto.hasOwnProperty;\n\t\n\t/** Native method references. */\n\tvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\n\t\n\t/* Native method references for those with the same name as other `lodash` methods. */\n\tvar nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys;\n\t\n\t/**\n\t * Used as the [maximum length](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.max_safe_integer)\n\t * of an array-like value.\n\t */\n\tvar MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;\n\t\n\t/**\n\t * An object environment feature flags.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @type Object\n\t */\n\tvar support = {};\n\t\n\t(function(x) {\n\t  var Ctor = function() { this.x = x; },\n\t      object = { '0': x, 'length': x },\n\t      props = [];\n\t\n\t  Ctor.prototype = { 'valueOf': x, 'y': x };\n\t  for (var key in new Ctor) { props.push(key); }\n\t\n\t  /**\n\t   * Detect if `arguments` object indexes are non-enumerable.\n\t   *\n\t   * In Firefox < 4, IE < 9, PhantomJS, and Safari < 5.1 `arguments` object\n\t   * indexes are non-enumerable. Chrome < 25 and Node.js < 0.11.0 treat\n\t   * `arguments` object indexes as non-enumerable and fail `hasOwnProperty`\n\t   * checks for indexes that exceed the number of function parameters and\n\t   * whose associated argument values are `0`.\n\t   *\n\t   * @memberOf _.support\n\t   * @type boolean\n\t   */\n\t  try {\n\t    support.nonEnumArgs = !propertyIsEnumerable.call(arguments, 1);\n\t  } catch(e) {\n\t    support.nonEnumArgs = true;\n\t  }\n\t}(1, 0));\n\t\n\t/**\n\t * Checks if `value` is a valid array-like index.\n\t *\n\t * @private\n\t * @param {*} value The value to check.\n\t * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n\t * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n\t */\n\tfunction isIndex(value, length) {\n\t  value = +value;\n\t  length = length == null ? MAX_SAFE_INTEGER : length;\n\t  return value > -1 && value % 1 == 0 && value < length;\n\t}\n\t\n\t/**\n\t * Checks if `value` is a valid array-like length.\n\t *\n\t * **Note:** This function is based on [`ToLength`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength).\n\t *\n\t * @private\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n\t */\n\tfunction isLength(value) {\n\t  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n\t}\n\t\n\t/**\n\t * A fallback implementation of `Object.keys` which creates an array of the\n\t * own enumerable property names of `object`.\n\t *\n\t * @private\n\t * @param {Object} object The object to query.\n\t * @returns {Array} Returns the array of property names.\n\t */\n\tfunction shimKeys(object) {\n\t  var props = keysIn(object),\n\t      propsLength = props.length,\n\t      length = propsLength && object.length;\n\t\n\t  var allowIndexes = length && isLength(length) &&\n\t    (isArray(object) || (support.nonEnumArgs && isArguments(object)));\n\t\n\t  var index = -1,\n\t      result = [];\n\t\n\t  while (++index < propsLength) {\n\t    var key = props[index];\n\t    if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {\n\t      result.push(key);\n\t    }\n\t  }\n\t  return result;\n\t}\n\t\n\t/**\n\t * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.\n\t * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n\t *\n\t * @static\n\t * @memberOf _\n\t * @category Lang\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n\t * @example\n\t *\n\t * _.isObject({});\n\t * // => true\n\t *\n\t * _.isObject([1, 2, 3]);\n\t * // => true\n\t *\n\t * _.isObject(1);\n\t * // => false\n\t */\n\tfunction isObject(value) {\n\t  // Avoid a V8 JIT bug in Chrome 19-20.\n\t  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n\t  var type = typeof value;\n\t  return type == 'function' || (!!value && type == 'object');\n\t}\n\t\n\t/**\n\t * Creates an array of the own enumerable property names of `object`.\n\t *\n\t * **Note:** Non-object values are coerced to objects. See the\n\t * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.keys)\n\t * for more details.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @category Object\n\t * @param {Object} object The object to query.\n\t * @returns {Array} Returns the array of property names.\n\t * @example\n\t *\n\t * function Foo() {\n\t *   this.a = 1;\n\t *   this.b = 2;\n\t * }\n\t *\n\t * Foo.prototype.c = 3;\n\t *\n\t * _.keys(new Foo);\n\t * // => ['a', 'b'] (iteration order is not guaranteed)\n\t *\n\t * _.keys('hi');\n\t * // => ['0', '1']\n\t */\n\tvar keys = !nativeKeys ? shimKeys : function(object) {\n\t  if (object) {\n\t    var Ctor = object.constructor,\n\t        length = object.length;\n\t  }\n\t  if ((typeof Ctor == 'function' && Ctor.prototype === object) ||\n\t      (typeof object != 'function' && isLength(length))) {\n\t    return shimKeys(object);\n\t  }\n\t  return isObject(object) ? nativeKeys(object) : [];\n\t};\n\t\n\t/**\n\t * Creates an array of the own and inherited enumerable property names of `object`.\n\t *\n\t * **Note:** Non-object values are coerced to objects.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @category Object\n\t * @param {Object} object The object to query.\n\t * @returns {Array} Returns the array of property names.\n\t * @example\n\t *\n\t * function Foo() {\n\t *   this.a = 1;\n\t *   this.b = 2;\n\t * }\n\t *\n\t * Foo.prototype.c = 3;\n\t *\n\t * _.keysIn(new Foo);\n\t * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n\t */\n\tfunction keysIn(object) {\n\t  if (object == null) {\n\t    return [];\n\t  }\n\t  if (!isObject(object)) {\n\t    object = Object(object);\n\t  }\n\t  var length = object.length;\n\t  length = (length && isLength(length) &&\n\t    (isArray(object) || (support.nonEnumArgs && isArguments(object))) && length) || 0;\n\t\n\t  var Ctor = object.constructor,\n\t      index = -1,\n\t      isProto = typeof Ctor == 'function' && Ctor.prototype === object,\n\t      result = Array(length),\n\t      skipIndexes = length > 0;\n\t\n\t  while (++index < length) {\n\t    result[index] = (index + '');\n\t  }\n\t  for (var key in object) {\n\t    if (!(skipIndexes && isIndex(key, length)) &&\n\t        !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\n\t      result.push(key);\n\t    }\n\t  }\n\t  return result;\n\t}\n\t\n\tmodule.exports = keys;\n\n\n/***/ }\n/******/ ])));\n\n\n/** WEBPACK FOOTER **\n ** vr.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap e575faca7415056888a3\n **/","(function () {\n\t'use strict';\n\n\t//global-ish declarations\n\tvar VR,\n\t\tNoSleep = require('nosleep').NoSleep;\n\n\tfunction initRequirements() {\n\t\t//load styles\n\t\trequire('!style!css!./css/style.css');\n\n\t\tVR = require('./vr');\n\t}\n\n\tfunction initUI() {\n\t\tvar container,\n\t\t\tenableFullscreen,\n\t\t\tdisableFullscreen,\n\t\t\tvrButton,\n\t\t\torientationButton,\n\t\t\telement,\n\n\t\t\tnoSleep = new NoSleep(),\n\n\t\t\tfullScreenElement = document.body,\n\n\t\t\tfullscreenEnabled = document.fullscreenEnabled ||\n\t\t\t\tdocument.webkitFullscreenEnabled ||\n\t\t\t\tdocument.mozFullScreenEnabled ||\n\t\t\t\tdocument.msFullscreenEnabled,\n\n\t\t\trequestFullscreen = fullScreenElement.webkitRequestFullscreen ||\n\t\t\t\tfullScreenElement.mozRequestFullScreen ||\n\t\t\t\tfullScreenElement.msRequestFullscreen;\n\n\t\tfunction svgButton(source, id) {\n\t\t\tvar span = document.createElement('span'),\n\t\t\t\tsvg;\n\n\t\t\tspan.innerHTML = source;\n\t\t\tspan.id = id;\n\n\t\t\tsvg = span.firstChild;\n\t\t\tsvg.setAttribute('width', 18);\n\t\t\tsvg.setAttribute('height', 18);\n\n\t\t\tcontainer.appendChild(span);\n\n\t\t\treturn span;\n\t\t}\n\n\t\tfunction toggleOrientation() {\n\t\t\tif (VR.orientationEnabled()) {\n\t\t\t\tVR.disableOrientation();\n\t\t\t} else {\n\t\t\t\tVR.enableOrientation();\n\t\t\t}\n\t\t}\n\n\t\tfunction deviceChange() {\n\t\t\tif (VR.controlMode()) {\n\t\t\t\tvrButton.classList.remove('unsupported');\n\t\t\t\torientationButton.classList.remove('unsupported');\n\t\t\t}\n\n\t\t\t//todo: enable this\n\t\t\t//info.innerHTML = hmd && hmd.deviceName ? 'HMD: ' + hmd.deviceName : '';\n\t\t\t//info.className = hmd && hmd.deviceId !== 'debug-0' ? 'has-hmd' : '';\n\t\t}\n\n\t\t//set up meta viewport tag for mobile devices\n\t\telement = document.createElement('meta');\n\t\telement.setAttribute('name', 'viewport');\n\t\telement.setAttribute('content', 'width=device-width, initial-scale=1, user-scalable=no');\n\t\tdocument.head.appendChild(element);\n\n\t\tcontainer = document.createElement('div');\n\t\tcontainer.id = 'buttons';\n\t\tdocument.body.appendChild(container);\n\n\t\t//todo: use icons instead of text\n\t\tif (requestFullscreen && fullscreenEnabled) {\n\t\t\tenableFullscreen = svgButton(require('raw!open-iconic/svg/fullscreen-enter.svg'), 'fs-enable');\n\t\t\tenableFullscreen.setAttribute('title', 'Enable Full Screen');\n\t\t\tenableFullscreen.addEventListener('click', requestFullscreen.bind(fullScreenElement), false);\n\n\t\t\tdisableFullscreen = svgButton(require('raw!open-iconic/svg/fullscreen-exit.svg'), 'fs-disable');\n\t\t\tdisableFullscreen.setAttribute('title', 'Exit Full Screen');\n\t\t\tdisableFullscreen.addEventListener('click', VR.exitFullscreen, false);\n\t\t}\n\n\t\tVR.on('fullscreenchange', function () {\n\t\t\tif (VR.isFullscreen()) {\n\t\t\t\tdisableFullscreen.style.display = 'inline-block';\n\t\t\t\tenableFullscreen.style.display = 'none';\n\t\t\t} else {\n\t\t\t\tdisableFullscreen.style.display = '';\n\t\t\t\tenableFullscreen.style.display = '';\n\t\t\t}\n\n\t\t\t//disable sleep on mobile devices in VR mode\n\t\t\tif (VR.vrMode()) {\n\t\t\t\tnoSleep.enable();\n\t\t\t} else {\n\t\t\t\tnoSleep.disable();\n\t\t\t}\n\t\t});\n\n\t\tvrButton = svgButton(require('raw!open-iconic/svg/eye.svg'), 'vr');\n\t\tvrButton.setAttribute('title', 'Toggle Virtual Reality');\n\t\tvrButton.className = 'unsupported';\n\t\tvrButton.addEventListener('click', VR.requestVR, false);\n\n\t\torientationButton = svgButton(require('raw!open-iconic/svg/compass.svg'), 'orientation');\n\t\torientationButton.setAttribute('title', 'Toggle Orientation');\n\t\torientationButton.className = 'unsupported';\n\t\torientationButton.addEventListener('click', toggleOrientation, false);\n\n\t\t//report on HMD\n\t\tVR.on('devicechange', deviceChange);\n\t\tdeviceChange();\n\n\t\t//keyboard shortcuts for making life a little easier\n\t\twindow.addEventListener('keydown', function (evt) {\n\t\t\tif (evt.keyCode === 'Z'.charCodeAt(0)) {\n\t\t\t\tVR.zeroSensor();\n\t\t\t} else if (evt.keyCode === 'O'.charCodeAt(0)) {\n\t\t\t\tVR.enableOrientation();\n\t\t\t} else if (evt.keyCode === 13) {\n\t\t\t\tVR.requestVR();\n\t\t\t}\n\t\t}, false);\n\n\t\tVR.resize();\n\t}\n\n\tfunction initialize() {\n\t\tinitRequirements();\n\n\t\t//todo: set up button/info elements\n\n\t\tVR.init();\n\n\t\tif (document.body) {\n\t\t\tinitUI();\n\t\t} else {\n\t\t\twindow.addEventListener('load', initUI, false);\n\t\t}\n\n\t\twindow.addEventListener('resize', VR.resize, false);\n\n\t\t/*\n\t\texport global things\n\t\t*/\n\t\twindow.VR = VR;\n\t\twindow.THREE = VR.THREE;\n\t}\n\n\tinitialize();\n\tVR.start();\n}());\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/entry.js\n ** module id = 0\n ** module chunks = 0\n **/","(function () {\n\t'use strict';\n\n\t//constants\n\tvar NEAR = 0.1,\n\t\tFAR = 1000000,\n\n\t//global-ish declarations\n\t\tTHREE,\n\t\teventEmitter,\n\t\tmaterials = require('./materials'),\n\t\tnop = function () {},\n\t\trequestFullscreen = nop,\n\t\texitFullscreen = (\n\t\t\tdocument.exitFullscreen ||\n\t\t\tdocument.mozCancelFullScreen ||\n\t\t\tdocument.webkitExitFullscreen ||\n\t\t\tdocument.msExitFullscreen ||\n\t\t\tnop\n\t\t).bind(document),\n\n\t//scene assets\n\t\tcamera,\n\t\tscene,\n\t\tbody,\n\t\trenderer,\n\t\taudioListener,\n\t\tvrControls,\n\t\tvrEffect,\n\t\tmouseControls,\n\t\traycaster,\n\t\ttarget,\n\n\t\tbodyWrapper,\n\t\tcameraWrapper,\n\n\t\tfloor,\n\n\t//state\n\t\tgoing = false,\n\t\tvrMode = false,\n\t\torientationEnabled,\n\t\torientationPossible = false,\n\n\t//exported object\n\t\tVR,\n\n\t\tVRObject = require('./vr-object'),\n\t\tobjectMethods = [\n\t\t\t'box',\n\t\t\t'cylinder',\n\t\t\t'torus',\n\t\t\t'sphere',\n\t\t\t'empty',\n\t\t\t'sound',\n\t\t\t'floor',\n\t\t\t'sky',\n\t\t\t'panorama',\n\t\t\t'image',\n\t\t\t'video',\n\t\t\t'text'\n\t\t],\n\n\t\t//todo: use a weak map or set instead\n\t\tvrObjects = [],\n\n\t\tlastTick = 0,\n\t\tanimationCallbacks = [];\n\n\tfunction isFullscreen() {\n\t\treturn !!(document.fullscreenElement ||\n\t\t\tdocument.mozFullScreenElement ||\n\t\t\tdocument.webkitFullscreenElement ||\n\t\t\tdocument.msFullscreenElement);\n\t}\n\n\tfunction fullScreenError() {\n\t\tvrMode = false;\n\t\tif (vrEffect) {\n\t\t\tvrEffect.exit();\n\t\t}\n\t}\n\n\tfunction raycast() {\n\t\tvar i,\n\t\t\tintersect,\n\t\t\tobject,\n\t\t\tintersects,\n\t\t\tvrObject;\n\n\t\traycaster.ray.origin.copy( camera.position );\n\t\traycaster.ray.direction.set(0, 0, 0.5).unproject(camera).sub(camera.position).normalize();\n\n\t\tintersects = raycaster.intersectObjects( scene.children );\n\t\tfor (i = 0; i < intersects.length; i++) {\n\t\t\tintersect = intersects[i];\n\t\t\tif (intersect.object instanceof THREE.Mesh) {\n\t\t\t\tobject = intersect.object;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (target !== object) {\n\t\t\tif (target) {\n\t\t\t\tvrObject = VRObject.findObject(target);\n\t\t\t\tvrObject.emit('lookaway');\n\t\t\t\tVR.emit('lookaway', vrObject);\n\t\t\t}\n\t\t\ttarget = object;\n\t\t\tif (target) {\n\t\t\t\tvrObject = VRObject.findObject(target);\n\t\t\t\tvrObject.emit('lookat', intersect);\n\t\t\t\tVR.emit('lookat', vrObject, intersect);\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction render() {\n\t\tvar now = Date.now() / 1000,\n\t\t\tdelta = Math.min(1, now - lastTick);\n\n\t\tvrControls.update();\n\n\t\tanimationCallbacks.forEach(function (cb) {\n\t\t\tcb(delta, now);\n\t\t});\n\n\t\tscene.updateMatrixWorld();\n\n\t\tvrObjects.forEach(function (object) {\n\t\t\tobject.update(now);\n\t\t});\n\n\t\traycast();\n\n\t\tvrEffect.render(scene, camera);\n\n\t\tlastTick = now;\n\t}\n\n\tfunction renderLoop() {\n\t\tif (going) {\n\t\t\trender();\n\t\t\trequestAnimationFrame(renderLoop);\n\t\t}\n\t}\n\n\tfunction stop() {\n\t\tgoing = false;\n\t}\n\n\tfunction start() {\n\t\tif (!going) {\n\t\t\tgoing = true;\n\t\t\trenderLoop();\n\t\t}\n\t}\n\n\t/*\n\tMute any sounds when this browser tab is in the background or minimized.\n\t*/\n\tfunction visibilityChange() {\n\t\tif (document.hidden || document.mozHidden || document.msHidden || document.webkitHidden) {\n\t\t\taudioListener.volume(0);\n\t\t} else {\n\t\t\taudioListener.volume(1);\n\t\t}\n\t}\n\n\tfunction resize(width, height) {\n\t\twidth = typeof width === 'number' && width || window.innerWidth;\n\t\theight = typeof height === 'number' && height || window.innerHeight;\n\n\t\tcamera.aspect = width / height;\n\t\tcamera.updateProjectionMatrix();\n\t\trenderer.setSize(width, height);\n\t}\n\n\tfunction initShake() {\n\t\tvar lastTime = 0,\n\t\t\tlastX,\n\t\t\tlastY,\n\t\t\tlastZ,\n\t\t\tthreshold = 15;\n\n\t\twindow.addEventListener('devicemotion', function (evt) {\n\t\t\tvar current = evt.accelerationIncludingGravity,\n\t\t\t\ttime,\n\t\t\t\tdiff,\n\t\t\t\tdeltaX = 0,\n\t\t\t\tdeltaY = 0,\n\t\t\t\tdeltaZ = 0,\n\t\t\t\tdist;\n\n\t\t\tif (lastX !== undefined) {\n\t\t\t\tdeltaX = Math.abs(lastX - current.x);\n\t\t\t\tdeltaY = Math.abs(lastY - current.y);\n\t\t\t\tdeltaZ = Math.abs(lastZ - current.z);\n\n\t\t\t\t// if (deltaX > threshold &&\n\t\t\t\t// \t\t(deltaY > threshold || deltaZ > threshold)\n\t\t\t\t// \t) {\n\t\t\t\tdist = Math.sqrt(deltaX * deltaX + deltaY * deltaY + deltaZ * deltaZ);\n\t\t\t\tif (dist > threshold) {\n\n\t\t\t\t\ttime = Date.now();\n\t\t\t\t\tdiff = time - lastTime;\n\t\t\t\t\tif (diff > 1000) {\n\t\t\t\t\t\tif (navigator.vibrate) {\n\t\t\t\t\t\t\tnavigator.vibrate(100);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlastTime = Date.now();\n\n\t\t\t\t\t\tVR.emit('shake');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlastX = current.x;\n\t\t\tlastY = current.y;\n\t\t\tlastZ = current.z;\n\n\t\t\torientationPossible = true;\n\t\t}, false);\n\t}\n\n\tfunction initScene() {\n\t\tfunction attachCanvas() {\n\t\t\tdocument.body.insertBefore(renderer.domElement, document.body.firstChild || null);\n\t\t\tresize();\n\t\t}\n\n\t\tif (renderer) {\n\t\t\treturn;\n\t\t}\n\n\t\t//create renderer and place in document\n\t\trenderer = new THREE.WebGLRenderer();\n\t\trenderer.domElement.addEventListener('webglcontextlost', function contextLost(event) {\n\t\t\tconsole.log('lost context', event);\n\t\t});\n\t\t// renderer.shadowMapEnabled = true;\n\t\t// renderer.shadowMapSoft = true;\n\n\t\t//need a scene to put all our objects in\n\t\tscene = new THREE.Scene();\n\n\t\tbodyWrapper = new VRObject(scene, require('./objects/empty'), null, {\n\t\t\tname: 'body'\n\t\t}).moveTo(0, 1.5, 4);\n\t\tbody = bodyWrapper.object;\n\n\t\tcameraWrapper = new VRObject(body, function (parent) {\n\t\t\t//need a camera with which to look at stuff\n\t\t\tcamera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, NEAR, FAR);\n\t\t\tparent.add(camera);\n\n\t\t\treturn camera;\n\t\t})\n\t\t// set camera position so that OrbitControls works properly.\n\t\t\t.moveTo(0, 0.0001, 0.0001);\n\n\t\taudioListener = new THREE.AudioListener();\n\t\taudioListener.name = 'audio-listener';\n\t\tcamera.add(audioListener);\n\n\t\t//VRControls point the camera wherever we're looking\n\t\tvrControls = new THREE.VRControls(camera);\n\t\tvrControls.freeze = !orientationEnabled;\n\n\t\t//render left and right eye\n\t\tvrEffect = new THREE.VRStereoEffect(renderer);\n\t\tvrEffect.near = NEAR;\n\t\tvrEffect.far = FAR;\n\t\tvrEffect.addEventListener('fullscreenchange', function (evt) {\n\t\t\tvar screen;\n\t\t\tif (isFullscreen()) {\n\t\t\t\tif (vrMode) {\n\t\t\t\t\t//no mouse control\n\t\t\t\t\tmouseControls.enabled = false;\n\n\t\t\t\t\tvrControls.freeze = false;\n\t\t\t\t\tvrControls.reset();\n\n\t\t\t\t\tscreen = window.screen;\n\t\t\t\t\tif (screen.lockOrientation) {\n\t\t\t\t\t\tscreen.lockOrientation('landscape-primary');\n\t\t\t\t\t} else if (screen.mozLockOrientation) {\n\t\t\t\t\t\tscreen.mozLockOrientation('landscape-primary');\n\t\t\t\t\t} else if (screen.orientation && screen.orientation.lock) {\n\t\t\t\t\t\tscreen.orientation.lock('landscape-primary');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tVR.exitVR();\n\t\t\t}\n\n\t\t\tcamera.position.set(0, 0.0001, 0.0001);\n\t\t\tcamera.rotation.set(0, 0, 0);\n\n\t\t\tVR.emit('fullscreenchange', evt);\n\t\t});\n\n\t\t//report on HMD\n\t\tvrControls.addEventListener('devicechange', function () {\n\t\t\torientationPossible = true;\n\t\t\tif (orientationEnabled === undefined) {\n\t\t\t\torientationEnabled = vrControls.mode() === 'deviceorientation';\n\t\t\t}\n\n\t\t\tvrControls.freeze = !orientationEnabled && !vrMode;\n\n\t\t\tVR.emit('devicechange', vrControls.mode(), vrEffect.hmd());\n\t\t});\n\n\t\t//mouse control in case got no orientation device\n\t\tmouseControls = new THREE.OrbitControls(camera);\n\t\tmouseControls.target0.set(0, 0.0001, 0.000);\n\t\tmouseControls.target.copy(mouseControls.target0);\n\t\tmouseControls.update();\n\n\t\t//todo: remove any default lights once other lights are added\n\t\tvar dLight = new THREE.DirectionalLight(0xffffff, 0.8);\n\t\tdLight.name = 'directional-light';\n\t\tdLight.position.set(20, 100, 100);\n\n\t\tdLight.castShadow = true;\n\t\tdLight.shadowCameraVisible = true;\n\n\t\tdLight.shadowMapWidth = 2048;\n\t\tdLight.shadowMapHeight = 2048;\n\n\t\tdLight.shadowCameraLeft = -10;\n\t\tdLight.shadowCameraRight = 10;\n\t\tdLight.shadowCameraTop = 10;\n\t\tdLight.shadowCameraBottom = -10;\n\n\t\tdLight.shadowCameraFar = 150;\n\t\tdLight.shadowCameraNear = 100;\n\t\tdLight.shadowDarkness = 1;\n\n\t\tscene.add(dLight);\n\n\t\tscene.add(new THREE.AmbientLight(0x444444));\n\n\t\tif (VR) {\n\t\t\tVR.camera = cameraWrapper;\n\t\t\tVR.body = bodyWrapper;\n\t\t\tVR.scene = scene;\n\t\t\tVR.canvas = renderer.domElement;\n\t\t\tVR.zeroSensor = vrControls.zeroSensor;\n\t\t}\n\n\t\traycaster = new THREE.Raycaster();\n\n\t\tif (document.body) {\n\t\t\tattachCanvas();\n\t\t} else {\n\t\t\twindow.addEventListener('load', attachCanvas, false);\n\t\t}\n\n\t\tVR.canvas.addEventListener('mozfullscreenerror', fullScreenError, false);\n\t\tVR.canvas.addEventListener('webkitfullscreenerror', fullScreenError, false);\n\t\tVR.canvas.addEventListener('fullscreenerror', fullScreenError, false);\n\t}\n\n\tfunction initRequirements() {\n\t\t//load external requirements\n\t\tTHREE = require('three');\n\t\trequire('imports?THREE=three!DeviceOrientationControls');\n\t\trequire('imports?THREE=three!OrbitControls');\n\n\t\t//if (typeof __DEV__ !== 'undefined' && __DEV__) {\n\t\t\trequire('imports?THREE=three!AugmentedConsole');\n\t\t//}\n\n\t\tTHREE.ImageUtils.crossOrigin = '';\n\n\t\teventEmitter = require('event-emitter');\n\n\t\t//my VR stuff. todo: move these to a separate repo or two for easy packaging\n\t\trequire('imports?THREE=three!./lib/VRStereoEffect');\n\t\trequire('imports?THREE=three!./lib/VRControls');\n\t}\n\n\tfunction initialize() {\n\t\t//todo: set up button/info elements\n\n\t\tinitScene();\n\n\t\tinitShake();\n\n\t\tresize();\n\n\t\tdocument.addEventListener('visibilitychange', visibilityChange);\n\t\tdocument.addEventListener('mozvisibilitychange', visibilityChange);\n\t\tdocument.addEventListener('msvisibilitychange', visibilityChange);\n\t\tdocument.addEventListener('webkitvisibilitychange', visibilityChange);\n\t}\n\n\tinitRequirements();\n\n\tmodule.exports = VR = {\n\t\tinit: initialize,\n\t\trender: render,\n\t\tstart: start,\n\t\tstop: stop,\n\t\tresize: resize,\n\n\t\tTHREE: THREE,\n\n\t\tmaterials: materials,\n\n\t\tanimate: function (callback) {\n\t\t\tvar i;\n\t\t\tif (typeof callback === 'function') {\n\t\t\t\ti = animationCallbacks.indexOf(callback);\n\t\t\t\tif (i < 0) {\n\t\t\t\t\tanimationCallbacks.push(callback);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tend: function (callback) {\n\t\t\tvar i;\n\n\t\t\tif (!callback) {\n\t\t\t\tanimationCallbacks.length = 0;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (typeof callback === 'function') {\n\t\t\t\ti = animationCallbacks.indexOf(callback);\n\t\t\t\tif (i >= 0) {\n\t\t\t\t\tanimationCallbacks.splice(i, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\trequestVR: function () {\n\t\t\t//todo: check if it's possible\n\t\t\tif (vrMode || !vrEffect) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvrMode = true;\n\n\t\t\t//full screen and render two eyes\n\t\t\t//always full screen\n\t\t\tvrEffect.requestFullScreen();\n\t\t},\n\n\t\texitVR: function () {\n\t\t\tvrMode = false;\n\t\t\tif (isFullscreen()) {\n\t\t\t\texitFullscreen();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tmouseControls.enabled = true;\n\t\t\tvrControls.freeze = !orientationEnabled;\n\t\t\tcamera.rotation.set(0, 0, 0);\n\t\t},\n\n\t\tvrMode: function () {\n\t\t\treturn vrMode && isFullscreen();\n\t\t},\n\n\t\torientationEnabled: function () {\n\t\t\treturn !!orientationEnabled;\n\t\t},\n\t\tenableOrientation: function () {\n\t\t\torientationEnabled = true;\n\t\t\tif (!vrMode) {\n\t\t\t\tvrControls.freeze = false;\n\t\t\t}\n\t\t},\n\t\tdisableOrientation: function () {\n\t\t\torientationEnabled = false;\n\t\t\tcamera.rotation.set(0, 0, 0);\n\t\t\tvrControls.freeze = !vrMode;\n\t\t},\n\n\t\tisFullscreen: isFullscreen,\n\t\trequestFullscreen: requestFullscreen,\n\t\texitFullscreen: function () {\n\t\t\tif (isFullscreen()) {\n\t\t\t\texitFullscreen();\n\t\t\t}\n\t\t},\n\n\t\tcontrolMode: function () {\n\t\t\treturn vrControls && vrControls.mode();\n\t\t},\n\n\t\tzeroSensor: nop,\n\n\t\tvibrate: navigator.vibrate ? navigator.vibrate.bind(navigator) : nop,\n\n\t\t// Utility\n\t\ttimes: function (n, callback) {\n\t\t\tvar i;\n\n\t\t\tfor (i = 0; i < n; i++) {\n\t\t\t\tcallback(i);\n\t\t\t}\n\t\t},\n\n\t\tcamera: cameraWrapper,\n\t\tbody: bodyWrapper,\n\t\tscene: scene,\n\t\tcanvas: renderer && renderer.domElement || null\n\t};\n\n\tobjectMethods.forEach(function (method) {\n\t\tvar creator = require('./objects/' + method),\n\t\t\tkey;\n\n\t\tVR[method] = function (options) {\n\t\t\tvar obj = new VRObject(scene, creator, body, options);\n\t\t\tvrObjects.push(obj);\n\t\t\treturn obj;\n\t\t};\n\n\t\tVRObject.prototype[method] = function (options) {\n\t\t\tvar obj = new VRObject(this.object, creator, body, options);\n\t\t\tvrObjects.push(obj);\n\t\t\treturn obj;\n\t\t};\n\n\t\tfor (key in creator) {\n\t\t\tif (creator.hasOwnProperty(key) && typeof creator[key] === 'function') {\n\t\t\t\tVR[method][key] = creator[key];\n\t\t\t\tVRObject.prototype[method][key] = creator[key];\n\t\t\t}\n\t\t}\n\t});\n\n\teventEmitter(VR);\n\n\tObject.defineProperty(VR, 'target', {\n\t\tget: function () {\n\t\t\treturn target;\n\t\t}\n\t});\n}());\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/vr.js\n ** module id = 1\n ** module chunks = 0\n **/","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!./../../node_modules/css-loader/index.js!./style.css\");\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = require(\"!./../../node_modules/style-loader/addStyles.js\")(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(module.hot) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!./../../node_modules/css-loader/index.js!./style.css\", function() {\n\t\t\tvar newContent = require(\"!!./../../node_modules/css-loader/index.js!./style.css\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/style-loader!./~/css-loader!./src/css/style.css\n ** module id = 2\n ** module chunks = 0\n **/","exports = module.exports = require(\"./../../node_modules/css-loader/lib/css-base.js\")();\nexports.push([module.id, \"body{font-family:'Helvetica Neue',Helvetica,Arial,sans-serif;color:#eee;overflow:hidden;background:#282828;height:100%;width:100%;margin:0;padding:0}canvas{width:100%!important;height:100%!important;top:0;left:0}#buttons{position:absolute;bottom:0;left:0;padding:12px;margin:8px;border-radius:8px;background-color:rgba(128,128,128,.6)}#buttons>*{margin:0 10px;display:inline-block;width:18px;height:18px;cursor:pointer}#buttons>:first-child{margin-left:0}#buttons>.unsupported,#fs-disable{display:none}\", \"\"]);\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/css-loader!./src/css/style.css\n ** module id = 3\n ** module chunks = 0\n **/","/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\nvar stylesInDom = {},\r\n\tmemoize = function(fn) {\r\n\t\tvar memo;\r\n\t\treturn function () {\r\n\t\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\r\n\t\t\treturn memo;\r\n\t\t};\r\n\t},\r\n\tisOldIE = memoize(function() {\r\n\t\treturn /msie [6-9]\\b/.test(window.navigator.userAgent.toLowerCase());\r\n\t}),\r\n\tgetHeadElement = memoize(function () {\r\n\t\treturn document.head || document.getElementsByTagName(\"head\")[0];\r\n\t}),\r\n\tsingletonElement = null,\r\n\tsingletonCounter = 0;\r\n\r\nmodule.exports = function(list, options) {\r\n\tif(typeof DEBUG !== \"undefined\" && DEBUG) {\r\n\t\tif(typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\r\n\t}\r\n\r\n\toptions = options || {};\r\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\r\n\t// tags it will allow on a page\r\n\tif (typeof options.singleton === \"undefined\") options.singleton = isOldIE();\r\n\r\n\tvar styles = listToStyles(list);\r\n\taddStylesToDom(styles, options);\r\n\r\n\treturn function update(newList) {\r\n\t\tvar mayRemove = [];\r\n\t\tfor(var i = 0; i < styles.length; i++) {\r\n\t\t\tvar item = styles[i];\r\n\t\t\tvar domStyle = stylesInDom[item.id];\r\n\t\t\tdomStyle.refs--;\r\n\t\t\tmayRemove.push(domStyle);\r\n\t\t}\r\n\t\tif(newList) {\r\n\t\t\tvar newStyles = listToStyles(newList);\r\n\t\t\taddStylesToDom(newStyles, options);\r\n\t\t}\r\n\t\tfor(var i = 0; i < mayRemove.length; i++) {\r\n\t\t\tvar domStyle = mayRemove[i];\r\n\t\t\tif(domStyle.refs === 0) {\r\n\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++)\r\n\t\t\t\t\tdomStyle.parts[j]();\r\n\t\t\t\tdelete stylesInDom[domStyle.id];\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n}\r\n\r\nfunction addStylesToDom(styles, options) {\r\n\tfor(var i = 0; i < styles.length; i++) {\r\n\t\tvar item = styles[i];\r\n\t\tvar domStyle = stylesInDom[item.id];\r\n\t\tif(domStyle) {\r\n\t\t\tdomStyle.refs++;\r\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\r\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\r\n\t\t\t}\r\n\t\t\tfor(; j < item.parts.length; j++) {\r\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tvar parts = [];\r\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\r\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\r\n\t\t\t}\r\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction listToStyles(list) {\r\n\tvar styles = [];\r\n\tvar newStyles = {};\r\n\tfor(var i = 0; i < list.length; i++) {\r\n\t\tvar item = list[i];\r\n\t\tvar id = item[0];\r\n\t\tvar css = item[1];\r\n\t\tvar media = item[2];\r\n\t\tvar sourceMap = item[3];\r\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\r\n\t\tif(!newStyles[id])\r\n\t\t\tstyles.push(newStyles[id] = {id: id, parts: [part]});\r\n\t\telse\r\n\t\t\tnewStyles[id].parts.push(part);\r\n\t}\r\n\treturn styles;\r\n}\r\n\r\nfunction createStyleElement() {\r\n\tvar styleElement = document.createElement(\"style\");\r\n\tvar head = getHeadElement();\r\n\tstyleElement.type = \"text/css\";\r\n\thead.appendChild(styleElement);\r\n\treturn styleElement;\r\n}\r\n\r\nfunction createLinkElement() {\r\n\tvar linkElement = document.createElement(\"link\");\r\n\tvar head = getHeadElement();\r\n\tlinkElement.rel = \"stylesheet\";\r\n\thead.appendChild(linkElement);\r\n\treturn linkElement;\r\n}\r\n\r\nfunction addStyle(obj, options) {\r\n\tvar styleElement, update, remove;\r\n\r\n\tif (options.singleton) {\r\n\t\tvar styleIndex = singletonCounter++;\r\n\t\tstyleElement = singletonElement || (singletonElement = createStyleElement());\r\n\t\tupdate = applyToSingletonTag.bind(null, styleElement, styleIndex, false);\r\n\t\tremove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);\r\n\t} else if(obj.sourceMap &&\r\n\t\ttypeof URL === \"function\" &&\r\n\t\ttypeof URL.createObjectURL === \"function\" &&\r\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\r\n\t\ttypeof Blob === \"function\" &&\r\n\t\ttypeof btoa === \"function\") {\r\n\t\tstyleElement = createLinkElement();\r\n\t\tupdate = updateLink.bind(null, styleElement);\r\n\t\tremove = function() {\r\n\t\t\tstyleElement.parentNode.removeChild(styleElement);\r\n\t\t\tif(styleElement.href)\r\n\t\t\t\tURL.revokeObjectURL(styleElement.href);\r\n\t\t};\r\n\t} else {\r\n\t\tstyleElement = createStyleElement();\r\n\t\tupdate = applyToTag.bind(null, styleElement);\r\n\t\tremove = function() {\r\n\t\t\tstyleElement.parentNode.removeChild(styleElement);\r\n\t\t};\r\n\t}\r\n\r\n\tupdate(obj);\r\n\r\n\treturn function updateStyle(newObj) {\r\n\t\tif(newObj) {\r\n\t\t\tif(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)\r\n\t\t\t\treturn;\r\n\t\t\tupdate(obj = newObj);\r\n\t\t} else {\r\n\t\t\tremove();\r\n\t\t}\r\n\t};\r\n}\r\n\r\nvar replaceText = (function () {\r\n\tvar textStore = [];\r\n\r\n\treturn function (index, replacement) {\r\n\t\ttextStore[index] = replacement;\r\n\t\treturn textStore.filter(Boolean).join('\\n');\r\n\t};\r\n})();\r\n\r\nfunction applyToSingletonTag(styleElement, index, remove, obj) {\r\n\tvar css = remove ? \"\" : obj.css;\r\n\r\n\tif (styleElement.styleSheet) {\r\n\t\tstyleElement.styleSheet.cssText = replaceText(index, css);\r\n\t} else {\r\n\t\tvar cssNode = document.createTextNode(css);\r\n\t\tvar childNodes = styleElement.childNodes;\r\n\t\tif (childNodes[index]) styleElement.removeChild(childNodes[index]);\r\n\t\tif (childNodes.length) {\r\n\t\t\tstyleElement.insertBefore(cssNode, childNodes[index]);\r\n\t\t} else {\r\n\t\t\tstyleElement.appendChild(cssNode);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction applyToTag(styleElement, obj) {\r\n\tvar css = obj.css;\r\n\tvar media = obj.media;\r\n\tvar sourceMap = obj.sourceMap;\r\n\r\n\tif(media) {\r\n\t\tstyleElement.setAttribute(\"media\", media)\r\n\t}\r\n\r\n\tif(styleElement.styleSheet) {\r\n\t\tstyleElement.styleSheet.cssText = css;\r\n\t} else {\r\n\t\twhile(styleElement.firstChild) {\r\n\t\t\tstyleElement.removeChild(styleElement.firstChild);\r\n\t\t}\r\n\t\tstyleElement.appendChild(document.createTextNode(css));\r\n\t}\r\n}\r\n\r\nfunction updateLink(linkElement, obj) {\r\n\tvar css = obj.css;\r\n\tvar media = obj.media;\r\n\tvar sourceMap = obj.sourceMap;\r\n\r\n\tif(sourceMap) {\r\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(JSON.stringify(sourceMap)) + \" */\";\r\n\t}\r\n\r\n\tvar blob = new Blob([css], { type: \"text/css\" });\r\n\r\n\tvar oldSrc = linkElement.href;\r\n\r\n\tlinkElement.href = URL.createObjectURL(blob);\r\n\r\n\tif(oldSrc)\r\n\t\tURL.revokeObjectURL(oldSrc);\r\n}\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/style-loader/addStyles.js\n ** module id = 4\n ** module chunks = 0\n **/","module.exports = \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"8\\\" height=\\\"8\\\" viewBox=\\\"0 0 8 8\\\">\\n  <path d=\\\"M0 0v4l1.5-1.5 1.5 1.5 1-1-1.5-1.5 1.5-1.5h-4zm5 4l-1 1 1.5 1.5-1.5 1.5h4v-4l-1.5 1.5-1.5-1.5z\\\" />\\n</svg>\"\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/raw-loader!./bower_components/open-iconic/svg/fullscreen-enter.svg\n ** module id = 5\n ** module chunks = 0\n **/","module.exports = \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"8\\\" height=\\\"8\\\" viewBox=\\\"0 0 8 8\\\">\\n  <path d=\\\"M1 0l-1 1 1.5 1.5-1.5 1.5h4v-4l-1.5 1.5-1.5-1.5zm3 4v4l1.5-1.5 1.5 1.5 1-1-1.5-1.5 1.5-1.5h-4z\\\" />\\n</svg>\"\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/raw-loader!./bower_components/open-iconic/svg/fullscreen-exit.svg\n ** module id = 6\n ** module chunks = 0\n **/","module.exports = \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"8\\\" height=\\\"8\\\" viewBox=\\\"0 0 8 8\\\">\\n  <path d=\\\"M4.03 0c-2.53 0-4.03 3-4.03 3s1.5 3 4.03 3c2.47 0 3.97-3 3.97-3s-1.5-3-3.97-3zm-.03 1c1.11 0 2 .9 2 2 0 1.11-.89 2-2 2-1.1 0-2-.89-2-2 0-1.1.9-2 2-2zm0 1c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1c0-.1-.04-.19-.06-.28-.08.16-.24.28-.44.28-.28 0-.5-.22-.5-.5 0-.2.12-.36.28-.44-.09-.03-.18-.06-.28-.06z\\\"\\n  transform=\\\"translate(0 1)\\\" />\\n</svg>\"\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/raw-loader!./bower_components/open-iconic/svg/eye.svg\n ** module id = 7\n ** module chunks = 0\n **/","module.exports = \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"8\\\" height=\\\"8\\\" viewBox=\\\"0 0 8 8\\\">\\n  <path d=\\\"M4 0c-2.2 0-4 1.8-4 4s1.8 4 4 4 4-1.8 4-4-1.8-4-4-4zm0 1c1.66 0 3 1.34 3 3s-1.34 3-3 3-3-1.34-3-3 1.34-3 3-3zm2 1l-3 1-1 3 3-1 1-3zm-2 1.5c.28 0 .5.22.5.5s-.22.5-.5.5-.5-.22-.5-.5.22-.5.5-.5z\\\" />\\n</svg>\"\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/raw-loader!./bower_components/open-iconic/svg/compass.svg\n ** module id = 8\n ** module chunks = 0\n **/","/**\n * NoSleep.js v0.5.0 - git.io/vfn01\n * Rich Tibbett\n * MIT license\n **/\n(function(root) {\n  // UA matching\n  var ua = {\n    Android: /Android/ig.test(navigator.userAgent),\n    iOS: /AppleWebKit/.test(navigator.userAgent) && /Mobile\\/\\w+/.test(navigator.userAgent)\n  };\n\n  var media = {\n    WebM: \"data:video/webm;base64,GkXfo0AgQoaBAUL3gQFC8oEEQvOBCEKCQAR3ZWJtQoeBAkKFgQIYU4BnQI0VSalmQCgq17FAAw9CQE2AQAZ3aGFtbXlXQUAGd2hhbW15RIlACECPQAAAAAAAFlSua0AxrkAu14EBY8WBAZyBACK1nEADdW5khkAFVl9WUDglhohAA1ZQOIOBAeBABrCBCLqBCB9DtnVAIueBAKNAHIEAAIAwAQCdASoIAAgAAUAmJaQAA3AA/vz0AAA=\",\n    MP4: \"data:video/mp4;base64,AAAAHGZ0eXBpc29tAAACAGlzb21pc28ybXA0MQAAAAhmcmVlAAAAG21kYXQAAAGzABAHAAABthADAowdbb9/AAAC6W1vb3YAAABsbXZoZAAAAAB8JbCAfCWwgAAAA+gAAAAAAAEAAAEAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAIVdHJhawAAAFx0a2hkAAAAD3wlsIB8JbCAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAQAAAAAAIAAAACAAAAAABsW1kaWEAAAAgbWRoZAAAAAB8JbCAfCWwgAAAA+gAAAAAVcQAAAAAAC1oZGxyAAAAAAAAAAB2aWRlAAAAAAAAAAAAAAAAVmlkZW9IYW5kbGVyAAAAAVxtaW5mAAAAFHZtaGQAAAABAAAAAAAAAAAAAAAkZGluZgAAABxkcmVmAAAAAAAAAAEAAAAMdXJsIAAAAAEAAAEcc3RibAAAALhzdHNkAAAAAAAAAAEAAACobXA0dgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAIAAgASAAAAEgAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABj//wAAAFJlc2RzAAAAAANEAAEABDwgEQAAAAADDUAAAAAABS0AAAGwAQAAAbWJEwAAAQAAAAEgAMSNiB9FAEQBFGMAAAGyTGF2YzUyLjg3LjQGAQIAAAAYc3R0cwAAAAAAAAABAAAAAQAAAAAAAAAcc3RzYwAAAAAAAAABAAAAAQAAAAEAAAABAAAAFHN0c3oAAAAAAAAAEwAAAAEAAAAUc3RjbwAAAAAAAAABAAAALAAAAGB1ZHRhAAAAWG1ldGEAAAAAAAAAIWhkbHIAAAAAAAAAAG1kaXJhcHBsAAAAAAAAAAAAAAAAK2lsc3QAAAAjqXRvbwAAABtkYXRhAAAAAQAAAABMYXZmNTIuNzguMw==\"\n  };\n\n  function addSourceToVideo(element, type, dataURI) {\n    var source = document.createElement('source');\n    source.src = dataURI;\n    source.type = \"video/\" + type;\n    element.appendChild(source);\n  }\n\n  // NoSleep instance constructor\n  var NoSleep = function() {\n    if (ua.iOS) {\n      this.noSleepTimer = null;\n    } else if (ua.Android) {\n      // Set up no sleep video element\n      this.noSleepVideo = document.createElement('video');\n      this.noSleepVideo.setAttribute(\"loop\", \"\");\n\n      // Append nosleep video sources\n      addSourceToVideo(this.noSleepVideo, \"webm\", media.WebM);\n      addSourceToVideo(this.noSleepVideo, \"mp4\", media.MP4);\n    }\n\n    return this;\n  };\n\n  // Enable NoSleep instance\n  NoSleep.prototype.enable = function(duration) {\n    if (ua.iOS) {\n      this.disable();\n      this.noSleepTimer = window.setInterval(function() {\n        window.location = window.location;\n        window.setTimeout(window.stop, 0);\n      }, duration || 15000);\n    } else if (ua.Android) {\n      this.noSleepVideo.play();\n    }\n  };\n\n  // Disable NoSleep instance\n  NoSleep.prototype.disable = function() {\n    if (ua.iOS) {\n      if (this.noSleepTimer) {\n        window.clearInterval(this.noSleepTimer);\n        this.noSleepTimer = null;\n      }\n    } else if (ua.Android) {\n      this.noSleepVideo.pause();\n    }\n  };\n\n  // Append NoSleep API to root object\n  root.NoSleep = NoSleep;\n})(this);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./bower_components/nosleep/NoSleep.js\n ** module id = 9\n ** module chunks = 0\n **/","module.exports = (function () {\n\t'use strict';\n\n\tvar THREE = require('three'),\n\t\tforEach = require('lodash.foreach'),\n\t\tassign = require('lodash.assign'),\n\n\t\tiOS = navigator.userAgent.match(/(iPad|iPhone|iPod)/g),\n\n\t\t// https://gist.github.com/dperini/729294\n\t\t//urlRegex = /^(?:(?:https?|ftp):\\/\\/)(?:\\S+(?::\\S*)?@)?(?:(?!(?:10|127)(?:\\.\\d{1,3}){3})(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))(?::\\d{2,5})?(?:\\/\\S*)?$/i,\n\t\turlRegex = require('./utils/urlregex'),\n\n\t\tdataUri = /^data:image\\/(?:png|jpe?g|gif);/,\n\t\tassetPath = __ASSET_PATH__,\n\n\t\timages = {},\n\n\t\tmaterialTypes = {\n\t\t\tlambert: THREE.MeshLambertMaterial,\n\t\t\tbasic: THREE.MeshBasicMaterial,\n\t\t\tphong: THREE.MeshPhongMaterial,\n\t\t\tnormal: THREE.MeshNormalMaterial,\n\t\t\tdepth: THREE.MeshDepthMaterial\n\t\t},\n\t\ttextureFiles = {\n\t\t\t'asphalt': {\n\t\t\t\trepeat: 12\n\t\t\t},\n\t\t\t'brick-tiles': {\n\t\t\t\trepeat: 2\n\t\t\t},\n\t\t\t'bricks': {\n\t\t\t\ttype: 'phong',\n\t\t\t\trepeat: 4,\n\t\t\t\tnormalMap: 'bricks-normal.jpg',\n\t\t\t\tspecularMap: 'bricks-specular.jpg'\n\t\t\t},\n\t\t\t'checkerboard': {\n\t\t\t\trepeat: 10,\n\t\t\t\tmap: 'checkerboard.png'\n\t\t\t},\n\t\t\t'grass': {\n\t\t\t\trepeat: 12\n\t\t\t},\n\t\t\t'metal-floor': {\n\t\t\t\ttype: 'phong',\n\t\t\t\tshininess: 100,\n\n\t\t\t\trepeat: 2\n\t\t\t},\n\t\t\t'metal': {\n\t\t\t\ttype: 'phong',\n\t\t\t\tshininess: 100,\n\t\t\t\tshading: THREE.SmoothShading,\n\n\t\t\t\trepeat: 2\n\t\t\t},\n\t\t\t'stone': {\n\t\t\t\trepeat: 8\n\t\t\t},\n\t\t\t'tiles': {\n\t\t\t\trepeat: 4\n\t\t\t},\n\t\t\t'weathered-wood': {\n\t\t\t\trepeat: 8\n\t\t\t},\n\t\t\t'wood': {\n\t\t\t\trepeat: 4\n\t\t\t}\n\t\t},\n\t\ttextures = {},\n\t\tmaterials;\n\n\tfunction imageTexture(src, mapping, callback) {\n\t\tvar image,\n\t\t\tparse,\n\t\t\ttexture,\n\t\t\tisDataUri;\n\n\t\tfunction imageLoaded() {\n\t\t\tvar scale,\n\t\t\t\tcanvas,\n\t\t\t\tctx,\n\t\t\t\tsmallImage;\n\n\t\t\t/*\n\t\t\tiOS doesn't know how to handle large images. Even though the MAX_TEXTURE_SIZE\n\t\t\tmay be 4096, it still breaks on images that large. So we scale them down.\n\t\t\t*/\n\t\t\tif (iOS && (image.naturalWidth > 2048 || image.naturalHeight > 2048)) {\n\t\t\t\tscale = 2048 / Math.max( image.naturalWidth, image.naturalHeight );\n\n\t\t\t\tcanvas = document.createElement('canvas');\n\t\t\t\tcanvas.width = Math.floor(image.naturalWidth * scale);\n\t\t\t\tcanvas.height = Math.floor(image.naturalHeight * scale);\n\n\t\t\t\tctx = canvas.getContext('2d');\n\t\t\t\tctx.drawImage(image, 0, 0, image.naturalWidth, image.naturalHeight, 0, 0, canvas.width, canvas.height);\n\n\t\t\t\timage = canvas;\n\t\t\t}\n\n\t\t\ttexture.image = image;\n\t\t\ttexture.needsUpdate = true;\n\t\t\tif (typeof callback === 'function') {\n\t\t\t\tsetTimeout(callback.bind(null, texture, image), 1);\n\t\t\t}\n\t\t}\n\n\t\tparse = dataUri.exec(src);\n\t\tisDataUri = !!parse;\n\t\tif (!parse) {\n\t\t\tparse = urlRegex.exec(src);\n\t\t}\n\n\t\t// if (!parse) {\n\t\t// \tconsole.error('Invalid image URL: ' + src);\n\t\t// \treturn;\n\t\t// }\n\n\t\tif (images[src]) {\n\t\t\timage = images[src];\n\t\t} else {\n\t\t\timage = document.createElement('img');\n\t\t\tif (parse && (parse[1] && parse[1] !== window.location.hostname || parse[2] && parse[2] !== window.location.port)) {\n\t\t\t\timage.crossOrigin = 'anonymous';\n\t\t\t}\n\t\t\timage.src = src;\n\t\t\timages[src] = image;\n\t\t}\n\n\t\ttexture = new THREE.Texture(undefined, mapping);\n\n\t\tif (image.naturalWidth || isDataUri) {\n\t\t\tsetTimeout(imageLoaded, 1);\n\t\t} else {\n\t\t\timage.addEventListener('load', imageLoaded);\n\t\t}\n\n\t\treturn texture;\n\t}\n\n\tfunction material(options) {\n\t\tvar opts,\n\t\t\tMaterial = materialTypes[options.type] || THREE.MeshLambertMaterial;\n\n\t\tfunction threeTexture(fn) {\n\t\t\tif (typeof fn === 'string') {\n\t\t\t\tif (urlRegex.test(fn) || dataUri.test(fn)) {\n\t\t\t\t\treturn imageTexture(fn);\n\t\t\t\t}\n\n\t\t\t\tfn = textures[fn];\n\t\t\t}\n\t\t\tif (typeof fn === 'function') {\n\t\t\t\treturn fn(options);\n\t\t\t}\n\n\t\t\treturn fn;\n\t\t}\n\n\t\topts = assign({}, options);\n\t\tforEach({\n\t\t\tambient: options.ambient || options.color,\n\t\t\temissive: options.emissive || options.color,\n\t\t\tmap: threeTexture(options.map),\n\t\t\tspecularMap: threeTexture(options.specularMap),\n\t\t\tnormalMap: threeTexture(options.normalMap),\n\t\t\talphaMap: threeTexture(options.alphaMap),\n\t\t\tenvMap: threeTexture(options.envMap),\n\t\t\tlightMap: threeTexture(options.lightMap)\n\t\t}, function (val, key) {\n\t\t\tif (val !== undefined) {\n\t\t\t\topts[key] = val;\n\t\t\t}\n\t\t});\n\n\t\tdelete opts.type;\n\n\t\treturn new Material(opts);\n\t}\n\n\t//figure out if script is loaded relative so we know where to find the images\n\tassetPath = (function () {\n\t\tvar url,\n\t\t\tscripts;\n\n\t\tif (document.currentScript) {\n\t\t\turl = document.currentScript.getAttribute('src');\n\t\t} else {\n\t\t\tscripts = document.getElementsByTagName('script');\n\t\t\turl = scripts[scripts.length - 1].getAttribute('src');\n\t\t}\n\n\t\tif (!urlRegex.test(url)) {\n\t\t\treturn url.replace(/[a-z\\-\\.]+\\.js$/i, '');\n\t\t}\n\n\t\treturn __ASSET_PATH__;\n\t}());\n\n\tmaterials = {\n\t\tstandard: function () {\n\t\t\treturn new THREE.MeshLambertMaterial();\n\t\t},\n\t\ttextures: textures,\n\t\timageTexture: imageTexture,\n\t\tmaterial: material,\n\t\tlibrary: ['standard']\n\t};\n\n\tforEach(textureFiles, function (props, key) {\n\t\tfunction textureFactory(file, options) {\n\t\t\tfunction imagePath(url) {\n\t\t\t\tif ((/^[a-z0-9\\/\\-]+\\.(png|jpg)$/i).test(url)) {\n\t\t\t\t\treturn assetPath + url;\n\t\t\t\t}\n\n\t\t\t\treturn url;\n\t\t\t}\n\n\t\t\toptions = options || {};\n\n\t\t\treturn function (opts) {\n\t\t\t\tvar texture = imageTexture(imagePath(require('./images/' + file)));\n\n\t\t\t\topts = assign({}, options, opts);\n\n\t\t\t\tif (opts.repeat) {\n\t\t\t\t\tif (opts.repeat > 0) {\n\t\t\t\t\t\ttexture.repeat.set(opts.repeat, opts.repeat);\n\t\t\t\t\t} else if (opts.repeat instanceof THREE.Vector2) {\n\t\t\t\t\t\ttexture.repeat.copy(opts.repeat);\n\t\t\t\t\t}\n\t\t\t\t\ttexture.wrapS = texture.wrapT = THREE.RepeatWrapping;\n\t\t\t\t}\n\t\t\t\treturn texture;\n\t\t\t};\n\t\t}\n\n\t\tvar map = textureFactory(props.map || key + '.jpg', props),\n\t\t\tmaterialDef;\n\n\t\tmaterialDef = assign({}, props, {\n\t\t\tmap: map\n\t\t});\n\t\ttextures[key] = map;\n\n\t\tif (props.normalMap) {\n\t\t\tmaterialDef.normalMap = textures[key + '-normal'] = textureFactory(props.normalMap, props);\n\t\t}\n\n\t\tif (props.specularMap) {\n\t\t\tmaterialDef.specularMap = textures[key + '-specular'] = textureFactory(props.specularMap, props);\n\t\t}\n\n\t\tmaterials.library.push(key);\n\t\tmaterials[key] = function (options) {\n\t\t\tvar opts = assign({}, materialDef, options);\n\n\t\t\treturn material(opts);\n\t\t};\n\t});\n\n\treturn materials;\n\n\t//var parse = urlRegex.exec('https://lh5.googleusercontent.com:80/-SNO8rWDqbUM/U085rfOBRuI/AAAAAAAAEdM/nWEWCtNceZ0/w955-h382-no/PANO_20130225_131211.jpg');\n}());\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/materials.js\n ** module id = 10\n ** module chunks = 0\n **/","module.exports = (function () {\n\t'use strict';\n\n\tvar\tNEAR_DISTANCE = 3,\n\t\tmaterials = require('./materials'),\n\t\tTHREE = require('three'),\n\t\teventEmitter = require('event-emitter'),\n\n\t\txAxis = new THREE.Vector3(1, 0, 0),\n\t\tyAxis = new THREE.Vector3(0, 1, 0),\n\t\tzAxis = new THREE.Vector3(0, 0, 1),\n\n\t\tscratchVector1 = new THREE.Vector3(),\n\t\tscratchVector2 = new THREE.Vector3(),\n\n\t\tallObjects = window.WeakMap ? new window.WeakMap() : {};\n\n\tfunction distance(object, origin) {\n\t\tvar geometry;\n\n\t\tgeometry = object.geometry;\n\n\t\t//assumes object world matrix has been updated\n\t\tscratchVector1.setFromMatrixPosition(origin.matrixWorld);\n\n\t\tif (!geometry) {\n\t\t\t//first convert to world coordinate\n\t\t\tscratchVector2.setFromMatrixPosition(object.matrixWorld);\n\t\t\treturn scratchVector2.distanceTo(scratchVector1);\n\t\t}\n\n\t\tgeometry.computeBoundingBox();\n\t\tobject.worldToLocal(scratchVector1);\n\t\treturn object.geometry.boundingBox.distanceToPoint(scratchVector1);\n\t}\n\n\tfunction VRObject(parent, creator, camera, options) {\n\t\tvar material,\n\t\t\tobject,\n\t\t\tself = this,\n\n\t\t\tisNear = false,\n\t\t\tisTarget = false,\n\t\t\traycaster;\n\n\t\toptions = options || {};\n\n\t\teventEmitter(this);\n\n\t\tif (camera) {\n\t\t\t// raycaster = new THREE.Raycaster();\n\n\t\t\tthis.update = function () {\n\t\t\t\tvar wasNear = isNear,\n\t\t\t\t\twasTarget = isTarget,\n\n\t\t\t\t\tintersects, intersect, i;\n\n\t\t\t\tisNear = self.distance < NEAR_DISTANCE;\n\t\t\t\tif (isNear !== wasNear) {\n\t\t\t\t\tif (isNear) {\n\t\t\t\t\t\tself.emit('near', self);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.emit('far', self);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\traycaster.ray.origin.copy(origin);\n\t\t\t\traycaster.ray.direction.set(0, 0, 0.5).unproject(camera).sub(origin).normalize();\n\n\t\t\t\t//todo: consider whether this needs to be recursive. maybe a different event\n\t\t\t\tintersects = raycaster.intersectObject(object);\n\t\t\t\tif (intersects.length) {\n\t\t\t\t\tisTarget = true;\n\t\t\t\t\tif (!wasTarget) {\n\t\t\t\t\t\tself.emit('target-on', intersects[0]);\n\t\t\t\t\t}\n\t\t\t\t} else if (wasTarget) {\n\t\t\t\t\tself.emit('target-off');\n\t\t\t\t}\n\t\t\t\t*/\n\t\t\t};\n\t\t}\n\n\t\t//todo: get material from options\n\t\tthis.object = object = creator.call(this, parent, options);\n\t\tthis.parent = this.object.parent || parent;\n\n\t\tif (object instanceof THREE.Mesh) {\n\t\t\tif (options.castShadow !== false) {\n\t\t\t\tobject.castShadow = true;\n\t\t\t}\n\t\t\tif (options.receiveShadow !== false) {\n\t\t\t\tobject.receiveShadow = true;\n\t\t\t}\n\t\t}\n\n\t\tif (options.name !== undefined) {\n\t\t\tobject.name = options.name;\n\t\t}\n\t\tself.name = object.name;\n\n\t\tif (allObjects.set) {\n\t\t\tallObjects.set(object, this);\n\t\t\t// allObjects.set(object.id, this);\n\t\t} else {\n\t\t\tallObjects[object.id] = this;\n\t\t}\n\n\t\tobject.position.set(\n\t\t\tparseFloat(options.x) || 0,\n\t\t\tparseFloat(options.y) || 0,\n\t\t\tparseFloat(options.z) || 0\n\t\t);\n\n\t\tthis.setMaterial(options.material);\n\n\t\tif (options.color) {\n\t\t\tmaterial = object.material;\n\t\t\tmaterial.color = new THREE.Color(options.color);\n\t\t\tmaterial.ambient = material.color;\n\t\t}\n\n\t\t['position', 'scale', 'rotation', 'quaternion', 'material'].forEach(function (prop) {\n\t\t\tif (prop in object && !self[prop]) {\n\t\t\t\tself[prop] = object[prop];\n\t\t\t}\n\t\t});\n\n\t\tObject.defineProperty(this, 'visible', {\n\t\t\tset: function (val) {\n\t\t\t\tself.object.visible = !!val;\n\t\t\t},\n\t\t\tget: function () {\n\t\t\t\treturn self.object.visible;\n\t\t\t}\n\t\t});\n\n\t\tObject.defineProperty(this, 'distance', {\n\t\t\tget: function () {\n\t\t\t\treturn distance(self.object, camera || parent);\n\t\t\t}\n\t\t});\n\t}\n\n\tVRObject.prototype.hide = function () {\n\t\tthis.object.visible = false;\n\t\treturn this;\n\t};\n\n\tVRObject.prototype.show = function () {\n\t\tthis.object.visible = true;\n\t\treturn this;\n\t};\n\n\tVRObject.prototype.moveTo = function (x, y, z) {\n\t\tvar position = this.object.position;\n\n\t\tx = !isNaN(x) ? x : position.x;\n\t\ty = !isNaN(y) ? y : position.y;\n\t\tz = !isNaN(z) ? z : position.z;\n\n\t\tposition.set(x, y, z);\n\n\t\treturn this;\n\t};\n\n\tVRObject.prototype.moveX = function (distance) {\n\t\tthis.object.translateX(distance);\n\t\treturn this;\n\t};\n\n\tVRObject.prototype.moveY = function (distance) {\n\t\tthis.object.translateY(distance);\n\t\treturn this;\n\t};\n\tVRObject.prototype.moveUp = VRObject.prototype.moveY;\n\tVRObject.prototype.moveDown = function (distance) {\n\t\tthis.moveY(-distance);\n\t\treturn this;\n\t};\n\n\tVRObject.prototype.moveZ = function (distance) {\n\t\tthis.object.translateZ(distance);\n\t\treturn this;\n\t};\n\n\tVRObject.prototype.rotateX = function (angle) {\n\t\tthis.object.rotateOnAxis(xAxis, angle);\n\t\treturn this;\n\t};\n\n\tVRObject.prototype.rotateY = function (angle) {\n\t\tthis.object.rotateOnAxis(yAxis, angle);\n\t\treturn this;\n\t};\n\n\tVRObject.prototype.rotateZ = function (angle) {\n\t\tthis.object.rotateOnAxis(zAxis, angle);\n\t\treturn this;\n\t};\n\n\tVRObject.prototype.setScale = function (x, y, z) {\n\t\tvar scale = this.object.scale;\n\n\t\tif (x !== undefined && !isNaN(x)) {\n\t\t\tif (y === undefined && z === undefined) {\n\t\t\t\ty = z = x;\n\t\t\t} else {\n\t\t\t\tx = scale.x;\n\t\t\t}\n\t\t}\n\n\t\tx = !isNaN(x) ? x : scale.x;\n\t\ty = !isNaN(y) ? y : scale.y;\n\t\tz = !isNaN(z) ? z : scale.z;\n\n\t\tscale.set(x, y, z);\n\n\t\treturn this;\n\t};\n\n\tVRObject.prototype.setMaterial = function (material, options) {\n\t\tif (material && this.object instanceof THREE.Mesh) {\n\t\t\tif (typeof material === 'function') {\n\t\t\t\tmaterial = material();\n\t\t\t} else if (typeof material === 'string' && materials[material]) {\n\t\t\t\tmaterial = materials[material](options);\n\t\t\t} else if (material && !(material instanceof THREE.Material) && typeof material !== 'number') {\n\t\t\t\ttry {\n\t\t\t\t\tmaterial = materials(material);\n\t\t\t\t} catch (e) {}\n\t\t\t}\n\t\t\tthis.object.material = material || this.object.material;\n\t\t}\n\n\t\treturn this;\n\t};\n\n\tVRObject.prototype.update = function () {};\n\n\tVRObject.repeat = function (count, options) {\n\t\tvar i,\n\t\t\tchange = false,\n\t\t\tlastObject = this,\n\t\t\tcurrentPosition = new THREE.Vector3(),\n\t\t\tdeltaPosition = new THREE.Vector3(),\n\t\t\tcurrentQuaternion = new THREE.Quaternion(),\n\t\t\tdeltaQuaternion = new THREE.Quaternion();\n\n\t\tif (!options) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (options.offset) {}\n\n\t\tfor (i = 0; i < count; i++) {\n\n\t\t}\n\t};\n\n\tVRObject.findObject = function (object) {\n\t\tif (object instanceof VRObject) {\n\t\t\treturn object;\n\t\t}\n\n\t\tif (object && object instanceof THREE.Object3D) {\n\t\t\tif (allObjects.get) {\n\t\t\t\treturn allObjects.get(object);\n\t\t\t}\n\n\t\t\treturn allObjects[object.id];\n\t\t}\n\n\t\t// if (typeof object === 'number') {\n\t\t// \treturn allObjects[object];\n\t\t// }\n\t};\n\n\treturn VRObject;\n\n}());\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/vr-object.js\n ** module id = 11\n ** module chunks = 0\n **/","var map = {\n\t\"./box\": 21,\n\t\"./box.js\": 21,\n\t\"./cylinder\": 22,\n\t\"./cylinder.js\": 22,\n\t\"./empty\": 13,\n\t\"./empty.js\": 13,\n\t\"./floor\": 23,\n\t\"./floor.js\": 23,\n\t\"./image\": 24,\n\t\"./image.js\": 24,\n\t\"./panorama\": 25,\n\t\"./panorama.js\": 25,\n\t\"./particles\": 26,\n\t\"./particles.js\": 26,\n\t\"./sky\": 27,\n\t\"./sky.js\": 27,\n\t\"./sound\": 28,\n\t\"./sound.js\": 28,\n\t\"./sphere\": 29,\n\t\"./sphere.js\": 29,\n\t\"./text\": 30,\n\t\"./text.js\": 30,\n\t\"./torus\": 31,\n\t\"./torus.js\": 31,\n\t\"./video\": 32,\n\t\"./video.js\": 32\n};\nfunction webpackContext(req) {\n\treturn __webpack_require__(webpackContextResolve(req));\n};\nfunction webpackContextResolve(req) {\n\treturn map[req] || (function() { throw new Error(\"Cannot find module '\" + req + \"'.\") }());\n};\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = 12;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/objects ^\\.\\/.*$\n ** module id = 12\n ** module chunks = 0\n **/","module.exports = (function () {\n\t'use strict';\n\n\tvar materials = require('../materials'),\n\t\tTHREE = require('three');\n\n\treturn function empty(parent, options) {\n\t\tvar obj = new THREE.Object3D();\n\n\t\tobj.name = 'empty';\n\n\t\tparent.add(obj);\n\n\t\treturn obj;\n\t};\n}());\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/objects/empty.js\n ** module id = 13\n ** module chunks = 0\n **/","/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n// css base code, injected by the css-loader\r\nmodule.exports = function() {\r\n\tvar list = [];\r\n\r\n\t// return the list of modules as css string\r\n\tlist.toString = function toString() {\r\n\t\tvar result = [];\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar item = this[i];\r\n\t\t\tif(item[2]) {\r\n\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\r\n\t\t\t} else {\r\n\t\t\t\tresult.push(item[1]);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result.join(\"\");\r\n\t};\r\n\r\n\t// import a list of modules into the list\r\n\tlist.i = function(modules, mediaQuery) {\r\n\t\tif(typeof modules === \"string\")\r\n\t\t\tmodules = [[null, modules, \"\"]];\r\n\t\tvar alreadyImportedModules = {};\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar id = this[i][0];\r\n\t\t\tif(typeof id === \"number\")\r\n\t\t\t\talreadyImportedModules[id] = true;\r\n\t\t}\r\n\t\tfor(i = 0; i < modules.length; i++) {\r\n\t\t\tvar item = modules[i];\r\n\t\t\t// skip already imported module\r\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\r\n\t\t\t//  when a module is imported multiple times with different media queries.\r\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\r\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\r\n\t\t\t\tif(mediaQuery && !item[2]) {\r\n\t\t\t\t\titem[2] = mediaQuery;\r\n\t\t\t\t} else if(mediaQuery) {\r\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\r\n\t\t\t\t}\r\n\t\t\t\tlist.push(item);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\treturn list;\r\n};\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/css-loader/lib/css-base.js\n ** module id = 14\n ** module chunks = 0\n **/","/*** IMPORTS FROM imports-loader ***/\nvar THREE = require(\"three\");\n\n/**\n * @author richt / http://richt.me\n * @author WestLangley / http://github.com/WestLangley\n *\n * W3C Device Orientation control (http://w3c.github.io/deviceorientation/spec-source-orientation.html)\n */\n\nTHREE.DeviceOrientationControls = function ( object ) {\n\n\tvar scope = this;\n\n\tthis.object = object;\n\tthis.object.rotation.reorder( \"YXZ\" );\n\n\tthis.enabled = true;\n\n\tthis.deviceOrientation = {};\n\tthis.screenOrientation = 0;\n\n\tvar onDeviceOrientationChangeEvent = function ( event ) {\n\n\t\tscope.deviceOrientation = event;\n\n\t};\n\n\tvar onScreenOrientationChangeEvent = function () {\n\n\t\tscope.screenOrientation = window.orientation || 0;\n\n\t};\n\n\t// The angles alpha, beta and gamma form a set of intrinsic Tait-Bryan angles of type Z-X'-Y''\n\n\tvar setObjectQuaternion = function () {\n\n\t\tvar zee = new THREE.Vector3( 0, 0, 1 );\n\n\t\tvar euler = new THREE.Euler();\n\n\t\tvar q0 = new THREE.Quaternion();\n\n\t\tvar q1 = new THREE.Quaternion( - Math.sqrt( 0.5 ), 0, 0, Math.sqrt( 0.5 ) ); // - PI/2 around the x-axis\n\n\t\treturn function ( quaternion, alpha, beta, gamma, orient ) {\n\n\t\t\teuler.set( beta, alpha, - gamma, 'YXZ' );                       // 'ZXY' for the device, but 'YXZ' for us\n\n\t\t\tquaternion.setFromEuler( euler );                               // orient the device\n\n\t\t\tquaternion.multiply( q1 );                                      // camera looks out the back of the device, not the top\n\n\t\t\tquaternion.multiply( q0.setFromAxisAngle( zee, - orient ) );    // adjust for screen orientation\n\n\t\t}\n\n\t}();\n\n\tthis.connect = function() {\n\n\t\tonScreenOrientationChangeEvent(); // run once on load\n\n\t\twindow.addEventListener( 'orientationchange', onScreenOrientationChangeEvent, false );\n\t\twindow.addEventListener( 'deviceorientation', onDeviceOrientationChangeEvent, false );\n\n\t\tscope.enabled = true;\n\n\t};\n\n\tthis.disconnect = function() {\n\n\t\twindow.removeEventListener( 'orientationchange', onScreenOrientationChangeEvent, false );\n\t\twindow.removeEventListener( 'deviceorientation', onDeviceOrientationChangeEvent, false );\n\n\t\tscope.enabled = false;\n\n\t};\n\n\tthis.update = function () {\n\n\t\tif ( scope.enabled === false ) return;\n\n\t\tvar alpha  = scope.deviceOrientation.alpha ? THREE.Math.degToRad( scope.deviceOrientation.alpha ) : 0; // Z\n\t\tvar beta   = scope.deviceOrientation.beta  ? THREE.Math.degToRad( scope.deviceOrientation.beta  ) : 0; // X'\n\t\tvar gamma  = scope.deviceOrientation.gamma ? THREE.Math.degToRad( scope.deviceOrientation.gamma ) : 0; // Y''\n\t\tvar orient = scope.screenOrientation       ? THREE.Math.degToRad( scope.screenOrientation       ) : 0; // O\n\n\t\tsetObjectQuaternion( scope.object.quaternion, alpha, beta, gamma, orient );\n\n\t};\n\n\tthis.connect();\n\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/imports-loader?THREE=three!./bower_components/DeviceOrientationControls/index.js\n ** module id = 15\n ** module chunks = 0\n **/","/*** IMPORTS FROM imports-loader ***/\nvar THREE = require(\"three\");\n\n/**\n * @author qiao / https://github.com/qiao\n * @author mrdoob / http://mrdoob.com\n * @author alteredq / http://alteredqualia.com/\n * @author WestLangley / http://github.com/WestLangley\n * @author erich666 / http://erichaines.com\n */\n/*global THREE, console */\n\n// This set of controls performs orbiting, dollying (zooming), and panning. It maintains\n// the \"up\" direction as +Y, unlike the TrackballControls. Touch on tablet and phones is\n// supported.\n//\n//    Orbit - left mouse / touch: one finger move\n//    Zoom - middle mouse, or mousewheel / touch: two finger spread or squish\n//    Pan - right mouse, or arrow keys / touch: three finter swipe\n//\n// This is a drop-in replacement for (most) TrackballControls used in examples.\n// That is, include this js file and wherever you see:\n//    \tcontrols = new THREE.TrackballControls( camera );\n//      controls.target.z = 150;\n// Simple substitute \"OrbitControls\" and the control should work as-is.\n\nTHREE.OrbitControls = function ( object, domElement ) {\n\n\tthis.object = object;\n\tthis.domElement = ( domElement !== undefined ) ? domElement : document;\n\n\t// API\n\n\t// Set to false to disable this control\n\tthis.enabled = true;\n\n\t// \"target\" sets the location of focus, where the control orbits around\n\t// and where it pans with respect to.\n\tthis.target = new THREE.Vector3();\n\n\t// center is old, deprecated; use \"target\" instead\n\tthis.center = this.target;\n\n\t// This option actually enables dollying in and out; left as \"zoom\" for\n\t// backwards compatibility\n\tthis.noZoom = false;\n\tthis.zoomSpeed = 1.0;\n\n\t// Limits to how far you can dolly in and out\n\tthis.minDistance = 0;\n\tthis.maxDistance = Infinity;\n\n\t// Set to true to disable this control\n\tthis.noRotate = false;\n\tthis.rotateSpeed = 1.0;\n\n\t// Set to true to disable this control\n\tthis.noPan = false;\n\tthis.keyPanSpeed = 7.0;\t// pixels moved per arrow key push\n\n\t// Set to true to automatically rotate around the target\n\tthis.autoRotate = false;\n\tthis.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60\n\n\t// How far you can orbit vertically, upper and lower limits.\n\t// Range is 0 to Math.PI radians.\n\tthis.minPolarAngle = 0; // radians\n\tthis.maxPolarAngle = Math.PI; // radians\n\n\t// How far you can orbit horizontally, upper and lower limits.\n\t// If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].\n\tthis.minAzimuthAngle = - Infinity; // radians\n\tthis.maxAzimuthAngle = Infinity; // radians\n\n\t// Set to true to disable use of the keys\n\tthis.noKeys = false;\n\n\t// The four arrow keys\n\tthis.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };\n\n\t// Mouse buttons\n\tthis.mouseButtons = { ORBIT: THREE.MOUSE.LEFT, ZOOM: THREE.MOUSE.MIDDLE, PAN: THREE.MOUSE.RIGHT };\n\n\t////////////\n\t// internals\n\n\tvar scope = this;\n\n\tvar EPS = 0.000001;\n\n\tvar rotateStart = new THREE.Vector2();\n\tvar rotateEnd = new THREE.Vector2();\n\tvar rotateDelta = new THREE.Vector2();\n\n\tvar panStart = new THREE.Vector2();\n\tvar panEnd = new THREE.Vector2();\n\tvar panDelta = new THREE.Vector2();\n\tvar panOffset = new THREE.Vector3();\n\n\tvar offset = new THREE.Vector3();\n\n\tvar dollyStart = new THREE.Vector2();\n\tvar dollyEnd = new THREE.Vector2();\n\tvar dollyDelta = new THREE.Vector2();\n\n\tvar theta;\n\tvar phi;\n\tvar phiDelta = 0;\n\tvar thetaDelta = 0;\n\tvar scale = 1;\n\tvar pan = new THREE.Vector3();\n\n\tvar lastPosition = new THREE.Vector3();\n\tvar lastQuaternion = new THREE.Quaternion();\n\n\tvar STATE = { NONE : -1, ROTATE : 0, DOLLY : 1, PAN : 2, TOUCH_ROTATE : 3, TOUCH_DOLLY : 4, TOUCH_PAN : 5 };\n\n\tvar state = STATE.NONE;\n\n\t// for reset\n\n\tthis.target0 = this.target.clone();\n\tthis.position0 = this.object.position.clone();\n\n\t// so camera.up is the orbit axis\n\n\tvar quat = new THREE.Quaternion().setFromUnitVectors( object.up, new THREE.Vector3( 0, 1, 0 ) );\n\tvar quatInverse = quat.clone().inverse();\n\n\t// events\n\n\tvar changeEvent = { type: 'change' };\n\tvar startEvent = { type: 'start'};\n\tvar endEvent = { type: 'end'};\n\n\tthis.rotateLeft = function ( angle ) {\n\n\t\tif ( angle === undefined ) {\n\n\t\t\tangle = getAutoRotationAngle();\n\n\t\t}\n\n\t\tthetaDelta -= angle;\n\n\t};\n\n\tthis.rotateUp = function ( angle ) {\n\n\t\tif ( angle === undefined ) {\n\n\t\t\tangle = getAutoRotationAngle();\n\n\t\t}\n\n\t\tphiDelta -= angle;\n\n\t};\n\n\t// pass in distance in world space to move left\n\tthis.panLeft = function ( distance ) {\n\n\t\tvar te = this.object.matrix.elements;\n\n\t\t// get X column of matrix\n\t\tpanOffset.set( te[ 0 ], te[ 1 ], te[ 2 ] );\n\t\tpanOffset.multiplyScalar( - distance );\n\n\t\tpan.add( panOffset );\n\n\t};\n\n\t// pass in distance in world space to move up\n\tthis.panUp = function ( distance ) {\n\n\t\tvar te = this.object.matrix.elements;\n\n\t\t// get Y column of matrix\n\t\tpanOffset.set( te[ 4 ], te[ 5 ], te[ 6 ] );\n\t\tpanOffset.multiplyScalar( distance );\n\n\t\tpan.add( panOffset );\n\n\t};\n\n\t// pass in x,y of change desired in pixel space,\n\t// right and down are positive\n\tthis.pan = function ( deltaX, deltaY ) {\n\n\t\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n\t\tif ( scope.object.fov !== undefined ) {\n\n\t\t\t// perspective\n\t\t\tvar position = scope.object.position;\n\t\t\tvar offset = position.clone().sub( scope.target );\n\t\t\tvar targetDistance = offset.length();\n\n\t\t\t// half of the fov is center to top of screen\n\t\t\ttargetDistance *= Math.tan( ( scope.object.fov / 2 ) * Math.PI / 180.0 );\n\n\t\t\t// we actually don't use screenWidth, since perspective camera is fixed to screen height\n\t\t\tscope.panLeft( 2 * deltaX * targetDistance / element.clientHeight );\n\t\t\tscope.panUp( 2 * deltaY * targetDistance / element.clientHeight );\n\n\t\t} else if ( scope.object.top !== undefined ) {\n\n\t\t\t// orthographic\n\t\t\tscope.panLeft( deltaX * (scope.object.right - scope.object.left) / element.clientWidth );\n\t\t\tscope.panUp( deltaY * (scope.object.top - scope.object.bottom) / element.clientHeight );\n\n\t\t} else {\n\n\t\t\t// camera neither orthographic or perspective\n\t\t\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );\n\n\t\t}\n\n\t};\n\n\tthis.dollyIn = function ( dollyScale ) {\n\n\t\tif ( dollyScale === undefined ) {\n\n\t\t\tdollyScale = getZoomScale();\n\n\t\t}\n\n\t\tscale /= dollyScale;\n\n\t};\n\n\tthis.dollyOut = function ( dollyScale ) {\n\n\t\tif ( dollyScale === undefined ) {\n\n\t\t\tdollyScale = getZoomScale();\n\n\t\t}\n\n\t\tscale *= dollyScale;\n\n\t};\n\n\tthis.update = function () {\n\n\t\tvar position = this.object.position;\n\n\t\toffset.copy( position ).sub( this.target );\n\n\t\t// rotate offset to \"y-axis-is-up\" space\n\t\toffset.applyQuaternion( quat );\n\n\t\t// angle from z-axis around y-axis\n\n\t\ttheta = Math.atan2( offset.x, offset.z );\n\n\t\t// angle from y-axis\n\n\t\tphi = Math.atan2( Math.sqrt( offset.x * offset.x + offset.z * offset.z ), offset.y );\n\n\t\tif ( this.autoRotate && state === STATE.NONE ) {\n\n\t\t\tthis.rotateLeft( getAutoRotationAngle() );\n\n\t\t}\n\n\t\ttheta += thetaDelta;\n\t\tphi += phiDelta;\n\n\t\t// restrict theta to be between desired limits\n\t\ttheta = Math.max( this.minAzimuthAngle, Math.min( this.maxAzimuthAngle, theta ) );\n\n\t\t// restrict phi to be between desired limits\n\t\tphi = Math.max( this.minPolarAngle, Math.min( this.maxPolarAngle, phi ) );\n\n\t\t// restrict phi to be betwee EPS and PI-EPS\n\t\tphi = Math.max( EPS, Math.min( Math.PI - EPS, phi ) );\n\n\t\tvar radius = offset.length() * scale;\n\n\t\t// restrict radius to be between desired limits\n\t\tradius = Math.max( this.minDistance, Math.min( this.maxDistance, radius ) );\n\n\t\t// move target to panned location\n\t\tthis.target.add( pan );\n\n\t\toffset.x = radius * Math.sin( phi ) * Math.sin( theta );\n\t\toffset.y = radius * Math.cos( phi );\n\t\toffset.z = radius * Math.sin( phi ) * Math.cos( theta );\n\n\t\t// rotate offset back to \"camera-up-vector-is-up\" space\n\t\toffset.applyQuaternion( quatInverse );\n\n\t\tposition.copy( this.target ).add( offset );\n\n\t\tthis.object.lookAt( this.target );\n\n\t\tthetaDelta = 0;\n\t\tphiDelta = 0;\n\t\tscale = 1;\n\t\tpan.set( 0, 0, 0 );\n\n\t\t// update condition is:\n\t\t// min(camera displacement, camera rotation in radians)^2 > EPS\n\t\t// using small-angle approximation cos(x/2) = 1 - x^2 / 8\n\n\t\tif ( lastPosition.distanceToSquared( this.object.position ) > EPS\n\t\t    || 8 * (1 - lastQuaternion.dot(this.object.quaternion)) > EPS ) {\n\n\t\t\tthis.dispatchEvent( changeEvent );\n\n\t\t\tlastPosition.copy( this.object.position );\n\t\t\tlastQuaternion.copy (this.object.quaternion );\n\n\t\t}\n\n\t};\n\n\n\tthis.reset = function () {\n\n\t\tstate = STATE.NONE;\n\n\t\tthis.target.copy( this.target0 );\n\t\tthis.object.position.copy( this.position0 );\n\n\t\tthis.update();\n\n\t};\n\n\tthis.getPolarAngle = function () {\n\n\t\treturn phi;\n\n\t};\n\n\tthis.getAzimuthalAngle = function () {\n\n\t\treturn theta\n\n\t};\n\n\tfunction getAutoRotationAngle() {\n\n\t\treturn 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;\n\n\t}\n\n\tfunction getZoomScale() {\n\n\t\treturn Math.pow( 0.95, scope.zoomSpeed );\n\n\t}\n\n\tfunction onMouseDown( event ) {\n\n\t\tif (event.button !== THREE.MOUSE.LEFT) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( scope.enabled === false ) return;\n\t\tevent.preventDefault();\n\n\t\tif ( event.button === scope.mouseButtons.ORBIT ) {\n\t\t\tif ( scope.noRotate === true ) return;\n\n\t\t\tstate = STATE.ROTATE;\n\n\t\t\trotateStart.set( event.clientX, event.clientY );\n\n\t\t} else if ( event.button === scope.mouseButtons.ZOOM ) {\n\t\t\tif ( scope.noZoom === true ) return;\n\n\t\t\tstate = STATE.DOLLY;\n\n\t\t\tdollyStart.set( event.clientX, event.clientY );\n\n\t\t} else if ( event.button === scope.mouseButtons.PAN ) {\n\t\t\tif ( scope.noPan === true ) return;\n\n\t\t\tstate = STATE.PAN;\n\n\t\t\tpanStart.set( event.clientX, event.clientY );\n\n\t\t}\n\n\t\tif ( state !== STATE.NONE ) {\n\t\t\twindow.addEventListener( 'mousemove', onMouseMove, false );\n\t\t\twindow.addEventListener( 'mouseup', onMouseUp, false );\n\t\t\tscope.dispatchEvent( startEvent );\n\t\t}\n\n\t}\n\n\tfunction onMouseMove( event ) {\n\n\t\tif ( scope.enabled === false ) return;\n\n\t\tevent.preventDefault();\n\n\t\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n\t\tif ( state === STATE.ROTATE ) {\n\n\t\t\tif ( scope.noRotate === true ) return;\n\n\t\t\trotateEnd.set( event.clientX, event.clientY );\n\t\t\trotateDelta.subVectors( rotateEnd, rotateStart );\n\n\t\t\t// rotating across whole screen goes 360 degrees around\n\t\t\tscope.rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );\n\n\t\t\t// rotating up and down along whole screen attempts to go 360, but limited to 180\n\t\t\tscope.rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );\n\n\t\t\trotateStart.copy( rotateEnd );\n\n\t\t} else if ( state === STATE.DOLLY ) {\n\n\t\t\tif ( scope.noZoom === true ) return;\n\n\t\t\tdollyEnd.set( event.clientX, event.clientY );\n\t\t\tdollyDelta.subVectors( dollyEnd, dollyStart );\n\n\t\t\tif ( dollyDelta.y > 0 ) {\n\n\t\t\t\tscope.dollyIn();\n\n\t\t\t} else {\n\n\t\t\t\tscope.dollyOut();\n\n\t\t\t}\n\n\t\t\tdollyStart.copy( dollyEnd );\n\n\t\t} else if ( state === STATE.PAN ) {\n\n\t\t\tif ( scope.noPan === true ) return;\n\n\t\t\tpanEnd.set( event.clientX, event.clientY );\n\t\t\tpanDelta.subVectors( panEnd, panStart );\n\n\t\t\tscope.pan( panDelta.x, panDelta.y );\n\n\t\t\tpanStart.copy( panEnd );\n\n\t\t}\n\n\t\tif ( state !== STATE.NONE ) scope.update();\n\n\t}\n\n\tfunction onMouseUp( /* event */ ) {\n\n\t\tif ( scope.enabled === false ) return;\n\n\t\t//window.removeEventListener( 'mousemove', onMouseMove, false );\n\t\twindow.removeEventListener( 'mouseup', onMouseUp, false );\n\t\tscope.dispatchEvent( endEvent );\n\t\tstate = STATE.NONE;\n\n\t}\n\n\tfunction onMouseWheel( event ) {\n\n\t\tif ( scope.enabled === false || scope.noZoom === true || state !== STATE.NONE ) return;\n\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\n\t\tvar delta = 0;\n\n\t\tif ( event.wheelDelta !== undefined ) { // WebKit / Opera / Explorer 9\n\n\t\t\tdelta = event.wheelDelta;\n\n\t\t} else if ( event.detail !== undefined ) { // Firefox\n\n\t\t\tdelta = - event.detail;\n\n\t\t}\n\n\t\tif ( delta > 0 ) {\n\n\t\t\tscope.dollyOut();\n\n\t\t} else {\n\n\t\t\tscope.dollyIn();\n\n\t\t}\n\n\t\tscope.update();\n\t\tscope.dispatchEvent( startEvent );\n\t\tscope.dispatchEvent( endEvent );\n\n\t}\n\n\tfunction onKeyDown( event ) {\n\n\t\tif ( scope.enabled === false || scope.noKeys === true || scope.noPan === true ) return;\n\n\t\tswitch ( event.keyCode ) {\n\n\t\t\tcase scope.keys.UP:\n\t\t\t\tscope.pan( 0, scope.keyPanSpeed );\n\t\t\t\tscope.update();\n\t\t\t\tbreak;\n\n\t\t\tcase scope.keys.BOTTOM:\n\t\t\t\tscope.pan( 0, - scope.keyPanSpeed );\n\t\t\t\tscope.update();\n\t\t\t\tbreak;\n\n\t\t\tcase scope.keys.LEFT:\n\t\t\t\tscope.pan( scope.keyPanSpeed, 0 );\n\t\t\t\tscope.update();\n\t\t\t\tbreak;\n\n\t\t\tcase scope.keys.RIGHT:\n\t\t\t\tscope.pan( - scope.keyPanSpeed, 0 );\n\t\t\t\tscope.update();\n\t\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\tfunction touchstart( event ) {\n\n\t\tif ( scope.enabled === false ) return;\n\n\t\tswitch ( event.touches.length ) {\n\n\t\t\tcase 1:\t// one-fingered touch: rotate\n\n\t\t\t\tif ( scope.noRotate === true ) return;\n\n\t\t\t\tstate = STATE.TOUCH_ROTATE;\n\n\t\t\t\trotateStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\t// two-fingered touch: dolly\n\n\t\t\t\tif ( scope.noZoom === true ) return;\n\n\t\t\t\tstate = STATE.TOUCH_DOLLY;\n\n\t\t\t\tvar dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\n\t\t\t\tvar dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\n\t\t\t\tvar distance = Math.sqrt( dx * dx + dy * dy );\n\t\t\t\tdollyStart.set( 0, distance );\n\t\t\t\tbreak;\n\n\t\t\tcase 3: // three-fingered touch: pan\n\n\t\t\t\tif ( scope.noPan === true ) return;\n\n\t\t\t\tstate = STATE.TOUCH_PAN;\n\n\t\t\t\tpanStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\tstate = STATE.NONE;\n\n\t\t}\n\n\t\tif ( state !== STATE.NONE ) scope.dispatchEvent( startEvent );\n\n\t}\n\n\tfunction touchmove( event ) {\n\n\t\tif ( scope.enabled === false ) return;\n\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\n\t\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n\t\tswitch ( event.touches.length ) {\n\n\t\t\tcase 1: // one-fingered touch: rotate\n\n\t\t\t\tif ( scope.noRotate === true ) return;\n\t\t\t\tif ( state !== STATE.TOUCH_ROTATE ) return;\n\n\t\t\t\trotateEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\n\t\t\t\trotateDelta.subVectors( rotateEnd, rotateStart );\n\n\t\t\t\t// rotating across whole screen goes 360 degrees around\n\t\t\t\tscope.rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );\n\t\t\t\t// rotating up and down along whole screen attempts to go 360, but limited to 180\n\t\t\t\tscope.rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );\n\n\t\t\t\trotateStart.copy( rotateEnd );\n\n\t\t\t\tscope.update();\n\t\t\t\tbreak;\n\n\t\t\tcase 2: // two-fingered touch: dolly\n\n\t\t\t\tif ( scope.noZoom === true ) return;\n\t\t\t\tif ( state !== STATE.TOUCH_DOLLY ) return;\n\n\t\t\t\tvar dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\n\t\t\t\tvar dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\n\t\t\t\tvar distance = Math.sqrt( dx * dx + dy * dy );\n\n\t\t\t\tdollyEnd.set( 0, distance );\n\t\t\t\tdollyDelta.subVectors( dollyEnd, dollyStart );\n\n\t\t\t\tif ( dollyDelta.y > 0 ) {\n\n\t\t\t\t\tscope.dollyOut();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tscope.dollyIn();\n\n\t\t\t\t}\n\n\t\t\t\tdollyStart.copy( dollyEnd );\n\n\t\t\t\tscope.update();\n\t\t\t\tbreak;\n\n\t\t\tcase 3: // three-fingered touch: pan\n\n\t\t\t\tif ( scope.noPan === true ) return;\n\t\t\t\tif ( state !== STATE.TOUCH_PAN ) return;\n\n\t\t\t\tpanEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\n\t\t\t\tpanDelta.subVectors( panEnd, panStart );\n\n\t\t\t\tscope.pan( panDelta.x, panDelta.y );\n\n\t\t\t\tpanStart.copy( panEnd );\n\n\t\t\t\tscope.update();\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\tstate = STATE.NONE;\n\n\t\t}\n\n\t}\n\n\tfunction touchend( /* event */ ) {\n\n\t\tif ( scope.enabled === false ) return;\n\n\t\tscope.dispatchEvent( endEvent );\n\t\tstate = STATE.NONE;\n\n\t}\n\n\t//this.domElement.addEventListener( 'contextmenu', function ( event ) { event.preventDefault(); }, false );\n\tthis.domElement.addEventListener( 'mousedown', onMouseDown, false );\n\tthis.domElement.addEventListener( 'mousewheel', onMouseWheel, false );\n\tthis.domElement.addEventListener( 'DOMMouseScroll', onMouseWheel, false ); // firefox\n\n\tthis.domElement.addEventListener( 'touchstart', touchstart, false );\n\tthis.domElement.addEventListener( 'touchend', touchend, false );\n\tthis.domElement.addEventListener( 'touchmove', touchmove, false );\n\n\twindow.addEventListener( 'keydown', onKeyDown, false );\n\n//window.addEventListener( 'mousemove', onMouseMove, true );\n\t// force an update at start\n\tthis.update();\n\n};\n\nTHREE.OrbitControls.prototype = Object.create( THREE.EventDispatcher.prototype );\nTHREE.OrbitControls.prototype.constructor = THREE.OrbitControls;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/imports-loader?THREE=three!./bower_components/OrbitControls/index.js\n ** module id = 16\n ** module chunks = 0\n **/","/*** IMPORTS FROM imports-loader ***/\nvar THREE = require(\"three\");\n\n( function() {\n\n\tvar _oldConsole = console.log;\n\n\tvar supportedTypes = [];\n\n\tfunction addSupportedType( type, format ) {\n\n\t\tsupportedTypes.push( {\n\t\t\ttype: type,\n\t\t\tformat: format\n\t\t} );\n\n\t}\n\n\taddSupportedType( THREE.Matrix4, function( v ) {\n\n\t\tvar e = v.elements;\n\t\t\t\t\n\t\treturn [\n\t\t\t[ e[ 0 ], e[ 1 ], e[ 2 ], e[ 3 ] ],\n\t\t\t[ e[ 4 ], e[ 5 ], e[ 6 ], e[ 7 ] ],\n\t\t\t[ e[ 8 ], e[ 9 ], e[ 10 ], e[ 11 ] ],\n\t\t\t[ e[ 12 ], e[ 13 ], e[ 14 ], e[ 15 ] ]\n\t\t];\n\n\t} );\n\n\taddSupportedType( THREE.Matrix3, function( v ) {\n\n\t\tvar e = v.elements;\n\t\t\t\t\n\t\treturn [\n\t\t\t[ e[ 0 ], e[ 1 ], e[ 2 ] ],\n\t\t\t[ e[ 3 ], e[ 4 ], e[ 5 ] ],\n\t\t\t[ e[ 6 ], e[ 7 ], e[ 8 ] ]\n\t\t];\n\n\t} );\n\n\taddSupportedType( THREE.Vector2, function( v ) {\n\n\t\treturn {\n\t\t\tVector2: { x: v.x, y: v.y }\n\t\t};\n\n\t} );\n\n\taddSupportedType( THREE.Vector3, function( v ) {\n\n\t\treturn {\n\t\t\tVector3: { x: v.x, y: v.y, z: v.z }\n\t\t};\n\n\t} );\n\n\taddSupportedType( THREE.Vector4, function( v ) {\n\n\t\treturn {\n\t\t\tVector4: { x: v.x, y: v.y, z: v.z, w: v.w }\n\t\t};\n\n\t} );\n\n\taddSupportedType( THREE.Euler, function( v ) {\n\n\t\treturn {\n\t\t\tVector4: { x: v.x, y: v.y, z: v.z, order: v.order }\n\t\t};\n\n\t} );\n\n\taddSupportedType( THREE.Ray, function( v ) {\n\n\t\treturn { \n\t\t\t'Ray origin': { x: v.origin.x, y: v.origin.y, z: v.origin.z },\n\t\t\t'Ray direction': { x: v.direction.x, y: v.direction.y, z: v.direction.z }\n\t\t};\n\n\t} );\n\n\tconsole.log = function() {\n\n\t\tvar special = false;\n\n\t\t[].forEach.call( arguments, function( a ) { \n\t\t\tsupportedTypes.forEach( function( t ) {\n\t\t\t\tif( a instanceof t.type ) special = true;;\n\t\t\t} );\n\t\t} );\n\n\t\tif( special ) {\n\n\t\t\t[].forEach.call( arguments, function( a ) { \n\t\t\t\n\t\t\t\t_oldConsole.apply( console, [ a ] );\n\n\t\t\t\tsupportedTypes.forEach( function( t ) {\n\n\t\t\t\t\tif( a instanceof t.type ) {\n\n\t\t\t\t\t\tconsole.table( t.format( a ) );\n\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t} );\n\n\t\t\t} );\n\n\t\t} else {\n\n\t\t\t_oldConsole.apply( console, arguments );\n\n\t\t}\n\n\t}\n\n} )();\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/imports-loader?THREE=three!./bower_components/AugmentedConsole/index.js\n ** module id = 17\n ** module chunks = 0\n **/","/*** IMPORTS FROM imports-loader ***/\nvar THREE = require(\"three\");\n\n/**\n * @author bchirls / http://bchirls.com/\n */\n\nTHREE.VRStereoEffect = function ( renderer, fullScreenElement, options ) {\n\n\t// internals\n\tvar self = this;\n\tvar width = 0, height = 0;\n\tvar hmdWidth, hmdHeight;\n\n\tvar hmdDevice;\n\tvar vrMode;\n\tvar vrPreview = false;\n\tvar eyeOffsetLeft = new THREE.Vector3();\n\tvar eyeOffsetRight = new THREE.Vector3();\n\n\tvar position = new THREE.Vector3();\n\tvar quaternion = new THREE.Quaternion();\n\tvar scale = new THREE.Vector3();\n\n\tvar cameraLeft = new THREE.PerspectiveCamera();\n\tvar cameraRight = new THREE.PerspectiveCamera();\n\tvar leftRenderRect = {\n\t\tx: 0, y: 0, width: 0, height: 0\n\t};\n\tvar rightRenderRect = {\n\t\tx: 0, y: 0, width: 0, height: 0\n\t};\n\n\tvar near = 2;\n\tvar far = 40000;\n\n\tvar requestFullscreen;\n\tvar fullScreenParam = {\n\t\tvrDisplay: null\n\t};\n\tvar fovScale;\n\n\tvar RADIANS = Math.PI / 180;\n\n\tvar poll = options && options.poll || 1000;\n\tvar pollTimeout;\n\n\tfunction perspectiveMatrixFromVRFieldOfView(fov, zNear, zFar) {\n\t\tvar outMat = new THREE.Matrix4(),\n\t\t\tout = outMat.elements,\n\t\t\tupTan = Math.tan(fov.upDegrees * RADIANS),\n\t\t\tdownTan = Math.tan(fov.downDegrees * RADIANS),\n\t\t\tleftTan = Math.tan(fov.leftDegrees * RADIANS),\n\t\t\trightTan = Math.tan(fov.rightDegrees * RADIANS),\n\n\t\t\txScale = 2 / (leftTan + rightTan),\n\t\t\tyScale = 2 / (upTan + downTan);\n\n\t\tout[0] = xScale;\n\t\tout[4] = 0;\n\t\tout[8] = -((leftTan - rightTan) * xScale * 0.5);\n\t\tout[12] = 0;\n\n\t\tout[1] = 0;\n\t\tout[5] = yScale;\n\t\tout[9] = ((upTan - downTan) * yScale * 0.5);\n\t\tout[13] = 0;\n\n\t\tout[2] = 0;\n\t\tout[6] = 0;\n\t\tout[10] = zFar / (zNear - zFar);\n\t\tout[14] = (zFar * zNear) / (zNear - zFar);\n\n\t\tout[3] = 0;\n\t\tout[7] = 0;\n\t\tout[11] = -1;\n\t\tout[15] = 0;\n\n\t\treturn outMat;\n\t}\n\n\tfunction resize() {\n\t\tvar w, h;\n\n\t\tif (hmdDevice && vrMode) {\n\t\t\tw = hmdWidth;// / Math.pow(window.devicePixelRatio || 1, 2);\n\t\t\th = hmdHeight;// / Math.pow(window.devicePixelRatio || 1, 2);\n\t\t} else {\n\t\t\tw = width || renderer.domElement.offsetWidth || window.innerWidth;\n\t\t\th = height || renderer.domElement.offsetHeight || window.innerHeight;\n\t\t}\n\n\t\trenderer.setSize(w, h);\n\t}\n\n\tfunction updateProjection() {\n\t\tvar fovLeft,\n\t\t\tfovRight,\n\n\t\t\tleftEyeParams,\n\t\t\trightEyeParams,\n\t\t\tleftEyeRect,\n\t\t\trightEyeRect,\n\n\t\t\tleftEyeViewport,\n\t\t\trightEyeViewport;\n\n\t\tif (!hmdDevice) {\n\t\t\tcameraLeft.fov = 80;\n\t\t\tcameraRight.fov = 80;\n\t\t\treturn;\n\t\t}\n\n\t\t// if (amount && hmdDevice.setFieldOfView) {\n\t\t// \tfovScale += amount;\n\t\t// \tfovScale = Math.max(0.1, fovScale);\n\n\t\t// \tfovLeft = hmdDevice.getRecommendedEyeFieldOfView('left');\n\n\t\t// \tfovLeft.upDegrees *= fovScale;\n\t\t// \tfovLeft.downDegrees *= fovScale;\n\t\t// \tfovLeft.leftDegrees *= fovScale;\n\t\t// \tfovLeft.rightDegrees *= fovScale;\n\n\t\t// \tfovRight = hmdDevice.getRecommendedEyeFieldOfView('right');\n\t\t// \tfovRight.upDegrees *= fovScale;\n\t\t// \tfovRight.downDegrees *= fovScale;\n\t\t// \tfovRight.leftDegrees *= fovScale;\n\t\t// \tfovRight.rightDegrees *= fovScale;\n\n\t\t// \thmdDevice.setFieldOfView(fovLeft, fovRight);\n\t\t// }\n\n\t\tif (hmdDevice.getEyeParameters) {\n\t\t\tleftEyeParams = hmdDevice.getEyeParameters('left');\n\t\t\trightEyeParams = hmdDevice.getEyeParameters('right');\n\t\t\tleftEyeRect = leftEyeParams.renderRect;\n\t\t\trightEyeRect = rightEyeParams.renderRect;\n\n\t\t\thmdWidth = rightEyeRect.x + rightEyeRect.width;\n\t\t\thmdHeight = Math.max(leftEyeRect.y + leftEyeRect.height, rightEyeRect.y + rightEyeRect.height);\n\n\t\t\tfovLeft = leftEyeParams.currentFieldOfView;\n\t\t\tfovRight = rightEyeParams.currentFieldOfView;\n\n\t\t\thmdDevice.setFieldOfView(fovLeft, fovRight, near, far);\n\n\t\t\teyeOffsetLeft.copy(leftEyeParams.eyeTranslation);\n\t\t\teyeOffsetRight.copy(rightEyeParams.eyeTranslation);\n\n\t\t\tleftRenderRect = leftEyeParams.renderRect;\n\t\t\trightRenderRect = rightEyeParams.renderRect;\n\t\t} else if (hmdDevice.getRecommendedEyeRenderRect) {\n\t\t\tleftEyeViewport = hmdDevice.getRecommendedEyeRenderRect('left');\n\t\t\trightEyeViewport = hmdDevice.getRecommendedEyeRenderRect('right');\n\n\t\t\thmdWidth = leftEyeViewport.width + rightEyeViewport.width;\n\t\t\thmdHeight = Math.max(leftEyeViewport.height, rightEyeViewport.height);\n\n\t\t\tif (hmdDevice.getCurrentEyeFieldOfView) {\n\t\t\t\tfovLeft = hmdDevice.getCurrentEyeFieldOfView('left');\n\t\t\t\tfovRight = hmdDevice.getCurrentEyeFieldOfView('right');\n\t\t\t} else {\n\t\t\t\tfovLeft = hmdDevice.getRecommendedEyeFieldOfView('left');\n\t\t\t\tfovRight = hmdDevice.getRecommendedEyeFieldOfView('right');\n\t\t\t}\n\n\t\t\teyeOffsetLeft.copy(hmdDevice.getEyeTranslation('left'));\n\t\t\teyeOffsetRight.copy(hmdDevice.getEyeTranslation('right'));\n\n\t\t\tleftRenderRect.x = leftEyeViewport.left;\n\t\t\tleftRenderRect.y = leftEyeViewport.top;\n\t\t\tleftRenderRect.width = leftEyeViewport.width;\n\t\t\tleftRenderRect.height = leftEyeViewport.height;\n\n\t\t\trightRenderRect.x = rightEyeViewport.left;\n\t\t\trightRenderRect.y = rightEyeViewport.top;\n\t\t\trightRenderRect.width = rightEyeViewport.width;\n\t\t\trightRenderRect.height = rightEyeViewport.height;\n\t\t}\n\n\t\tresize();\n\n\t\tcameraLeft.projectionMatrix = perspectiveMatrixFromVRFieldOfView(fovLeft, near, far);\n\t\tcameraRight.projectionMatrix = perspectiveMatrixFromVRFieldOfView(fovRight, near, far);\n\t}\n\n\tfunction gotVRDevices(devices) {\n\t\tvar i,\n\t\t\tdevice;\n\n\t\tfor (i = 0; i < devices.length; i++) {\n\t\t\tdevice = devices[i];\n\t\t\tif ( device instanceof HMDVRDevice ) {\n\n\t\t\t\tif ( hmdDevice && device.hardwareUnitId === hmdDevice.hardwareUnitId ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\thmdDevice = device;\n\t\t\t\tconsole.log('Using HMD Device:', hmdDevice.deviceName);\n\n\t\t\t\tif (hmdDevice.setTimewarp) {\n\t\t\t\t\t//hmdDevice.setTimewarp(false);\n\t\t\t\t}\n\n\t\t\t\tupdateProjection();\n\n\t\t\t\tfullScreenParam.vrDisplay = hmdDevice;\n\n\t\t\t\tself.dispatchEvent( {\n\t\t\t\t\ttype: \"devicechange\"\n\t\t\t\t} );\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (poll) {\n\t\t\tclearTimeout(pollTimeout);\n\t\t\tsetTimeout(self.scan, poll);\n\t\t}\n\t}\n\n\tfunction onFullscreenChange() {\n\t\tif (!document.webkitFullscreenElement &&\n\t\t\t\t!document.mozFullScreenElement &&\n\t\t\t\t!document.msFullscreenElement) {\n\t\t\tvrMode = false;\n\t\t}\n\n\t\tupdateProjection();\n\n\t\tself.dispatchEvent( {\n\t\t\ttype: \"fullscreenchange\"\n\t\t} );\n\t}\n\n\t// API\n\n\tthis.separation = 0.01;\n\n\t// initialization\n\n\trenderer.autoClear = false;\n\n\tif (!fullScreenElement) {\n\t\tfullScreenElement = renderer.domElement;\n\t}\n\trequestFullscreen = fullScreenElement.webkitRequestFullscreen ||\n\t\tfullScreenElement.mozRequestFullScreen ||\n\t\tfullScreenElement.msRequestFullscreen;\n\tif (requestFullscreen) {\n\t\trequestFullscreen = requestFullscreen.bind(fullScreenElement, fullScreenParam);\n\t}\n\n\tdocument.addEventListener('fullscreenchange', onFullscreenChange, false);\n\tdocument.addEventListener('webkitfullscreenchange', onFullscreenChange, false);\n\tdocument.addEventListener('mozfullscreenchange', onFullscreenChange, false);\n\tdocument.addEventListener('MSFullscreenChange', onFullscreenChange, false);\n\n\t//todo: method for adjusting HMD FOV\n\n\tthis.scan = function () {\n\t\tif (navigator.getVRDevices) {\n\t\t\tnavigator.getVRDevices().then(gotVRDevices);\n\t\t} else if (navigator.mozGetVRDevices) {\n\t\t\tnavigator.mozGetVRDevices(gotVRDevices);\n\t\t}\n\t};\n\n\tthis.requestFullScreen = function () {\n\t\tvrMode = true;\n\t\trequestFullscreen();\n\t};\n\n\tthis.exit = function () {\n\t\tvrMode = false;\n\t\tvrPreview = false;\n\t};\n\n\tthis.setSize = function ( w, h ) {\n\t\twidth = w;\n\t\theight = h;\n\n\t\tresize();\n\t};\n\n\tthis.vrPreview = function (val) {\n\t\tif (val !== undefined) {\n\t\t\tvrPreview = !!val;\n\t\t}\n\t\treturn vrPreview;\n\t};\n\n\tthis.isFullscreen = function () {\n\t\treturn vrMode;\n\t};\n\n\tthis.hmd = function () {\n\t\treturn hmdDevice;\n\t};\n\n\tthis.render = function ( leftScene, rightScene, camera, renderTarget, forceClear ) {\n\t\tvar w, h;\n\n\t\tif ( rightScene && rightScene instanceof THREE.Scene ) {\n\t\t\t//rightScene.updateMatrixWorld();\n\t\t} else {\n\t\t\tif ( (!camera || camera instanceof THREE.WebGLRenderTarget) && rightScene instanceof THREE.Camera ) {\n\t\t\t\tforceClear = renderTarget;\n\t\t\t\trenderTarget = camera;\n\t\t\t\tcamera = rightScene;\n\t\t\t}\n\t\t\trightScene = leftScene;\n\t\t}\n\n\t\t//leftScene.updateMatrixWorld();\n\n\t\tif ( camera.parent === undefined ) {\n\t\t\tcamera.updateMatrixWorld();\n\t\t}\n\n\t\tw = width || renderer.domElement.width;\n\t\th = height || renderer.domElement.height;\n\t\t// w /= window.devicePixelRatio || 1;\n\t\t// h /= window.devicePixelRatio || 1;\n\n\t\t/*\n\t\ttodo: make this work when CSS VR Rendering is fixed\n\t\thttp://blog.bitops.com/blog/2014/08/20/updated-firefox-vr-builds/\n\t\tif (renderer instanceof THREE.CSS3DRenderer) {\n\t\t\trenderer.render( leftScene, camera );\n\t\t\treturn;\n\t\t}\n\t\t*/\n\n\t\tif (!vrMode && !vrPreview) {\n\t\t\trenderer.enableScissorTest( false );\n\t\t\trenderer.setViewport( 0, 0, w, h );\n\t\t\trenderer.render( leftScene, camera, renderTarget, true );\n\t\t\treturn;\n\t\t}\n\n\t\tcamera.matrixWorld.decompose( position, quaternion, scale );\n\n\t\tif (!hmdDevice) {\n\t\t\t// left\n\t\t\t//cameraLeft.fov = camera.fov;\n\t\t\tcameraLeft.aspect = 0.5 * camera.aspect;\n\t\t\tcameraLeft.near = camera.near;\n\t\t\tcameraLeft.far = camera.far;\n\t\t\tcameraLeft.updateProjectionMatrix();\n\n\t\t\t// right\n\n\t\t\t// cameraRight.fov = camera.fov;\n\t\t\tcameraRight.aspect = 0.5 * camera.aspect;\n\t\t\tcameraRight.near = camera.near;\n\t\t\tcameraRight.far = camera.far;\n\t\t\tcameraRight.updateProjectionMatrix();\n\t\t}\n\n\t\tcameraLeft.position.copy( position );\n\t\tcameraLeft.quaternion.copy( quaternion );\n\n\t\tcameraRight.position.copy( position );\n\t\tcameraRight.quaternion.copy( quaternion );\n\n\t\tif (hmdDevice) {\n\t\t\tcameraLeft.position.add( eyeOffsetLeft ) ;\n\t\t\tcameraRight.position.add( eyeOffsetRight );\n\t\t} else {\n\t\t\tcameraLeft.translateX( - this.separation );\n\t\t\tcameraRight.translateX( this.separation );\n\t\t}\n\n\t\tcameraLeft.updateMatrixWorld();\n\t\tcameraRight.updateMatrixWorld();\n\n\t\t//\n\n\t\trenderer.enableScissorTest(true);\n\n\t\tw = renderer.context.drawingBufferWidth / 2;\n\n\t\tif (renderTarget) {\n\t\t\trenderer.setRenderTarget(renderTarget);\n\t\t}\n\n\t\trightScene.traverseVisible(function (obj) {\n\t\t\tif (obj.material && obj.material.map) {\n\t\t\t\tif (obj.userData.stereo === 'vertical') {\n\t\t\t\t\tobj.material.map.offset.set(0, 0.5);\n\t\t\t\t} else if (obj.userData.stereo) {\n\t\t\t\t\tobj.material.map.offset.set(0.5, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\trenderer.setScissor( w, 0, w, h );\n\t\trenderer.setViewport( w, 0, w, h );\n\t\trenderer.render( rightScene, cameraRight, renderTarget, forceClear );\n\n\t\tleftScene.traverseVisible(function (obj) {\n\t\t\tif (obj.userData.stereo && obj.material && obj.material.map) {\n\t\t\t\tobj.material.map.offset.set(0, 0);\n\t\t\t}\n\t\t});\n\t\trenderer.setScissor( 0, 0, w, h );\n\t\trenderer.setViewport( 0, 0, w, h );\n\t\trenderer.render( leftScene, cameraLeft, renderTarget, forceClear );\n\n\t\t//reset viewport, scissor\n\t\tw *= 2;\n\t\trenderer.setViewport( 0, 0, w, h );\n\t\trenderer.setScissor( 0, 0, w, h );\n\t\trenderer.enableScissorTest( false );\n\t};\n\n\tObject.defineProperty(this, 'near', {\n\t\tget: function () {\n\t\t\treturn near;\n\t\t},\n\t\tset: function (val) {\n\t\t\tval = parseFloat(val);\n\t\t\tif (val && !isNaN(val)) {\n\t\t\t\tnear = Math.max(0, val);\n\t\t\t\tupdateProjection();\n\t\t\t}\n\t\t}\n\t});\n\n\tObject.defineProperty(this, 'far', {\n\t\tget: function () {\n\t\t\treturn far;\n\t\t},\n\t\tset: function (val) {\n\t\t\tval = parseFloat(val);\n\t\t\tif (val && !isNaN(val)) {\n\t\t\t\tfar = Math.max(0, val);\n\t\t\t\tupdateProjection();\n\t\t\t}\n\t\t}\n\t});\n\n\tthis.scan();\n\tresize();\n};\n\nTHREE.VRStereoEffect.prototype = Object.create( THREE.EventDispatcher.prototype );\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/imports-loader?THREE=three!./src/lib/VRStereoEffect.js\n ** module id = 18\n ** module chunks = 0\n **/","/*** IMPORTS FROM imports-loader ***/\nvar THREE = require(\"three\");\n\nTHREE.VRControls = function ( object, options ) {\n\n\tvar self = this;\n\n\t//HMD sensor stuff\n\tvar sensorDevice;\n\tvar vrState;\n\n\t//device orientation stuff\n\tvar deviceControls;\n\tvar zeroAngle = 0;\n\n\tvar mode = '';\n\n\tvar vrBrowser = navigator.getVRDevices || navigator.mozGetVRDevices;\n\n\tvar poll = options && options.poll || 1000;\n\tvar pollTimeout;\n\n\tfunction gotVRDevices( devices ) {\n\t\tvar i,\n\t\t\tdevice;\n\n\t\tfor ( i = 0; i < devices.length; ++i ) {\n\t\t\tdevice = devices[i];\n\t\t\tif ( devices[i] instanceof PositionSensorVRDevice ) {\n\n\t\t\t\tif ( sensorDevice && devices[i].hardwareUnitId === sensorDevice.hardwareUnitId ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tsensorDevice = device;\n\t\t\t\tconsole.log('Using Sensor Device:', sensorDevice.deviceName);\n\n\t\t\t\tif ( sensorDevice.zeroSensor ) {\n\t\t\t\t\tself.zeroSensor = sensorDevice.zeroSensor.bind(sensorDevice);\n\t\t\t\t} else if ( sensorDevice.resetSensor ) {\n\t\t\t\t\tself.zeroSensor = sensorDevice.resetSensor.bind(sensorDevice);\n\t\t\t\t}\n\t\t\t\tself.zeroSensor();\n\n\t\t\t\tmode = 'hmd';\n\n\t\t\t\tself.dispatchEvent( {\n\t\t\t\t\ttype: \"devicechange\"\n\t\t\t\t} );\n\n\t\t\t\tbreak; // We keep the first we encounter\n\t\t\t}\n\t\t}\n\n\t\tif (poll) {\n\t\t\tclearTimeout(pollTimeout);\n\t\t\tsetTimeout(self.scan, poll);\n\t\t}\n\t}\n\n\tfunction deviceOrientationChange( event ) {\n\t\tif ( typeof event.gamma === 'number' ) {\n\t\t\tmode = 'deviceorientation';\n\t\t\twindow.removeEventListener( 'deviceorientation', deviceOrientationChange, false );\n\t\t\tdeviceControls = new THREE.DeviceOrientationControls( object );\n\t\t\tdeviceControls.connect();\n\t\t\tif (!this.freeze) {\n\t\t\t\tdeviceControls.update();\n\t\t\t}\n\n\t\t\tself.dispatchEvent( {\n\t\t\t\ttype: \"devicechange\"\n\t\t\t} );\n\t\t}\n\t}\n\n\tthis.update = function() {\n\t\t// Applies head rotation from sensor data.\n\t\tif (self.freeze) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( sensorDevice ) {\n\t\t\tvrState = sensorDevice.getState();\n\t\t\tif ( vrState ) {\n\t\t\t\tif ( vrState.orientation && vrState.hasOrientation !== false ) {\n\t\t\t\t\tobject.quaternion.copy( vrState.orientation );\n\t\t\t\t}\n\n\t\t\t\tif ( vrState.position && vrState.hasPosition !== false ) {\n\t\t\t\t\t// vrState.position is null if using DK1 or if DK2 camera is not plugged in\n\t\t\t\t\tobject.position.copy( vrState.position );\n\t\t\t\t}\n\n\t\t\t\tobject.updateMatrixWorld();\n\t\t\t}\n\t\t} else if (deviceControls && deviceControls.deviceOrientation.gamma !== undefined) {\n\t\t\tdeviceControls.update();\n\t\t\tobject.rotateY(-zeroAngle);\n\t\t\tobject.updateMatrixWorld();\n\t\t}\n\t};\n\n\t//only useful when frozen\n\tthis.reset = function () {\n\t\tif ( object ) {\n\t\t\tobject.quaternion.set( 0, 0, 0, 1 );\n\t\t\tobject.position.set( 0, 0, 0 );\n\t\t}\n\t};\n\n\t//zeros only rotation on Y axis\n\t//todo: find out if it zeros out position. need a DK2 to test\n\tthis.zeroSensor = function () {\n\t\tif (sensorDevice && sensorDevice.zeroSensor) {\n\t\t\tsensorDevice.zeroSensor();\n\t\t}\n\t\tzeroAngle = object.rotation.y;\n\t\tself.update();\n\t};\n\n\tthis.freeze = false;\n\n\t//method to query which tech we're using\n\tthis.mode = function () {\n\t\treturn mode;\n\t};\n\n\tthis.scan = function () {\n\t\tif ( navigator.getVRDevices ) {\n\t\t\tnavigator.getVRDevices().then( gotVRDevices );\n\t\t} else if ( navigator.mozGetVRDevices ) {\n\t\t\tnavigator.mozGetVRDevices( gotVRDevices );\n\t\t}\n\t};\n\n\t//todo: connect/disconnect methods\n\t//todo: method to query orientation/position without changing object\n\t//todo: work without an object\n\n\tif ( vrBrowser ) {\n\t\tthis.scan();\n\t} else if ( \"DeviceOrientationEvent\" in window && THREE.DeviceOrientationControls) {\n\t\t//device orientation\n\t\twindow.addEventListener( \"deviceorientation\", deviceOrientationChange, false );\n\t}\n};\n\nTHREE.VRControls.prototype = Object.create( THREE.EventDispatcher.prototype );\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/imports-loader?THREE=three!./src/lib/VRControls.js\n ** module id = 19\n ** module chunks = 0\n **/","'use strict';\n\nvar d        = require('d')\n  , callable = require('es5-ext/object/valid-callable')\n\n  , apply = Function.prototype.apply, call = Function.prototype.call\n  , create = Object.create, defineProperty = Object.defineProperty\n  , defineProperties = Object.defineProperties\n  , hasOwnProperty = Object.prototype.hasOwnProperty\n  , descriptor = { configurable: true, enumerable: false, writable: true }\n\n  , on, once, off, emit, methods, descriptors, base;\n\non = function (type, listener) {\n\tvar data;\n\n\tcallable(listener);\n\n\tif (!hasOwnProperty.call(this, '__ee__')) {\n\t\tdata = descriptor.value = create(null);\n\t\tdefineProperty(this, '__ee__', descriptor);\n\t\tdescriptor.value = null;\n\t} else {\n\t\tdata = this.__ee__;\n\t}\n\tif (!data[type]) data[type] = listener;\n\telse if (typeof data[type] === 'object') data[type].push(listener);\n\telse data[type] = [data[type], listener];\n\n\treturn this;\n};\n\nonce = function (type, listener) {\n\tvar once, self;\n\n\tcallable(listener);\n\tself = this;\n\ton.call(this, type, once = function () {\n\t\toff.call(self, type, once);\n\t\tapply.call(listener, this, arguments);\n\t});\n\n\tonce.__eeOnceListener__ = listener;\n\treturn this;\n};\n\noff = function (type, listener) {\n\tvar data, listeners, candidate, i;\n\n\tcallable(listener);\n\n\tif (!hasOwnProperty.call(this, '__ee__')) return this;\n\tdata = this.__ee__;\n\tif (!data[type]) return this;\n\tlisteners = data[type];\n\n\tif (typeof listeners === 'object') {\n\t\tfor (i = 0; (candidate = listeners[i]); ++i) {\n\t\t\tif ((candidate === listener) ||\n\t\t\t\t\t(candidate.__eeOnceListener__ === listener)) {\n\t\t\t\tif (listeners.length === 2) data[type] = listeners[i ? 0 : 1];\n\t\t\t\telse listeners.splice(i, 1);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif ((listeners === listener) ||\n\t\t\t\t(listeners.__eeOnceListener__ === listener)) {\n\t\t\tdelete data[type];\n\t\t}\n\t}\n\n\treturn this;\n};\n\nemit = function (type) {\n\tvar i, l, listener, listeners, args;\n\n\tif (!hasOwnProperty.call(this, '__ee__')) return;\n\tlisteners = this.__ee__[type];\n\tif (!listeners) return;\n\n\tif (typeof listeners === 'object') {\n\t\tl = arguments.length;\n\t\targs = new Array(l - 1);\n\t\tfor (i = 1; i < l; ++i) args[i - 1] = arguments[i];\n\n\t\tlisteners = listeners.slice();\n\t\tfor (i = 0; (listener = listeners[i]); ++i) {\n\t\t\tapply.call(listener, this, args);\n\t\t}\n\t} else {\n\t\tswitch (arguments.length) {\n\t\tcase 1:\n\t\t\tcall.call(listeners, this);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tcall.call(listeners, this, arguments[1]);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tcall.call(listeners, this, arguments[1], arguments[2]);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tl = arguments.length;\n\t\t\targs = new Array(l - 1);\n\t\t\tfor (i = 1; i < l; ++i) {\n\t\t\t\targs[i - 1] = arguments[i];\n\t\t\t}\n\t\t\tapply.call(listeners, this, args);\n\t\t}\n\t}\n};\n\nmethods = {\n\ton: on,\n\tonce: once,\n\toff: off,\n\temit: emit\n};\n\ndescriptors = {\n\ton: d(on),\n\tonce: d(once),\n\toff: d(off),\n\temit: d(emit)\n};\n\nbase = defineProperties({}, descriptors);\n\nmodule.exports = exports = function (o) {\n\treturn (o == null) ? create(base) : defineProperties(Object(o), descriptors);\n};\nexports.methods = methods;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/event-emitter/index.js\n ** module id = 20\n ** module chunks = 0\n **/","module.exports = (function () {\n\t'use strict';\n\n\tvar materials = require('../materials'),\n\t\tTHREE = require('three'),\n\t\tgeometry = new THREE.BoxGeometry( 1, 1, 1 );\n\n\treturn function box(parent, options) {\n\t\tvar mesh;\n\n\t\tmesh = new THREE.Mesh(geometry, materials.standard());\n\t\tmesh.name = 'box';\n\n\t\tparent.add(mesh);\n\n\t\treturn mesh;\n\t};\n}());\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/objects/box.js\n ** module id = 21\n ** module chunks = 0\n **/","module.exports = (function () {\n\t'use strict';\n\n\tvar materials = require('../materials'),\n\t\tTHREE = require('three');\n\n\tfunction cylinder(parent, options) {\n\t\tvar geometry,\n\t\t\tmesh;\n\n\t\tgeometry = new THREE.CylinderGeometry(\n\t\t\toptions.radiusTop === undefined ? 0.5 : options.radiusTop,\n\t\t\toptions.radiusBottom === undefined ? 0.5 : options.radiusBottom,\n\t\t\toptions.height === undefined ? 1 : options.height,\n\t\t\toptions.radiusSegments === undefined ? 16 : options.radiusSegments,\n\t\t\toptions.heightSegments,\n\t\t\toptions.openEnded\n\t\t);\n\t\tmesh = new THREE.Mesh(geometry, materials.standard());\n\t\tmesh.name = 'cylinder';\n\n\t\tparent.add(mesh);\n\n\t\treturn mesh;\n\t}\n\n\treturn cylinder;\n}());\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/objects/cylinder.js\n ** module id = 22\n ** module chunks = 0\n **/","module.exports = (function () {\n\t'use strict';\n\n\tvar materials = require('../materials'),\n\t\tTHREE = require('three');\n\n\tfunction floor(parent, options) {\n\t\tvar obj,\n\t\t\tgeometry;\n\n\t\tgeometry = new THREE.CircleGeometry( options.radius || 100, options.segments || 16 );\n\t\tgeometry.applyMatrix( new THREE.Matrix4().makeRotationX(-Math.PI / 2));\n\n\t\tobj = new THREE.Mesh(\n\t\t\tgeometry,\n\t\t\tmaterials.checkerboard({\n\t\t\t\trepeat: 100\n\t\t\t})\n\t\t);\n\t\tobj.name = 'floor';\n\n\t\tobj.receiveShadow = true;\n\n\t\tparent.add(obj);\n\n\t\treturn obj;\n\t}\n\n\treturn floor;\n}());\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/objects/floor.js\n ** module id = 23\n ** module chunks = 0\n **/","module.exports = (function () {\n\t'use strict';\n\n\tvar materials = require('../materials'),\n\t\tTHREE = require('three');\n\n\treturn function image(parent, options) {\n\t\tvar geometry,\n\t\t\tmaterial,\n\t\t\tmesh,\n\t\t\tsrc,\n\t\t\ttex;\n\n\t\tif (typeof options === 'string') {\n\t\t\tsrc = options;\n\t\t} else if (options) {\n\t\t\tsrc = options.src;\n\t\t}\n\n\t\tif (src) {\n\t\t\ttex = materials.imageTexture(src, THREE.UVMapping, function (t, image) {\n\t\t\t\t//todo: don't do any of this if object has been deleted\n\t\t\t\tgeometry.applyMatrix(new THREE.Matrix4().makeScale(1, image.naturalHeight / image.naturalWidth, 1));\n\t\t\t\tmaterial.map = tex;\n\t\t\t\tmaterial.visible = true;\n\t\t\t\tmesh.visible = true;\n\t\t\t\tparent.add(mesh);\n\t\t\t});\n\t\t}\n\n\t\tgeometry = new THREE.PlaneBufferGeometry(1, 1, 8);\n\n\t\tmaterial = new THREE.MeshBasicMaterial({\n\t\t\tside: THREE.DoubleSide,\n\t\t\ttransparent: true,\n\t\t\tmap: tex\n\t\t});\n\n\t\tmesh = new THREE.Mesh( geometry, material );\n\n\t\tmesh.visible = false;\n\n\t\tparent.add(mesh);\n\n\t\treturn mesh;\n\t};\n}());\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/objects/image.js\n ** module id = 24\n ** module chunks = 0\n **/","module.exports = (function () {\n\t'use strict';\n\n\tvar materials = require('../materials'),\n\t\tTHREE = require('three'),\n\t\tgeometry = new THREE.SphereGeometry(1000, 60, 60);\n\n\tgeometry.applyMatrix(new THREE.Matrix4().makeScale(-1, 1, 1));\n\tgeometry.applyMatrix(new THREE.Matrix4().makeRotationY(- Math.PI / 2));\n\n\treturn function panorama(parent, options) {\n\t\tvar material,\n\t\t\tmesh,\n\t\t\tsrc,\n\t\t\ttex;\n\n\t\tif (typeof options === 'string') {\n\t\t\tsrc = options;\n\t\t} else if (options) {\n\t\t\tsrc = options.src;\n\t\t}\n\n\t\tif (src) {\n\t\t\ttex = materials.imageTexture(src, THREE.UVMapping);\n\t\t}\n\n\t\tmaterial = new THREE.MeshBasicMaterial({\n\t\t\ttransparent: true,\n\t\t\tmap: tex\n\t\t});\n\n\t\tmesh = new THREE.Mesh(geometry, material);\n\n\t\tif (options && options.stereo) {\n\t\t\tif (options.stereo === 'vertical') {\n\t\t\t\ttex.repeat.y = 0.5;\n\t\t\t} else {\n\t\t\t\ttex.repeat.x = 0.5;\n\t\t\t}\n\t\t\tmesh.userData.stereo = options.stereo;\n\t\t}\n\n\t\tmesh.name = 'panorama';\n\n\t\tparent.add(mesh);\n\n\t\treturn mesh;\n\t};\n}());\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/objects/panorama.js\n ** module id = 25\n ** module chunks = 0\n **/","module.exports = (function () {\n\t'use strict';\n\n\tvar materials = require('../materials'),\n\t\tTHREE = require('three'),\n\t\tSPE = require('imports?THREE=three!exports?SPE!ShaderParticles'),\n\t\tassign = require('lodash.assign'),\n\n\t\tgroupFields = [\n\t\t\t'maxAge',\n\t\t\t'hasPerspective',\n\t\t\t'colorize',\n\t\t\t'blending',\n\t\t\t'transparent',\n\t\t\t'alphaTest',\n\t\t\t'depthWrite',\n\t\t\t'depthTest',\n\t\t\t'fixedTimeStep'\n\t\t];\n\n\treturn function particles(parent, options) {\n\t\tvar obj = new THREE.Object3D(),\n\t\t\tkey,\n\t\t\tgroupOptions = {},\n\t\t\temitterOptions = {};\n\n\t\tobj.name = 'particles';\n\n\t\tif (options) {\n\t\t\tgroupFields.forEach(function (field) {\n\t\t\t\tif (options[field] !== undefined) {\n\t\t\t\t\tgroupOptions[field] = options[field];\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tvar particleGroup = new SPE.Group({\n\t\t\ttexture: materials.textures.cloud(),\n\t\t\t// texture: materials.imageTexture('http://squarefeet.github.io/ShaderParticleEngine/examples/img/cloudSml.png'),\n\t\t\tmaxAge: 20,\n\t\t\tblending: THREE.NormalBlending,\n\t\t\thasPerspective: 1\n\t\t});\n\n\t\tvar emitter = new SPE.Emitter({\n\t\t\tpositionSpread: new THREE.Vector3(4, 1, 24),\n\n\t\t\t//acceleration: new THREE.Vector3(0, 0, 0),\n\n\t\t\t// velocity: new THREE.Vector3(0, 0, 1),\n\n\t\t\tcolorStart: new THREE.Color('white'),\n\t\t\tsizeStart: 0.5,\n\t\t\tsizeStartSpread: 1.5 / 4,\n\t\t\t// opacityStart: 0,\n\t\t\t// opacityMiddle: 1,\n\t\t\t// opacityEnd: 0,\n\n\t\t\tparticleCount: 8000,\n\t\t\tisStatic: 0\n\t\t});\n\n\t\tparticleGroup.addEmitter(emitter);\n\t\tobj.add(particleGroup.mesh);\n\n\t\tparent.add(obj);\n\n\t\tvar lastTime = 0;\n\t\tthis.update = function (time) {\n\t\t\tvar delta = Math.min(500, time - lastTime);\n\t\t\tlastTime = time;\n\t\t\tparticleGroup.tick(delta);\n\t\t};\n\n\t\treturn obj;\n\t};\n}());\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/objects/particles.js\n ** module id = 26\n ** module chunks = 0\n **/","module.exports = (function () {\n\t'use strict';\n\n\tvar materials = require('../materials'),\n\t\tTHREE = require('three'),\n\t\tTAU = Math.PI * 2,\n\t\tHALF_PI = Math.PI / 2,\n\n\t\tdistance = 400000,\n\t\tscratchVector = new THREE.Vector3(),\n\n\t\tparams = [\n\t\t\t'luminance',\n\t\t\t'turbidity',\n\t\t\t'reileigh',\n\t\t\t'mieCoefficient',\n\t\t\t'mieDirectionalG'\n\t\t];\n\n\trequire('imports?THREE=three!SkyShader');\n\n\treturn function sky(parent, options) {\n\t\tvar obj = new THREE.Sky(),\n\t\t\tself = this,\n\t\t\tscene = parent,\n\t\t\tlight,\n\t\t\tsunPosition,\n\t\t\tazimuth = Math.PI / 6,\n\t\t\taltitude = Math.PI / 6;\n\n\t\tfunction mod(x, y) {\n\t\t\treturn x - y * Math.floor(x / y);\n\t\t}\n\n\t\tfunction update() {\n\t\t\tvar sinTheta,\n\t\t\t\tcosTheta,\n\t\t\t\tphi,\n\t\t\t\tsinPhi,\n\t\t\t\tcosPhi;\n\n\t\t\tsinTheta = Math.sin(altitude);\n\t\t\tcosTheta = Math.cos(altitude);\n\t\t\tphi = -HALF_PI - azimuth;\n\t\t\tsinPhi = Math.sin(phi);\n\t\t\tcosPhi = Math.cos(phi);\n\n\t\t\tsunPosition.set(\n\t\t\t\tdistance * cosPhi * cosTheta,\n\t\t\t\tdistance * sinTheta,\n\t\t\t\tdistance * sinPhi * cosTheta\n\t\t\t);\n\n\t\t\tif (light) {\n\t\t\t\tlight.intensity = 1.5 * Math.max(0.0, 1.0 - Math.exp(-((Math.PI / 1.95 - Math.abs(HALF_PI - altitude)) / 1.5)));\n\t\t\t\tlight.position.copy(sunPosition).normalize().multiplyScalar(100);\n\t\t\t}\n\t\t}\n\n\t\tobj.mesh.name = 'sky';\n\n\t\tparent.add(obj.mesh);\n\n\t\twhile (!(scene instanceof THREE.Scene) && scene.parent) {\n\t\t\tscene = scene.parent;\n\t\t}\n\t\tlight = scene.getObjectByName('directional-light');\n\n\t\tthis.setOptions = function (options) {\n\t\t\tvar needUpdate = false,\n\t\t\t\taltitude,\n\t\t\t\tazimuth;\n\n\t\t\tif (options) {\n\t\t\t\tparams.forEach(function (param) {\n\t\t\t\t\tvar val = options[param];\n\t\t\t\t\tif (val !== undefined) {\n\t\t\t\t\t\tval = parseFloat(val);\n\t\t\t\t\t\tif (!isNaN(val)) {\n\t\t\t\t\t\t\tobj.uniforms[param].value = val;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tif (options.sunPosition instanceof THREE.Vector3) {\n\t\t\t\t\tobj.uniforms.sunPosition.value.copy(options.sunPosition);\n\t\t\t\t} else if (Array.isArray(options.sunPosition)) {\n\t\t\t\t\tobj.uniforms.sunPosition.value.set(obj.uniforms.sunPosition.value, options.sunPosition);\n\t\t\t\t} else {\n\t\t\t\t\tself.altitude = options.altitude;\n\t\t\t\t\tself.azimuth = options.azimuth;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tObject.defineProperty(this, 'azimuth', {\n\t\t\tset: function (val) {\n\t\t\t\tval = mod(parseFloat(val), TAU);\n\t\t\t\tif (!isNaN(val) && val !== azimuth) {\n\t\t\t\t\tazimuth = val;\n\t\t\t\t\tupdate();\n\t\t\t\t}\n\t\t\t},\n\t\t\tget: function () {\n\t\t\t\treturn azimuth;\n\t\t\t}\n\t\t});\n\n\t\tObject.defineProperty(this, 'altitude', {\n\t\t\tset: function (val) {\n\t\t\t\tval = mod(parseFloat(val), TAU);\n\t\t\t\tif (!isNaN(val) && val !== altitude) {\n\t\t\t\t\taltitude = val;\n\t\t\t\t\tupdate();\n\t\t\t\t}\n\t\t\t},\n\t\t\tget: function() {\n\t\t\t\treturn altitude;\n\t\t\t}\n\t\t});\n\n\t\tthis.setAltitude = function (val) {\n\t\t\tself.altitude = val;\n\t\t\treturn this;\n\t\t};\n\n\t\tthis.setAzimuth = function (val) {\n\t\t\tself.azimuth = val;\n\t\t\treturn this;\n\t\t};\n\n\t\tsunPosition = obj.uniforms.sunPosition.value;\n\t\tupdate();\n\n\t\tthis.setOptions(options);\n\n\t\treturn obj.mesh;\n\t};\n}());\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/objects/sky.js\n ** module id = 27\n ** module chunks = 0\n **/","module.exports = (function () {\n\t'use strict';\n\n\tvar materials = require('../materials'),\n\t\tTHREE = require('three');\n\n\trequire('imports?THREE=three!../lib/ThreeAudio');\n\n\treturn function sound(parent, options) {\n\t\tvar obj,\n\t\t\tsrc,\n\t\t\tlistener,\n\t\t\tscene = parent;\n\n\t\tif (typeof options === 'string' || Array.isArray(options)) {\n\t\t\tsrc = options;\n\t\t} else if (options) {\n\t\t\tsrc = options.src;\n\t\t}\n\n\t\twhile (!(scene instanceof THREE.Scene) && scene.parent) {\n\t\t\tscene = scene.parent;\n\t\t}\n\n\t\tlistener = scene.getObjectByName('audio-listener');\n\t\tobj = new THREE.Audio(listener);\n\t\t// obj.setLoop(true);\n\t\tobj.load(src);\n\n\t\tthis.start = obj.start.bind(obj);\n\t\tthis.volume = obj.volume.bind(obj);\n\n\t\tparent.add(obj);\n\n\t\treturn obj;\n\t};\n}());\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/objects/sound.js\n ** module id = 28\n ** module chunks = 0\n **/","module.exports = (function () {\n\t'use strict';\n\n\tvar materials = require('../materials'),\n\t\tTHREE = require('three');\n\n\treturn function box(parent, options) {\n\t\tvar geometry,\n\t\t\tmesh;\n\n\t\tgeometry = new THREE.SphereGeometry(\n\t\t\toptions.radius === undefined ? 0.5 : options.radius,\n\t\t\toptions.widthSegments === undefined ? 16 : options.widthSegments,\n\t\t\toptions.heightSegments === undefined ? 12 : options.heightSegments,\n\t\t\toptions.phiStart,\n\t\t\toptions.phiLength,\n\t\t\toptions.thetaStart,\n\t\t\toptions.thetaLength\n\t\t);\n\t\tmesh = new THREE.Mesh(geometry, materials.standard());\n\t\tmesh.name = 'sphere';\n\n\t\tparent.add(mesh);\n\n\t\treturn mesh;\n\t};\n}());\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/objects/sphere.js\n ** module id = 29\n ** module chunks = 0\n **/","module.exports = (function () {\n\t'use strict';\n\n\tvar THREE = require('three'),\n\t\tfontSizeRegex = /(\\d+)px/i,\n\t\tnewLineRegex = /[\\n\\r]/,\n\t\tspaceRegex = /[\\t ]/,\n\t\tlog2 = Math.log(2),\n\t\tgeometry = new THREE.PlaneBufferGeometry(1, 1);\n\n\treturn function text(parent, options) {\n\t\tvar self = this,\n\t\t\tmaterial,\n\t\t\tcanvas,\n\t\t\tctx,\n\t\t\tmesh,\n\t\t\tcontainer,\n\t\t\tsrc,\n\t\t\ttextWidth = 0,\n\t\t\ttextHeight = 0,\n\t\t\tprops = {\n\t\t\t\ttext: '',\n\t\t\t\tfont: '80px sans-serif',\n\t\t\t\ttextAlign: 'center',\n\t\t\t\ttextBaseline: '',\n\t\t\t\tdirection: '',\n\t\t\t\tfillStyle: 'white',\n\t\t\t\tresolution: 256, //pixels per meter\n\t\t\t\twrap: 5 //in meters\n\t\t\t},\n\t\t\ttex;\n\n\t\tfunction nextPowerOfTwo(n) {\n\t\t\treturn Math.pow(2, Math.ceil(Math.log(n) / log2));\n\t\t}\n\n\t\tfunction Line(word) {\n\t\t\tthis.spaceWidth = ctx.measureText(' ').width;\n\t\t\tthis.totalWidth = 0;\n\t\t\tthis.wordsWidth = 0;\n\t\t\tthis.words = [];\n\t\t\tthis.wrap = false;\n\t\t\tif (word) {\n\t\t\t\tthis.add(word);\n\t\t\t}\n\t\t}\n\n\t\tLine.prototype.text = function () {\n\t\t\treturn this.words.join(' ');\n\t\t};\n\n\t\tLine.prototype.add = function(word) {\n\t\t\tvar wordWidth;\n\t\t\tif (this.words.length) {\n\t\t\t\tthis.totalWidth += this.spaceWidth;\n\t\t\t}\n\t\t\tthis.words.push(word);\n\t\t\twordWidth = Line.measure(word);\n\t\t\tthis.totalWidth += wordWidth;\n\t\t\tthis.wordsWidth += wordWidth;\n\t\t};\n\n\t\tLine.prototype.measure = function(word) {\n\t\t\tvar width = this.totalWidth;\n\t\t\tif (word) {\n\t\t\t\twidth += Line.measure(word);\n\t\t\t\tif (this.words.length) {\n\t\t\t\t\twidth += this.spaceWidth;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn width;\n\t\t};\n\n\t\tLine.measure = function(word) {\n\t\t\treturn ctx.measureText(word).width;\n\t\t};\n\n\t\tfunction update() {\n\t\t\t//text stuffs\n\t\t\tvar text,\n\t\t\t\tword = '',\n\t\t\t\tletter,\n\t\t\t\tisSpace,\n\t\t\t\tline,\n\t\t\t\tlines = [],\n\t\t\t\tparse,\n\n\t\t\t\t//layout\n\t\t\t\tdirection = getComputedStyle(document.body).direction,\n\t\t\t\tinherit,\n\t\t\t\tresolution = parseFloat(props.resolution) || 256,\n\t\t\t\twrap,\n\t\t\t\twrapped = false,\n\t\t\t\tfontSize,\n\t\t\t\tpadding,\n\n\t\t\t\t//measurements\n\t\t\t\tlineHeight,\n\t\t\t\ti, start, y, measure,\n\t\t\t\twidth,\n\t\t\t\theight = 0;\n\n\t\t\twrap = parseFloat(props.wrap);\n\t\t\tif (isNaN(wrap) || wrap < 0) {\n\t\t\t\twrap = 5;\n\t\t\t}\n\t\t\twidth = resolution * wrap;\n\n\t\t\tctx.font = props.font;\n\t\t\tparse = fontSizeRegex.exec(ctx.font);\n\t\t\tfontSize = parseFloat(parse && parse[1]) || 50;\n\n\t\t\tlineHeight = fontSize * 1.5;\n\n\t\t\tline = new Line();\n\n\t\t\ttext = props.text === 0 ? '0' : String(props.text || '');\n\t\t\tif (wrap) {\n\t\t\t\ttext = text.trim() + ' ';\n\t\t\t\tfor (i = 0; i < text.length; i++) {\n\t\t\t\t\tletter = text.charAt(i);\n\t\t\t\t\tif (newLineRegex.test(letter)) {\n\t\t\t\t\t\tline.add(word);\n\t\t\t\t\t\tlines.push(line);\n\t\t\t\t\t\tword = '';\n\t\t\t\t\t\tline = new Line();\n\t\t\t\t\t} else if (spaceRegex.test(letter)) {\n\t\t\t\t\t\tmeasure = line.measure(word);\n\t\t\t\t\t\tif (measure < width) {\n\t\t\t\t\t\t\tif (line) {\n\t\t\t\t\t\t\t\tline.add(word);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tline = new Line(word);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (!line && Line.measure(word) >= width) {\n\t\t\t\t\t\t\t//one very long word\n\t\t\t\t\t\t\tlines.push(new Line(word));\n\t\t\t\t\t\t\tword = '';\n\t\t\t\t\t\t\tline = new Line();\n\t\t\t\t\t\t\twrapped = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tline.wrap = true;\n\t\t\t\t\t\t\tlines.push(line);\n\t\t\t\t\t\t\tline = new Line(word);\n\t\t\t\t\t\t\twrapped = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tword = '';\n\t\t\t\t\t} else {\n\t\t\t\t\t\tword += letter;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (line) {\n\t\t\t\t\tlines.push(line);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlines.push(new Line(text));\n\t\t\t}\n\n\t\t\tif (!width || !wrapped) {\n\t\t\t\twidth = lines.reduce(function (previous, line) {\n\t\t\t\t\treturn Math.max(previous, line.totalWidth);\n\t\t\t\t}, 0);\n\t\t\t}\n\t\t\twidth = Math.min(width, 2048);\n\n\t\t\theight = lines.length * lineHeight;\n\n\t\t\tif (options && options.mipmap === false) {\n\t\t\t\tcanvas.width = width;\n\t\t\t\tcanvas.height = height;\n\t\t\t} else {\n\t\t\t\tcanvas.width = nextPowerOfTwo(width);\n\t\t\t\tcanvas.height = nextPowerOfTwo(height);\n\t\t\t}\n\n\t\t\tmesh.scale.set(canvas.width / resolution, canvas.height / resolution, 1);\n\n\t\t\t//debug\n\t\t\t// ctx.fillStyle = 'rgba(100, 100, 100, 0.5)';\n\t\t\t// ctx.fillRect(0, 0, canvas.width, canvas.height);\n\t\t\t// document.body.appendChild(canvas);\n\t\t\t// canvas.style.cssText = 'position: absolute; width: auto !important; height: auto !important; max-width: 80%';\n\n\t\t\t/*\n\t\t\tset all these properties again because they get reset\n\t\t\twhen you resize the canvas\n\t\t\t*/\n\t\t\tctx.font = props.font;\n\t\t\tctx.textAlign = props.textAlign;\n\t\t\tctx.textBaseline = props.textBaseline;\n\t\t\tctx.direction = props.direction;\n\t\t\tctx.fillStyle = props.fillStyle;\n\t\t\t//todo: add maxWidth?\n\n\t\t\tpadding = (canvas.width - width) / 2;\n\t\t\ty = (canvas.height - height) / 2 + lineHeight / 2;\n\n\t\t\tinherit = (ctx.direction === '' || ctx.direction === 'inherit');\n\t\t\tif (ctx.textAlign === 'center') {\n\t\t\t\tstart = canvas.width / 2;\n\t\t\t} else if (ctx.textAlign === 'right' ||\n\t\t\t\tctx.textAlign === 'end' && (ctx.direction === 'ltr' || inherit && direction === 'ltr') ||\n\t\t\t\tctx.textAlign === 'start' && (ctx.direction === 'rtl' || inherit && direction === 'rtl')) {\n\n\t\t\t\tstart = canvas.width - padding;\n\t\t\t} else {\n\t\t\t\tstart = padding;\n\t\t\t}\n\n\t\t\tlines.forEach(function (line) {\n\t\t\t\tvar x,\n\t\t\t\t\tspace;\n\t\t\t\tif (props.textAlign === 'justify' && line.wrap && line.words.length > 1) {\n\t\t\t\t\tx = start;\n\t\t\t\t\tspace = (width - line.wordsWidth) / (line.words.length - 1);\n\t\t\t\t\tline.words.forEach(function (word) {\n\t\t\t\t\t\tctx.fillText(word, x, y);\n\t\t\t\t\t\tx += space + Line.measure(word);\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tctx.fillText(line.text(), start, y);\n\t\t\t\t}\n\t\t\t\ty += lineHeight;\n\t\t\t});\n\n\t\t\ttextWidth = width / resolution;\n\t\t\ttextHeight = lines.length * lineHeight / resolution;\n\n\t\t\ttex.needsUpdate = true;\n\n\t\t\tmesh.name = text.trim();\n\t\t}\n\n\t\tcanvas = document.createElement('canvas');\n\t\tctx = canvas.getContext('2d');\n\t\ttex = new THREE.Texture(canvas);\n\n\t\tif (canvas.width === nextPowerOfTwo(canvas.width) &&\n\t\t\tcanvas.height === nextPowerOfTwo(canvas.height)) {\n\n\t\t\ttex.minFilter = THREE.LinearMipMapLinearFilter;\n\t\t\ttex.generateMipmaps = true;\n\t\t}\n\n\t\tmaterial = new THREE.MeshBasicMaterial({\n\t\t\tside: THREE.DoubleSide,\n\t\t\ttransparent: true,\n\t\t\tmap: tex\n\t\t});\n\n\t\tmesh = new THREE.Mesh(geometry, material);\n\n\t\tcontainer = new THREE.Object3D();\n\t\tcontainer.name = 'text';\n\t\tcontainer.add(mesh);\n\t\tparent.add(container);\n\n\t\tif (typeof options === 'string') {\n\t\t\tprops.text = options;\n\t\t} else if (options) {\n\t\t\tObject.keys(props).forEach(function (key) {\n\t\t\t\tprops[key] = options[key] || props[key];\n\t\t\t});\n\t\t}\n\t\tupdate();\n\n\t\tObject.keys(props).forEach(function (key) {\n\t\t\tObject.defineProperty(self, key, {\n\t\t\t\tget: function () {\n\t\t\t\t\treturn props[key];\n\t\t\t\t},\n\t\t\t\tset: function (val) {\n\t\t\t\t\tprops[key] = val;\n\t\t\t\t\tupdate();\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\n\t\tObject.defineProperty(self, 'width', {\n\t\t\tget: function () {\n\t\t\t\treturn textWidth;\n\t\t\t}\n\t\t});\n\n\t\tObject.defineProperty(self, 'height', {\n\t\t\tget: function () {\n\t\t\t\treturn textHeight;\n\t\t\t}\n\t\t});\n\n\t\tthis.material = material;\n\n\t\treturn container;\n\t};\n}());\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/objects/text.js\n ** module id = 30\n ** module chunks = 0\n **/","module.exports = (function () {\n\t'use strict';\n\n\tvar materials = require('../materials'),\n\t\tTHREE = require('three');\n\n\treturn function torus(parent, options) {\n\t\tvar geometry,\n\t\t\tmesh;\n\n\t\tgeometry = new THREE.TorusGeometry(\n\t\t\toptions.radius === undefined ? 0.5 : options.radius,\n\t\t\toptions.tube === undefined ? 0.125 : options.tube,\n\t\t\toptions.radialSegments === undefined ? 12 : options.radialSegments,\n\t\t\toptions.tubularSegments === undefined ? 16 : options.tubularSegments,\n\t\t\toptions.arc\n\t\t);\n\t\tmesh = new THREE.Mesh(geometry, materials.standard());\n\t\tmesh.name = 'torus';\n\n\t\tparent.add(mesh);\n\n\t\treturn mesh;\n\t};\n}());\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/objects/torus.js\n ** module id = 31\n ** module chunks = 0\n **/","module.exports = (function () {\n\t'use strict';\n\n\tvar THREE = require('three'),\n\t\turlRegex = require('../utils/urlregex'),\n\t\textRegex = /\\.(webm|ogg|ogv|m4v|mp4|mov)/i,\n\t\tvideo;\n\n\tvideo = function (parent, options) {\n\t\tvar geometry,\n\t\t\tmaterial,\n\t\t\tmesh,\n\t\t\tvid,\n\t\t\ttex,\n\t\t\taspectRatio = 1,\n\t\t\tplaying = false,\n\t\t\tself = this;\n\n\t\tfunction isPowerOfTwo(num) {\n\t\t\treturn num > 0 && (num & (num-1)) === 0; // jshint ignore:line\n\t\t}\n\n\t\tfunction loadedMetadata() {\n\t\t\t//todo: don't do any of this if object has been deleted\n\n\t\t\tvar newAspectRatio = vid.videoWidth / vid.videoHeight;\n\t\t\tif (!options || !options.sphere) {\n\t\t\t\tgeometry.applyMatrix(new THREE.Matrix4().makeScale(1, aspectRatio / newAspectRatio, 1));\n\t\t\t}\n\t\t\taspectRatio = newAspectRatio;\n\n\t\t\tif (vid.videoWidth === vid.videoHeight &&\n\t\t\t\t\tisPowerOfTwo(vid.videoWidth) && isPowerOfTwo(vid.videoHeight)) {\n\n\t\t\t\ttex.minFilter = THREE.LinearMipMapLinearFilter;\n\t\t\t\ttex.generateMipmaps = true;\n\t\t\t} else {\n\t\t\t\ttex.minFilter = THREE.LinearFilter;\n\t\t\t\ttex.generateMipmaps = false;\n\t\t\t}\n\n\t\t\tmaterial.map = tex;\n\t\t\tmaterial.visible = true;\n\n\t\t\tif (playing) {\n\t\t\t\tvid.play();\n\t\t\t}\n\t\t}\n\n\t\tfunction setSource(sources) {\n\t\t\tsources.forEach(function (src) {\n\t\t\t\tvar parse,\n\t\t\t\t\text,\n\t\t\t\t\tsource;\n\n\t\t\t\tif (!src) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tparse = urlRegex.exec(src);\n\t\t\t\tif (parse &&\n\t\t\t\t\t\t(parse[1] && parse[1] !== window.location.hostÎ© ||\n\t\t\t\t\t\t\tparse[2] && parse[2] !== window.location.port)) {\n\n\t\t\t\t\tif (vid.crossOrigin !== undefined) {\n\t\t\t\t\t\tvid.crossOrigin = 'anonymous';\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.warn('Browser does not support cross-origin video');\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsource = document.createElement('source');\n\t\t\t\tsource.src = src;\n\n\t\t\t\text = extRegex.exec(src);\n\t\t\t\tif (!ext || vid.canPlayType('video/' + ext[1])) {\n\t\t\t\t\tvid.appendChild(source);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t/*\n\t\tPause the video when this browser tab is in the background or minimized.\n\t\tResume when it comes back in focus, but only if the user didn't pause manually.\n\t\t*/\n\t\tfunction visibilityChange() {\n\t\t\tif (document.hidden || document.mozHidden || document.msHidden || document.webkitHidden) {\n\t\t\t\tvid.pause();\n\t\t\t} else if (playing) {\n\t\t\t\tvid.play();\n\t\t\t}\n\t\t}\n\n\t\tvid = document.createElement('video');\n\t\tvid.loop = true;\n\t\tvid.addEventListener('loadedmetadata', loadedMetadata, false);\n\n\t\tif (Array.isArray(options)) {\n\t\t\tsetSource(options);\n\t\t} if (typeof options === 'string') {\n\t\t\tsetSource([options]);\n\t\t} else if (typeof options.src === 'string') {\n\t\t\tsetSource([options.src]);\n\t\t} else if (Array.isArray(options.src)) {\n\t\t\tsetSource(options.src);\n\t\t}\n\n\t\tvid.load();\n\n\t\ttex = new THREE.VideoTexture(vid, THREE.UVMapping);\n\t\ttex.format = THREE.RGBFormat;\n\n\t\tif (options && options.sphere) {\n\t\t\tgeometry = new THREE.SphereGeometry(\n\t\t\t\t994, //radius\n\t\t\t\t60, //widthSegments\n\t\t\t\t60, //heightSegments\n\t\t\t\t(parseFloat(options.phiStart) || 0) * Math.PI * 2,\n\t\t\t\t(parseFloat(options.phiLength) || 1) * Math.PI * 2,\n\t\t\t\t(parseFloat(options.thetaStart) || 0) * Math.PI,\n\t\t\t\t(parseFloat(options.thetaLength) || 1) * Math.PI\n\t\t\t);\n\t\t\tgeometry.applyMatrix(new THREE.Matrix4().makeScale(-1, 1, 1));\n\t\t\tgeometry.applyMatrix(new THREE.Matrix4().makeRotationY(- Math.PI / 2));\n\t\t} else {\n\t\t\tgeometry = new THREE.PlaneBufferGeometry(1, 1, 8);\n\t\t}\n\n\t\tmaterial = new THREE.MeshBasicMaterial({\n\t\t\tside: THREE.DoubleSide,\n\t\t\tmap: tex,\n\t\t\tvisible: false\n\t\t});\n\n\t\tmesh = new THREE.Mesh(geometry, material);\n\n\t\tif (options && options.stereo) {\n\t\t\tif (options.stereo === 'vertical') {\n\t\t\t\ttex.repeat.y = 0.5;\n\t\t\t} else {\n\t\t\t\ttex.repeat.x = 0.5;\n\t\t\t}\n\t\t\tmesh.userData.stereo = options.stereo;\n\t\t}\n\n\t\tif (vid.readyState) {\n\t\t\tloadedMetadata();\n\t\t}\n\n\t\tthis.play = function play() {\n\t\t\tplaying = true;\n\t\t\tvid.play();\n\t\t\treturn this;\n\t\t};\n\n\t\tthis.pause = function pause() {\n\t\t\tplaying = false;\n\t\t\tvid.pause();\n\t\t\treturn this;\n\t\t};\n\n\t\tthis.canPlayType = video.canPlayType;\n\n\t\tObject.defineProperty(this, 'width', {\n\t\t\tget: function () {\n\t\t\t\treturn vid.videoWidth;\n\t\t\t}\n\t\t});\n\n\t\tObject.defineProperty(this, 'height', {\n\t\t\tget: function () {\n\t\t\t\treturn vid.videoHeight;\n\t\t\t}\n\t\t});\n\n\t\tObject.defineProperty(this, 'paused', {\n\t\t\tget: function () {\n\t\t\t\treturn !playing;\n\t\t\t}\n\t\t});\n\n\t\tObject.defineProperty(this, 'volume', {\n\t\t\tget: function () {\n\t\t\t\treturn vid.volume;\n\t\t\t},\n\t\t\tset: function (vol) {\n\t\t\t\tvid.volume = vol;\n\t\t\t}\n\t\t});\n\n\t\tObject.defineProperty(this, 'muted', {\n\t\t\tget: function () {\n\t\t\t\treturn vid.muted;\n\t\t\t},\n\t\t\tset: function (muted) {\n\t\t\t\tvid.muted = muted;\n\t\t\t}\n\t\t});\n\n\t\tObject.defineProperty(this, 'duration', {\n\t\t\tget: function () {\n\t\t\t\treturn vid.duration || 0;\n\t\t\t}\n\t\t});\n\n\t\tObject.defineProperty(this, 'currentTime', {\n\t\t\tget: function () {\n\t\t\t\treturn vid.currentTime;\n\t\t\t},\n\t\t\tset: function (currentTime) {\n\t\t\t\tif (vid.readyState && currentTime < vid.duration && currentTime >= 0) {\n\t\t\t\t\tvid.currentTime = currentTime;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\t[\n\t\t\t'loadedmetadata',\n\t\t\t'play',\n\t\t\t'pause',\n\t\t\t'playing',\n\t\t\t'progress'\n\t\t].forEach(function registerMediaEvent(event) {\n\t\t\tvid.addEventListener(event, self.emit.bind(self, event));\n\t\t});\n\n\t\t//sometimes video fails to play because it's too big. remove it and try again\n\t\tvid.addEventListener('error', function (evt) {\n\t\t\tif (vid.error.code === window.MediaError.MEDIA_ERR_DECODE && vid.childNodes.length > 1) {\n\t\t\t\tmaterial.visible = false;\n\t\t\t\tvid.removeChild(vid.firstChild);\n\t\t\t\tvid.load();\n\t\t\t}\n\n\t\t\tself.emit(event, evt);\n\t\t}, true);\n\n\t\tthis.element = vid;\n\n\t\twindow.addEventListener('touchstart', function touchStart() {\n\t\t\tif (playing) {\n\t\t\t\tvid.play();\n\t\t\t} else {\n\t\t\t\tvid.load();\n\t\t\t}\n\t\t\twindow.removeEventListener('touchstart', touchStart, true);\n\t\t}, true);\n\n\t\t//pause when window is hidden\n\t\tdocument.addEventListener('visibilitychange', visibilityChange);\n\t\tdocument.addEventListener('mozvisibilitychange', visibilityChange);\n\t\tdocument.addEventListener('msvisibilitychange', visibilityChange);\n\t\tdocument.addEventListener('webkitvisibilitychange', visibilityChange);\n\n\t\tmesh.name = 'video';\n\t\tparent.add(mesh);\n\n\t\treturn mesh;\n\t};\n\n\tvideo.canPlayType = function canPlayType(type) {\n\t\tvar element = document.createElement('video');\n\t\treturn element.canPlayType(type);\n\t};\n\n\treturn video;\n}());\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/objects/video.js\n ** module id = 32\n ** module chunks = 0\n **/","var self = self || {};// File:src/Three.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nvar THREE = { REVISION: '71' };\r\n\r\n// browserify support\r\n\r\nif ( typeof module === 'object' ) {\r\n\r\n\tmodule.exports = THREE;\r\n\r\n}\r\n\r\n// polyfills\r\n\r\nif ( Math.sign === undefined ) {\r\n\r\n\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign\r\n\r\n\tMath.sign = function ( x ) {\r\n\r\n\t\treturn ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : +x;\r\n\r\n\t};\r\n\r\n}\r\n\r\n\r\n// set the default log handlers\r\nTHREE.log = function() { console.log.apply( console, arguments ); }\r\nTHREE.warn = function() { console.warn.apply( console, arguments ); }\r\nTHREE.error = function() { console.error.apply( console, arguments ); }\r\n\r\n\r\n// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent.button\r\n\r\nTHREE.MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };\r\n\r\n// GL STATE CONSTANTS\r\n\r\nTHREE.CullFaceNone = 0;\r\nTHREE.CullFaceBack = 1;\r\nTHREE.CullFaceFront = 2;\r\nTHREE.CullFaceFrontBack = 3;\r\n\r\nTHREE.FrontFaceDirectionCW = 0;\r\nTHREE.FrontFaceDirectionCCW = 1;\r\n\r\n// SHADOWING TYPES\r\n\r\nTHREE.BasicShadowMap = 0;\r\nTHREE.PCFShadowMap = 1;\r\nTHREE.PCFSoftShadowMap = 2;\r\n\r\n// MATERIAL CONSTANTS\r\n\r\n// side\r\n\r\nTHREE.FrontSide = 0;\r\nTHREE.BackSide = 1;\r\nTHREE.DoubleSide = 2;\r\n\r\n// shading\r\n\r\nTHREE.NoShading = 0;\r\nTHREE.FlatShading = 1;\r\nTHREE.SmoothShading = 2;\r\n\r\n// colors\r\n\r\nTHREE.NoColors = 0;\r\nTHREE.FaceColors = 1;\r\nTHREE.VertexColors = 2;\r\n\r\n// blending modes\r\n\r\nTHREE.NoBlending = 0;\r\nTHREE.NormalBlending = 1;\r\nTHREE.AdditiveBlending = 2;\r\nTHREE.SubtractiveBlending = 3;\r\nTHREE.MultiplyBlending = 4;\r\nTHREE.CustomBlending = 5;\r\n\r\n// custom blending equations\r\n// (numbers start from 100 not to clash with other\r\n//  mappings to OpenGL constants defined in Texture.js)\r\n\r\nTHREE.AddEquation = 100;\r\nTHREE.SubtractEquation = 101;\r\nTHREE.ReverseSubtractEquation = 102;\r\nTHREE.MinEquation = 103;\r\nTHREE.MaxEquation = 104;\r\n\r\n// custom blending destination factors\r\n\r\nTHREE.ZeroFactor = 200;\r\nTHREE.OneFactor = 201;\r\nTHREE.SrcColorFactor = 202;\r\nTHREE.OneMinusSrcColorFactor = 203;\r\nTHREE.SrcAlphaFactor = 204;\r\nTHREE.OneMinusSrcAlphaFactor = 205;\r\nTHREE.DstAlphaFactor = 206;\r\nTHREE.OneMinusDstAlphaFactor = 207;\r\n\r\n// custom blending source factors\r\n\r\n//THREE.ZeroFactor = 200;\r\n//THREE.OneFactor = 201;\r\n//THREE.SrcAlphaFactor = 204;\r\n//THREE.OneMinusSrcAlphaFactor = 205;\r\n//THREE.DstAlphaFactor = 206;\r\n//THREE.OneMinusDstAlphaFactor = 207;\r\nTHREE.DstColorFactor = 208;\r\nTHREE.OneMinusDstColorFactor = 209;\r\nTHREE.SrcAlphaSaturateFactor = 210;\r\n\r\n\r\n// TEXTURE CONSTANTS\r\n\r\nTHREE.MultiplyOperation = 0;\r\nTHREE.MixOperation = 1;\r\nTHREE.AddOperation = 2;\r\n\r\n// Mapping modes\r\n\r\nTHREE.UVMapping = 300;\r\n\r\nTHREE.CubeReflectionMapping = 301;\r\nTHREE.CubeRefractionMapping = 302;\r\n\r\nTHREE.EquirectangularReflectionMapping = 303;\r\nTHREE.EquirectangularRefractionMapping = 304;\r\n\r\nTHREE.SphericalReflectionMapping = 305;\r\n\r\n// Wrapping modes\r\n\r\nTHREE.RepeatWrapping = 1000;\r\nTHREE.ClampToEdgeWrapping = 1001;\r\nTHREE.MirroredRepeatWrapping = 1002;\r\n\r\n// Filters\r\n\r\nTHREE.NearestFilter = 1003;\r\nTHREE.NearestMipMapNearestFilter = 1004;\r\nTHREE.NearestMipMapLinearFilter = 1005;\r\nTHREE.LinearFilter = 1006;\r\nTHREE.LinearMipMapNearestFilter = 1007;\r\nTHREE.LinearMipMapLinearFilter = 1008;\r\n\r\n// Data types\r\n\r\nTHREE.UnsignedByteType = 1009;\r\nTHREE.ByteType = 1010;\r\nTHREE.ShortType = 1011;\r\nTHREE.UnsignedShortType = 1012;\r\nTHREE.IntType = 1013;\r\nTHREE.UnsignedIntType = 1014;\r\nTHREE.FloatType = 1015;\r\nTHREE.HalfFloatType = 1025;\r\n\r\n// Pixel types\r\n\r\n//THREE.UnsignedByteType = 1009;\r\nTHREE.UnsignedShort4444Type = 1016;\r\nTHREE.UnsignedShort5551Type = 1017;\r\nTHREE.UnsignedShort565Type = 1018;\r\n\r\n// Pixel formats\r\n\r\nTHREE.AlphaFormat = 1019;\r\nTHREE.RGBFormat = 1020;\r\nTHREE.RGBAFormat = 1021;\r\nTHREE.LuminanceFormat = 1022;\r\nTHREE.LuminanceAlphaFormat = 1023;\r\n// THREE.RGBEFormat handled as THREE.RGBAFormat in shaders\r\nTHREE.RGBEFormat = THREE.RGBAFormat; //1024;\r\n\r\n// DDS / ST3C Compressed texture formats\r\n\r\nTHREE.RGB_S3TC_DXT1_Format = 2001;\r\nTHREE.RGBA_S3TC_DXT1_Format = 2002;\r\nTHREE.RGBA_S3TC_DXT3_Format = 2003;\r\nTHREE.RGBA_S3TC_DXT5_Format = 2004;\r\n\r\n\r\n// PVRTC compressed texture formats\r\n\r\nTHREE.RGB_PVRTC_4BPPV1_Format = 2100;\r\nTHREE.RGB_PVRTC_2BPPV1_Format = 2101;\r\nTHREE.RGBA_PVRTC_4BPPV1_Format = 2102;\r\nTHREE.RGBA_PVRTC_2BPPV1_Format = 2103;\r\n\r\n\r\n// DEPRECATED\r\n\r\nTHREE.Projector = function () {\r\n\r\n\tTHREE.error( 'THREE.Projector has been moved to /examples/js/renderers/Projector.js.' );\r\n\r\n\tthis.projectVector = function ( vector, camera ) {\r\n\r\n\t\tTHREE.warn( 'THREE.Projector: .projectVector() is now vector.project().' );\r\n\t\tvector.project( camera );\r\n\r\n\t};\r\n\r\n\tthis.unprojectVector = function ( vector, camera ) {\r\n\r\n\t\tTHREE.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );\r\n\t\tvector.unproject( camera );\r\n\r\n\t};\r\n\r\n\tthis.pickingRay = function ( vector, camera ) {\r\n\r\n\t\tTHREE.error( 'THREE.Projector: .pickingRay() is now raycaster.setFromCamera().' );\r\n\r\n\t};\r\n\r\n};\r\n\r\nTHREE.CanvasRenderer = function () {\r\n\r\n\tTHREE.error( 'THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js' );\r\n\r\n\tthis.domElement = document.createElement( 'canvas' );\r\n\tthis.clear = function () {};\r\n\tthis.render = function () {};\r\n\tthis.setClearColor = function () {};\r\n\tthis.setSize = function () {};\r\n\r\n};\r\n\r\n// File:src/math/Color.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Color = function ( color ) {\r\n\r\n\tif ( arguments.length === 3 ) {\r\n\r\n\t\treturn this.setRGB( arguments[ 0 ], arguments[ 1 ], arguments[ 2 ] );\r\n\r\n\t}\r\n\r\n\treturn this.set( color )\r\n\r\n};\r\n\r\nTHREE.Color.prototype = {\r\n\r\n\tconstructor: THREE.Color,\r\n\r\n\tr: 1, g: 1, b: 1,\r\n\r\n\tset: function ( value ) {\r\n\r\n\t\tif ( value instanceof THREE.Color ) {\r\n\r\n\t\t\tthis.copy( value );\r\n\r\n\t\t} else if ( typeof value === 'number' ) {\r\n\r\n\t\t\tthis.setHex( value );\r\n\r\n\t\t} else if ( typeof value === 'string' ) {\r\n\r\n\t\t\tthis.setStyle( value );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetHex: function ( hex ) {\r\n\r\n\t\thex = Math.floor( hex );\r\n\r\n\t\tthis.r = ( hex >> 16 & 255 ) / 255;\r\n\t\tthis.g = ( hex >> 8 & 255 ) / 255;\r\n\t\tthis.b = ( hex & 255 ) / 255;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetRGB: function ( r, g, b ) {\r\n\r\n\t\tthis.r = r;\r\n\t\tthis.g = g;\r\n\t\tthis.b = b;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetHSL: function ( h, s, l ) {\r\n\r\n\t\t// h,s,l ranges are in 0.0 - 1.0\r\n\r\n\t\tif ( s === 0 ) {\r\n\r\n\t\t\tthis.r = this.g = this.b = l;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tvar hue2rgb = function ( p, q, t ) {\r\n\r\n\t\t\t\tif ( t < 0 ) t += 1;\r\n\t\t\t\tif ( t > 1 ) t -= 1;\r\n\t\t\t\tif ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;\r\n\t\t\t\tif ( t < 1 / 2 ) return q;\r\n\t\t\t\tif ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );\r\n\t\t\t\treturn p;\r\n\r\n\t\t\t};\r\n\r\n\t\t\tvar p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );\r\n\t\t\tvar q = ( 2 * l ) - p;\r\n\r\n\t\t\tthis.r = hue2rgb( q, p, h + 1 / 3 );\r\n\t\t\tthis.g = hue2rgb( q, p, h );\r\n\t\t\tthis.b = hue2rgb( q, p, h - 1 / 3 );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetStyle: function ( style ) {\r\n\r\n\t\t// rgb(255,0,0)\r\n\r\n\t\tif ( /^rgb\\((\\d+), ?(\\d+), ?(\\d+)\\)$/i.test( style ) ) {\r\n\r\n\t\t\tvar color = /^rgb\\((\\d+), ?(\\d+), ?(\\d+)\\)$/i.exec( style );\r\n\r\n\t\t\tthis.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;\r\n\t\t\tthis.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;\r\n\t\t\tthis.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t// rgb(100%,0%,0%)\r\n\r\n\t\tif ( /^rgb\\((\\d+)\\%, ?(\\d+)\\%, ?(\\d+)\\%\\)$/i.test( style ) ) {\r\n\r\n\t\t\tvar color = /^rgb\\((\\d+)\\%, ?(\\d+)\\%, ?(\\d+)\\%\\)$/i.exec( style );\r\n\r\n\t\t\tthis.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;\r\n\t\t\tthis.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;\r\n\t\t\tthis.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t// #ff0000\r\n\r\n\t\tif ( /^\\#([0-9a-f]{6})$/i.test( style ) ) {\r\n\r\n\t\t\tvar color = /^\\#([0-9a-f]{6})$/i.exec( style );\r\n\r\n\t\t\tthis.setHex( parseInt( color[ 1 ], 16 ) );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t// #f00\r\n\r\n\t\tif ( /^\\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.test( style ) ) {\r\n\r\n\t\t\tvar color = /^\\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.exec( style );\r\n\r\n\t\t\tthis.setHex( parseInt( color[ 1 ] + color[ 1 ] + color[ 2 ] + color[ 2 ] + color[ 3 ] + color[ 3 ], 16 ) );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t// red\r\n\r\n\t\tif ( /^(\\w+)$/i.test( style ) ) {\r\n\r\n\t\t\tthis.setHex( THREE.ColorKeywords[ style ] );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\r\n\t},\r\n\r\n\tcopy: function ( color ) {\r\n\r\n\t\tthis.r = color.r;\r\n\t\tthis.g = color.g;\r\n\t\tthis.b = color.b;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopyGammaToLinear: function ( color, gammaFactor ) {\r\n\r\n\t\tif ( gammaFactor === undefined ) gammaFactor = 2.0;\r\n\r\n\t\tthis.r = Math.pow( color.r, gammaFactor );\r\n\t\tthis.g = Math.pow( color.g, gammaFactor );\r\n\t\tthis.b = Math.pow( color.b, gammaFactor );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopyLinearToGamma: function ( color, gammaFactor ) {\r\n\r\n\t\tif ( gammaFactor === undefined ) gammaFactor = 2.0;\r\n\r\n\t\tvar safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;\r\n\r\n\t\tthis.r = Math.pow( color.r, safeInverse );\r\n\t\tthis.g = Math.pow( color.g, safeInverse );\r\n\t\tthis.b = Math.pow( color.b, safeInverse );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tconvertGammaToLinear: function () {\r\n\r\n\t\tvar r = this.r, g = this.g, b = this.b;\r\n\r\n\t\tthis.r = r * r;\r\n\t\tthis.g = g * g;\r\n\t\tthis.b = b * b;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tconvertLinearToGamma: function () {\r\n\r\n\t\tthis.r = Math.sqrt( this.r );\r\n\t\tthis.g = Math.sqrt( this.g );\r\n\t\tthis.b = Math.sqrt( this.b );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetHex: function () {\r\n\r\n\t\treturn ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;\r\n\r\n\t},\r\n\r\n\tgetHexString: function () {\r\n\r\n\t\treturn ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );\r\n\r\n\t},\r\n\r\n\tgetHSL: function ( optionalTarget ) {\r\n\r\n\t\t// h,s,l ranges are in 0.0 - 1.0\r\n\r\n\t\tvar hsl = optionalTarget || { h: 0, s: 0, l: 0 };\r\n\r\n\t\tvar r = this.r, g = this.g, b = this.b;\r\n\r\n\t\tvar max = Math.max( r, g, b );\r\n\t\tvar min = Math.min( r, g, b );\r\n\r\n\t\tvar hue, saturation;\r\n\t\tvar lightness = ( min + max ) / 2.0;\r\n\r\n\t\tif ( min === max ) {\r\n\r\n\t\t\thue = 0;\r\n\t\t\tsaturation = 0;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tvar delta = max - min;\r\n\r\n\t\t\tsaturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );\r\n\r\n\t\t\tswitch ( max ) {\r\n\r\n\t\t\t\tcase r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;\r\n\t\t\t\tcase g: hue = ( b - r ) / delta + 2; break;\r\n\t\t\t\tcase b: hue = ( r - g ) / delta + 4; break;\r\n\r\n\t\t\t}\r\n\r\n\t\t\thue /= 6;\r\n\r\n\t\t}\r\n\r\n\t\thsl.h = hue;\r\n\t\thsl.s = saturation;\r\n\t\thsl.l = lightness;\r\n\r\n\t\treturn hsl;\r\n\r\n\t},\r\n\r\n\tgetStyle: function () {\r\n\r\n\t\treturn 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';\r\n\r\n\t},\r\n\r\n\toffsetHSL: function ( h, s, l ) {\r\n\r\n\t\tvar hsl = this.getHSL();\r\n\r\n\t\thsl.h += h; hsl.s += s; hsl.l += l;\r\n\r\n\t\tthis.setHSL( hsl.h, hsl.s, hsl.l );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tadd: function ( color ) {\r\n\r\n\t\tthis.r += color.r;\r\n\t\tthis.g += color.g;\r\n\t\tthis.b += color.b;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddColors: function ( color1, color2 ) {\r\n\r\n\t\tthis.r = color1.r + color2.r;\r\n\t\tthis.g = color1.g + color2.g;\r\n\t\tthis.b = color1.b + color2.b;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddScalar: function ( s ) {\r\n\r\n\t\tthis.r += s;\r\n\t\tthis.g += s;\r\n\t\tthis.b += s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiply: function ( color ) {\r\n\r\n\t\tthis.r *= color.r;\r\n\t\tthis.g *= color.g;\r\n\t\tthis.b *= color.b;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiplyScalar: function ( s ) {\r\n\r\n\t\tthis.r *= s;\r\n\t\tthis.g *= s;\r\n\t\tthis.b *= s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tlerp: function ( color, alpha ) {\r\n\r\n\t\tthis.r += ( color.r - this.r ) * alpha;\r\n\t\tthis.g += ( color.g - this.g ) * alpha;\r\n\t\tthis.b += ( color.b - this.b ) * alpha;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tequals: function ( c ) {\r\n\r\n\t\treturn ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );\r\n\r\n\t},\r\n\r\n\tfromArray: function ( array ) {\r\n\r\n\t\tthis.r = array[ 0 ];\r\n\t\tthis.g = array[ 1 ];\r\n\t\tthis.b = array[ 2 ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttoArray: function ( array, offset ) {\r\n\r\n\t\tif ( array === undefined ) array = [];\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tarray[ offset ] = this.r;\r\n\t\tarray[ offset + 1 ] = this.g;\r\n\t\tarray[ offset + 2 ] = this.b;\r\n\r\n\t\treturn array;\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new THREE.Color().setRGB( this.r, this.g, this.b );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,\r\n'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,\r\n'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,\r\n'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,\r\n'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,\r\n'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,\r\n'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,\r\n'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,\r\n'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,\r\n'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,\r\n'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,\r\n'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,\r\n'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,\r\n'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,\r\n'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,\r\n'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,\r\n'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,\r\n'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,\r\n'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,\r\n'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,\r\n'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,\r\n'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,\r\n'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,\r\n'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };\r\n\r\n// File:src/math/Quaternion.js\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n * @author bhouston / http://exocortex.com\r\n */\r\n\r\nTHREE.Quaternion = function ( x, y, z, w ) {\r\n\r\n\tthis._x = x || 0;\r\n\tthis._y = y || 0;\r\n\tthis._z = z || 0;\r\n\tthis._w = ( w !== undefined ) ? w : 1;\r\n\r\n};\r\n\r\nTHREE.Quaternion.prototype = {\r\n\r\n\tconstructor: THREE.Quaternion,\r\n\r\n\t_x: 0,_y: 0, _z: 0, _w: 0,\r\n\r\n\tget x () {\r\n\r\n\t\treturn this._x;\r\n\r\n\t},\r\n\r\n\tset x ( value ) {\r\n\r\n\t\tthis._x = value;\r\n\t\tthis.onChangeCallback();\r\n\r\n\t},\r\n\r\n\tget y () {\r\n\r\n\t\treturn this._y;\r\n\r\n\t},\r\n\r\n\tset y ( value ) {\r\n\r\n\t\tthis._y = value;\r\n\t\tthis.onChangeCallback();\r\n\r\n\t},\r\n\r\n\tget z () {\r\n\r\n\t\treturn this._z;\r\n\r\n\t},\r\n\r\n\tset z ( value ) {\r\n\r\n\t\tthis._z = value;\r\n\t\tthis.onChangeCallback();\r\n\r\n\t},\r\n\r\n\tget w () {\r\n\r\n\t\treturn this._w;\r\n\r\n\t},\r\n\r\n\tset w ( value ) {\r\n\r\n\t\tthis._w = value;\r\n\t\tthis.onChangeCallback();\r\n\r\n\t},\r\n\r\n\tset: function ( x, y, z, w ) {\r\n\r\n\t\tthis._x = x;\r\n\t\tthis._y = y;\r\n\t\tthis._z = z;\r\n\t\tthis._w = w;\r\n\r\n\t\tthis.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopy: function ( quaternion ) {\r\n\r\n\t\tthis._x = quaternion.x;\r\n\t\tthis._y = quaternion.y;\r\n\t\tthis._z = quaternion.z;\r\n\t\tthis._w = quaternion.w;\r\n\r\n\t\tthis.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromEuler: function ( euler, update ) {\r\n\r\n\t\tif ( euler instanceof THREE.Euler === false ) {\r\n\r\n\t\t\tthrow new Error( 'THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );\r\n\t\t}\r\n\r\n\t\t// http://www.mathworks.com/matlabcentral/fileexchange/\r\n\t\t// \t20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\r\n\t\t//\tcontent/SpinCalc.m\r\n\r\n\t\tvar c1 = Math.cos( euler._x / 2 );\r\n\t\tvar c2 = Math.cos( euler._y / 2 );\r\n\t\tvar c3 = Math.cos( euler._z / 2 );\r\n\t\tvar s1 = Math.sin( euler._x / 2 );\r\n\t\tvar s2 = Math.sin( euler._y / 2 );\r\n\t\tvar s3 = Math.sin( euler._z / 2 );\r\n\r\n\t\tif ( euler.order === 'XYZ' ) {\r\n\r\n\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\r\n\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\r\n\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\r\n\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\r\n\r\n\t\t} else if ( euler.order === 'YXZ' ) {\r\n\r\n\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\r\n\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\r\n\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\r\n\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\r\n\r\n\t\t} else if ( euler.order === 'ZXY' ) {\r\n\r\n\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\r\n\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\r\n\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\r\n\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\r\n\r\n\t\t} else if ( euler.order === 'ZYX' ) {\r\n\r\n\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\r\n\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\r\n\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\r\n\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\r\n\r\n\t\t} else if ( euler.order === 'YZX' ) {\r\n\r\n\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\r\n\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\r\n\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\r\n\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\r\n\r\n\t\t} else if ( euler.order === 'XZY' ) {\r\n\r\n\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\r\n\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\r\n\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\r\n\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\r\n\r\n\t\t}\r\n\r\n\t\tif ( update !== false ) this.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromAxisAngle: function ( axis, angle ) {\r\n\r\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\r\n\r\n\t\t// assumes axis is normalized\r\n\r\n\t\tvar halfAngle = angle / 2, s = Math.sin( halfAngle );\r\n\r\n\t\tthis._x = axis.x * s;\r\n\t\tthis._y = axis.y * s;\r\n\t\tthis._z = axis.z * s;\r\n\t\tthis._w = Math.cos( halfAngle );\r\n\r\n\t\tthis.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromRotationMatrix: function ( m ) {\r\n\r\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\r\n\r\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\r\n\r\n\t\tvar te = m.elements,\r\n\r\n\t\t\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\r\n\t\t\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\r\n\t\t\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],\r\n\r\n\t\t\ttrace = m11 + m22 + m33,\r\n\t\t\ts;\r\n\r\n\t\tif ( trace > 0 ) {\r\n\r\n\t\t\ts = 0.5 / Math.sqrt( trace + 1.0 );\r\n\r\n\t\t\tthis._w = 0.25 / s;\r\n\t\t\tthis._x = ( m32 - m23 ) * s;\r\n\t\t\tthis._y = ( m13 - m31 ) * s;\r\n\t\t\tthis._z = ( m21 - m12 ) * s;\r\n\r\n\t\t} else if ( m11 > m22 && m11 > m33 ) {\r\n\r\n\t\t\ts = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );\r\n\r\n\t\t\tthis._w = ( m32 - m23 ) / s;\r\n\t\t\tthis._x = 0.25 * s;\r\n\t\t\tthis._y = ( m12 + m21 ) / s;\r\n\t\t\tthis._z = ( m13 + m31 ) / s;\r\n\r\n\t\t} else if ( m22 > m33 ) {\r\n\r\n\t\t\ts = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );\r\n\r\n\t\t\tthis._w = ( m13 - m31 ) / s;\r\n\t\t\tthis._x = ( m12 + m21 ) / s;\r\n\t\t\tthis._y = 0.25 * s;\r\n\t\t\tthis._z = ( m23 + m32 ) / s;\r\n\r\n\t\t} else {\r\n\r\n\t\t\ts = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );\r\n\r\n\t\t\tthis._w = ( m21 - m12 ) / s;\r\n\t\t\tthis._x = ( m13 + m31 ) / s;\r\n\t\t\tthis._y = ( m23 + m32 ) / s;\r\n\t\t\tthis._z = 0.25 * s;\r\n\r\n\t\t}\r\n\r\n\t\tthis.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromUnitVectors: function () {\r\n\r\n\t\t// http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final\r\n\r\n\t\t// assumes direction vectors vFrom and vTo are normalized\r\n\r\n\t\tvar v1, r;\r\n\r\n\t\tvar EPS = 0.000001;\r\n\r\n\t\treturn function ( vFrom, vTo ) {\r\n\r\n\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\r\n\r\n\t\t\tr = vFrom.dot( vTo ) + 1;\r\n\r\n\t\t\tif ( r < EPS ) {\r\n\r\n\t\t\t\tr = 0;\r\n\r\n\t\t\t\tif ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {\r\n\r\n\t\t\t\t\tv1.set( - vFrom.y, vFrom.x, 0 );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tv1.set( 0, - vFrom.z, vFrom.y );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tv1.crossVectors( vFrom, vTo );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis._x = v1.x;\r\n\t\t\tthis._y = v1.y;\r\n\t\t\tthis._z = v1.z;\r\n\t\t\tthis._w = r;\r\n\r\n\t\t\tthis.normalize();\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t}(),\r\n\r\n\tinverse: function () {\r\n\r\n\t\tthis.conjugate().normalize();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tconjugate: function () {\r\n\r\n\t\tthis._x *= - 1;\r\n\t\tthis._y *= - 1;\r\n\t\tthis._z *= - 1;\r\n\r\n\t\tthis.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdot: function ( v ) {\r\n\r\n\t\treturn this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;\r\n\r\n\t},\r\n\r\n\tlengthSq: function () {\r\n\r\n\t\treturn this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;\r\n\r\n\t},\r\n\r\n\tlength: function () {\r\n\r\n\t\treturn Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );\r\n\r\n\t},\r\n\r\n\tnormalize: function () {\r\n\r\n\t\tvar l = this.length();\r\n\r\n\t\tif ( l === 0 ) {\r\n\r\n\t\t\tthis._x = 0;\r\n\t\t\tthis._y = 0;\r\n\t\t\tthis._z = 0;\r\n\t\t\tthis._w = 1;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tl = 1 / l;\r\n\r\n\t\t\tthis._x = this._x * l;\r\n\t\t\tthis._y = this._y * l;\r\n\t\t\tthis._z = this._z * l;\r\n\t\t\tthis._w = this._w * l;\r\n\r\n\t\t}\r\n\r\n\t\tthis.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiply: function ( q, p ) {\r\n\r\n\t\tif ( p !== undefined ) {\r\n\r\n\t\t\tTHREE.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );\r\n\t\t\treturn this.multiplyQuaternions( q, p );\r\n\r\n\t\t}\r\n\r\n\t\treturn this.multiplyQuaternions( this, q );\r\n\r\n\t},\r\n\r\n\tmultiplyQuaternions: function ( a, b ) {\r\n\r\n\t\t// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm\r\n\r\n\t\tvar qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;\r\n\t\tvar qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;\r\n\r\n\t\tthis._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\r\n\t\tthis._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\r\n\t\tthis._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\r\n\t\tthis._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\r\n\r\n\t\tthis.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiplyVector3: function ( vector ) {\r\n\r\n\t\tTHREE.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );\r\n\t\treturn vector.applyQuaternion( this );\r\n\r\n\t},\r\n\r\n\tslerp: function ( qb, t ) {\r\n\r\n\t\tif ( t === 0 ) return this;\r\n\t\tif ( t === 1 ) return this.copy( qb );\r\n\r\n\t\tvar x = this._x, y = this._y, z = this._z, w = this._w;\r\n\r\n\t\t// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/\r\n\r\n\t\tvar cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;\r\n\r\n\t\tif ( cosHalfTheta < 0 ) {\r\n\r\n\t\t\tthis._w = - qb._w;\r\n\t\t\tthis._x = - qb._x;\r\n\t\t\tthis._y = - qb._y;\r\n\t\t\tthis._z = - qb._z;\r\n\r\n\t\t\tcosHalfTheta = - cosHalfTheta;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.copy( qb );\r\n\r\n\t\t}\r\n\r\n\t\tif ( cosHalfTheta >= 1.0 ) {\r\n\r\n\t\t\tthis._w = w;\r\n\t\t\tthis._x = x;\r\n\t\t\tthis._y = y;\r\n\t\t\tthis._z = z;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\tvar halfTheta = Math.acos( cosHalfTheta );\r\n\t\tvar sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );\r\n\r\n\t\tif ( Math.abs( sinHalfTheta ) < 0.001 ) {\r\n\r\n\t\t\tthis._w = 0.5 * ( w + this._w );\r\n\t\t\tthis._x = 0.5 * ( x + this._x );\r\n\t\t\tthis._y = 0.5 * ( y + this._y );\r\n\t\t\tthis._z = 0.5 * ( z + this._z );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\tvar ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,\r\n\t\tratioB = Math.sin( t * halfTheta ) / sinHalfTheta;\r\n\r\n\t\tthis._w = ( w * ratioA + this._w * ratioB );\r\n\t\tthis._x = ( x * ratioA + this._x * ratioB );\r\n\t\tthis._y = ( y * ratioA + this._y * ratioB );\r\n\t\tthis._z = ( z * ratioA + this._z * ratioB );\r\n\r\n\t\tthis.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tequals: function ( quaternion ) {\r\n\r\n\t\treturn ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );\r\n\r\n\t},\r\n\r\n\tfromArray: function ( array, offset ) {\r\n\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tthis._x = array[ offset ];\r\n\t\tthis._y = array[ offset + 1 ];\r\n\t\tthis._z = array[ offset + 2 ];\r\n\t\tthis._w = array[ offset + 3 ];\r\n\r\n\t\tthis.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttoArray: function ( array, offset ) {\r\n\r\n\t\tif ( array === undefined ) array = [];\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tarray[ offset ] = this._x;\r\n\t\tarray[ offset + 1 ] = this._y;\r\n\t\tarray[ offset + 2 ] = this._z;\r\n\t\tarray[ offset + 3 ] = this._w;\r\n\r\n\t\treturn array;\r\n\r\n\t},\r\n\r\n\tonChange: function ( callback ) {\r\n\r\n\t\tthis.onChangeCallback = callback;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tonChangeCallback: function () {},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new THREE.Quaternion( this._x, this._y, this._z, this._w );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.Quaternion.slerp = function ( qa, qb, qm, t ) {\r\n\r\n\treturn qm.copy( qa ).slerp( qb, t );\r\n\r\n}\r\n\r\n// File:src/math/Vector2.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author philogb / http://blog.thejit.org/\r\n * @author egraether / http://egraether.com/\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n */\r\n\r\nTHREE.Vector2 = function ( x, y ) {\r\n\r\n\tthis.x = x || 0;\r\n\tthis.y = y || 0;\r\n\r\n};\r\n\r\nTHREE.Vector2.prototype = {\r\n\r\n\tconstructor: THREE.Vector2,\r\n\r\n\tset: function ( x, y ) {\r\n\r\n\t\tthis.x = x;\r\n\t\tthis.y = y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetX: function ( x ) {\r\n\r\n\t\tthis.x = x;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetY: function ( y ) {\r\n\r\n\t\tthis.y = y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetComponent: function ( index, value ) {\r\n\r\n\t\tswitch ( index ) {\r\n\r\n\t\t\tcase 0: this.x = value; break;\r\n\t\t\tcase 1: this.y = value; break;\r\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tgetComponent: function ( index ) {\r\n\r\n\t\tswitch ( index ) {\r\n\r\n\t\t\tcase 0: return this.x;\r\n\t\t\tcase 1: return this.y;\r\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tcopy: function ( v ) {\r\n\r\n\t\tthis.x = v.x;\r\n\t\tthis.y = v.y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tadd: function ( v, w ) {\r\n\r\n\t\tif ( w !== undefined ) {\r\n\r\n\t\t\tTHREE.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\r\n\t\t\treturn this.addVectors( v, w );\r\n\r\n\t\t}\r\n\r\n\t\tthis.x += v.x;\r\n\t\tthis.y += v.y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddScalar: function ( s ) {\r\n\r\n\t\tthis.x += s;\r\n\t\tthis.y += s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddVectors: function ( a, b ) {\r\n\r\n\t\tthis.x = a.x + b.x;\r\n\t\tthis.y = a.y + b.y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsub: function ( v, w ) {\r\n\r\n\t\tif ( w !== undefined ) {\r\n\r\n\t\t\tTHREE.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\r\n\t\t\treturn this.subVectors( v, w );\r\n\r\n\t\t}\r\n\r\n\t\tthis.x -= v.x;\r\n\t\tthis.y -= v.y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsubScalar: function ( s ) {\r\n\r\n\t\tthis.x -= s;\r\n\t\tthis.y -= s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsubVectors: function ( a, b ) {\r\n\r\n\t\tthis.x = a.x - b.x;\r\n\t\tthis.y = a.y - b.y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiply: function ( v ) {\r\n\r\n\t\tthis.x *= v.x;\r\n\t\tthis.y *= v.y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiplyScalar: function ( s ) {\r\n\r\n\t\tthis.x *= s;\r\n\t\tthis.y *= s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdivide: function ( v ) {\r\n\r\n\t\tthis.x /= v.x;\r\n\t\tthis.y /= v.y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdivideScalar: function ( scalar ) {\r\n\r\n\t\tif ( scalar !== 0 ) {\r\n\r\n\t\t\tvar invScalar = 1 / scalar;\r\n\r\n\t\t\tthis.x *= invScalar;\r\n\t\t\tthis.y *= invScalar;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.x = 0;\r\n\t\t\tthis.y = 0;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmin: function ( v ) {\r\n\r\n\t\tif ( this.x > v.x ) {\r\n\r\n\t\t\tthis.x = v.x;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.y > v.y ) {\r\n\r\n\t\t\tthis.y = v.y;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmax: function ( v ) {\r\n\r\n\t\tif ( this.x < v.x ) {\r\n\r\n\t\t\tthis.x = v.x;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.y < v.y ) {\r\n\r\n\t\t\tthis.y = v.y;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclamp: function ( min, max ) {\r\n\r\n\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\r\n\r\n\t\tif ( this.x < min.x ) {\r\n\r\n\t\t\tthis.x = min.x;\r\n\r\n\t\t} else if ( this.x > max.x ) {\r\n\r\n\t\t\tthis.x = max.x;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.y < min.y ) {\r\n\r\n\t\t\tthis.y = min.y;\r\n\r\n\t\t} else if ( this.y > max.y ) {\r\n\r\n\t\t\tthis.y = max.y;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tclampScalar: ( function () {\r\n\r\n\t\tvar min, max;\r\n\r\n\t\treturn function ( minVal, maxVal ) {\r\n\r\n\t\t\tif ( min === undefined ) {\r\n\r\n\t\t\t\tmin = new THREE.Vector2();\r\n\t\t\t\tmax = new THREE.Vector2();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmin.set( minVal, minVal );\r\n\t\t\tmax.set( maxVal, maxVal );\r\n\r\n\t\t\treturn this.clamp( min, max );\r\n\r\n\t\t};\r\n\r\n\t} )(),\r\n\r\n\tfloor: function () {\r\n\r\n\t\tthis.x = Math.floor( this.x );\r\n\t\tthis.y = Math.floor( this.y );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tceil: function () {\r\n\r\n\t\tthis.x = Math.ceil( this.x );\r\n\t\tthis.y = Math.ceil( this.y );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tround: function () {\r\n\r\n\t\tthis.x = Math.round( this.x );\r\n\t\tthis.y = Math.round( this.y );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\troundToZero: function () {\r\n\r\n\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\r\n\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tnegate: function () {\r\n\r\n\t\tthis.x = - this.x;\r\n\t\tthis.y = - this.y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdot: function ( v ) {\r\n\r\n\t\treturn this.x * v.x + this.y * v.y;\r\n\r\n\t},\r\n\r\n\tlengthSq: function () {\r\n\r\n\t\treturn this.x * this.x + this.y * this.y;\r\n\r\n\t},\r\n\r\n\tlength: function () {\r\n\r\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y );\r\n\r\n\t},\r\n\r\n\tnormalize: function () {\r\n\r\n\t\treturn this.divideScalar( this.length() );\r\n\r\n\t},\r\n\r\n\tdistanceTo: function ( v ) {\r\n\r\n\t\treturn Math.sqrt( this.distanceToSquared( v ) );\r\n\r\n\t},\r\n\r\n\tdistanceToSquared: function ( v ) {\r\n\r\n\t\tvar dx = this.x - v.x, dy = this.y - v.y;\r\n\t\treturn dx * dx + dy * dy;\r\n\r\n\t},\r\n\r\n\tsetLength: function ( l ) {\r\n\r\n\t\tvar oldLength = this.length();\r\n\r\n\t\tif ( oldLength !== 0 && l !== oldLength ) {\r\n\r\n\t\t\tthis.multiplyScalar( l / oldLength );\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tlerp: function ( v, alpha ) {\r\n\r\n\t\tthis.x += ( v.x - this.x ) * alpha;\r\n\t\tthis.y += ( v.y - this.y ) * alpha;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tlerpVectors: function ( v1, v2, alpha ) {\r\n\r\n\t\tthis.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tequals: function ( v ) {\r\n\r\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) );\r\n\r\n\t},\r\n\r\n\tfromArray: function ( array, offset ) {\r\n\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tthis.x = array[ offset ];\r\n\t\tthis.y = array[ offset + 1 ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttoArray: function ( array, offset ) {\r\n\r\n\t\tif ( array === undefined ) array = [];\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tarray[ offset ] = this.x;\r\n\t\tarray[ offset + 1 ] = this.y;\r\n\r\n\t\treturn array;\r\n\r\n\t},\r\n\r\n\tfromAttribute: function ( attribute, index, offset ) {\r\n\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tindex = index * attribute.itemSize + offset;\r\n\r\n\t\tthis.x = attribute.array[ index ];\r\n\t\tthis.y = attribute.array[ index + 1 ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new THREE.Vector2( this.x, this.y );\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/math/Vector3.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author *kile / http://kile.stravaganza.org/\r\n * @author philogb / http://blog.thejit.org/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author egraether / http://egraether.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\r\n\r\nTHREE.Vector3 = function ( x, y, z ) {\r\n\r\n\tthis.x = x || 0;\r\n\tthis.y = y || 0;\r\n\tthis.z = z || 0;\r\n\r\n};\r\n\r\nTHREE.Vector3.prototype = {\r\n\r\n\tconstructor: THREE.Vector3,\r\n\r\n\tset: function ( x, y, z ) {\r\n\r\n\t\tthis.x = x;\r\n\t\tthis.y = y;\r\n\t\tthis.z = z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetX: function ( x ) {\r\n\r\n\t\tthis.x = x;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetY: function ( y ) {\r\n\r\n\t\tthis.y = y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetZ: function ( z ) {\r\n\r\n\t\tthis.z = z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetComponent: function ( index, value ) {\r\n\r\n\t\tswitch ( index ) {\r\n\r\n\t\t\tcase 0: this.x = value; break;\r\n\t\t\tcase 1: this.y = value; break;\r\n\t\t\tcase 2: this.z = value; break;\r\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tgetComponent: function ( index ) {\r\n\r\n\t\tswitch ( index ) {\r\n\r\n\t\t\tcase 0: return this.x;\r\n\t\t\tcase 1: return this.y;\r\n\t\t\tcase 2: return this.z;\r\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tcopy: function ( v ) {\r\n\r\n\t\tthis.x = v.x;\r\n\t\tthis.y = v.y;\r\n\t\tthis.z = v.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tadd: function ( v, w ) {\r\n\r\n\t\tif ( w !== undefined ) {\r\n\r\n\t\t\tTHREE.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\r\n\t\t\treturn this.addVectors( v, w );\r\n\r\n\t\t}\r\n\r\n\t\tthis.x += v.x;\r\n\t\tthis.y += v.y;\r\n\t\tthis.z += v.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddScalar: function ( s ) {\r\n\r\n\t\tthis.x += s;\r\n\t\tthis.y += s;\r\n\t\tthis.z += s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddVectors: function ( a, b ) {\r\n\r\n\t\tthis.x = a.x + b.x;\r\n\t\tthis.y = a.y + b.y;\r\n\t\tthis.z = a.z + b.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsub: function ( v, w ) {\r\n\r\n\t\tif ( w !== undefined ) {\r\n\r\n\t\t\tTHREE.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\r\n\t\t\treturn this.subVectors( v, w );\r\n\r\n\t\t}\r\n\r\n\t\tthis.x -= v.x;\r\n\t\tthis.y -= v.y;\r\n\t\tthis.z -= v.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\t\r\n\tsubScalar: function ( s ) {\r\n\r\n\t\tthis.x -= s;\r\n\t\tthis.y -= s;\r\n\t\tthis.z -= s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsubVectors: function ( a, b ) {\r\n\r\n\t\tthis.x = a.x - b.x;\r\n\t\tthis.y = a.y - b.y;\r\n\t\tthis.z = a.z - b.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiply: function ( v, w ) {\r\n\r\n\t\tif ( w !== undefined ) {\r\n\r\n\t\t\tTHREE.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );\r\n\t\t\treturn this.multiplyVectors( v, w );\r\n\r\n\t\t}\r\n\r\n\t\tthis.x *= v.x;\r\n\t\tthis.y *= v.y;\r\n\t\tthis.z *= v.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiplyScalar: function ( scalar ) {\r\n\r\n\t\tthis.x *= scalar;\r\n\t\tthis.y *= scalar;\r\n\t\tthis.z *= scalar;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiplyVectors: function ( a, b ) {\r\n\r\n\t\tthis.x = a.x * b.x;\r\n\t\tthis.y = a.y * b.y;\r\n\t\tthis.z = a.z * b.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tapplyEuler: function () {\r\n\r\n\t\tvar quaternion;\r\n\r\n\t\treturn function ( euler ) {\r\n\r\n\t\t\tif ( euler instanceof THREE.Euler === false ) {\r\n\r\n\t\t\t\tTHREE.error( 'THREE.Vector3: .applyEuler() now expects a Euler rotation rather than a Vector3 and order.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( quaternion === undefined ) quaternion = new THREE.Quaternion();\r\n\r\n\t\t\tthis.applyQuaternion( quaternion.setFromEuler( euler ) );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tapplyAxisAngle: function () {\r\n\r\n\t\tvar quaternion;\r\n\r\n\t\treturn function ( axis, angle ) {\r\n\r\n\t\t\tif ( quaternion === undefined ) quaternion = new THREE.Quaternion();\r\n\r\n\t\t\tthis.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tapplyMatrix3: function ( m ) {\r\n\r\n\t\tvar x = this.x;\r\n\t\tvar y = this.y;\r\n\t\tvar z = this.z;\r\n\r\n\t\tvar e = m.elements;\r\n\r\n\t\tthis.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;\r\n\t\tthis.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;\r\n\t\tthis.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tapplyMatrix4: function ( m ) {\r\n\r\n\t\t// input: THREE.Matrix4 affine matrix\r\n\r\n\t\tvar x = this.x, y = this.y, z = this.z;\r\n\r\n\t\tvar e = m.elements;\r\n\r\n\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ];\r\n\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ];\r\n\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tapplyProjection: function ( m ) {\r\n\r\n\t\t// input: THREE.Matrix4 projection matrix\r\n\r\n\t\tvar x = this.x, y = this.y, z = this.z;\r\n\r\n\t\tvar e = m.elements;\r\n\t\tvar d = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] ); // perspective divide\r\n\r\n\t\tthis.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ] ) * d;\r\n\t\tthis.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ] ) * d;\r\n\t\tthis.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * d;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tapplyQuaternion: function ( q ) {\r\n\r\n\t\tvar x = this.x;\r\n\t\tvar y = this.y;\r\n\t\tvar z = this.z;\r\n\r\n\t\tvar qx = q.x;\r\n\t\tvar qy = q.y;\r\n\t\tvar qz = q.z;\r\n\t\tvar qw = q.w;\r\n\r\n\t\t// calculate quat * vector\r\n\r\n\t\tvar ix =  qw * x + qy * z - qz * y;\r\n\t\tvar iy =  qw * y + qz * x - qx * z;\r\n\t\tvar iz =  qw * z + qx * y - qy * x;\r\n\t\tvar iw = - qx * x - qy * y - qz * z;\r\n\r\n\t\t// calculate result * inverse quat\r\n\r\n\t\tthis.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;\r\n\t\tthis.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;\r\n\t\tthis.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tproject: function () {\r\n\r\n\t\tvar matrix;\r\n\r\n\t\treturn function ( camera ) {\r\n\r\n\t\t\tif ( matrix === undefined ) matrix = new THREE.Matrix4();\r\n\r\n\t\t\tmatrix.multiplyMatrices( camera.projectionMatrix, matrix.getInverse( camera.matrixWorld ) );\r\n\t\t\treturn this.applyProjection( matrix );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tunproject: function () {\r\n\r\n\t\tvar matrix;\r\n\r\n\t\treturn function ( camera ) {\r\n\r\n\t\t\tif ( matrix === undefined ) matrix = new THREE.Matrix4();\r\n\r\n\t\t\tmatrix.multiplyMatrices( camera.matrixWorld, matrix.getInverse( camera.projectionMatrix ) );\r\n\t\t\treturn this.applyProjection( matrix );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\ttransformDirection: function ( m ) {\r\n\r\n\t\t// input: THREE.Matrix4 affine matrix\r\n\t\t// vector interpreted as a direction\r\n\r\n\t\tvar x = this.x, y = this.y, z = this.z;\r\n\r\n\t\tvar e = m.elements;\r\n\r\n\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z;\r\n\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z;\r\n\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;\r\n\r\n\t\tthis.normalize();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdivide: function ( v ) {\r\n\r\n\t\tthis.x /= v.x;\r\n\t\tthis.y /= v.y;\r\n\t\tthis.z /= v.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdivideScalar: function ( scalar ) {\r\n\r\n\t\tif ( scalar !== 0 ) {\r\n\r\n\t\t\tvar invScalar = 1 / scalar;\r\n\r\n\t\t\tthis.x *= invScalar;\r\n\t\t\tthis.y *= invScalar;\r\n\t\t\tthis.z *= invScalar;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.x = 0;\r\n\t\t\tthis.y = 0;\r\n\t\t\tthis.z = 0;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmin: function ( v ) {\r\n\r\n\t\tif ( this.x > v.x ) {\r\n\r\n\t\t\tthis.x = v.x;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.y > v.y ) {\r\n\r\n\t\t\tthis.y = v.y;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.z > v.z ) {\r\n\r\n\t\t\tthis.z = v.z;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmax: function ( v ) {\r\n\r\n\t\tif ( this.x < v.x ) {\r\n\r\n\t\t\tthis.x = v.x;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.y < v.y ) {\r\n\r\n\t\t\tthis.y = v.y;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.z < v.z ) {\r\n\r\n\t\t\tthis.z = v.z;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclamp: function ( min, max ) {\r\n\r\n\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\r\n\r\n\t\tif ( this.x < min.x ) {\r\n\r\n\t\t\tthis.x = min.x;\r\n\r\n\t\t} else if ( this.x > max.x ) {\r\n\r\n\t\t\tthis.x = max.x;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.y < min.y ) {\r\n\r\n\t\t\tthis.y = min.y;\r\n\r\n\t\t} else if ( this.y > max.y ) {\r\n\r\n\t\t\tthis.y = max.y;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.z < min.z ) {\r\n\r\n\t\t\tthis.z = min.z;\r\n\r\n\t\t} else if ( this.z > max.z ) {\r\n\r\n\t\t\tthis.z = max.z;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclampScalar: ( function () {\r\n\r\n\t\tvar min, max;\r\n\r\n\t\treturn function ( minVal, maxVal ) {\r\n\r\n\t\t\tif ( min === undefined ) {\r\n\r\n\t\t\t\tmin = new THREE.Vector3();\r\n\t\t\t\tmax = new THREE.Vector3();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmin.set( minVal, minVal, minVal );\r\n\t\t\tmax.set( maxVal, maxVal, maxVal );\r\n\r\n\t\t\treturn this.clamp( min, max );\r\n\r\n\t\t};\r\n\r\n\t} )(),\r\n\r\n\tfloor: function () {\r\n\r\n\t\tthis.x = Math.floor( this.x );\r\n\t\tthis.y = Math.floor( this.y );\r\n\t\tthis.z = Math.floor( this.z );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tceil: function () {\r\n\r\n\t\tthis.x = Math.ceil( this.x );\r\n\t\tthis.y = Math.ceil( this.y );\r\n\t\tthis.z = Math.ceil( this.z );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tround: function () {\r\n\r\n\t\tthis.x = Math.round( this.x );\r\n\t\tthis.y = Math.round( this.y );\r\n\t\tthis.z = Math.round( this.z );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\troundToZero: function () {\r\n\r\n\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\r\n\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\r\n\t\tthis.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tnegate: function () {\r\n\r\n\t\tthis.x = - this.x;\r\n\t\tthis.y = - this.y;\r\n\t\tthis.z = - this.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdot: function ( v ) {\r\n\r\n\t\treturn this.x * v.x + this.y * v.y + this.z * v.z;\r\n\r\n\t},\r\n\r\n\tlengthSq: function () {\r\n\r\n\t\treturn this.x * this.x + this.y * this.y + this.z * this.z;\r\n\r\n\t},\r\n\r\n\tlength: function () {\r\n\r\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );\r\n\r\n\t},\r\n\r\n\tlengthManhattan: function () {\r\n\r\n\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );\r\n\r\n\t},\r\n\r\n\tnormalize: function () {\r\n\r\n\t\treturn this.divideScalar( this.length() );\r\n\r\n\t},\r\n\r\n\tsetLength: function ( l ) {\r\n\r\n\t\tvar oldLength = this.length();\r\n\r\n\t\tif ( oldLength !== 0 && l !== oldLength  ) {\r\n\r\n\t\t\tthis.multiplyScalar( l / oldLength );\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tlerp: function ( v, alpha ) {\r\n\r\n\t\tthis.x += ( v.x - this.x ) * alpha;\r\n\t\tthis.y += ( v.y - this.y ) * alpha;\r\n\t\tthis.z += ( v.z - this.z ) * alpha;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tlerpVectors: function ( v1, v2, alpha ) {\r\n\r\n\t\tthis.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcross: function ( v, w ) {\r\n\r\n\t\tif ( w !== undefined ) {\r\n\r\n\t\t\tTHREE.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );\r\n\t\t\treturn this.crossVectors( v, w );\r\n\r\n\t\t}\r\n\r\n\t\tvar x = this.x, y = this.y, z = this.z;\r\n\r\n\t\tthis.x = y * v.z - z * v.y;\r\n\t\tthis.y = z * v.x - x * v.z;\r\n\t\tthis.z = x * v.y - y * v.x;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcrossVectors: function ( a, b ) {\r\n\r\n\t\tvar ax = a.x, ay = a.y, az = a.z;\r\n\t\tvar bx = b.x, by = b.y, bz = b.z;\r\n\r\n\t\tthis.x = ay * bz - az * by;\r\n\t\tthis.y = az * bx - ax * bz;\r\n\t\tthis.z = ax * by - ay * bx;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tprojectOnVector: function () {\r\n\r\n\t\tvar v1, dot;\r\n\r\n\t\treturn function ( vector ) {\r\n\r\n\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\r\n\r\n\t\t\tv1.copy( vector ).normalize();\r\n\r\n\t\t\tdot = this.dot( v1 );\r\n\r\n\t\t\treturn this.copy( v1 ).multiplyScalar( dot );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tprojectOnPlane: function () {\r\n\r\n\t\tvar v1;\r\n\r\n\t\treturn function ( planeNormal ) {\r\n\r\n\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\r\n\r\n\t\t\tv1.copy( this ).projectOnVector( planeNormal );\r\n\r\n\t\t\treturn this.sub( v1 );\r\n\r\n\t\t}\r\n\r\n\t}(),\r\n\r\n\treflect: function () {\r\n\r\n\t\t// reflect incident vector off plane orthogonal to normal\r\n\t\t// normal is assumed to have unit length\r\n\r\n\t\tvar v1;\r\n\r\n\t\treturn function ( normal ) {\r\n\r\n\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\r\n\r\n\t\t\treturn this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );\r\n\r\n\t\t}\r\n\r\n\t}(),\r\n\r\n\tangleTo: function ( v ) {\r\n\r\n\t\tvar theta = this.dot( v ) / ( this.length() * v.length() );\r\n\r\n\t\t// clamp, to handle numerical problems\r\n\r\n\t\treturn Math.acos( THREE.Math.clamp( theta, - 1, 1 ) );\r\n\r\n\t},\r\n\r\n\tdistanceTo: function ( v ) {\r\n\r\n\t\treturn Math.sqrt( this.distanceToSquared( v ) );\r\n\r\n\t},\r\n\r\n\tdistanceToSquared: function ( v ) {\r\n\r\n\t\tvar dx = this.x - v.x;\r\n\t\tvar dy = this.y - v.y;\r\n\t\tvar dz = this.z - v.z;\r\n\r\n\t\treturn dx * dx + dy * dy + dz * dz;\r\n\r\n\t},\r\n\r\n\tsetEulerFromRotationMatrix: function ( m, order ) {\r\n\r\n\t\tTHREE.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );\r\n\r\n\t},\r\n\r\n\tsetEulerFromQuaternion: function ( q, order ) {\r\n\r\n\t\tTHREE.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );\r\n\r\n\t},\r\n\r\n\tgetPositionFromMatrix: function ( m ) {\r\n\r\n\t\tTHREE.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );\r\n\r\n\t\treturn this.setFromMatrixPosition( m );\r\n\r\n\t},\r\n\r\n\tgetScaleFromMatrix: function ( m ) {\r\n\r\n\t\tTHREE.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );\r\n\r\n\t\treturn this.setFromMatrixScale( m );\r\n\t},\r\n\r\n\tgetColumnFromMatrix: function ( index, matrix ) {\r\n\r\n\t\tTHREE.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );\r\n\r\n\t\treturn this.setFromMatrixColumn( index, matrix );\r\n\r\n\t},\r\n\r\n\tsetFromMatrixPosition: function ( m ) {\r\n\r\n\t\tthis.x = m.elements[ 12 ];\r\n\t\tthis.y = m.elements[ 13 ];\r\n\t\tthis.z = m.elements[ 14 ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromMatrixScale: function ( m ) {\r\n\r\n\t\tvar sx = this.set( m.elements[ 0 ], m.elements[ 1 ], m.elements[  2 ] ).length();\r\n\t\tvar sy = this.set( m.elements[ 4 ], m.elements[ 5 ], m.elements[  6 ] ).length();\r\n\t\tvar sz = this.set( m.elements[ 8 ], m.elements[ 9 ], m.elements[ 10 ] ).length();\r\n\r\n\t\tthis.x = sx;\r\n\t\tthis.y = sy;\r\n\t\tthis.z = sz;\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsetFromMatrixColumn: function ( index, matrix ) {\r\n\t\t\r\n\t\tvar offset = index * 4;\r\n\r\n\t\tvar me = matrix.elements;\r\n\r\n\t\tthis.x = me[ offset ];\r\n\t\tthis.y = me[ offset + 1 ];\r\n\t\tthis.z = me[ offset + 2 ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tequals: function ( v ) {\r\n\r\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );\r\n\r\n\t},\r\n\r\n\tfromArray: function ( array, offset ) {\r\n\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tthis.x = array[ offset ];\r\n\t\tthis.y = array[ offset + 1 ];\r\n\t\tthis.z = array[ offset + 2 ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttoArray: function ( array, offset ) {\r\n\r\n\t\tif ( array === undefined ) array = [];\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tarray[ offset ] = this.x;\r\n\t\tarray[ offset + 1 ] = this.y;\r\n\t\tarray[ offset + 2 ] = this.z;\r\n\r\n\t\treturn array;\r\n\r\n\t},\r\n\r\n\tfromAttribute: function ( attribute, index, offset ) {\r\n\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tindex = index * attribute.itemSize + offset;\r\n\r\n\t\tthis.x = attribute.array[ index ];\r\n\t\tthis.y = attribute.array[ index + 1 ];\r\n\t\tthis.z = attribute.array[ index + 2 ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new THREE.Vector3( this.x, this.y, this.z );\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/math/Vector4.js\r\n\r\n/**\r\n * @author supereggbert / http://www.paulbrunt.co.uk/\r\n * @author philogb / http://blog.thejit.org/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author egraether / http://egraether.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\r\n\r\nTHREE.Vector4 = function ( x, y, z, w ) {\r\n\r\n\tthis.x = x || 0;\r\n\tthis.y = y || 0;\r\n\tthis.z = z || 0;\r\n\tthis.w = ( w !== undefined ) ? w : 1;\r\n\r\n};\r\n\r\nTHREE.Vector4.prototype = {\r\n\r\n\tconstructor: THREE.Vector4,\r\n\r\n\tset: function ( x, y, z, w ) {\r\n\r\n\t\tthis.x = x;\r\n\t\tthis.y = y;\r\n\t\tthis.z = z;\r\n\t\tthis.w = w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetX: function ( x ) {\r\n\r\n\t\tthis.x = x;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetY: function ( y ) {\r\n\r\n\t\tthis.y = y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetZ: function ( z ) {\r\n\r\n\t\tthis.z = z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetW: function ( w ) {\r\n\r\n\t\tthis.w = w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetComponent: function ( index, value ) {\r\n\r\n\t\tswitch ( index ) {\r\n\r\n\t\t\tcase 0: this.x = value; break;\r\n\t\t\tcase 1: this.y = value; break;\r\n\t\t\tcase 2: this.z = value; break;\r\n\t\t\tcase 3: this.w = value; break;\r\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tgetComponent: function ( index ) {\r\n\r\n\t\tswitch ( index ) {\r\n\r\n\t\t\tcase 0: return this.x;\r\n\t\t\tcase 1: return this.y;\r\n\t\t\tcase 2: return this.z;\r\n\t\t\tcase 3: return this.w;\r\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tcopy: function ( v ) {\r\n\r\n\t\tthis.x = v.x;\r\n\t\tthis.y = v.y;\r\n\t\tthis.z = v.z;\r\n\t\tthis.w = ( v.w !== undefined ) ? v.w : 1;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tadd: function ( v, w ) {\r\n\r\n\t\tif ( w !== undefined ) {\r\n\r\n\t\t\tTHREE.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\r\n\t\t\treturn this.addVectors( v, w );\r\n\r\n\t\t}\r\n\r\n\t\tthis.x += v.x;\r\n\t\tthis.y += v.y;\r\n\t\tthis.z += v.z;\r\n\t\tthis.w += v.w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddScalar: function ( s ) {\r\n\r\n\t\tthis.x += s;\r\n\t\tthis.y += s;\r\n\t\tthis.z += s;\r\n\t\tthis.w += s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddVectors: function ( a, b ) {\r\n\r\n\t\tthis.x = a.x + b.x;\r\n\t\tthis.y = a.y + b.y;\r\n\t\tthis.z = a.z + b.z;\r\n\t\tthis.w = a.w + b.w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsub: function ( v, w ) {\r\n\r\n\t\tif ( w !== undefined ) {\r\n\r\n\t\t\tTHREE.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\r\n\t\t\treturn this.subVectors( v, w );\r\n\r\n\t\t}\r\n\r\n\t\tthis.x -= v.x;\r\n\t\tthis.y -= v.y;\r\n\t\tthis.z -= v.z;\r\n\t\tthis.w -= v.w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsubScalar: function ( s ) {\r\n\r\n\t\tthis.x -= s;\r\n\t\tthis.y -= s;\r\n\t\tthis.z -= s;\r\n\t\tthis.w -= s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsubVectors: function ( a, b ) {\r\n\r\n\t\tthis.x = a.x - b.x;\r\n\t\tthis.y = a.y - b.y;\r\n\t\tthis.z = a.z - b.z;\r\n\t\tthis.w = a.w - b.w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiplyScalar: function ( scalar ) {\r\n\r\n\t\tthis.x *= scalar;\r\n\t\tthis.y *= scalar;\r\n\t\tthis.z *= scalar;\r\n\t\tthis.w *= scalar;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tapplyMatrix4: function ( m ) {\r\n\r\n\t\tvar x = this.x;\r\n\t\tvar y = this.y;\r\n\t\tvar z = this.z;\r\n\t\tvar w = this.w;\r\n\r\n\t\tvar e = m.elements;\r\n\r\n\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;\r\n\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;\r\n\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;\r\n\t\tthis.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdivideScalar: function ( scalar ) {\r\n\r\n\t\tif ( scalar !== 0 ) {\r\n\r\n\t\t\tvar invScalar = 1 / scalar;\r\n\r\n\t\t\tthis.x *= invScalar;\r\n\t\t\tthis.y *= invScalar;\r\n\t\t\tthis.z *= invScalar;\r\n\t\t\tthis.w *= invScalar;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.x = 0;\r\n\t\t\tthis.y = 0;\r\n\t\t\tthis.z = 0;\r\n\t\t\tthis.w = 1;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetAxisAngleFromQuaternion: function ( q ) {\r\n\r\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm\r\n\r\n\t\t// q is assumed to be normalized\r\n\r\n\t\tthis.w = 2 * Math.acos( q.w );\r\n\r\n\t\tvar s = Math.sqrt( 1 - q.w * q.w );\r\n\r\n\t\tif ( s < 0.0001 ) {\r\n\r\n\t\t\t this.x = 1;\r\n\t\t\t this.y = 0;\r\n\t\t\t this.z = 0;\r\n\r\n\t\t} else {\r\n\r\n\t\t\t this.x = q.x / s;\r\n\t\t\t this.y = q.y / s;\r\n\t\t\t this.z = q.z / s;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetAxisAngleFromRotationMatrix: function ( m ) {\r\n\r\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm\r\n\r\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\r\n\r\n\t\tvar angle, x, y, z,\t\t// variables for result\r\n\t\t\tepsilon = 0.01,\t\t// margin to allow for rounding errors\r\n\t\t\tepsilon2 = 0.1,\t\t// margin to distinguish between 0 and 180 degrees\r\n\r\n\t\t\tte = m.elements,\r\n\r\n\t\t\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\r\n\t\t\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\r\n\t\t\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\r\n\r\n\t\tif ( ( Math.abs( m12 - m21 ) < epsilon )\r\n\t\t   && ( Math.abs( m13 - m31 ) < epsilon )\r\n\t\t   && ( Math.abs( m23 - m32 ) < epsilon ) ) {\r\n\r\n\t\t\t// singularity found\r\n\t\t\t// first check for identity matrix which must have +1 for all terms\r\n\t\t\t// in leading diagonal and zero in other terms\r\n\r\n\t\t\tif ( ( Math.abs( m12 + m21 ) < epsilon2 )\r\n\t\t\t   && ( Math.abs( m13 + m31 ) < epsilon2 )\r\n\t\t\t   && ( Math.abs( m23 + m32 ) < epsilon2 )\r\n\t\t\t   && ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {\r\n\r\n\t\t\t\t// this singularity is identity matrix so angle = 0\r\n\r\n\t\t\t\tthis.set( 1, 0, 0, 0 );\r\n\r\n\t\t\t\treturn this; // zero angle, arbitrary axis\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// otherwise this singularity is angle = 180\r\n\r\n\t\t\tangle = Math.PI;\r\n\r\n\t\t\tvar xx = ( m11 + 1 ) / 2;\r\n\t\t\tvar yy = ( m22 + 1 ) / 2;\r\n\t\t\tvar zz = ( m33 + 1 ) / 2;\r\n\t\t\tvar xy = ( m12 + m21 ) / 4;\r\n\t\t\tvar xz = ( m13 + m31 ) / 4;\r\n\t\t\tvar yz = ( m23 + m32 ) / 4;\r\n\r\n\t\t\tif ( ( xx > yy ) && ( xx > zz ) ) { // m11 is the largest diagonal term\r\n\r\n\t\t\t\tif ( xx < epsilon ) {\r\n\r\n\t\t\t\t\tx = 0;\r\n\t\t\t\t\ty = 0.707106781;\r\n\t\t\t\t\tz = 0.707106781;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tx = Math.sqrt( xx );\r\n\t\t\t\t\ty = xy / x;\r\n\t\t\t\t\tz = xz / x;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( yy > zz ) { // m22 is the largest diagonal term\r\n\r\n\t\t\t\tif ( yy < epsilon ) {\r\n\r\n\t\t\t\t\tx = 0.707106781;\r\n\t\t\t\t\ty = 0;\r\n\t\t\t\t\tz = 0.707106781;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\ty = Math.sqrt( yy );\r\n\t\t\t\t\tx = xy / y;\r\n\t\t\t\t\tz = yz / y;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else { // m33 is the largest diagonal term so base result on this\r\n\r\n\t\t\t\tif ( zz < epsilon ) {\r\n\r\n\t\t\t\t\tx = 0.707106781;\r\n\t\t\t\t\ty = 0.707106781;\r\n\t\t\t\t\tz = 0;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tz = Math.sqrt( zz );\r\n\t\t\t\t\tx = xz / z;\r\n\t\t\t\t\ty = yz / z;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.set( x, y, z, angle );\r\n\r\n\t\t\treturn this; // return 180 deg rotation\r\n\r\n\t\t}\r\n\r\n\t\t// as we have reached here there are no singularities so we can handle normally\r\n\r\n\t\tvar s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 )\r\n\t\t\t\t\t\t  + ( m13 - m31 ) * ( m13 - m31 )\r\n\t\t\t\t\t\t  + ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize\r\n\r\n\t\tif ( Math.abs( s ) < 0.001 ) s = 1;\r\n\r\n\t\t// prevent divide by zero, should not happen if matrix is orthogonal and should be\r\n\t\t// caught by singularity test above, but I've left it in just in case\r\n\r\n\t\tthis.x = ( m32 - m23 ) / s;\r\n\t\tthis.y = ( m13 - m31 ) / s;\r\n\t\tthis.z = ( m21 - m12 ) / s;\r\n\t\tthis.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmin: function ( v ) {\r\n\r\n\t\tif ( this.x > v.x ) {\r\n\r\n\t\t\tthis.x = v.x;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.y > v.y ) {\r\n\r\n\t\t\tthis.y = v.y;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.z > v.z ) {\r\n\r\n\t\t\tthis.z = v.z;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.w > v.w ) {\r\n\r\n\t\t\tthis.w = v.w;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmax: function ( v ) {\r\n\r\n\t\tif ( this.x < v.x ) {\r\n\r\n\t\t\tthis.x = v.x;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.y < v.y ) {\r\n\r\n\t\t\tthis.y = v.y;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.z < v.z ) {\r\n\r\n\t\t\tthis.z = v.z;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.w < v.w ) {\r\n\r\n\t\t\tthis.w = v.w;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclamp: function ( min, max ) {\r\n\r\n\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\r\n\r\n\t\tif ( this.x < min.x ) {\r\n\r\n\t\t\tthis.x = min.x;\r\n\r\n\t\t} else if ( this.x > max.x ) {\r\n\r\n\t\t\tthis.x = max.x;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.y < min.y ) {\r\n\r\n\t\t\tthis.y = min.y;\r\n\r\n\t\t} else if ( this.y > max.y ) {\r\n\r\n\t\t\tthis.y = max.y;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.z < min.z ) {\r\n\r\n\t\t\tthis.z = min.z;\r\n\r\n\t\t} else if ( this.z > max.z ) {\r\n\r\n\t\t\tthis.z = max.z;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.w < min.w ) {\r\n\r\n\t\t\tthis.w = min.w;\r\n\r\n\t\t} else if ( this.w > max.w ) {\r\n\r\n\t\t\tthis.w = max.w;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclampScalar: ( function () {\r\n\r\n\t\tvar min, max;\r\n\r\n\t\treturn function ( minVal, maxVal ) {\r\n\r\n\t\t\tif ( min === undefined ) {\r\n\r\n\t\t\t\tmin = new THREE.Vector4();\r\n\t\t\t\tmax = new THREE.Vector4();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmin.set( minVal, minVal, minVal, minVal );\r\n\t\t\tmax.set( maxVal, maxVal, maxVal, maxVal );\r\n\r\n\t\t\treturn this.clamp( min, max );\r\n\r\n\t\t};\r\n\r\n\t} )(),\r\n\r\n  floor: function () {\r\n\r\n\t\tthis.x = Math.floor( this.x );\r\n\t\tthis.y = Math.floor( this.y );\r\n\t\tthis.z = Math.floor( this.z );\r\n\t\tthis.w = Math.floor( this.w );\r\n\r\n\t\treturn this;\r\n\r\n  },\r\n\r\n  ceil: function () {\r\n\r\n\t\tthis.x = Math.ceil( this.x );\r\n\t\tthis.y = Math.ceil( this.y );\r\n\t\tthis.z = Math.ceil( this.z );\r\n\t\tthis.w = Math.ceil( this.w );\r\n\r\n\t\treturn this;\r\n\r\n  },\r\n\r\n  round: function () {\r\n\r\n\t\tthis.x = Math.round( this.x );\r\n\t\tthis.y = Math.round( this.y );\r\n\t\tthis.z = Math.round( this.z );\r\n\t\tthis.w = Math.round( this.w );\r\n\r\n\t\treturn this;\r\n\r\n  },\r\n\r\n  roundToZero: function () {\r\n\r\n\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\r\n\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\r\n\t\tthis.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\r\n\t\tthis.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );\r\n\r\n\t\treturn this;\r\n\r\n  },\r\n\r\n\tnegate: function () {\r\n\r\n\t\tthis.x = - this.x;\r\n\t\tthis.y = - this.y;\r\n\t\tthis.z = - this.z;\r\n\t\tthis.w = - this.w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdot: function ( v ) {\r\n\r\n\t\treturn this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\r\n\r\n\t},\r\n\r\n\tlengthSq: function () {\r\n\r\n\t\treturn this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\r\n\r\n\t},\r\n\r\n\tlength: function () {\r\n\r\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );\r\n\r\n\t},\r\n\r\n\tlengthManhattan: function () {\r\n\r\n\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );\r\n\r\n\t},\r\n\r\n\tnormalize: function () {\r\n\r\n\t\treturn this.divideScalar( this.length() );\r\n\r\n\t},\r\n\r\n\tsetLength: function ( l ) {\r\n\r\n\t\tvar oldLength = this.length();\r\n\r\n\t\tif ( oldLength !== 0 && l !== oldLength ) {\r\n\r\n\t\t\tthis.multiplyScalar( l / oldLength );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tlerp: function ( v, alpha ) {\r\n\r\n\t\tthis.x += ( v.x - this.x ) * alpha;\r\n\t\tthis.y += ( v.y - this.y ) * alpha;\r\n\t\tthis.z += ( v.z - this.z ) * alpha;\r\n\t\tthis.w += ( v.w - this.w ) * alpha;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tlerpVectors: function ( v1, v2, alpha ) {\r\n\r\n\t\tthis.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tequals: function ( v ) {\r\n\r\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );\r\n\r\n\t},\r\n\r\n\tfromArray: function ( array, offset ) {\r\n\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tthis.x = array[ offset ];\r\n\t\tthis.y = array[ offset + 1 ];\r\n\t\tthis.z = array[ offset + 2 ];\r\n\t\tthis.w = array[ offset + 3 ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttoArray: function ( array, offset ) {\r\n\r\n\t\tif ( array === undefined ) array = [];\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tarray[ offset ] = this.x;\r\n\t\tarray[ offset + 1 ] = this.y;\r\n\t\tarray[ offset + 2 ] = this.z;\r\n\t\tarray[ offset + 3 ] = this.w;\r\n\r\n\t\treturn array;\r\n\r\n\t},\r\n\r\n\tfromAttribute: function ( attribute, index, offset ) {\r\n\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tindex = index * attribute.itemSize + offset;\r\n\r\n\t\tthis.x = attribute.array[ index ];\r\n\t\tthis.y = attribute.array[ index + 1 ];\r\n\t\tthis.z = attribute.array[ index + 2 ];\r\n\t\tthis.w = attribute.array[ index + 3 ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new THREE.Vector4( this.x, this.y, this.z, this.w );\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/math/Euler.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n * @author bhouston / http://exocortex.com\r\n */\r\n\r\nTHREE.Euler = function ( x, y, z, order ) {\r\n\r\n\tthis._x = x || 0;\r\n\tthis._y = y || 0;\r\n\tthis._z = z || 0;\r\n\tthis._order = order || THREE.Euler.DefaultOrder;\r\n\r\n};\r\n\r\nTHREE.Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];\r\n\r\nTHREE.Euler.DefaultOrder = 'XYZ';\r\n\r\nTHREE.Euler.prototype = {\r\n\r\n\tconstructor: THREE.Euler,\r\n\r\n\t_x: 0, _y: 0, _z: 0, _order: THREE.Euler.DefaultOrder,\r\n\r\n\tget x () {\r\n\r\n\t\treturn this._x;\r\n\r\n\t},\r\n\r\n\tset x ( value ) {\r\n\r\n\t\tthis._x = value;\r\n\t\tthis.onChangeCallback();\r\n\r\n\t},\r\n\r\n\tget y () {\r\n\r\n\t\treturn this._y;\r\n\r\n\t},\r\n\r\n\tset y ( value ) {\r\n\r\n\t\tthis._y = value;\r\n\t\tthis.onChangeCallback();\r\n\r\n\t},\r\n\r\n\tget z () {\r\n\r\n\t\treturn this._z;\r\n\r\n\t},\r\n\r\n\tset z ( value ) {\r\n\r\n\t\tthis._z = value;\r\n\t\tthis.onChangeCallback();\r\n\r\n\t},\r\n\r\n\tget order () {\r\n\r\n\t\treturn this._order;\r\n\r\n\t},\r\n\r\n\tset order ( value ) {\r\n\r\n\t\tthis._order = value;\r\n\t\tthis.onChangeCallback();\r\n\r\n\t},\r\n\r\n\tset: function ( x, y, z, order ) {\r\n\r\n\t\tthis._x = x;\r\n\t\tthis._y = y;\r\n\t\tthis._z = z;\r\n\t\tthis._order = order || this._order;\r\n\r\n\t\tthis.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopy: function ( euler ) {\r\n\r\n\t\tthis._x = euler._x;\r\n\t\tthis._y = euler._y;\r\n\t\tthis._z = euler._z;\r\n\t\tthis._order = euler._order;\r\n\r\n\t\tthis.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromRotationMatrix: function ( m, order, update ) {\r\n\r\n\t\tvar clamp = THREE.Math.clamp;\r\n\r\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\r\n\r\n\t\tvar te = m.elements;\r\n\t\tvar m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];\r\n\t\tvar m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];\r\n\t\tvar m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\r\n\r\n\t\torder = order || this._order;\r\n\r\n\t\tif ( order === 'XYZ' ) {\r\n\r\n\t\t\tthis._y = Math.asin( clamp( m13, - 1, 1 ) );\r\n\r\n\t\t\tif ( Math.abs( m13 ) < 0.99999 ) {\r\n\r\n\t\t\t\tthis._x = Math.atan2( - m23, m33 );\r\n\t\t\t\tthis._z = Math.atan2( - m12, m11 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis._x = Math.atan2( m32, m22 );\r\n\t\t\t\tthis._z = 0;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( order === 'YXZ' ) {\r\n\r\n\t\t\tthis._x = Math.asin( - clamp( m23, - 1, 1 ) );\r\n\r\n\t\t\tif ( Math.abs( m23 ) < 0.99999 ) {\r\n\r\n\t\t\t\tthis._y = Math.atan2( m13, m33 );\r\n\t\t\t\tthis._z = Math.atan2( m21, m22 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis._y = Math.atan2( - m31, m11 );\r\n\t\t\t\tthis._z = 0;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( order === 'ZXY' ) {\r\n\r\n\t\t\tthis._x = Math.asin( clamp( m32, - 1, 1 ) );\r\n\r\n\t\t\tif ( Math.abs( m32 ) < 0.99999 ) {\r\n\r\n\t\t\t\tthis._y = Math.atan2( - m31, m33 );\r\n\t\t\t\tthis._z = Math.atan2( - m12, m22 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis._y = 0;\r\n\t\t\t\tthis._z = Math.atan2( m21, m11 );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( order === 'ZYX' ) {\r\n\r\n\t\t\tthis._y = Math.asin( - clamp( m31, - 1, 1 ) );\r\n\r\n\t\t\tif ( Math.abs( m31 ) < 0.99999 ) {\r\n\r\n\t\t\t\tthis._x = Math.atan2( m32, m33 );\r\n\t\t\t\tthis._z = Math.atan2( m21, m11 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis._x = 0;\r\n\t\t\t\tthis._z = Math.atan2( - m12, m22 );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( order === 'YZX' ) {\r\n\r\n\t\t\tthis._z = Math.asin( clamp( m21, - 1, 1 ) );\r\n\r\n\t\t\tif ( Math.abs( m21 ) < 0.99999 ) {\r\n\r\n\t\t\t\tthis._x = Math.atan2( - m23, m22 );\r\n\t\t\t\tthis._y = Math.atan2( - m31, m11 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis._x = 0;\r\n\t\t\t\tthis._y = Math.atan2( m13, m33 );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( order === 'XZY' ) {\r\n\r\n\t\t\tthis._z = Math.asin( - clamp( m12, - 1, 1 ) );\r\n\r\n\t\t\tif ( Math.abs( m12 ) < 0.99999 ) {\r\n\r\n\t\t\t\tthis._x = Math.atan2( m32, m22 );\r\n\t\t\t\tthis._y = Math.atan2( m13, m11 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis._x = Math.atan2( - m23, m33 );\r\n\t\t\t\tthis._y = 0;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tTHREE.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order )\r\n\r\n\t\t}\r\n\r\n\t\tthis._order = order;\r\n\r\n\t\tif ( update !== false ) this.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromQuaternion: function () {\r\n\r\n\t\tvar matrix;\r\n\r\n\t\treturn function ( q, order, update ) {\r\n\r\n\t\t\tif ( matrix === undefined ) matrix = new THREE.Matrix4();\r\n\t\t\tmatrix.makeRotationFromQuaternion( q );\r\n\t\t\tthis.setFromRotationMatrix( matrix, order, update );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tsetFromVector3: function ( v, order ) {\r\n\r\n\t\treturn this.set( v.x, v.y, v.z, order || this._order );\r\n\r\n\t},\r\n\r\n\treorder: function () {\r\n\r\n\t\t// WARNING: this discards revolution information -bhouston\r\n\r\n\t\tvar q = new THREE.Quaternion();\r\n\r\n\t\treturn function ( newOrder ) {\r\n\r\n\t\t\tq.setFromEuler( this );\r\n\t\t\tthis.setFromQuaternion( q, newOrder );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tequals: function ( euler ) {\r\n\r\n\t\treturn ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );\r\n\r\n\t},\r\n\r\n\tfromArray: function ( array ) {\r\n\r\n\t\tthis._x = array[ 0 ];\r\n\t\tthis._y = array[ 1 ];\r\n\t\tthis._z = array[ 2 ];\r\n\t\tif ( array[ 3 ] !== undefined ) this._order = array[ 3 ];\r\n\r\n\t\tthis.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttoArray: function ( array, offset ) {\r\n\r\n\t\tif ( array === undefined ) array = [];\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tarray[ offset ] = this._x;\r\n\t\tarray[ offset + 1 ] = this._y;\r\n\t\tarray[ offset + 2 ] = this._z;\r\n\t\tarray[ offset + 3 ] = this._order;\r\n\r\n\t\treturn array;\r\n\t},\r\n\r\n\ttoVector3: function ( optionalResult ) {\r\n\r\n\t\tif ( optionalResult ) {\r\n\r\n\t\t\treturn optionalResult.set( this._x, this._y, this._z );\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn new THREE.Vector3( this._x, this._y, this._z );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tonChange: function ( callback ) {\r\n\r\n\t\tthis.onChangeCallback = callback;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tonChangeCallback: function () {},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new THREE.Euler( this._x, this._y, this._z, this._order );\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/math/Line3.js\r\n\r\n/**\r\n * @author bhouston / http://exocortex.com\r\n */\r\n\r\nTHREE.Line3 = function ( start, end ) {\r\n\r\n\tthis.start = ( start !== undefined ) ? start : new THREE.Vector3();\r\n\tthis.end = ( end !== undefined ) ? end : new THREE.Vector3();\r\n\r\n};\r\n\r\nTHREE.Line3.prototype = {\r\n\r\n\tconstructor: THREE.Line3,\r\n\r\n\tset: function ( start, end ) {\r\n\r\n\t\tthis.start.copy( start );\r\n\t\tthis.end.copy( end );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopy: function ( line ) {\r\n\r\n\t\tthis.start.copy( line.start );\r\n\t\tthis.end.copy( line.end );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcenter: function ( optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\treturn result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );\r\n\r\n\t},\r\n\r\n\tdelta: function ( optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\treturn result.subVectors( this.end, this.start );\r\n\r\n\t},\r\n\r\n\tdistanceSq: function () {\r\n\r\n\t\treturn this.start.distanceToSquared( this.end );\r\n\r\n\t},\r\n\r\n\tdistance: function () {\r\n\r\n\t\treturn this.start.distanceTo( this.end );\r\n\r\n\t},\r\n\r\n\tat: function ( t, optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\r\n\t\treturn this.delta( result ).multiplyScalar( t ).add( this.start );\r\n\r\n\t},\r\n\r\n\tclosestPointToPointParameter: function () {\r\n\r\n\t\tvar startP = new THREE.Vector3();\r\n\t\tvar startEnd = new THREE.Vector3();\r\n\r\n\t\treturn function ( point, clampToLine ) {\r\n\r\n\t\t\tstartP.subVectors( point, this.start );\r\n\t\t\tstartEnd.subVectors( this.end, this.start );\r\n\r\n\t\t\tvar startEnd2 = startEnd.dot( startEnd );\r\n\t\t\tvar startEnd_startP = startEnd.dot( startP );\r\n\r\n\t\t\tvar t = startEnd_startP / startEnd2;\r\n\r\n\t\t\tif ( clampToLine ) {\r\n\r\n\t\t\t\tt = THREE.Math.clamp( t, 0, 1 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn t;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tclosestPointToPoint: function ( point, clampToLine, optionalTarget ) {\r\n\r\n\t\tvar t = this.closestPointToPointParameter( point, clampToLine );\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\r\n\t\treturn this.delta( result ).multiplyScalar( t ).add( this.start );\r\n\r\n\t},\r\n\r\n\tapplyMatrix4: function ( matrix ) {\r\n\r\n\t\tthis.start.applyMatrix4( matrix );\r\n\t\tthis.end.applyMatrix4( matrix );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tequals: function ( line ) {\r\n\r\n\t\treturn line.start.equals( this.start ) && line.end.equals( this.end );\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new THREE.Line3().copy( this );\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/math/Box2.js\r\n\r\n/**\r\n * @author bhouston / http://exocortex.com\r\n */\r\n\r\nTHREE.Box2 = function ( min, max ) {\r\n\r\n\tthis.min = ( min !== undefined ) ? min : new THREE.Vector2( Infinity, Infinity );\r\n\tthis.max = ( max !== undefined ) ? max : new THREE.Vector2( - Infinity, - Infinity );\r\n\r\n};\r\n\r\nTHREE.Box2.prototype = {\r\n\r\n\tconstructor: THREE.Box2,\r\n\r\n\tset: function ( min, max ) {\r\n\r\n\t\tthis.min.copy( min );\r\n\t\tthis.max.copy( max );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromPoints: function ( points ) {\r\n\r\n\t\tthis.makeEmpty();\r\n\r\n\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\r\n\r\n\t\t\tthis.expandByPoint( points[ i ] )\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromCenterAndSize: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector2();\r\n\r\n\t\treturn function ( center, size ) {\r\n\r\n\t\t\tvar halfSize = v1.copy( size ).multiplyScalar( 0.5 );\r\n\t\t\tthis.min.copy( center ).sub( halfSize );\r\n\t\t\tthis.max.copy( center ).add( halfSize );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tcopy: function ( box ) {\r\n\r\n\t\tthis.min.copy( box.min );\r\n\t\tthis.max.copy( box.max );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmakeEmpty: function () {\r\n\r\n\t\tthis.min.x = this.min.y = Infinity;\r\n\t\tthis.max.x = this.max.y = - Infinity;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tempty: function () {\r\n\r\n\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\r\n\r\n\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );\r\n\r\n\t},\r\n\r\n\tcenter: function ( optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector2();\r\n\t\treturn result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\r\n\r\n\t},\r\n\r\n\tsize: function ( optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector2();\r\n\t\treturn result.subVectors( this.max, this.min );\r\n\r\n\t},\r\n\r\n\texpandByPoint: function ( point ) {\r\n\r\n\t\tthis.min.min( point );\r\n\t\tthis.max.max( point );\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\texpandByVector: function ( vector ) {\r\n\r\n\t\tthis.min.sub( vector );\r\n\t\tthis.max.add( vector );\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\texpandByScalar: function ( scalar ) {\r\n\r\n\t\tthis.min.addScalar( - scalar );\r\n\t\tthis.max.addScalar( scalar );\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tcontainsPoint: function ( point ) {\r\n\r\n\t\tif ( point.x < this.min.x || point.x > this.max.x ||\r\n\t\t     point.y < this.min.y || point.y > this.max.y ) {\r\n\r\n\t\t\treturn false;\r\n\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\t},\r\n\r\n\tcontainsBox: function ( box ) {\r\n\r\n\t\tif ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&\r\n\t\t     ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) ) {\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\r\n\t},\r\n\r\n\tgetParameter: function ( point, optionalTarget ) {\r\n\r\n\t\t// This can potentially have a divide by zero if the box\r\n\t\t// has a size dimension of 0.\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector2();\r\n\r\n\t\treturn result.set(\r\n\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\r\n\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y )\r\n\t\t);\r\n\r\n\t},\r\n\r\n\tisIntersectionBox: function ( box ) {\r\n\r\n\t\t// using 6 splitting planes to rule out intersections.\r\n\r\n\t\tif ( box.max.x < this.min.x || box.min.x > this.max.x ||\r\n\t\t     box.max.y < this.min.y || box.min.y > this.max.y ) {\r\n\r\n\t\t\treturn false;\r\n\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\t},\r\n\r\n\tclampPoint: function ( point, optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector2();\r\n\t\treturn result.copy( point ).clamp( this.min, this.max );\r\n\r\n\t},\r\n\r\n\tdistanceToPoint: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector2();\r\n\r\n\t\treturn function ( point ) {\r\n\r\n\t\t\tvar clampedPoint = v1.copy( point ).clamp( this.min, this.max );\r\n\t\t\treturn clampedPoint.sub( point ).length();\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tintersect: function ( box ) {\r\n\r\n\t\tthis.min.max( box.min );\r\n\t\tthis.max.min( box.max );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tunion: function ( box ) {\r\n\r\n\t\tthis.min.min( box.min );\r\n\t\tthis.max.max( box.max );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttranslate: function ( offset ) {\r\n\r\n\t\tthis.min.add( offset );\r\n\t\tthis.max.add( offset );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tequals: function ( box ) {\r\n\r\n\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new THREE.Box2().copy( this );\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/math/Box3.js\r\n\r\n/**\r\n * @author bhouston / http://exocortex.com\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\r\n\r\nTHREE.Box3 = function ( min, max ) {\r\n\r\n\tthis.min = ( min !== undefined ) ? min : new THREE.Vector3( Infinity, Infinity, Infinity );\r\n\tthis.max = ( max !== undefined ) ? max : new THREE.Vector3( - Infinity, - Infinity, - Infinity );\r\n\r\n};\r\n\r\nTHREE.Box3.prototype = {\r\n\r\n\tconstructor: THREE.Box3,\r\n\r\n\tset: function ( min, max ) {\r\n\r\n\t\tthis.min.copy( min );\r\n\t\tthis.max.copy( max );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromPoints: function ( points ) {\r\n\r\n\t\tthis.makeEmpty();\r\n\r\n\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\r\n\r\n\t\t\tthis.expandByPoint( points[ i ] )\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromCenterAndSize: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function ( center, size ) {\r\n\r\n\t\t\tvar halfSize = v1.copy( size ).multiplyScalar( 0.5 );\r\n\r\n\t\t\tthis.min.copy( center ).sub( halfSize );\r\n\t\t\tthis.max.copy( center ).add( halfSize );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tsetFromObject: function () {\r\n\r\n\t\t// Computes the world-axis-aligned bounding box of an object (including its children),\r\n\t\t// accounting for both the object's, and childrens', world transforms\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function ( object ) {\r\n\r\n\t\t\tvar scope = this;\r\n\r\n\t\t\tobject.updateMatrixWorld( true );\r\n\r\n\t\t\tthis.makeEmpty();\r\n\r\n\t\t\tobject.traverse( function ( node ) {\r\n\r\n\t\t\t\tvar geometry = node.geometry;\r\n\r\n\t\t\t\tif ( geometry !== undefined ) {\r\n\r\n\t\t\t\t\tif ( geometry instanceof THREE.Geometry ) {\r\n\r\n\t\t\t\t\t\tvar vertices = geometry.vertices;\r\n\r\n\t\t\t\t\t\tfor ( var i = 0, il = vertices.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\t\t\tv1.copy( vertices[ i ] );\r\n\r\n\t\t\t\t\t\t\tv1.applyMatrix4( node.matrixWorld );\r\n\r\n\t\t\t\t\t\t\tscope.expandByPoint( v1 );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( geometry instanceof THREE.BufferGeometry && geometry.attributes[ 'position' ] !== undefined ) {\r\n\r\n\t\t\t\t\t\tvar positions = geometry.attributes[ 'position' ].array;\r\n\r\n\t\t\t\t\t\tfor ( var i = 0, il = positions.length; i < il; i += 3 ) {\r\n\r\n\t\t\t\t\t\t\tv1.set( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );\r\n\r\n\t\t\t\t\t\t\tv1.applyMatrix4( node.matrixWorld );\r\n\r\n\t\t\t\t\t\t\tscope.expandByPoint( v1 );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tcopy: function ( box ) {\r\n\r\n\t\tthis.min.copy( box.min );\r\n\t\tthis.max.copy( box.max );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmakeEmpty: function () {\r\n\r\n\t\tthis.min.x = this.min.y = this.min.z = Infinity;\r\n\t\tthis.max.x = this.max.y = this.max.z = - Infinity;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tempty: function () {\r\n\r\n\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\r\n\r\n\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );\r\n\r\n\t},\r\n\r\n\tcenter: function ( optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\treturn result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\r\n\r\n\t},\r\n\r\n\tsize: function ( optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\treturn result.subVectors( this.max, this.min );\r\n\r\n\t},\r\n\r\n\texpandByPoint: function ( point ) {\r\n\r\n\t\tthis.min.min( point );\r\n\t\tthis.max.max( point );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\texpandByVector: function ( vector ) {\r\n\r\n\t\tthis.min.sub( vector );\r\n\t\tthis.max.add( vector );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\texpandByScalar: function ( scalar ) {\r\n\r\n\t\tthis.min.addScalar( - scalar );\r\n\t\tthis.max.addScalar( scalar );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcontainsPoint: function ( point ) {\r\n\r\n\t\tif ( point.x < this.min.x || point.x > this.max.x ||\r\n\t\t     point.y < this.min.y || point.y > this.max.y ||\r\n\t\t     point.z < this.min.z || point.z > this.max.z ) {\r\n\r\n\t\t\treturn false;\r\n\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\t},\r\n\r\n\tcontainsBox: function ( box ) {\r\n\r\n\t\tif ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&\r\n\t\t\t ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) &&\r\n\t\t\t ( this.min.z <= box.min.z ) && ( box.max.z <= this.max.z ) ) {\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\r\n\t},\r\n\r\n\tgetParameter: function ( point, optionalTarget ) {\r\n\r\n\t\t// This can potentially have a divide by zero if the box\r\n\t\t// has a size dimension of 0.\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\r\n\t\treturn result.set(\r\n\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\r\n\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y ),\r\n\t\t\t( point.z - this.min.z ) / ( this.max.z - this.min.z )\r\n\t\t);\r\n\r\n\t},\r\n\r\n\tisIntersectionBox: function ( box ) {\r\n\r\n\t\t// using 6 splitting planes to rule out intersections.\r\n\r\n\t\tif ( box.max.x < this.min.x || box.min.x > this.max.x ||\r\n\t\t     box.max.y < this.min.y || box.min.y > this.max.y ||\r\n\t\t     box.max.z < this.min.z || box.min.z > this.max.z ) {\r\n\r\n\t\t\treturn false;\r\n\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\t},\r\n\r\n\tclampPoint: function ( point, optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\treturn result.copy( point ).clamp( this.min, this.max );\r\n\r\n\t},\r\n\r\n\tdistanceToPoint: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function ( point ) {\r\n\r\n\t\t\tvar clampedPoint = v1.copy( point ).clamp( this.min, this.max );\r\n\t\t\treturn clampedPoint.sub( point ).length();\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tgetBoundingSphere: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function ( optionalTarget ) {\r\n\r\n\t\t\tvar result = optionalTarget || new THREE.Sphere();\r\n\r\n\t\t\tresult.center = this.center();\r\n\t\t\tresult.radius = this.size( v1 ).length() * 0.5;\r\n\r\n\t\t\treturn result;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tintersect: function ( box ) {\r\n\r\n\t\tthis.min.max( box.min );\r\n\t\tthis.max.min( box.max );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tunion: function ( box ) {\r\n\r\n\t\tthis.min.min( box.min );\r\n\t\tthis.max.max( box.max );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tapplyMatrix4: function () {\r\n\r\n\t\tvar points = [\r\n\t\t\tnew THREE.Vector3(),\r\n\t\t\tnew THREE.Vector3(),\r\n\t\t\tnew THREE.Vector3(),\r\n\t\t\tnew THREE.Vector3(),\r\n\t\t\tnew THREE.Vector3(),\r\n\t\t\tnew THREE.Vector3(),\r\n\t\t\tnew THREE.Vector3(),\r\n\t\t\tnew THREE.Vector3()\r\n\t\t];\r\n\r\n\t\treturn function ( matrix ) {\r\n\r\n\t\t\t// NOTE: I am using a binary pattern to specify all 2^3 combinations below\r\n\t\t\tpoints[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000\r\n\t\t\tpoints[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001\r\n\t\t\tpoints[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010\r\n\t\t\tpoints[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011\r\n\t\t\tpoints[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100\r\n\t\t\tpoints[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101\r\n\t\t\tpoints[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110\r\n\t\t\tpoints[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix );  // 111\r\n\r\n\t\t\tthis.makeEmpty();\r\n\t\t\tthis.setFromPoints( points );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\ttranslate: function ( offset ) {\r\n\r\n\t\tthis.min.add( offset );\r\n\t\tthis.max.add( offset );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tequals: function ( box ) {\r\n\r\n\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new THREE.Box3().copy( this );\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/math/Matrix3.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n * @author bhouston / http://exocortex.com\r\n */\r\n\r\nTHREE.Matrix3 = function () {\r\n\r\n\tthis.elements = new Float32Array( [\r\n\r\n\t\t1, 0, 0,\r\n\t\t0, 1, 0,\r\n\t\t0, 0, 1\r\n\r\n\t] );\r\n\r\n\tif ( arguments.length > 0 ) {\r\n\r\n\t\tTHREE.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.Matrix3.prototype = {\r\n\r\n\tconstructor: THREE.Matrix3,\r\n\r\n\tset: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tte[ 0 ] = n11; te[ 3 ] = n12; te[ 6 ] = n13;\r\n\t\tte[ 1 ] = n21; te[ 4 ] = n22; te[ 7 ] = n23;\r\n\t\tte[ 2 ] = n31; te[ 5 ] = n32; te[ 8 ] = n33;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tidentity: function () {\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\t1, 0, 0,\r\n\t\t\t0, 1, 0,\r\n\t\t\t0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopy: function ( m ) {\r\n\r\n\t\tvar me = m.elements;\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\tme[ 0 ], me[ 3 ], me[ 6 ],\r\n\t\t\tme[ 1 ], me[ 4 ], me[ 7 ],\r\n\t\t\tme[ 2 ], me[ 5 ], me[ 8 ]\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiplyVector3: function ( vector ) {\r\n\r\n\t\tTHREE.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );\r\n\t\treturn vector.applyMatrix3( this );\r\n\r\n\t},\r\n\r\n\tmultiplyVector3Array: function ( a ) {\r\n\r\n\t\tTHREE.warn( 'THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );\r\n\t\treturn this.applyToVector3Array( a );\r\n\r\n\t},\r\n\r\n\tapplyToVector3Array: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function ( array, offset, length ) {\r\n\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\t\tif ( length === undefined ) length = array.length;\r\n\r\n\t\t\tfor ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {\r\n\r\n\t\t\t\tv1.x = array[ j ];\r\n\t\t\t\tv1.y = array[ j + 1 ];\r\n\t\t\t\tv1.z = array[ j + 2 ];\r\n\r\n\t\t\t\tv1.applyMatrix3( this );\r\n\r\n\t\t\t\tarray[ j ]     = v1.x;\r\n\t\t\t\tarray[ j + 1 ] = v1.y;\r\n\t\t\t\tarray[ j + 2 ] = v1.z;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn array;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tmultiplyScalar: function ( s ) {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tte[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;\r\n\t\tte[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;\r\n\t\tte[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdeterminant: function () {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tvar a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],\r\n\t\t\td = te[ 3 ], e = te[ 4 ], f = te[ 5 ],\r\n\t\t\tg = te[ 6 ], h = te[ 7 ], i = te[ 8 ];\r\n\r\n\t\treturn a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;\r\n\r\n\t},\r\n\r\n\tgetInverse: function ( matrix, throwOnInvertible ) {\r\n\r\n\t\t// input: THREE.Matrix4\r\n\t\t// ( based on http://code.google.com/p/webgl-mjs/ )\r\n\r\n\t\tvar me = matrix.elements;\r\n\t\tvar te = this.elements;\r\n\r\n\t\tte[ 0 ] =   me[ 10 ] * me[ 5 ] - me[ 6 ] * me[ 9 ];\r\n\t\tte[ 1 ] = - me[ 10 ] * me[ 1 ] + me[ 2 ] * me[ 9 ];\r\n\t\tte[ 2 ] =   me[ 6 ] * me[ 1 ] - me[ 2 ] * me[ 5 ];\r\n\t\tte[ 3 ] = - me[ 10 ] * me[ 4 ] + me[ 6 ] * me[ 8 ];\r\n\t\tte[ 4 ] =   me[ 10 ] * me[ 0 ] - me[ 2 ] * me[ 8 ];\r\n\t\tte[ 5 ] = - me[ 6 ] * me[ 0 ] + me[ 2 ] * me[ 4 ];\r\n\t\tte[ 6 ] =   me[ 9 ] * me[ 4 ] - me[ 5 ] * me[ 8 ];\r\n\t\tte[ 7 ] = - me[ 9 ] * me[ 0 ] + me[ 1 ] * me[ 8 ];\r\n\t\tte[ 8 ] =   me[ 5 ] * me[ 0 ] - me[ 1 ] * me[ 4 ];\r\n\r\n\t\tvar det = me[ 0 ] * te[ 0 ] + me[ 1 ] * te[ 3 ] + me[ 2 ] * te[ 6 ];\r\n\r\n\t\t// no inverse\r\n\r\n\t\tif ( det === 0 ) {\r\n\r\n\t\t\tvar msg = \"Matrix3.getInverse(): can't invert matrix, determinant is 0\";\r\n\r\n\t\t\tif ( throwOnInvertible || false ) {\r\n\r\n\t\t\t\tthrow new Error( msg );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tTHREE.warn( msg );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.identity();\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\tthis.multiplyScalar( 1.0 / det );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttranspose: function () {\r\n\r\n\t\tvar tmp, m = this.elements;\r\n\r\n\t\ttmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;\r\n\t\ttmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;\r\n\t\ttmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tflattenToArrayOffset: function ( array, offset ) {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tarray[ offset     ] = te[ 0 ];\r\n\t\tarray[ offset + 1 ] = te[ 1 ];\r\n\t\tarray[ offset + 2 ] = te[ 2 ];\r\n\r\n\t\tarray[ offset + 3 ] = te[ 3 ];\r\n\t\tarray[ offset + 4 ] = te[ 4 ];\r\n\t\tarray[ offset + 5 ] = te[ 5 ];\r\n\r\n\t\tarray[ offset + 6 ] = te[ 6 ];\r\n\t\tarray[ offset + 7 ] = te[ 7 ];\r\n\t\tarray[ offset + 8 ]  = te[ 8 ];\r\n\r\n\t\treturn array;\r\n\r\n\t},\r\n\r\n\tgetNormalMatrix: function ( m ) {\r\n\r\n\t\t// input: THREE.Matrix4\r\n\r\n\t\tthis.getInverse( m ).transpose();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttransposeIntoArray: function ( r ) {\r\n\r\n\t\tvar m = this.elements;\r\n\r\n\t\tr[ 0 ] = m[ 0 ];\r\n\t\tr[ 1 ] = m[ 3 ];\r\n\t\tr[ 2 ] = m[ 6 ];\r\n\t\tr[ 3 ] = m[ 1 ];\r\n\t\tr[ 4 ] = m[ 4 ];\r\n\t\tr[ 5 ] = m[ 7 ];\r\n\t\tr[ 6 ] = m[ 2 ];\r\n\t\tr[ 7 ] = m[ 5 ];\r\n\t\tr[ 8 ] = m[ 8 ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tfromArray: function ( array ) {\r\n\r\n\t\tthis.elements.set( array );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttoArray: function () {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\treturn [\r\n\t\t\tte[ 0 ], te[ 1 ], te[ 2 ],\r\n\t\t\tte[ 3 ], te[ 4 ], te[ 5 ],\r\n\t\t\tte[ 6 ], te[ 7 ], te[ 8 ]\r\n\t\t];\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new THREE.Matrix3().fromArray( this.elements );\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/math/Matrix4.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author supereggbert / http://www.paulbrunt.co.uk/\r\n * @author philogb / http://blog.thejit.org/\r\n * @author jordi_ros / http://plattsoft.com\r\n * @author D1plo1d / http://github.com/D1plo1d\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author timknip / http://www.floorplanner.com/\r\n * @author bhouston / http://exocortex.com\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\r\n\r\nTHREE.Matrix4 = function () {\r\n\r\n\tthis.elements = new Float32Array( [\r\n\r\n\t\t1, 0, 0, 0,\r\n\t\t0, 1, 0, 0,\r\n\t\t0, 0, 1, 0,\r\n\t\t0, 0, 0, 1\r\n\r\n\t] );\r\n\r\n\tif ( arguments.length > 0 ) {\r\n\r\n\t\tTHREE.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.Matrix4.prototype = {\r\n\r\n\tconstructor: THREE.Matrix4,\r\n\r\n\tset: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tte[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;\r\n\t\tte[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;\r\n\t\tte[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;\r\n\t\tte[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tidentity: function () {\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\t1, 0, 0, 0,\r\n\t\t\t0, 1, 0, 0,\r\n\t\t\t0, 0, 1, 0,\r\n\t\t\t0, 0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopy: function ( m ) {\r\n\r\n\t\tthis.elements.set( m.elements );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\textractPosition: function ( m ) {\r\n\r\n\t\tTHREE.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );\r\n\t\treturn this.copyPosition( m );\r\n\r\n\t},\r\n\r\n\tcopyPosition: function ( m ) {\r\n\r\n\t\tvar te = this.elements;\r\n\t\tvar me = m.elements;\r\n\r\n\t\tte[ 12 ] = me[ 12 ];\r\n\t\tte[ 13 ] = me[ 13 ];\r\n\t\tte[ 14 ] = me[ 14 ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\textractBasis: function ( xAxis, yAxis, zAxis ) {\r\n \r\n\t\tvar te = this.elements;\r\n \r\n\t\txAxis.set( te[ 0 ], te[ 1 ], te[ 2 ] );\r\n\t\tyAxis.set( te[ 4 ], te[ 5 ], te[ 6 ] );\r\n\t\tzAxis.set( te[ 8 ], te[ 9 ], te[ 10 ] );\r\n \r\n\t\treturn this;\r\n \t\t\r\n\t},\r\n \r\n\tmakeBasis: function ( xAxis, yAxis, zAxis ) {\r\n\r\n\t\tthis.set(\r\n\t\t\txAxis.x, yAxis.x, zAxis.x, 0,\r\n\t\t\txAxis.y, yAxis.y, zAxis.y, 0,\r\n\t\t\txAxis.z, yAxis.z, zAxis.z, 0,\r\n\t\t\t0,       0,       0,       1\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\textractRotation: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function ( m ) {\r\n\r\n\t\t\tvar te = this.elements;\r\n\t\t\tvar me = m.elements;\r\n\r\n\t\t\tvar scaleX = 1 / v1.set( me[ 0 ], me[ 1 ], me[ 2 ] ).length();\r\n\t\t\tvar scaleY = 1 / v1.set( me[ 4 ], me[ 5 ], me[ 6 ] ).length();\r\n\t\t\tvar scaleZ = 1 / v1.set( me[ 8 ], me[ 9 ], me[ 10 ] ).length();\r\n\r\n\t\t\tte[ 0 ] = me[ 0 ] * scaleX;\r\n\t\t\tte[ 1 ] = me[ 1 ] * scaleX;\r\n\t\t\tte[ 2 ] = me[ 2 ] * scaleX;\r\n\r\n\t\t\tte[ 4 ] = me[ 4 ] * scaleY;\r\n\t\t\tte[ 5 ] = me[ 5 ] * scaleY;\r\n\t\t\tte[ 6 ] = me[ 6 ] * scaleY;\r\n\r\n\t\t\tte[ 8 ] = me[ 8 ] * scaleZ;\r\n\t\t\tte[ 9 ] = me[ 9 ] * scaleZ;\r\n\t\t\tte[ 10 ] = me[ 10 ] * scaleZ;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tmakeRotationFromEuler: function ( euler ) {\r\n\r\n\t\tif ( euler instanceof THREE.Euler === false ) {\r\n\r\n\t\t\tTHREE.error( 'THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );\r\n\r\n\t\t}\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tvar x = euler.x, y = euler.y, z = euler.z;\r\n\t\tvar a = Math.cos( x ), b = Math.sin( x );\r\n\t\tvar c = Math.cos( y ), d = Math.sin( y );\r\n\t\tvar e = Math.cos( z ), f = Math.sin( z );\r\n\r\n\t\tif ( euler.order === 'XYZ' ) {\r\n\r\n\t\t\tvar ae = a * e, af = a * f, be = b * e, bf = b * f;\r\n\r\n\t\t\tte[ 0 ] = c * e;\r\n\t\t\tte[ 4 ] = - c * f;\r\n\t\t\tte[ 8 ] = d;\r\n\r\n\t\t\tte[ 1 ] = af + be * d;\r\n\t\t\tte[ 5 ] = ae - bf * d;\r\n\t\t\tte[ 9 ] = - b * c;\r\n\r\n\t\t\tte[ 2 ] = bf - ae * d;\r\n\t\t\tte[ 6 ] = be + af * d;\r\n\t\t\tte[ 10 ] = a * c;\r\n\r\n\t\t} else if ( euler.order === 'YXZ' ) {\r\n\r\n\t\t\tvar ce = c * e, cf = c * f, de = d * e, df = d * f;\r\n\r\n\t\t\tte[ 0 ] = ce + df * b;\r\n\t\t\tte[ 4 ] = de * b - cf;\r\n\t\t\tte[ 8 ] = a * d;\r\n\r\n\t\t\tte[ 1 ] = a * f;\r\n\t\t\tte[ 5 ] = a * e;\r\n\t\t\tte[ 9 ] = - b;\r\n\r\n\t\t\tte[ 2 ] = cf * b - de;\r\n\t\t\tte[ 6 ] = df + ce * b;\r\n\t\t\tte[ 10 ] = a * c;\r\n\r\n\t\t} else if ( euler.order === 'ZXY' ) {\r\n\r\n\t\t\tvar ce = c * e, cf = c * f, de = d * e, df = d * f;\r\n\r\n\t\t\tte[ 0 ] = ce - df * b;\r\n\t\t\tte[ 4 ] = - a * f;\r\n\t\t\tte[ 8 ] = de + cf * b;\r\n\r\n\t\t\tte[ 1 ] = cf + de * b;\r\n\t\t\tte[ 5 ] = a * e;\r\n\t\t\tte[ 9 ] = df - ce * b;\r\n\r\n\t\t\tte[ 2 ] = - a * d;\r\n\t\t\tte[ 6 ] = b;\r\n\t\t\tte[ 10 ] = a * c;\r\n\r\n\t\t} else if ( euler.order === 'ZYX' ) {\r\n\r\n\t\t\tvar ae = a * e, af = a * f, be = b * e, bf = b * f;\r\n\r\n\t\t\tte[ 0 ] = c * e;\r\n\t\t\tte[ 4 ] = be * d - af;\r\n\t\t\tte[ 8 ] = ae * d + bf;\r\n\r\n\t\t\tte[ 1 ] = c * f;\r\n\t\t\tte[ 5 ] = bf * d + ae;\r\n\t\t\tte[ 9 ] = af * d - be;\r\n\r\n\t\t\tte[ 2 ] = - d;\r\n\t\t\tte[ 6 ] = b * c;\r\n\t\t\tte[ 10 ] = a * c;\r\n\r\n\t\t} else if ( euler.order === 'YZX' ) {\r\n\r\n\t\t\tvar ac = a * c, ad = a * d, bc = b * c, bd = b * d;\r\n\r\n\t\t\tte[ 0 ] = c * e;\r\n\t\t\tte[ 4 ] = bd - ac * f;\r\n\t\t\tte[ 8 ] = bc * f + ad;\r\n\r\n\t\t\tte[ 1 ] = f;\r\n\t\t\tte[ 5 ] = a * e;\r\n\t\t\tte[ 9 ] = - b * e;\r\n\r\n\t\t\tte[ 2 ] = - d * e;\r\n\t\t\tte[ 6 ] = ad * f + bc;\r\n\t\t\tte[ 10 ] = ac - bd * f;\r\n\r\n\t\t} else if ( euler.order === 'XZY' ) {\r\n\r\n\t\t\tvar ac = a * c, ad = a * d, bc = b * c, bd = b * d;\r\n\r\n\t\t\tte[ 0 ] = c * e;\r\n\t\t\tte[ 4 ] = - f;\r\n\t\t\tte[ 8 ] = d * e;\r\n\r\n\t\t\tte[ 1 ] = ac * f + bd;\r\n\t\t\tte[ 5 ] = a * e;\r\n\t\t\tte[ 9 ] = ad * f - bc;\r\n\r\n\t\t\tte[ 2 ] = bc * f - ad;\r\n\t\t\tte[ 6 ] = b * e;\r\n\t\t\tte[ 10 ] = bd * f + ac;\r\n\r\n\t\t}\r\n\r\n\t\t// last column\r\n\t\tte[ 3 ] = 0;\r\n\t\tte[ 7 ] = 0;\r\n\t\tte[ 11 ] = 0;\r\n\r\n\t\t// bottom row\r\n\t\tte[ 12 ] = 0;\r\n\t\tte[ 13 ] = 0;\r\n\t\tte[ 14 ] = 0;\r\n\t\tte[ 15 ] = 1;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetRotationFromQuaternion: function ( q ) {\r\n\r\n\t\tTHREE.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );\r\n\r\n\t\treturn this.makeRotationFromQuaternion( q );\r\n\r\n\t},\r\n\r\n\tmakeRotationFromQuaternion: function ( q ) {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tvar x = q.x, y = q.y, z = q.z, w = q.w;\r\n\t\tvar x2 = x + x, y2 = y + y, z2 = z + z;\r\n\t\tvar xx = x * x2, xy = x * y2, xz = x * z2;\r\n\t\tvar yy = y * y2, yz = y * z2, zz = z * z2;\r\n\t\tvar wx = w * x2, wy = w * y2, wz = w * z2;\r\n\r\n\t\tte[ 0 ] = 1 - ( yy + zz );\r\n\t\tte[ 4 ] = xy - wz;\r\n\t\tte[ 8 ] = xz + wy;\r\n\r\n\t\tte[ 1 ] = xy + wz;\r\n\t\tte[ 5 ] = 1 - ( xx + zz );\r\n\t\tte[ 9 ] = yz - wx;\r\n\r\n\t\tte[ 2 ] = xz - wy;\r\n\t\tte[ 6 ] = yz + wx;\r\n\t\tte[ 10 ] = 1 - ( xx + yy );\r\n\r\n\t\t// last column\r\n\t\tte[ 3 ] = 0;\r\n\t\tte[ 7 ] = 0;\r\n\t\tte[ 11 ] = 0;\r\n\r\n\t\t// bottom row\r\n\t\tte[ 12 ] = 0;\r\n\t\tte[ 13 ] = 0;\r\n\t\tte[ 14 ] = 0;\r\n\t\tte[ 15 ] = 1;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tlookAt: function () {\r\n\r\n\t\tvar x = new THREE.Vector3();\r\n\t\tvar y = new THREE.Vector3();\r\n\t\tvar z = new THREE.Vector3();\r\n\r\n\t\treturn function ( eye, target, up ) {\r\n\r\n\t\t\tvar te = this.elements;\r\n\r\n\t\t\tz.subVectors( eye, target ).normalize();\r\n\r\n\t\t\tif ( z.length() === 0 ) {\r\n\r\n\t\t\t\tz.z = 1;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tx.crossVectors( up, z ).normalize();\r\n\r\n\t\t\tif ( x.length() === 0 ) {\r\n\r\n\t\t\t\tz.x += 0.0001;\r\n\t\t\t\tx.crossVectors( up, z ).normalize();\r\n\r\n\t\t\t}\r\n\r\n\t\t\ty.crossVectors( z, x );\r\n\r\n\r\n\t\t\tte[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;\r\n\t\t\tte[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;\r\n\t\t\tte[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tmultiply: function ( m, n ) {\r\n\r\n\t\tif ( n !== undefined ) {\r\n\r\n\t\t\tTHREE.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );\r\n\t\t\treturn this.multiplyMatrices( m, n );\r\n\r\n\t\t}\r\n\r\n\t\treturn this.multiplyMatrices( this, m );\r\n\r\n\t},\r\n\r\n\tmultiplyMatrices: function ( a, b ) {\r\n\r\n\t\tvar ae = a.elements;\r\n\t\tvar be = b.elements;\r\n\t\tvar te = this.elements;\r\n\r\n\t\tvar a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];\r\n\t\tvar a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];\r\n\t\tvar a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];\r\n\t\tvar a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];\r\n\r\n\t\tvar b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];\r\n\t\tvar b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];\r\n\t\tvar b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];\r\n\t\tvar b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];\r\n\r\n\t\tte[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\r\n\t\tte[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\r\n\t\tte[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\r\n\t\tte[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\r\n\r\n\t\tte[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\r\n\t\tte[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\r\n\t\tte[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\r\n\t\tte[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\r\n\r\n\t\tte[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\r\n\t\tte[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\r\n\t\tte[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\r\n\t\tte[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\r\n\r\n\t\tte[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\r\n\t\tte[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\r\n\t\tte[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\r\n\t\tte[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiplyToArray: function ( a, b, r ) {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tthis.multiplyMatrices( a, b );\r\n\r\n\t\tr[ 0 ] = te[ 0 ]; r[ 1 ] = te[ 1 ]; r[ 2 ] = te[ 2 ]; r[ 3 ] = te[ 3 ];\r\n\t\tr[ 4 ] = te[ 4 ]; r[ 5 ] = te[ 5 ]; r[ 6 ] = te[ 6 ]; r[ 7 ] = te[ 7 ];\r\n\t\tr[ 8 ]  = te[ 8 ]; r[ 9 ]  = te[ 9 ]; r[ 10 ] = te[ 10 ]; r[ 11 ] = te[ 11 ];\r\n\t\tr[ 12 ] = te[ 12 ]; r[ 13 ] = te[ 13 ]; r[ 14 ] = te[ 14 ]; r[ 15 ] = te[ 15 ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiplyScalar: function ( s ) {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tte[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;\r\n\t\tte[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;\r\n\t\tte[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;\r\n\t\tte[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiplyVector3: function ( vector ) {\r\n\r\n\t\tTHREE.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.' );\r\n\t\treturn vector.applyProjection( this );\r\n\r\n\t},\r\n\r\n\tmultiplyVector4: function ( vector ) {\r\n\r\n\t\tTHREE.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\r\n\t\treturn vector.applyMatrix4( this );\r\n\r\n\t},\r\n\r\n\tmultiplyVector3Array: function ( a ) {\r\n\r\n\t\tTHREE.warn( 'THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );\r\n\t\treturn this.applyToVector3Array( a );\r\n\r\n\t},\r\n\r\n\tapplyToVector3Array: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function ( array, offset, length ) {\r\n\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\t\tif ( length === undefined ) length = array.length;\r\n\r\n\t\t\tfor ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {\r\n\r\n\t\t\t\tv1.x = array[ j ];\r\n\t\t\t\tv1.y = array[ j + 1 ];\r\n\t\t\t\tv1.z = array[ j + 2 ];\r\n\r\n\t\t\t\tv1.applyMatrix4( this );\r\n\r\n\t\t\t\tarray[ j ]     = v1.x;\r\n\t\t\t\tarray[ j + 1 ] = v1.y;\r\n\t\t\t\tarray[ j + 2 ] = v1.z;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn array;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\trotateAxis: function ( v ) {\r\n\r\n\t\tTHREE.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );\r\n\r\n\t\tv.transformDirection( this );\r\n\r\n\t},\r\n\r\n\tcrossVector: function ( vector ) {\r\n\r\n\t\tTHREE.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\r\n\t\treturn vector.applyMatrix4( this );\r\n\r\n\t},\r\n\r\n\tdeterminant: function () {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tvar n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];\r\n\t\tvar n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];\r\n\t\tvar n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];\r\n\t\tvar n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];\r\n\r\n\t\t//TODO: make this more efficient\r\n\t\t//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )\r\n\r\n\t\treturn (\r\n\t\t\tn41 * (\r\n\t\t\t\t+ n14 * n23 * n32\r\n\t\t\t\t - n13 * n24 * n32\r\n\t\t\t\t - n14 * n22 * n33\r\n\t\t\t\t + n12 * n24 * n33\r\n\t\t\t\t + n13 * n22 * n34\r\n\t\t\t\t - n12 * n23 * n34\r\n\t\t\t) +\r\n\t\t\tn42 * (\r\n\t\t\t\t+ n11 * n23 * n34\r\n\t\t\t\t - n11 * n24 * n33\r\n\t\t\t\t + n14 * n21 * n33\r\n\t\t\t\t - n13 * n21 * n34\r\n\t\t\t\t + n13 * n24 * n31\r\n\t\t\t\t - n14 * n23 * n31\r\n\t\t\t) +\r\n\t\t\tn43 * (\r\n\t\t\t\t+ n11 * n24 * n32\r\n\t\t\t\t - n11 * n22 * n34\r\n\t\t\t\t - n14 * n21 * n32\r\n\t\t\t\t + n12 * n21 * n34\r\n\t\t\t\t + n14 * n22 * n31\r\n\t\t\t\t - n12 * n24 * n31\r\n\t\t\t) +\r\n\t\t\tn44 * (\r\n\t\t\t\t- n13 * n22 * n31\r\n\t\t\t\t - n11 * n23 * n32\r\n\t\t\t\t + n11 * n22 * n33\r\n\t\t\t\t + n13 * n21 * n32\r\n\t\t\t\t - n12 * n21 * n33\r\n\t\t\t\t + n12 * n23 * n31\r\n\t\t\t)\r\n\r\n\t\t);\r\n\r\n\t},\r\n\r\n\ttranspose: function () {\r\n\r\n\t\tvar te = this.elements;\r\n\t\tvar tmp;\r\n\r\n\t\ttmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;\r\n\t\ttmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;\r\n\t\ttmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;\r\n\r\n\t\ttmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;\r\n\t\ttmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;\r\n\t\ttmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tflattenToArrayOffset: function ( array, offset ) {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tarray[ offset     ] = te[ 0 ];\r\n\t\tarray[ offset + 1 ] = te[ 1 ];\r\n\t\tarray[ offset + 2 ] = te[ 2 ];\r\n\t\tarray[ offset + 3 ] = te[ 3 ];\r\n\r\n\t\tarray[ offset + 4 ] = te[ 4 ];\r\n\t\tarray[ offset + 5 ] = te[ 5 ];\r\n\t\tarray[ offset + 6 ] = te[ 6 ];\r\n\t\tarray[ offset + 7 ] = te[ 7 ];\r\n\r\n\t\tarray[ offset + 8 ]  = te[ 8 ];\r\n\t\tarray[ offset + 9 ]  = te[ 9 ];\r\n\t\tarray[ offset + 10 ] = te[ 10 ];\r\n\t\tarray[ offset + 11 ] = te[ 11 ];\r\n\r\n\t\tarray[ offset + 12 ] = te[ 12 ];\r\n\t\tarray[ offset + 13 ] = te[ 13 ];\r\n\t\tarray[ offset + 14 ] = te[ 14 ];\r\n\t\tarray[ offset + 15 ] = te[ 15 ];\r\n\r\n\t\treturn array;\r\n\r\n\t},\r\n\r\n\tgetPosition: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function () {\r\n\r\n\t\t\tTHREE.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );\r\n\r\n\t\t\tvar te = this.elements;\r\n\t\t\treturn v1.set( te[ 12 ], te[ 13 ], te[ 14 ] );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tsetPosition: function ( v ) {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tte[ 12 ] = v.x;\r\n\t\tte[ 13 ] = v.y;\r\n\t\tte[ 14 ] = v.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetInverse: function ( m, throwOnInvertible ) {\r\n\r\n\t\t// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\r\n\t\tvar te = this.elements;\r\n\t\tvar me = m.elements;\r\n\r\n\t\tvar n11 = me[ 0 ], n12 = me[ 4 ], n13 = me[ 8 ], n14 = me[ 12 ];\r\n\t\tvar n21 = me[ 1 ], n22 = me[ 5 ], n23 = me[ 9 ], n24 = me[ 13 ];\r\n\t\tvar n31 = me[ 2 ], n32 = me[ 6 ], n33 = me[ 10 ], n34 = me[ 14 ];\r\n\t\tvar n41 = me[ 3 ], n42 = me[ 7 ], n43 = me[ 11 ], n44 = me[ 15 ];\r\n\r\n\t\tte[ 0 ] = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44;\r\n\t\tte[ 4 ] = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44;\r\n\t\tte[ 8 ] = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44;\r\n\t\tte[ 12 ] = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;\r\n\t\tte[ 1 ] = n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44;\r\n\t\tte[ 5 ] = n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44;\r\n\t\tte[ 9 ] = n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44;\r\n\t\tte[ 13 ] = n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34;\r\n\t\tte[ 2 ] = n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44;\r\n\t\tte[ 6 ] = n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44;\r\n\t\tte[ 10 ] = n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44;\r\n\t\tte[ 14 ] = n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34;\r\n\t\tte[ 3 ] = n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43;\r\n\t\tte[ 7 ] = n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43;\r\n\t\tte[ 11 ] = n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43;\r\n\t\tte[ 15 ] = n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33;\r\n\r\n\t\tvar det = n11 * te[ 0 ] + n21 * te[ 4 ] + n31 * te[ 8 ] + n41 * te[ 12 ];\r\n\r\n\t\tif ( det == 0 ) {\r\n\r\n\t\t\tvar msg = \"THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0\";\r\n\r\n\t\t\tif ( throwOnInvertible || false ) {\r\n\r\n\t\t\t\tthrow new Error( msg );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tTHREE.warn( msg );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.identity();\r\n\r\n\t\t\treturn this;\r\n\t\t}\r\n\r\n\t\tthis.multiplyScalar( 1 / det );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttranslate: function ( v ) {\r\n\r\n\t\tTHREE.error( 'THREE.Matrix4: .translate() has been removed.' );\r\n\r\n\t},\r\n\r\n\trotateX: function ( angle ) {\r\n\r\n\t\tTHREE.error( 'THREE.Matrix4: .rotateX() has been removed.' );\r\n\r\n\t},\r\n\r\n\trotateY: function ( angle ) {\r\n\r\n\t\tTHREE.error( 'THREE.Matrix4: .rotateY() has been removed.' );\r\n\r\n\t},\r\n\r\n\trotateZ: function ( angle ) {\r\n\r\n\t\tTHREE.error( 'THREE.Matrix4: .rotateZ() has been removed.' );\r\n\r\n\t},\r\n\r\n\trotateByAxis: function ( axis, angle ) {\r\n\r\n\t\tTHREE.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );\r\n\r\n\t},\r\n\r\n\tscale: function ( v ) {\r\n\r\n\t\tvar te = this.elements;\r\n\t\tvar x = v.x, y = v.y, z = v.z;\r\n\r\n\t\tte[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;\r\n\t\tte[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;\r\n\t\tte[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;\r\n\t\tte[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetMaxScaleOnAxis: function () {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tvar scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];\r\n\t\tvar scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];\r\n\t\tvar scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];\r\n\r\n\t\treturn Math.sqrt( Math.max( scaleXSq, Math.max( scaleYSq, scaleZSq ) ) );\r\n\r\n\t},\r\n\r\n\tmakeTranslation: function ( x, y, z ) {\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\t1, 0, 0, x,\r\n\t\t\t0, 1, 0, y,\r\n\t\t\t0, 0, 1, z,\r\n\t\t\t0, 0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmakeRotationX: function ( theta ) {\r\n\r\n\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\t1, 0,  0, 0,\r\n\t\t\t0, c, - s, 0,\r\n\t\t\t0, s,  c, 0,\r\n\t\t\t0, 0,  0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmakeRotationY: function ( theta ) {\r\n\r\n\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\t c, 0, s, 0,\r\n\t\t\t 0, 1, 0, 0,\r\n\t\t\t- s, 0, c, 0,\r\n\t\t\t 0, 0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmakeRotationZ: function ( theta ) {\r\n\r\n\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\tc, - s, 0, 0,\r\n\t\t\ts,  c, 0, 0,\r\n\t\t\t0,  0, 1, 0,\r\n\t\t\t0,  0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmakeRotationAxis: function ( axis, angle ) {\r\n\r\n\t\t// Based on http://www.gamedev.net/reference/articles/article1199.asp\r\n\r\n\t\tvar c = Math.cos( angle );\r\n\t\tvar s = Math.sin( angle );\r\n\t\tvar t = 1 - c;\r\n\t\tvar x = axis.x, y = axis.y, z = axis.z;\r\n\t\tvar tx = t * x, ty = t * y;\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\ttx * x + c, tx * y - s * z, tx * z + s * y, 0,\r\n\t\t\ttx * y + s * z, ty * y + c, ty * z - s * x, 0,\r\n\t\t\ttx * z - s * y, ty * z + s * x, t * z * z + c, 0,\r\n\t\t\t0, 0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\t return this;\r\n\r\n\t},\r\n\r\n\tmakeScale: function ( x, y, z ) {\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\tx, 0, 0, 0,\r\n\t\t\t0, y, 0, 0,\r\n\t\t\t0, 0, z, 0,\r\n\t\t\t0, 0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcompose: function ( position, quaternion, scale ) {\r\n\r\n\t\tthis.makeRotationFromQuaternion( quaternion );\r\n\t\tthis.scale( scale );\r\n\t\tthis.setPosition( position );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdecompose: function () {\r\n\r\n\t\tvar vector = new THREE.Vector3();\r\n\t\tvar matrix = new THREE.Matrix4();\r\n\r\n\t\treturn function ( position, quaternion, scale ) {\r\n\r\n\t\t\tvar te = this.elements;\r\n\r\n\t\t\tvar sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();\r\n\t\t\tvar sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();\r\n\t\t\tvar sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();\r\n\r\n\t\t\t// if determine is negative, we need to invert one scale\r\n\t\t\tvar det = this.determinant();\r\n\t\t\tif ( det < 0 ) {\r\n\t\t\t\tsx = - sx;\r\n\t\t\t}\r\n\r\n\t\t\tposition.x = te[ 12 ];\r\n\t\t\tposition.y = te[ 13 ];\r\n\t\t\tposition.z = te[ 14 ];\r\n\r\n\t\t\t// scale the rotation part\r\n\r\n\t\t\tmatrix.elements.set( this.elements ); // at this point matrix is incomplete so we can't use .copy()\r\n\r\n\t\t\tvar invSX = 1 / sx;\r\n\t\t\tvar invSY = 1 / sy;\r\n\t\t\tvar invSZ = 1 / sz;\r\n\r\n\t\t\tmatrix.elements[ 0 ] *= invSX;\r\n\t\t\tmatrix.elements[ 1 ] *= invSX;\r\n\t\t\tmatrix.elements[ 2 ] *= invSX;\r\n\r\n\t\t\tmatrix.elements[ 4 ] *= invSY;\r\n\t\t\tmatrix.elements[ 5 ] *= invSY;\r\n\t\t\tmatrix.elements[ 6 ] *= invSY;\r\n\r\n\t\t\tmatrix.elements[ 8 ] *= invSZ;\r\n\t\t\tmatrix.elements[ 9 ] *= invSZ;\r\n\t\t\tmatrix.elements[ 10 ] *= invSZ;\r\n\r\n\t\t\tquaternion.setFromRotationMatrix( matrix );\r\n\r\n\t\t\tscale.x = sx;\r\n\t\t\tscale.y = sy;\r\n\t\t\tscale.z = sz;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tmakeFrustum: function ( left, right, bottom, top, near, far ) {\r\n\r\n\t\tvar te = this.elements;\r\n\t\tvar x = 2 * near / ( right - left );\r\n\t\tvar y = 2 * near / ( top - bottom );\r\n\r\n\t\tvar a = ( right + left ) / ( right - left );\r\n\t\tvar b = ( top + bottom ) / ( top - bottom );\r\n\t\tvar c = - ( far + near ) / ( far - near );\r\n\t\tvar d = - 2 * far * near / ( far - near );\r\n\r\n\t\tte[ 0 ] = x;\tte[ 4 ] = 0;\tte[ 8 ] = a;\tte[ 12 ] = 0;\r\n\t\tte[ 1 ] = 0;\tte[ 5 ] = y;\tte[ 9 ] = b;\tte[ 13 ] = 0;\r\n\t\tte[ 2 ] = 0;\tte[ 6 ] = 0;\tte[ 10 ] = c;\tte[ 14 ] = d;\r\n\t\tte[ 3 ] = 0;\tte[ 7 ] = 0;\tte[ 11 ] = - 1;\tte[ 15 ] = 0;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmakePerspective: function ( fov, aspect, near, far ) {\r\n\r\n\t\tvar ymax = near * Math.tan( THREE.Math.degToRad( fov * 0.5 ) );\r\n\t\tvar ymin = - ymax;\r\n\t\tvar xmin = ymin * aspect;\r\n\t\tvar xmax = ymax * aspect;\r\n\r\n\t\treturn this.makeFrustum( xmin, xmax, ymin, ymax, near, far );\r\n\r\n\t},\r\n\r\n\tmakeOrthographic: function ( left, right, top, bottom, near, far ) {\r\n\r\n\t\tvar te = this.elements;\r\n\t\tvar w = right - left;\r\n\t\tvar h = top - bottom;\r\n\t\tvar p = far - near;\r\n\r\n\t\tvar x = ( right + left ) / w;\r\n\t\tvar y = ( top + bottom ) / h;\r\n\t\tvar z = ( far + near ) / p;\r\n\r\n\t\tte[ 0 ] = 2 / w;\tte[ 4 ] = 0;\tte[ 8 ] = 0;\tte[ 12 ] = - x;\r\n\t\tte[ 1 ] = 0;\tte[ 5 ] = 2 / h;\tte[ 9 ] = 0;\tte[ 13 ] = - y;\r\n\t\tte[ 2 ] = 0;\tte[ 6 ] = 0;\tte[ 10 ] = - 2 / p;\tte[ 14 ] = - z;\r\n\t\tte[ 3 ] = 0;\tte[ 7 ] = 0;\tte[ 11 ] = 0;\tte[ 15 ] = 1;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tfromArray: function ( array ) {\r\n\r\n\t\tthis.elements.set( array );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttoArray: function () {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\treturn [\r\n\t\t\tte[ 0 ], te[ 1 ], te[ 2 ], te[ 3 ],\r\n\t\t\tte[ 4 ], te[ 5 ], te[ 6 ], te[ 7 ],\r\n\t\t\tte[ 8 ], te[ 9 ], te[ 10 ], te[ 11 ],\r\n\t\t\tte[ 12 ], te[ 13 ], te[ 14 ], te[ 15 ]\r\n\t\t];\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new THREE.Matrix4().fromArray( this.elements );\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/math/Ray.js\r\n\r\n/**\r\n * @author bhouston / http://exocortex.com\r\n */\r\n\r\nTHREE.Ray = function ( origin, direction ) {\r\n\r\n\tthis.origin = ( origin !== undefined ) ? origin : new THREE.Vector3();\r\n\tthis.direction = ( direction !== undefined ) ? direction : new THREE.Vector3();\r\n\r\n};\r\n\r\nTHREE.Ray.prototype = {\r\n\r\n\tconstructor: THREE.Ray,\r\n\r\n\tset: function ( origin, direction ) {\r\n\r\n\t\tthis.origin.copy( origin );\r\n\t\tthis.direction.copy( direction );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopy: function ( ray ) {\r\n\r\n\t\tthis.origin.copy( ray.origin );\r\n\t\tthis.direction.copy( ray.direction );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tat: function ( t, optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\r\n\t\treturn result.copy( this.direction ).multiplyScalar( t ).add( this.origin );\r\n\r\n\t},\r\n\r\n\trecast: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function ( t ) {\r\n\r\n\t\t\tthis.origin.copy( this.at( t, v1 ) );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tclosestPointToPoint: function ( point, optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\tresult.subVectors( point, this.origin );\r\n\t\tvar directionDistance = result.dot( this.direction );\r\n\r\n\t\tif ( directionDistance < 0 ) {\r\n\r\n\t\t\treturn result.copy( this.origin );\r\n\r\n\t\t}\r\n\r\n\t\treturn result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\r\n\r\n\t},\r\n\r\n\tdistanceToPoint: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function ( point ) {\r\n\r\n\t\t\tvar directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );\r\n\r\n\t\t\t// point behind the ray\r\n\r\n\t\t\tif ( directionDistance < 0 ) {\r\n\r\n\t\t\t\treturn this.origin.distanceTo( point );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tv1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\r\n\r\n\t\t\treturn v1.distanceTo( point );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tdistanceSqToSegment: function () {\r\n\r\n\t\tvar segCenter = new THREE.Vector3();\r\n\t\tvar segDir = new THREE.Vector3();\r\n\t\tvar diff = new THREE.Vector3();\r\n\r\n\t\treturn function ( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {\r\n\r\n\t\t\t// from http://www.geometrictools.com/LibMathematics/Distance/Wm5DistRay3Segment3.cpp\r\n\t\t\t// It returns the min distance between the ray and the segment\r\n\t\t\t// defined by v0 and v1\r\n\t\t\t// It can also set two optional targets :\r\n\t\t\t// - The closest point on the ray\r\n\t\t\t// - The closest point on the segment\r\n\r\n\t\t\tsegCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );\r\n\t\t\tsegDir.copy( v1 ).sub( v0 ).normalize();\r\n\t\t\tdiff.copy( this.origin ).sub( segCenter );\r\n\r\n\t\t\tvar segExtent = v0.distanceTo( v1 ) * 0.5;\r\n\t\t\tvar a01 = - this.direction.dot( segDir );\r\n\t\t\tvar b0 = diff.dot( this.direction );\r\n\t\t\tvar b1 = - diff.dot( segDir );\r\n\t\t\tvar c = diff.lengthSq();\r\n\t\t\tvar det = Math.abs( 1 - a01 * a01 );\r\n\t\t\tvar s0, s1, sqrDist, extDet;\r\n\r\n\t\t\tif ( det > 0 ) {\r\n\r\n\t\t\t\t// The ray and segment are not parallel.\r\n\r\n\t\t\t\ts0 = a01 * b1 - b0;\r\n\t\t\t\ts1 = a01 * b0 - b1;\r\n\t\t\t\textDet = segExtent * det;\r\n\r\n\t\t\t\tif ( s0 >= 0 ) {\r\n\r\n\t\t\t\t\tif ( s1 >= - extDet ) {\r\n\r\n\t\t\t\t\t\tif ( s1 <= extDet ) {\r\n\r\n\t\t\t\t\t\t\t// region 0\r\n\t\t\t\t\t\t\t// Minimum at interior points of ray and segment.\r\n\r\n\t\t\t\t\t\t\tvar invDet = 1 / det;\r\n\t\t\t\t\t\t\ts0 *= invDet;\r\n\t\t\t\t\t\t\ts1 *= invDet;\r\n\t\t\t\t\t\t\tsqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t// region 1\r\n\r\n\t\t\t\t\t\t\ts1 = segExtent;\r\n\t\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\r\n\t\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t// region 5\r\n\r\n\t\t\t\t\t\ts1 = - segExtent;\r\n\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\r\n\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tif ( s1 <= - extDet ) {\r\n\r\n\t\t\t\t\t\t// region 4\r\n\r\n\t\t\t\t\t\ts0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );\r\n\t\t\t\t\t\ts1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\r\n\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\r\n\r\n\t\t\t\t\t} else if ( s1 <= extDet ) {\r\n\r\n\t\t\t\t\t\t// region 3\r\n\r\n\t\t\t\t\t\ts0 = 0;\r\n\t\t\t\t\t\ts1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );\r\n\t\t\t\t\t\tsqrDist = s1 * ( s1 + 2 * b1 ) + c;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t// region 2\r\n\r\n\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * segExtent + b0 ) );\r\n\t\t\t\t\t\ts1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\r\n\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// Ray and segment are parallel.\r\n\r\n\t\t\t\ts1 = ( a01 > 0 ) ? - segExtent : segExtent;\r\n\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\r\n\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( optionalPointOnRay ) {\r\n\r\n\t\t\t\toptionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( optionalPointOnSegment ) {\r\n\r\n\t\t\t\toptionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn sqrDist;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\r\n\tisIntersectionSphere: function ( sphere ) {\r\n\r\n\t\treturn this.distanceToPoint( sphere.center ) <= sphere.radius;\r\n\r\n\t},\r\n\r\n\tintersectSphere: function () {\r\n\r\n\t\t// from http://www.scratchapixel.com/lessons/3d-basic-lessons/lesson-7-intersecting-simple-shapes/ray-sphere-intersection/\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function ( sphere, optionalTarget ) {\r\n\r\n\t\t\tv1.subVectors( sphere.center, this.origin );\r\n\r\n\t\t\tvar tca = v1.dot( this.direction );\r\n\r\n\t\t\tvar d2 = v1.dot( v1 ) - tca * tca;\r\n\r\n\t\t\tvar radius2 = sphere.radius * sphere.radius;\r\n\r\n\t\t\tif ( d2 > radius2 ) return null;\r\n\r\n\t\t\tvar thc = Math.sqrt( radius2 - d2 );\r\n\r\n\t\t\t// t0 = first intersect point - entrance on front of sphere\r\n\t\t\tvar t0 = tca - thc;\r\n\r\n\t\t\t// t1 = second intersect point - exit point on back of sphere\r\n\t\t\tvar t1 = tca + thc;\r\n\r\n\t\t\t// test to see if both t0 and t1 are behind the ray - if so, return null\r\n\t\t\tif ( t0 < 0 && t1 < 0 ) return null;\r\n\r\n\t\t\t// test to see if t0 is behind the ray:\r\n\t\t\t// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,\r\n\t\t\t// in order to always return an intersect point that is in front of the ray.\r\n\t\t\tif ( t0 < 0 ) return this.at( t1, optionalTarget );\r\n\r\n\t\t\t// else t0 is in front of the ray, so return the first collision point scaled by t0 \r\n\t\t\treturn this.at( t0, optionalTarget );\r\n\r\n\t\t}\r\n\r\n\t}(),\r\n\r\n\tisIntersectionPlane: function ( plane ) {\r\n\r\n\t\t// check if the ray lies on the plane first\r\n\r\n\t\tvar distToPoint = plane.distanceToPoint( this.origin );\r\n\r\n\t\tif ( distToPoint === 0 ) {\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t}\r\n\r\n\t\tvar denominator = plane.normal.dot( this.direction );\r\n\r\n\t\tif ( denominator * distToPoint < 0 ) {\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t}\r\n\r\n\t\t// ray origin is behind the plane (and is pointing behind it)\r\n\r\n\t\treturn false;\r\n\r\n\t},\r\n\r\n\tdistanceToPlane: function ( plane ) {\r\n\r\n\t\tvar denominator = plane.normal.dot( this.direction );\r\n\t\tif ( denominator == 0 ) {\r\n\r\n\t\t\t// line is coplanar, return origin\r\n\t\t\tif ( plane.distanceToPoint( this.origin ) == 0 ) {\r\n\r\n\t\t\t\treturn 0;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Null is preferable to undefined since undefined means.... it is undefined\r\n\r\n\t\t\treturn null;\r\n\r\n\t\t}\r\n\r\n\t\tvar t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;\r\n\r\n\t\t// Return if the ray never intersects the plane\r\n\r\n\t\treturn t >= 0 ? t :  null;\r\n\r\n\t},\r\n\r\n\tintersectPlane: function ( plane, optionalTarget ) {\r\n\r\n\t\tvar t = this.distanceToPlane( plane );\r\n\r\n\t\tif ( t === null ) {\r\n\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\treturn this.at( t, optionalTarget );\r\n\r\n\t},\r\n\r\n\tisIntersectionBox: function () {\r\n\r\n\t\tvar v = new THREE.Vector3();\r\n\r\n\t\treturn function ( box ) {\r\n\r\n\t\t\treturn this.intersectBox( box, v ) !== null;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tintersectBox: function ( box, optionalTarget ) {\r\n\r\n\t\t// http://www.scratchapixel.com/lessons/3d-basic-lessons/lesson-7-intersecting-simple-shapes/ray-box-intersection/\r\n\r\n\t\tvar tmin,tmax,tymin,tymax,tzmin,tzmax;\r\n\r\n\t\tvar invdirx = 1 / this.direction.x,\r\n\t\t\tinvdiry = 1 / this.direction.y,\r\n\t\t\tinvdirz = 1 / this.direction.z;\r\n\r\n\t\tvar origin = this.origin;\r\n\r\n\t\tif ( invdirx >= 0 ) {\r\n\r\n\t\t\ttmin = ( box.min.x - origin.x ) * invdirx;\r\n\t\t\ttmax = ( box.max.x - origin.x ) * invdirx;\r\n\r\n\t\t} else {\r\n\r\n\t\t\ttmin = ( box.max.x - origin.x ) * invdirx;\r\n\t\t\ttmax = ( box.min.x - origin.x ) * invdirx;\r\n\t\t}\r\n\r\n\t\tif ( invdiry >= 0 ) {\r\n\r\n\t\t\ttymin = ( box.min.y - origin.y ) * invdiry;\r\n\t\t\ttymax = ( box.max.y - origin.y ) * invdiry;\r\n\r\n\t\t} else {\r\n\r\n\t\t\ttymin = ( box.max.y - origin.y ) * invdiry;\r\n\t\t\ttymax = ( box.min.y - origin.y ) * invdiry;\r\n\t\t}\r\n\r\n\t\tif ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;\r\n\r\n\t\t// These lines also handle the case where tmin or tmax is NaN\r\n\t\t// (result of 0 * Infinity). x !== x returns true if x is NaN\r\n\r\n\t\tif ( tymin > tmin || tmin !== tmin ) tmin = tymin;\r\n\r\n\t\tif ( tymax < tmax || tmax !== tmax ) tmax = tymax;\r\n\r\n\t\tif ( invdirz >= 0 ) {\r\n\r\n\t\t\ttzmin = ( box.min.z - origin.z ) * invdirz;\r\n\t\t\ttzmax = ( box.max.z - origin.z ) * invdirz;\r\n\r\n\t\t} else {\r\n\r\n\t\t\ttzmin = ( box.max.z - origin.z ) * invdirz;\r\n\t\t\ttzmax = ( box.min.z - origin.z ) * invdirz;\r\n\t\t}\r\n\r\n\t\tif ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;\r\n\r\n\t\tif ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;\r\n\r\n\t\tif ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;\r\n\r\n\t\t//return point closest to the ray (positive side)\r\n\r\n\t\tif ( tmax < 0 ) return null;\r\n\r\n\t\treturn this.at( tmin >= 0 ? tmin : tmax, optionalTarget );\r\n\r\n\t},\r\n\r\n\tintersectTriangle: function () {\r\n\r\n\t\t// Compute the offset origin, edges, and normal.\r\n\t\tvar diff = new THREE.Vector3();\r\n\t\tvar edge1 = new THREE.Vector3();\r\n\t\tvar edge2 = new THREE.Vector3();\r\n\t\tvar normal = new THREE.Vector3();\r\n\r\n\t\treturn function ( a, b, c, backfaceCulling, optionalTarget ) {\r\n\r\n\t\t\t// from http://www.geometrictools.com/LibMathematics/Intersection/Wm5IntrRay3Triangle3.cpp\r\n\r\n\t\t\tedge1.subVectors( b, a );\r\n\t\t\tedge2.subVectors( c, a );\r\n\t\t\tnormal.crossVectors( edge1, edge2 );\r\n\r\n\t\t\t// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,\r\n\t\t\t// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by\r\n\t\t\t//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))\r\n\t\t\t//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))\r\n\t\t\t//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)\r\n\t\t\tvar DdN = this.direction.dot( normal );\r\n\t\t\tvar sign;\r\n\r\n\t\t\tif ( DdN > 0 ) {\r\n\r\n\t\t\t\tif ( backfaceCulling ) return null;\r\n\t\t\t\tsign = 1;\r\n\r\n\t\t\t} else if ( DdN < 0 ) {\r\n\r\n\t\t\t\tsign = - 1;\r\n\t\t\t\tDdN = - DdN;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tdiff.subVectors( this.origin, a );\r\n\t\t\tvar DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );\r\n\r\n\t\t\t// b1 < 0, no intersection\r\n\t\t\tif ( DdQxE2 < 0 ) {\r\n\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );\r\n\r\n\t\t\t// b2 < 0, no intersection\r\n\t\t\tif ( DdE1xQ < 0 ) {\r\n\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// b1+b2 > 1, no intersection\r\n\t\t\tif ( DdQxE2 + DdE1xQ > DdN ) {\r\n\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Line intersects triangle, check if ray does.\r\n\t\t\tvar QdN = - sign * diff.dot( normal );\r\n\r\n\t\t\t// t < 0, no intersection\r\n\t\t\tif ( QdN < 0 ) {\r\n\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Ray intersects triangle.\r\n\t\t\treturn this.at( QdN / DdN, optionalTarget );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tapplyMatrix4: function ( matrix4 ) {\r\n\r\n\t\tthis.direction.add( this.origin ).applyMatrix4( matrix4 );\r\n\t\tthis.origin.applyMatrix4( matrix4 );\r\n\t\tthis.direction.sub( this.origin );\r\n\t\tthis.direction.normalize();\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tequals: function ( ray ) {\r\n\r\n\t\treturn ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new THREE.Ray().copy( this );\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/math/Sphere.js\r\n\r\n/**\r\n * @author bhouston / http://exocortex.com\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Sphere = function ( center, radius ) {\r\n\r\n\tthis.center = ( center !== undefined ) ? center : new THREE.Vector3();\r\n\tthis.radius = ( radius !== undefined ) ? radius : 0;\r\n\r\n};\r\n\r\nTHREE.Sphere.prototype = {\r\n\r\n\tconstructor: THREE.Sphere,\r\n\r\n\tset: function ( center, radius ) {\r\n\r\n\t\tthis.center.copy( center );\r\n\t\tthis.radius = radius;\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsetFromPoints: function () {\r\n\r\n\t\tvar box = new THREE.Box3();\r\n\r\n\t\treturn function ( points, optionalCenter ) {\r\n\r\n\t\t\tvar center = this.center;\r\n\r\n\t\t\tif ( optionalCenter !== undefined ) {\r\n\r\n\t\t\t\tcenter.copy( optionalCenter );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tbox.setFromPoints( points ).center( center );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar maxRadiusSq = 0;\r\n\r\n\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.radius = Math.sqrt( maxRadiusSq );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tcopy: function ( sphere ) {\r\n\r\n\t\tthis.center.copy( sphere.center );\r\n\t\tthis.radius = sphere.radius;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tempty: function () {\r\n\r\n\t\treturn ( this.radius <= 0 );\r\n\r\n\t},\r\n\r\n\tcontainsPoint: function ( point ) {\r\n\r\n\t\treturn ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );\r\n\r\n\t},\r\n\r\n\tdistanceToPoint: function ( point ) {\r\n\r\n\t\treturn ( point.distanceTo( this.center ) - this.radius );\r\n\r\n\t},\r\n\r\n\tintersectsSphere: function ( sphere ) {\r\n\r\n\t\tvar radiusSum = this.radius + sphere.radius;\r\n\r\n\t\treturn sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );\r\n\r\n\t},\r\n\r\n\tclampPoint: function ( point, optionalTarget ) {\r\n\r\n\t\tvar deltaLengthSq = this.center.distanceToSquared( point );\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\tresult.copy( point );\r\n\r\n\t\tif ( deltaLengthSq > ( this.radius * this.radius ) ) {\r\n\r\n\t\t\tresult.sub( this.center ).normalize();\r\n\t\t\tresult.multiplyScalar( this.radius ).add( this.center );\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t},\r\n\r\n\tgetBoundingBox: function ( optionalTarget ) {\r\n\r\n\t\tvar box = optionalTarget || new THREE.Box3();\r\n\r\n\t\tbox.set( this.center, this.center );\r\n\t\tbox.expandByScalar( this.radius );\r\n\r\n\t\treturn box;\r\n\r\n\t},\r\n\r\n\tapplyMatrix4: function ( matrix ) {\r\n\r\n\t\tthis.center.applyMatrix4( matrix );\r\n\t\tthis.radius = this.radius * matrix.getMaxScaleOnAxis();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttranslate: function ( offset ) {\r\n\r\n\t\tthis.center.add( offset );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tequals: function ( sphere ) {\r\n\r\n\t\treturn sphere.center.equals( this.center ) && ( sphere.radius === this.radius );\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new THREE.Sphere().copy( this );\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/math/Frustum.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author bhouston / http://exocortex.com\r\n */\r\n\r\nTHREE.Frustum = function ( p0, p1, p2, p3, p4, p5 ) {\r\n\r\n\tthis.planes = [\r\n\r\n\t\t( p0 !== undefined ) ? p0 : new THREE.Plane(),\r\n\t\t( p1 !== undefined ) ? p1 : new THREE.Plane(),\r\n\t\t( p2 !== undefined ) ? p2 : new THREE.Plane(),\r\n\t\t( p3 !== undefined ) ? p3 : new THREE.Plane(),\r\n\t\t( p4 !== undefined ) ? p4 : new THREE.Plane(),\r\n\t\t( p5 !== undefined ) ? p5 : new THREE.Plane()\r\n\r\n\t];\r\n\r\n};\r\n\r\nTHREE.Frustum.prototype = {\r\n\r\n\tconstructor: THREE.Frustum,\r\n\r\n\tset: function ( p0, p1, p2, p3, p4, p5 ) {\r\n\r\n\t\tvar planes = this.planes;\r\n\r\n\t\tplanes[ 0 ].copy( p0 );\r\n\t\tplanes[ 1 ].copy( p1 );\r\n\t\tplanes[ 2 ].copy( p2 );\r\n\t\tplanes[ 3 ].copy( p3 );\r\n\t\tplanes[ 4 ].copy( p4 );\r\n\t\tplanes[ 5 ].copy( p5 );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopy: function ( frustum ) {\r\n\r\n\t\tvar planes = this.planes;\r\n\r\n\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\tplanes[ i ].copy( frustum.planes[ i ] );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromMatrix: function ( m ) {\r\n\r\n\t\tvar planes = this.planes;\r\n\t\tvar me = m.elements;\r\n\t\tvar me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];\r\n\t\tvar me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];\r\n\t\tvar me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];\r\n\t\tvar me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];\r\n\r\n\t\tplanes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();\r\n\t\tplanes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();\r\n\t\tplanes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();\r\n\t\tplanes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();\r\n\t\tplanes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();\r\n\t\tplanes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tintersectsObject: function () {\r\n\r\n\t\tvar sphere = new THREE.Sphere();\r\n\r\n\t\treturn function ( object ) {\r\n\r\n\t\t\tvar geometry = object.geometry;\r\n\r\n\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\r\n\r\n\t\t\tsphere.copy( geometry.boundingSphere );\r\n\t\t\tsphere.applyMatrix4( object.matrixWorld );\r\n\r\n\t\t\treturn this.intersectsSphere( sphere );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tintersectsSphere: function ( sphere ) {\r\n\r\n\t\tvar planes = this.planes;\r\n\t\tvar center = sphere.center;\r\n\t\tvar negRadius = - sphere.radius;\r\n\r\n\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\tvar distance = planes[ i ].distanceToPoint( center );\r\n\r\n\t\t\tif ( distance < negRadius ) {\r\n\r\n\t\t\t\treturn false;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\t},\r\n\r\n\tintersectsBox: function () {\r\n\r\n\t\tvar p1 = new THREE.Vector3(),\r\n\t\t\tp2 = new THREE.Vector3();\r\n\r\n\t\treturn function ( box ) {\r\n\r\n\t\t\tvar planes = this.planes;\r\n\r\n\t\t\tfor ( var i = 0; i < 6 ; i ++ ) {\r\n\r\n\t\t\t\tvar plane = planes[ i ];\r\n\r\n\t\t\t\tp1.x = plane.normal.x > 0 ? box.min.x : box.max.x;\r\n\t\t\t\tp2.x = plane.normal.x > 0 ? box.max.x : box.min.x;\r\n\t\t\t\tp1.y = plane.normal.y > 0 ? box.min.y : box.max.y;\r\n\t\t\t\tp2.y = plane.normal.y > 0 ? box.max.y : box.min.y;\r\n\t\t\t\tp1.z = plane.normal.z > 0 ? box.min.z : box.max.z;\r\n\t\t\t\tp2.z = plane.normal.z > 0 ? box.max.z : box.min.z;\r\n\r\n\t\t\t\tvar d1 = plane.distanceToPoint( p1 );\r\n\t\t\t\tvar d2 = plane.distanceToPoint( p2 );\r\n\r\n\t\t\t\t// if both outside plane, no intersection\r\n\r\n\t\t\t\tif ( d1 < 0 && d2 < 0 ) {\r\n\r\n\t\t\t\t\treturn false;\r\n\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn true;\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\r\n\tcontainsPoint: function ( point ) {\r\n\r\n\t\tvar planes = this.planes;\r\n\r\n\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\tif ( planes[ i ].distanceToPoint( point ) < 0 ) {\r\n\r\n\t\t\t\treturn false;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new THREE.Frustum().copy( this );\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/math/Plane.js\r\n\r\n/**\r\n * @author bhouston / http://exocortex.com\r\n */\r\n\r\nTHREE.Plane = function ( normal, constant ) {\r\n\r\n\tthis.normal = ( normal !== undefined ) ? normal : new THREE.Vector3( 1, 0, 0 );\r\n\tthis.constant = ( constant !== undefined ) ? constant : 0;\r\n\r\n};\r\n\r\nTHREE.Plane.prototype = {\r\n\r\n\tconstructor: THREE.Plane,\r\n\r\n\tset: function ( normal, constant ) {\r\n\r\n\t\tthis.normal.copy( normal );\r\n\t\tthis.constant = constant;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetComponents: function ( x, y, z, w ) {\r\n\r\n\t\tthis.normal.set( x, y, z );\r\n\t\tthis.constant = w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromNormalAndCoplanarPoint: function ( normal, point ) {\r\n\r\n\t\tthis.normal.copy( normal );\r\n\t\tthis.constant = - point.dot( this.normal );\t// must be this.normal, not normal, as this.normal is normalized\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromCoplanarPoints: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\t\tvar v2 = new THREE.Vector3();\r\n\r\n\t\treturn function ( a, b, c ) {\r\n\r\n\t\t\tvar normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();\r\n\r\n\t\t\t// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?\r\n\r\n\t\t\tthis.setFromNormalAndCoplanarPoint( normal, a );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\r\n\tcopy: function ( plane ) {\r\n\r\n\t\tthis.normal.copy( plane.normal );\r\n\t\tthis.constant = plane.constant;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tnormalize: function () {\r\n\r\n\t\t// Note: will lead to a divide by zero if the plane is invalid.\r\n\r\n\t\tvar inverseNormalLength = 1.0 / this.normal.length();\r\n\t\tthis.normal.multiplyScalar( inverseNormalLength );\r\n\t\tthis.constant *= inverseNormalLength;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tnegate: function () {\r\n\r\n\t\tthis.constant *= - 1;\r\n\t\tthis.normal.negate();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdistanceToPoint: function ( point ) {\r\n\r\n\t\treturn this.normal.dot( point ) + this.constant;\r\n\r\n\t},\r\n\r\n\tdistanceToSphere: function ( sphere ) {\r\n\r\n\t\treturn this.distanceToPoint( sphere.center ) - sphere.radius;\r\n\r\n\t},\r\n\r\n\tprojectPoint: function ( point, optionalTarget ) {\r\n\r\n\t\treturn this.orthoPoint( point, optionalTarget ).sub( point ).negate();\r\n\r\n\t},\r\n\r\n\torthoPoint: function ( point, optionalTarget ) {\r\n\r\n\t\tvar perpendicularMagnitude = this.distanceToPoint( point );\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\treturn result.copy( this.normal ).multiplyScalar( perpendicularMagnitude );\r\n\r\n\t},\r\n\r\n\tisIntersectionLine: function ( line ) {\r\n\r\n\t\t// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.\r\n\r\n\t\tvar startSign = this.distanceToPoint( line.start );\r\n\t\tvar endSign = this.distanceToPoint( line.end );\r\n\r\n\t\treturn ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );\r\n\r\n\t},\r\n\r\n\tintersectLine: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function ( line, optionalTarget ) {\r\n\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\r\n\t\t\tvar direction = line.delta( v1 );\r\n\r\n\t\t\tvar denominator = this.normal.dot( direction );\r\n\r\n\t\t\tif ( denominator == 0 ) {\r\n\r\n\t\t\t\t// line is coplanar, return origin\r\n\t\t\t\tif ( this.distanceToPoint( line.start ) == 0 ) {\r\n\r\n\t\t\t\t\treturn result.copy( line.start );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Unsure if this is the correct method to handle this case.\r\n\t\t\t\treturn undefined;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;\r\n\r\n\t\t\tif ( t < 0 || t > 1 ) {\r\n\r\n\t\t\t\treturn undefined;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn result.copy( direction ).multiplyScalar( t ).add( line.start );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\r\n\tcoplanarPoint: function ( optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\treturn result.copy( this.normal ).multiplyScalar( - this.constant );\r\n\r\n\t},\r\n\r\n\tapplyMatrix4: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\t\tvar v2 = new THREE.Vector3();\r\n\t\tvar m1 = new THREE.Matrix3();\r\n\r\n\t\treturn function ( matrix, optionalNormalMatrix ) {\r\n\r\n\t\t\t// compute new normal based on theory here:\r\n\t\t\t// http://www.songho.ca/opengl/gl_normaltransform.html\r\n\t\t\tvar normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );\r\n\t\t\tvar newNormal = v1.copy( this.normal ).applyMatrix3( normalMatrix );\r\n\r\n\t\t\tvar newCoplanarPoint = this.coplanarPoint( v2 );\r\n\t\t\tnewCoplanarPoint.applyMatrix4( matrix );\r\n\r\n\t\t\tthis.setFromNormalAndCoplanarPoint( newNormal, newCoplanarPoint );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\ttranslate: function ( offset ) {\r\n\r\n\t\tthis.constant = this.constant - offset.dot( this.normal );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tequals: function ( plane ) {\r\n\r\n\t\treturn plane.normal.equals( this.normal ) && ( plane.constant == this.constant );\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new THREE.Plane().copy( this );\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/math/Math.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Math = {\r\n\r\n\tgenerateUUID: function () {\r\n\r\n\t\t// http://www.broofa.com/Tools/Math.uuid.htm\r\n\r\n\t\tvar chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split( '' );\r\n\t\tvar uuid = new Array( 36 );\r\n\t\tvar rnd = 0, r;\r\n\r\n\t\treturn function () {\r\n\r\n\t\t\tfor ( var i = 0; i < 36; i ++ ) {\r\n\r\n\t\t\t\tif ( i == 8 || i == 13 || i == 18 || i == 23 ) {\r\n\r\n\t\t\t\t\tuuid[ i ] = '-';\r\n\r\n\t\t\t\t} else if ( i == 14 ) {\r\n\r\n\t\t\t\t\tuuid[ i ] = '4';\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tif ( rnd <= 0x02 ) rnd = 0x2000000 + ( Math.random() * 0x1000000 ) | 0;\r\n\t\t\t\t\tr = rnd & 0xf;\r\n\t\t\t\t\trnd = rnd >> 4;\r\n\t\t\t\t\tuuid[ i ] = chars[ ( i == 19 ) ? ( r & 0x3 ) | 0x8 : r ];\r\n\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn uuid.join( '' );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\t// Clamp value to range <a, b>\r\n\r\n\tclamp: function ( x, a, b ) {\r\n\r\n\t\treturn ( x < a ) ? a : ( ( x > b ) ? b : x );\r\n\r\n\t},\r\n\r\n\t// Clamp value to range <a, inf)\r\n\r\n\tclampBottom: function ( x, a ) {\r\n\r\n\t\treturn x < a ? a : x;\r\n\r\n\t},\r\n\r\n\t// Linear mapping from range <a1, a2> to range <b1, b2>\r\n\r\n\tmapLinear: function ( x, a1, a2, b1, b2 ) {\r\n\r\n\t\treturn b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );\r\n\r\n\t},\r\n\r\n\t// http://en.wikipedia.org/wiki/Smoothstep\r\n\r\n\tsmoothstep: function ( x, min, max ) {\r\n\r\n\t\tif ( x <= min ) return 0;\r\n\t\tif ( x >= max ) return 1;\r\n\r\n\t\tx = ( x - min ) / ( max - min );\r\n\r\n\t\treturn x * x * ( 3 - 2 * x );\r\n\r\n\t},\r\n\r\n\tsmootherstep: function ( x, min, max ) {\r\n\r\n\t\tif ( x <= min ) return 0;\r\n\t\tif ( x >= max ) return 1;\r\n\r\n\t\tx = ( x - min ) / ( max - min );\r\n\r\n\t\treturn x * x * x * ( x * ( x * 6 - 15 ) + 10 );\r\n\r\n\t},\r\n\r\n\t// Random float from <0, 1> with 16 bits of randomness\r\n\t// (standard Math.random() creates repetitive patterns when applied over larger space)\r\n\r\n\trandom16: function () {\r\n\r\n\t\treturn ( 65280 * Math.random() + 255 * Math.random() ) / 65535;\r\n\r\n\t},\r\n\r\n\t// Random integer from <low, high> interval\r\n\r\n\trandInt: function ( low, high ) {\r\n\r\n\t\treturn Math.floor( this.randFloat( low, high ) );\r\n\r\n\t},\r\n\r\n\t// Random float from <low, high> interval\r\n\r\n\trandFloat: function ( low, high ) {\r\n\r\n\t\treturn low + Math.random() * ( high - low );\r\n\r\n\t},\r\n\r\n\t// Random float from <-range/2, range/2> interval\r\n\r\n\trandFloatSpread: function ( range ) {\r\n\r\n\t\treturn range * ( 0.5 - Math.random() );\r\n\r\n\t},\r\n\r\n\tdegToRad: function () {\r\n\r\n\t\tvar degreeToRadiansFactor = Math.PI / 180;\r\n\r\n\t\treturn function ( degrees ) {\r\n\r\n\t\t\treturn degrees * degreeToRadiansFactor;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tradToDeg: function () {\r\n\r\n\t\tvar radianToDegreesFactor = 180 / Math.PI;\r\n\r\n\t\treturn function ( radians ) {\r\n\r\n\t\t\treturn radians * radianToDegreesFactor;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tisPowerOfTwo: function ( value ) {\r\n\r\n\t\treturn ( value & ( value - 1 ) ) === 0 && value !== 0;\r\n\r\n\t},\r\n\r\n\tnextPowerOfTwo: function ( value ) {\r\n\r\n\t\tvalue --;\r\n\t\tvalue |= value >> 1;\r\n\t\tvalue |= value >> 2;\r\n\t\tvalue |= value >> 4;\r\n\t\tvalue |= value >> 8;\r\n\t\tvalue |= value >> 16;\r\n\t\tvalue ++;\r\n\r\n\t\treturn value;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/math/Spline.js\r\n\r\n/**\r\n * Spline from Tween.js, slightly optimized (and trashed)\r\n * http://sole.github.com/tween.js/examples/05_spline.html\r\n *\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Spline = function ( points ) {\r\n\r\n\tthis.points = points;\r\n\r\n\tvar c = [], v3 = { x: 0, y: 0, z: 0 },\r\n\tpoint, intPoint, weight, w2, w3,\r\n\tpa, pb, pc, pd;\r\n\r\n\tthis.initFromArray = function ( a ) {\r\n\r\n\t\tthis.points = [];\r\n\r\n\t\tfor ( var i = 0; i < a.length; i ++ ) {\r\n\r\n\t\t\tthis.points[ i ] = { x: a[ i ][ 0 ], y: a[ i ][ 1 ], z: a[ i ][ 2 ] };\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.getPoint = function ( k ) {\r\n\r\n\t\tpoint = ( this.points.length - 1 ) * k;\r\n\t\tintPoint = Math.floor( point );\r\n\t\tweight = point - intPoint;\r\n\r\n\t\tc[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;\r\n\t\tc[ 1 ] = intPoint;\r\n\t\tc[ 2 ] = intPoint  > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;\r\n\t\tc[ 3 ] = intPoint  > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;\r\n\r\n\t\tpa = this.points[ c[ 0 ] ];\r\n\t\tpb = this.points[ c[ 1 ] ];\r\n\t\tpc = this.points[ c[ 2 ] ];\r\n\t\tpd = this.points[ c[ 3 ] ];\r\n\r\n\t\tw2 = weight * weight;\r\n\t\tw3 = weight * w2;\r\n\r\n\t\tv3.x = interpolate( pa.x, pb.x, pc.x, pd.x, weight, w2, w3 );\r\n\t\tv3.y = interpolate( pa.y, pb.y, pc.y, pd.y, weight, w2, w3 );\r\n\t\tv3.z = interpolate( pa.z, pb.z, pc.z, pd.z, weight, w2, w3 );\r\n\r\n\t\treturn v3;\r\n\r\n\t};\r\n\r\n\tthis.getControlPointsArray = function () {\r\n\r\n\t\tvar i, p, l = this.points.length,\r\n\t\t\tcoords = [];\r\n\r\n\t\tfor ( i = 0; i < l; i ++ ) {\r\n\r\n\t\t\tp = this.points[ i ];\r\n\t\t\tcoords[ i ] = [ p.x, p.y, p.z ];\r\n\r\n\t\t}\r\n\r\n\t\treturn coords;\r\n\r\n\t};\r\n\r\n\t// approximate length by summing linear segments\r\n\r\n\tthis.getLength = function ( nSubDivisions ) {\r\n\r\n\t\tvar i, index, nSamples, position,\r\n\t\t\tpoint = 0, intPoint = 0, oldIntPoint = 0,\r\n\t\t\toldPosition = new THREE.Vector3(),\r\n\t\t\ttmpVec = new THREE.Vector3(),\r\n\t\t\tchunkLengths = [],\r\n\t\t\ttotalLength = 0;\r\n\r\n\t\t// first point has 0 length\r\n\r\n\t\tchunkLengths[ 0 ] = 0;\r\n\r\n\t\tif ( ! nSubDivisions ) nSubDivisions = 100;\r\n\r\n\t\tnSamples = this.points.length * nSubDivisions;\r\n\r\n\t\toldPosition.copy( this.points[ 0 ] );\r\n\r\n\t\tfor ( i = 1; i < nSamples; i ++ ) {\r\n\r\n\t\t\tindex = i / nSamples;\r\n\r\n\t\t\tposition = this.getPoint( index );\r\n\t\t\ttmpVec.copy( position );\r\n\r\n\t\t\ttotalLength += tmpVec.distanceTo( oldPosition );\r\n\r\n\t\t\toldPosition.copy( position );\r\n\r\n\t\t\tpoint = ( this.points.length - 1 ) * index;\r\n\t\t\tintPoint = Math.floor( point );\r\n\r\n\t\t\tif ( intPoint != oldIntPoint ) {\r\n\r\n\t\t\t\tchunkLengths[ intPoint ] = totalLength;\r\n\t\t\t\toldIntPoint = intPoint;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// last point ends with total length\r\n\r\n\t\tchunkLengths[ chunkLengths.length ] = totalLength;\r\n\r\n\t\treturn { chunks: chunkLengths, total: totalLength };\r\n\r\n\t};\r\n\r\n\tthis.reparametrizeByArcLength = function ( samplingCoef ) {\r\n\r\n\t\tvar i, j,\r\n\t\t\tindex, indexCurrent, indexNext,\r\n\t\t\trealDistance,\r\n\t\t\tsampling, position,\r\n\t\t\tnewpoints = [],\r\n\t\t\ttmpVec = new THREE.Vector3(),\r\n\t\t\tsl = this.getLength();\r\n\r\n\t\tnewpoints.push( tmpVec.copy( this.points[ 0 ] ).clone() );\r\n\r\n\t\tfor ( i = 1; i < this.points.length; i ++ ) {\r\n\r\n\t\t\t//tmpVec.copy( this.points[ i - 1 ] );\r\n\t\t\t//linearDistance = tmpVec.distanceTo( this.points[ i ] );\r\n\r\n\t\t\trealDistance = sl.chunks[ i ] - sl.chunks[ i - 1 ];\r\n\r\n\t\t\tsampling = Math.ceil( samplingCoef * realDistance / sl.total );\r\n\r\n\t\t\tindexCurrent = ( i - 1 ) / ( this.points.length - 1 );\r\n\t\t\tindexNext = i / ( this.points.length - 1 );\r\n\r\n\t\t\tfor ( j = 1; j < sampling - 1; j ++ ) {\r\n\r\n\t\t\t\tindex = indexCurrent + j * ( 1 / sampling ) * ( indexNext - indexCurrent );\r\n\r\n\t\t\t\tposition = this.getPoint( index );\r\n\t\t\t\tnewpoints.push( tmpVec.copy( position ).clone() );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tnewpoints.push( tmpVec.copy( this.points[ i ] ).clone() );\r\n\r\n\t\t}\r\n\r\n\t\tthis.points = newpoints;\r\n\r\n\t};\r\n\r\n\t// Catmull-Rom\r\n\r\n\tfunction interpolate( p0, p1, p2, p3, t, t2, t3 ) {\r\n\r\n\t\tvar v0 = ( p2 - p0 ) * 0.5,\r\n\t\t\tv1 = ( p3 - p1 ) * 0.5;\r\n\r\n\t\treturn ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;\r\n\r\n\t};\r\n\r\n};\r\n\r\n// File:src/math/Triangle.js\r\n\r\n/**\r\n * @author bhouston / http://exocortex.com\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Triangle = function ( a, b, c ) {\r\n\r\n\tthis.a = ( a !== undefined ) ? a : new THREE.Vector3();\r\n\tthis.b = ( b !== undefined ) ? b : new THREE.Vector3();\r\n\tthis.c = ( c !== undefined ) ? c : new THREE.Vector3();\r\n\r\n};\r\n\r\nTHREE.Triangle.normal = function () {\r\n\r\n\tvar v0 = new THREE.Vector3();\r\n\r\n\treturn function ( a, b, c, optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\r\n\t\tresult.subVectors( c, b );\r\n\t\tv0.subVectors( a, b );\r\n\t\tresult.cross( v0 );\r\n\r\n\t\tvar resultLengthSq = result.lengthSq();\r\n\t\tif ( resultLengthSq > 0 ) {\r\n\r\n\t\t\treturn result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn result.set( 0, 0, 0 );\r\n\r\n\t};\r\n\r\n}();\r\n\r\n// static/instance method to calculate barycoordinates\r\n// based on: http://www.blackpawn.com/texts/pointinpoly/default.html\r\nTHREE.Triangle.barycoordFromPoint = function () {\r\n\r\n\tvar v0 = new THREE.Vector3();\r\n\tvar v1 = new THREE.Vector3();\r\n\tvar v2 = new THREE.Vector3();\r\n\r\n\treturn function ( point, a, b, c, optionalTarget ) {\r\n\r\n\t\tv0.subVectors( c, a );\r\n\t\tv1.subVectors( b, a );\r\n\t\tv2.subVectors( point, a );\r\n\r\n\t\tvar dot00 = v0.dot( v0 );\r\n\t\tvar dot01 = v0.dot( v1 );\r\n\t\tvar dot02 = v0.dot( v2 );\r\n\t\tvar dot11 = v1.dot( v1 );\r\n\t\tvar dot12 = v1.dot( v2 );\r\n\r\n\t\tvar denom = ( dot00 * dot11 - dot01 * dot01 );\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\r\n\t\t// colinear or singular triangle\r\n\t\tif ( denom == 0 ) {\r\n\t\t\t// arbitrary location outside of triangle?\r\n\t\t\t// not sure if this is the best idea, maybe should be returning undefined\r\n\t\t\treturn result.set( - 2, - 1, - 1 );\r\n\t\t}\r\n\r\n\t\tvar invDenom = 1 / denom;\r\n\t\tvar u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;\r\n\t\tvar v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;\r\n\r\n\t\t// barycoordinates must always sum to 1\r\n\t\treturn result.set( 1 - u - v, v, u );\r\n\r\n\t};\r\n\r\n}();\r\n\r\nTHREE.Triangle.containsPoint = function () {\r\n\r\n\tvar v1 = new THREE.Vector3();\r\n\r\n\treturn function ( point, a, b, c ) {\r\n\r\n\t\tvar result = THREE.Triangle.barycoordFromPoint( point, a, b, c, v1 );\r\n\r\n\t\treturn ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );\r\n\r\n\t};\r\n\r\n}();\r\n\r\nTHREE.Triangle.prototype = {\r\n\r\n\tconstructor: THREE.Triangle,\r\n\r\n\tset: function ( a, b, c ) {\r\n\r\n\t\tthis.a.copy( a );\r\n\t\tthis.b.copy( b );\r\n\t\tthis.c.copy( c );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromPointsAndIndices: function ( points, i0, i1, i2 ) {\r\n\r\n\t\tthis.a.copy( points[ i0 ] );\r\n\t\tthis.b.copy( points[ i1 ] );\r\n\t\tthis.c.copy( points[ i2 ] );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopy: function ( triangle ) {\r\n\r\n\t\tthis.a.copy( triangle.a );\r\n\t\tthis.b.copy( triangle.b );\r\n\t\tthis.c.copy( triangle.c );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tarea: function () {\r\n\r\n\t\tvar v0 = new THREE.Vector3();\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function () {\r\n\r\n\t\t\tv0.subVectors( this.c, this.b );\r\n\t\t\tv1.subVectors( this.a, this.b );\r\n\r\n\t\t\treturn v0.cross( v1 ).length() * 0.5;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tmidpoint: function ( optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\treturn result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );\r\n\r\n\t},\r\n\r\n\tnormal: function ( optionalTarget ) {\r\n\r\n\t\treturn THREE.Triangle.normal( this.a, this.b, this.c, optionalTarget );\r\n\r\n\t},\r\n\r\n\tplane: function ( optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Plane();\r\n\r\n\t\treturn result.setFromCoplanarPoints( this.a, this.b, this.c );\r\n\r\n\t},\r\n\r\n\tbarycoordFromPoint: function ( point, optionalTarget ) {\r\n\r\n\t\treturn THREE.Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );\r\n\r\n\t},\r\n\r\n\tcontainsPoint: function ( point ) {\r\n\r\n\t\treturn THREE.Triangle.containsPoint( point, this.a, this.b, this.c );\r\n\r\n\t},\r\n\r\n\tequals: function ( triangle ) {\r\n\r\n\t\treturn triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new THREE.Triangle().copy( this );\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/core/Clock.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Clock = function ( autoStart ) {\r\n\r\n\tthis.autoStart = ( autoStart !== undefined ) ? autoStart : true;\r\n\r\n\tthis.startTime = 0;\r\n\tthis.oldTime = 0;\r\n\tthis.elapsedTime = 0;\r\n\r\n\tthis.running = false;\r\n\r\n};\r\n\r\nTHREE.Clock.prototype = {\r\n\r\n\tconstructor: THREE.Clock,\r\n\r\n\tstart: function () {\r\n\r\n\t\tthis.startTime = self.performance !== undefined && self.performance.now !== undefined\r\n\t\t\t\t\t ? self.performance.now()\r\n\t\t\t\t\t : Date.now();\r\n\r\n\t\tthis.oldTime = this.startTime;\r\n\t\tthis.running = true;\r\n\t},\r\n\r\n\tstop: function () {\r\n\r\n\t\tthis.getElapsedTime();\r\n\t\tthis.running = false;\r\n\r\n\t},\r\n\r\n\tgetElapsedTime: function () {\r\n\r\n\t\tthis.getDelta();\r\n\t\treturn this.elapsedTime;\r\n\r\n\t},\r\n\r\n\tgetDelta: function () {\r\n\r\n\t\tvar diff = 0;\r\n\r\n\t\tif ( this.autoStart && ! this.running ) {\r\n\r\n\t\t\tthis.start();\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.running ) {\r\n\r\n\t\t\tvar newTime = self.performance !== undefined && self.performance.now !== undefined\r\n\t\t\t\t\t ? self.performance.now()\r\n\t\t\t\t\t : Date.now();\r\n\r\n\t\t\tdiff = 0.001 * ( newTime - this.oldTime );\r\n\t\t\tthis.oldTime = newTime;\r\n\r\n\t\t\tthis.elapsedTime += diff;\r\n\r\n\t\t}\r\n\r\n\t\treturn diff;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/core/EventDispatcher.js\r\n\r\n/**\r\n * https://github.com/mrdoob/eventdispatcher.js/\r\n */\r\n\r\nTHREE.EventDispatcher = function () {}\r\n\r\nTHREE.EventDispatcher.prototype = {\r\n\r\n\tconstructor: THREE.EventDispatcher,\r\n\r\n\tapply: function ( object ) {\r\n\r\n\t\tobject.addEventListener = THREE.EventDispatcher.prototype.addEventListener;\r\n\t\tobject.hasEventListener = THREE.EventDispatcher.prototype.hasEventListener;\r\n\t\tobject.removeEventListener = THREE.EventDispatcher.prototype.removeEventListener;\r\n\t\tobject.dispatchEvent = THREE.EventDispatcher.prototype.dispatchEvent;\r\n\r\n\t},\r\n\r\n\taddEventListener: function ( type, listener ) {\r\n\r\n\t\tif ( this._listeners === undefined ) this._listeners = {};\r\n\r\n\t\tvar listeners = this._listeners;\r\n\r\n\t\tif ( listeners[ type ] === undefined ) {\r\n\r\n\t\t\tlisteners[ type ] = [];\r\n\r\n\t\t}\r\n\r\n\t\tif ( listeners[ type ].indexOf( listener ) === - 1 ) {\r\n\r\n\t\t\tlisteners[ type ].push( listener );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\thasEventListener: function ( type, listener ) {\r\n\r\n\t\tif ( this._listeners === undefined ) return false;\r\n\r\n\t\tvar listeners = this._listeners;\r\n\r\n\t\tif ( listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1 ) {\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\r\n\t},\r\n\r\n\tremoveEventListener: function ( type, listener ) {\r\n\r\n\t\tif ( this._listeners === undefined ) return;\r\n\r\n\t\tvar listeners = this._listeners;\r\n\t\tvar listenerArray = listeners[ type ];\r\n\r\n\t\tif ( listenerArray !== undefined ) {\r\n\r\n\t\t\tvar index = listenerArray.indexOf( listener );\r\n\r\n\t\t\tif ( index !== - 1 ) {\r\n\r\n\t\t\t\tlistenerArray.splice( index, 1 );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tdispatchEvent: function ( event ) {\r\n\r\n\t\tif ( this._listeners === undefined ) return;\r\n\r\n\t\tvar listeners = this._listeners;\r\n\t\tvar listenerArray = listeners[ event.type ];\r\n\r\n\t\tif ( listenerArray !== undefined ) {\r\n\r\n\t\t\tevent.target = this;\r\n\r\n\t\t\tvar array = [];\r\n\t\t\tvar length = listenerArray.length;\r\n\r\n\t\t\tfor ( var i = 0; i < length; i ++ ) {\r\n\r\n\t\t\t\tarray[ i ] = listenerArray[ i ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var i = 0; i < length; i ++ ) {\r\n\r\n\t\t\t\tarray[ i ].call( this, event );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/core/Raycaster.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author bhouston / http://exocortex.com/\r\n * @author stephomi / http://stephaneginier.com/\r\n */\r\n\r\n( function ( THREE ) {\r\n\r\n\tTHREE.Raycaster = function ( origin, direction, near, far ) {\r\n\r\n\t\tthis.ray = new THREE.Ray( origin, direction );\r\n\t\t// direction is assumed to be normalized (for accurate distance calculations)\r\n\r\n\t\tthis.near = near || 0;\r\n\t\tthis.far = far || Infinity;\r\n\r\n\t\tthis.params = {\r\n\t\t\tSprite: {},\r\n\t\t\tMesh: {},\r\n\t\t\tPointCloud: { threshold: 1 },\r\n\t\t\tLOD: {},\r\n\t\t\tLine: {}\r\n\t\t};\r\n\r\n\t};\r\n\r\n\tvar descSort = function ( a, b ) {\r\n\r\n\t\treturn a.distance - b.distance;\r\n\r\n\t};\r\n\r\n\tvar intersectObject = function ( object, raycaster, intersects, recursive ) {\r\n\r\n\t\tobject.raycast( raycaster, intersects );\r\n\r\n\t\tif ( recursive === true ) {\r\n\r\n\t\t\tvar children = object.children;\r\n\r\n\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tintersectObject( children[ i ], raycaster, intersects, true );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t//\r\n\r\n\tTHREE.Raycaster.prototype = {\r\n\r\n\t\tconstructor: THREE.Raycaster,\r\n\r\n\t\tprecision: 0.0001,\r\n\t\tlinePrecision: 1,\r\n\r\n\t\tset: function ( origin, direction ) {\r\n\r\n\t\t\t// direction is assumed to be normalized (for accurate distance calculations)\r\n\r\n\t\t\tthis.ray.set( origin, direction );\r\n\r\n\t\t},\r\n\r\n\t\tsetFromCamera: function ( coords, camera ) {\r\n\r\n\t\t\t// camera is assumed _not_ to be a child of a transformed object\r\n\r\n\t\t\tif ( camera instanceof THREE.PerspectiveCamera ) {\r\n\r\n\t\t\t\tthis.ray.origin.copy( camera.position );\r\n\t\t\t\tthis.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( camera.position ).normalize();\r\n\r\n\t\t\t} else if ( camera instanceof THREE.OrthographicCamera ) {\r\n\r\n\t\t\t\tthis.ray.origin.set( coords.x, coords.y, - 1 ).unproject( camera );\r\n\t\t\t\tthis.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tTHREE.error( 'THREE.Raycaster: Unsupported camera type.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\t\tintersectObject: function ( object, recursive ) {\r\n\r\n\t\t\tvar intersects = [];\r\n\r\n\t\t\tintersectObject( object, this, intersects, recursive );\r\n\r\n\t\t\tintersects.sort( descSort );\r\n\r\n\t\t\treturn intersects;\r\n\r\n\t\t},\r\n\r\n\t\tintersectObjects: function ( objects, recursive ) {\r\n\r\n\t\t\tvar intersects = [];\r\n\r\n\t\t\tif ( objects instanceof Array === false ) {\r\n\r\n\t\t\t\tTHREE.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );\r\n\t\t\t\treturn intersects;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var i = 0, l = objects.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tintersectObject( objects[ i ], this, intersects, recursive );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tintersects.sort( descSort );\r\n\r\n\t\t\treturn intersects;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n}( THREE ) );\r\n\r\n// File:src/core/Object3D.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\r\n\r\nTHREE.Object3D = function () {\r\n\r\n\tObject.defineProperty( this, 'id', { value: THREE.Object3DIdCount ++ } );\r\n\r\n\tthis.uuid = THREE.Math.generateUUID();\r\n\r\n\tthis.name = '';\r\n\tthis.type = 'Object3D';\r\n\r\n\tthis.parent = undefined;\r\n\tthis.children = [];\r\n\r\n\tthis.up = THREE.Object3D.DefaultUp.clone();\r\n\r\n\tvar position = new THREE.Vector3();\r\n\tvar rotation = new THREE.Euler();\r\n\tvar quaternion = new THREE.Quaternion();\r\n\tvar scale = new THREE.Vector3( 1, 1, 1 );\r\n\r\n\tvar onRotationChange = function () {\r\n\t\tquaternion.setFromEuler( rotation, false );\r\n\t};\r\n\r\n\tvar onQuaternionChange = function () {\r\n\t\trotation.setFromQuaternion( quaternion, undefined, false );\r\n\t};\r\n\r\n\trotation.onChange( onRotationChange );\r\n\tquaternion.onChange( onQuaternionChange );\r\n\r\n\tObject.defineProperties( this, {\r\n\t\tposition: {\r\n\t\t\tenumerable: true,\r\n\t\t\tvalue: position\r\n\t\t},\r\n\t\trotation: {\r\n\t\t\tenumerable: true,\r\n\t\t\tvalue: rotation\r\n\t\t},\r\n\t\tquaternion: {\r\n\t\t\tenumerable: true,\r\n\t\t\tvalue: quaternion\r\n\t\t},\r\n\t\tscale: {\r\n\t\t\tenumerable: true,\r\n\t\t\tvalue: scale\r\n\t\t}\r\n\t} );\r\n\r\n\tthis.rotationAutoUpdate = true;\r\n\r\n\tthis.matrix = new THREE.Matrix4();\r\n\tthis.matrixWorld = new THREE.Matrix4();\r\n\r\n\tthis.matrixAutoUpdate = true;\r\n\tthis.matrixWorldNeedsUpdate = false;\r\n\r\n\tthis.visible = true;\r\n\r\n\tthis.castShadow = false;\r\n\tthis.receiveShadow = false;\r\n\r\n\tthis.frustumCulled = true;\r\n\tthis.renderOrder = 0;\r\n\r\n\tthis.userData = {};\r\n\r\n};\r\n\r\nTHREE.Object3D.DefaultUp = new THREE.Vector3( 0, 1, 0 );\r\n\r\nTHREE.Object3D.prototype = {\r\n\r\n\tconstructor: THREE.Object3D,\r\n\r\n\tget eulerOrder () {\r\n\r\n\t\tTHREE.warn( 'THREE.Object3D: .eulerOrder has been moved to .rotation.order.' );\r\n\r\n\t\treturn this.rotation.order;\r\n\r\n\t},\r\n\r\n\tset eulerOrder ( value ) {\r\n\r\n\t\tTHREE.warn( 'THREE.Object3D: .eulerOrder has been moved to .rotation.order.' );\r\n\r\n\t\tthis.rotation.order = value;\r\n\r\n\t},\r\n\r\n\tget useQuaternion () {\r\n\r\n\t\tTHREE.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );\r\n\r\n\t},\r\n\r\n\tset useQuaternion ( value ) {\r\n\r\n\t\tTHREE.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );\r\n\r\n\t},\r\n\r\n\tapplyMatrix: function ( matrix ) {\r\n\r\n\t\tthis.matrix.multiplyMatrices( matrix, this.matrix );\r\n\r\n\t\tthis.matrix.decompose( this.position, this.quaternion, this.scale );\r\n\r\n\t},\r\n\r\n\tsetRotationFromAxisAngle: function ( axis, angle ) {\r\n\r\n\t\t// assumes axis is normalized\r\n\r\n\t\tthis.quaternion.setFromAxisAngle( axis, angle );\r\n\r\n\t},\r\n\r\n\tsetRotationFromEuler: function ( euler ) {\r\n\r\n\t\tthis.quaternion.setFromEuler( euler, true );\r\n\r\n\t},\r\n\r\n\tsetRotationFromMatrix: function ( m ) {\r\n\r\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\r\n\r\n\t\tthis.quaternion.setFromRotationMatrix( m );\r\n\r\n\t},\r\n\r\n\tsetRotationFromQuaternion: function ( q ) {\r\n\r\n\t\t// assumes q is normalized\r\n\r\n\t\tthis.quaternion.copy( q );\r\n\r\n\t},\r\n\r\n\trotateOnAxis: function () {\r\n\r\n\t\t// rotate object on axis in object space\r\n\t\t// axis is assumed to be normalized\r\n\r\n\t\tvar q1 = new THREE.Quaternion();\r\n\r\n\t\treturn function ( axis, angle ) {\r\n\r\n\t\t\tq1.setFromAxisAngle( axis, angle );\r\n\r\n\t\t\tthis.quaternion.multiply( q1 );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t}(),\r\n\r\n\trotateX: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3( 1, 0, 0 );\r\n\r\n\t\treturn function ( angle ) {\r\n\r\n\t\t\treturn this.rotateOnAxis( v1, angle );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\trotateY: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3( 0, 1, 0 );\r\n\r\n\t\treturn function ( angle ) {\r\n\r\n\t\t\treturn this.rotateOnAxis( v1, angle );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\trotateZ: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3( 0, 0, 1 );\r\n\r\n\t\treturn function ( angle ) {\r\n\r\n\t\t\treturn this.rotateOnAxis( v1, angle );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\ttranslateOnAxis: function () {\r\n\r\n\t\t// translate object by distance along axis in object space\r\n\t\t// axis is assumed to be normalized\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function ( axis, distance ) {\r\n\r\n\t\t\tv1.copy( axis ).applyQuaternion( this.quaternion );\r\n\r\n\t\t\tthis.position.add( v1.multiplyScalar( distance ) );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t}(),\r\n\r\n\ttranslate: function ( distance, axis ) {\r\n\r\n\t\tTHREE.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );\r\n\t\treturn this.translateOnAxis( axis, distance );\r\n\r\n\t},\r\n\r\n\ttranslateX: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3( 1, 0, 0 );\r\n\r\n\t\treturn function ( distance ) {\r\n\r\n\t\t\treturn this.translateOnAxis( v1, distance );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\ttranslateY: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3( 0, 1, 0 );\r\n\r\n\t\treturn function ( distance ) {\r\n\r\n\t\t\treturn this.translateOnAxis( v1, distance );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\ttranslateZ: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3( 0, 0, 1 );\r\n\r\n\t\treturn function ( distance ) {\r\n\r\n\t\t\treturn this.translateOnAxis( v1, distance );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tlocalToWorld: function ( vector ) {\r\n\r\n\t\treturn vector.applyMatrix4( this.matrixWorld );\r\n\r\n\t},\r\n\r\n\tworldToLocal: function () {\r\n\r\n\t\tvar m1 = new THREE.Matrix4();\r\n\r\n\t\treturn function ( vector ) {\r\n\r\n\t\t\treturn vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tlookAt: function () {\r\n\r\n\t\t// This routine does not support objects with rotated and/or translated parent(s)\r\n\r\n\t\tvar m1 = new THREE.Matrix4();\r\n\r\n\t\treturn function ( vector ) {\r\n\r\n\t\t\tm1.lookAt( vector, this.position, this.up );\r\n\r\n\t\t\tthis.quaternion.setFromRotationMatrix( m1 );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tadd: function ( object ) {\r\n\r\n\t\tif ( arguments.length > 1 ) {\r\n\r\n\t\t\tfor ( var i = 0; i < arguments.length; i ++ ) {\r\n\r\n\t\t\t\tthis.add( arguments[ i ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t\tif ( object === this ) {\r\n\r\n\t\t\tTHREE.error( \"THREE.Object3D.add: object can't be added as a child of itself.\", object );\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\tif ( object instanceof THREE.Object3D ) {\r\n\r\n\t\t\tif ( object.parent !== undefined ) {\r\n\r\n\t\t\t\tobject.parent.remove( object );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tobject.parent = this;\r\n\t\t\tobject.dispatchEvent( { type: 'added' } );\r\n\r\n\t\t\tthis.children.push( object );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tTHREE.error( \"THREE.Object3D.add: object not an instance of THREE.Object3D.\", object );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tremove: function ( object ) {\r\n\r\n\t\tif ( arguments.length > 1 ) {\r\n\r\n\t\t\tfor ( var i = 0; i < arguments.length; i ++ ) {\r\n\r\n\t\t\t\tthis.remove( arguments[ i ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t\tvar index = this.children.indexOf( object );\r\n\r\n\t\tif ( index !== - 1 ) {\r\n\r\n\t\t\tobject.parent = undefined;\r\n\r\n\t\t\tobject.dispatchEvent( { type: 'removed' } );\r\n\r\n\t\t\tthis.children.splice( index, 1 );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tgetChildByName: function ( name ) {\r\n\r\n\t\tTHREE.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );\r\n\t\treturn this.getObjectByName( name );\r\n\r\n\t},\r\n\r\n\tgetObjectById: function ( id ) {\r\n\r\n\t\treturn this.getObjectByProperty( 'id', id );\r\n\r\n\t},\r\n\r\n\tgetObjectByName: function ( name ) {\r\n\r\n\t\treturn this.getObjectByProperty( 'name', name );\r\n\r\n\t},\r\n\r\n\tgetObjectByProperty: function ( name, value ) {\r\n\r\n\t\tif ( this[ name ] === value ) return this;\r\n\r\n\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar child = this.children[ i ];\r\n\t\t\tvar object = child.getObjectByProperty( name, value );\r\n\r\n\t\t\tif ( object !== undefined ) {\r\n\r\n\t\t\t\treturn object;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn undefined;\r\n\r\n\t},\r\n\r\n\tgetWorldPosition: function ( optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\r\n\t\tthis.updateMatrixWorld( true );\r\n\r\n\t\treturn result.setFromMatrixPosition( this.matrixWorld );\r\n\r\n\t},\r\n\r\n\tgetWorldQuaternion: function () {\r\n\r\n\t\tvar position = new THREE.Vector3();\r\n\t\tvar scale = new THREE.Vector3();\r\n\r\n\t\treturn function ( optionalTarget ) {\r\n\r\n\t\t\tvar result = optionalTarget || new THREE.Quaternion();\r\n\r\n\t\t\tthis.updateMatrixWorld( true );\r\n\r\n\t\t\tthis.matrixWorld.decompose( position, result, scale );\r\n\r\n\t\t\treturn result;\r\n\r\n\t\t}\r\n\r\n\t}(),\r\n\r\n\tgetWorldRotation: function () {\r\n\r\n\t\tvar quaternion = new THREE.Quaternion();\r\n\r\n\t\treturn function ( optionalTarget ) {\r\n\r\n\t\t\tvar result = optionalTarget || new THREE.Euler();\r\n\r\n\t\t\tthis.getWorldQuaternion( quaternion );\r\n\r\n\t\t\treturn result.setFromQuaternion( quaternion, this.rotation.order, false );\r\n\r\n\t\t}\r\n\r\n\t}(),\r\n\r\n\tgetWorldScale: function () {\r\n\r\n\t\tvar position = new THREE.Vector3();\r\n\t\tvar quaternion = new THREE.Quaternion();\r\n\r\n\t\treturn function ( optionalTarget ) {\r\n\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\r\n\t\t\tthis.updateMatrixWorld( true );\r\n\r\n\t\t\tthis.matrixWorld.decompose( position, quaternion, result );\r\n\r\n\t\t\treturn result;\r\n\r\n\t\t}\r\n\r\n\t}(),\r\n\r\n\tgetWorldDirection: function () {\r\n\r\n\t\tvar quaternion = new THREE.Quaternion();\r\n\r\n\t\treturn function ( optionalTarget ) {\r\n\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\r\n\t\t\tthis.getWorldQuaternion( quaternion );\r\n\r\n\t\t\treturn result.set( 0, 0, 1 ).applyQuaternion( quaternion );\r\n\r\n\t\t}\r\n\r\n\t}(),\r\n\r\n\traycast: function () {},\r\n\r\n\ttraverse: function ( callback ) {\r\n\r\n\t\tcallback( this );\r\n\r\n\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\r\n\r\n\t\t\tthis.children[ i ].traverse( callback );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\ttraverseVisible: function ( callback ) {\r\n\r\n\t\tif ( this.visible === false ) return;\r\n\r\n\t\tcallback( this );\r\n\r\n\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\r\n\r\n\t\t\tthis.children[ i ].traverseVisible( callback );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\ttraverseAncestors: function ( callback ) {\r\n\r\n\t\tif ( this.parent ) {\r\n\r\n\t\t\tcallback( this.parent );\r\n\r\n\t\t\tthis.parent.traverseAncestors( callback );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tupdateMatrix: function () {\r\n\r\n\t\tthis.matrix.compose( this.position, this.quaternion, this.scale );\r\n\r\n\t\tthis.matrixWorldNeedsUpdate = true;\r\n\r\n\t},\r\n\r\n\tupdateMatrixWorld: function ( force ) {\r\n\r\n\t\tif ( this.matrixAutoUpdate === true ) this.updateMatrix();\r\n\r\n\t\tif ( this.matrixWorldNeedsUpdate === true || force === true ) {\r\n\r\n\t\t\tif ( this.parent === undefined ) {\r\n\r\n\t\t\t\tthis.matrixWorld.copy( this.matrix );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.matrixWorldNeedsUpdate = false;\r\n\r\n\t\t\tforce = true;\r\n\r\n\t\t}\r\n\r\n\t\t// update children\r\n\r\n\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\r\n\r\n\t\t\tthis.children[ i ].updateMatrixWorld( force );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\ttoJSON: function () {\r\n\r\n\t\tvar output = {\r\n\t\t\tmetadata: {\r\n\t\t\t\tversion: 4.3,\r\n\t\t\t\ttype: 'Object',\r\n\t\t\t\tgenerator: 'ObjectExporter'\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t//\r\n\r\n\t\tvar geometries = {};\r\n\r\n\t\tvar parseGeometry = function ( geometry ) {\r\n\r\n\t\t\tif ( output.geometries === undefined ) {\r\n\r\n\t\t\t\toutput.geometries = [];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( geometries[ geometry.uuid ] === undefined ) {\r\n\r\n\t\t\t\tvar json = geometry.toJSON();\r\n\r\n\t\t\t\tdelete json.metadata;\r\n\r\n\t\t\t\tgeometries[ geometry.uuid ] = json;\r\n\r\n\t\t\t\toutput.geometries.push( json );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn geometry.uuid;\r\n\r\n\t\t};\r\n\r\n\t\t//\r\n\r\n\t\tvar materials = {};\r\n\r\n\t\tvar parseMaterial = function ( material ) {\r\n\r\n\t\t\tif ( output.materials === undefined ) {\r\n\r\n\t\t\t\toutput.materials = [];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( materials[ material.uuid ] === undefined ) {\r\n\r\n\t\t\t\tvar json = material.toJSON();\r\n\r\n\t\t\t\tdelete json.metadata;\r\n\r\n\t\t\t\tmaterials[ material.uuid ] = json;\r\n\r\n\t\t\t\toutput.materials.push( json );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn material.uuid;\r\n\r\n\t\t};\r\n\r\n\t\t//\r\n\r\n\t\tvar parseObject = function ( object ) {\r\n\r\n\t\t\tvar data = {};\r\n\r\n\t\t\tdata.uuid = object.uuid;\r\n\t\t\tdata.type = object.type;\r\n\r\n\t\t\tif ( object.name !== '' ) data.name = object.name;\r\n\t\t\tif ( JSON.stringify( object.userData ) !== '{}' ) data.userData = object.userData;\r\n\t\t\tif ( object.visible !== true ) data.visible = object.visible;\r\n\r\n\t\t\tif ( object instanceof THREE.PerspectiveCamera ) {\r\n\r\n\t\t\t\tdata.fov = object.fov;\r\n\t\t\t\tdata.aspect = object.aspect;\r\n\t\t\t\tdata.near = object.near;\r\n\t\t\t\tdata.far = object.far;\r\n\r\n\t\t\t} else if ( object instanceof THREE.OrthographicCamera ) {\r\n\r\n\t\t\t\tdata.left = object.left;\r\n\t\t\t\tdata.right = object.right;\r\n\t\t\t\tdata.top = object.top;\r\n\t\t\t\tdata.bottom = object.bottom;\r\n\t\t\t\tdata.near = object.near;\r\n\t\t\t\tdata.far = object.far;\r\n\r\n\t\t\t} else if ( object instanceof THREE.AmbientLight ) {\r\n\r\n\t\t\t\tdata.color = object.color.getHex();\r\n\r\n\t\t\t} else if ( object instanceof THREE.DirectionalLight ) {\r\n\r\n\t\t\t\tdata.color = object.color.getHex();\r\n\t\t\t\tdata.intensity = object.intensity;\r\n\r\n\t\t\t} else if ( object instanceof THREE.PointLight ) {\r\n\r\n\t\t\t\tdata.color = object.color.getHex();\r\n\t\t\t\tdata.intensity = object.intensity;\r\n\t\t\t\tdata.distance = object.distance;\r\n\t\t\t\tdata.decay = object.decay;\r\n\r\n\t\t\t} else if ( object instanceof THREE.SpotLight ) {\r\n\r\n\t\t\t\tdata.color = object.color.getHex();\r\n\t\t\t\tdata.intensity = object.intensity;\r\n\t\t\t\tdata.distance = object.distance;\r\n\t\t\t\tdata.angle = object.angle;\r\n\t\t\t\tdata.exponent = object.exponent;\r\n\t\t\t\tdata.decay = object.decay;\r\n\r\n\t\t\t} else if ( object instanceof THREE.HemisphereLight ) {\r\n\r\n\t\t\t\tdata.color = object.color.getHex();\r\n\t\t\t\tdata.groundColor = object.groundColor.getHex();\r\n\r\n\t\t\t} else if ( object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.PointCloud ) {\r\n\r\n\t\t\t\tdata.geometry = parseGeometry( object.geometry );\r\n\t\t\t\tdata.material = parseMaterial( object.material );\r\n\r\n\t\t\t\tif ( object instanceof THREE.Line ) data.mode = object.mode;\r\n\r\n\t\t\t} else if ( object instanceof THREE.Sprite ) {\r\n\r\n\t\t\t\tdata.material = parseMaterial( object.material );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tdata.matrix = object.matrix.toArray();\r\n\r\n\t\t\tif ( object.children.length > 0 ) {\r\n\r\n\t\t\t\tdata.children = [];\r\n\r\n\t\t\t\tfor ( var i = 0; i < object.children.length; i ++ ) {\r\n\r\n\t\t\t\t\tdata.children.push( parseObject( object.children[ i ] ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn data;\r\n\r\n\t\t}\r\n\r\n\t\toutput.object = parseObject( this );\r\n\r\n\t\treturn output;\r\n\r\n\t},\r\n\r\n\tclone: function ( object, recursive ) {\r\n\r\n\t\tif ( object === undefined ) object = new THREE.Object3D();\r\n\t\tif ( recursive === undefined ) recursive = true;\r\n\r\n\t\tobject.name = this.name;\r\n\r\n\t\tobject.up.copy( this.up );\r\n\r\n\t\tobject.position.copy( this.position );\r\n\t\tobject.quaternion.copy( this.quaternion );\r\n\t\tobject.scale.copy( this.scale );\r\n\r\n\t\tobject.rotationAutoUpdate = this.rotationAutoUpdate;\r\n\r\n\t\tobject.matrix.copy( this.matrix );\r\n\t\tobject.matrixWorld.copy( this.matrixWorld );\r\n\r\n\t\tobject.matrixAutoUpdate = this.matrixAutoUpdate;\r\n\t\tobject.matrixWorldNeedsUpdate = this.matrixWorldNeedsUpdate;\r\n\r\n\t\tobject.visible = this.visible;\r\n\r\n\t\tobject.castShadow = this.castShadow;\r\n\t\tobject.receiveShadow = this.receiveShadow;\r\n\r\n\t\tobject.frustumCulled = this.frustumCulled;\r\n\r\n\t\tobject.userData = JSON.parse( JSON.stringify( this.userData ) );\r\n\r\n\t\tif ( recursive === true ) {\r\n\r\n\t\t\tfor ( var i = 0; i < this.children.length; i ++ ) {\r\n\r\n\t\t\t\tvar child = this.children[ i ];\r\n\t\t\t\tobject.add( child.clone() );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn object;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.EventDispatcher.prototype.apply( THREE.Object3D.prototype );\r\n\r\nTHREE.Object3DIdCount = 0;\r\n\r\n// File:src/core/Face3.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Face3 = function ( a, b, c, normal, color, materialIndex ) {\r\n\r\n\tthis.a = a;\r\n\tthis.b = b;\r\n\tthis.c = c;\r\n\r\n\tthis.normal = normal instanceof THREE.Vector3 ? normal : new THREE.Vector3();\r\n\tthis.vertexNormals = normal instanceof Array ? normal : [];\r\n\r\n\tthis.color = color instanceof THREE.Color ? color : new THREE.Color();\r\n\tthis.vertexColors = color instanceof Array ? color : [];\r\n\r\n\tthis.vertexTangents = [];\r\n\r\n\tthis.materialIndex = materialIndex !== undefined ? materialIndex : 0;\r\n\r\n};\r\n\r\nTHREE.Face3.prototype = {\r\n\r\n\tconstructor: THREE.Face3,\r\n\r\n\tclone: function () {\r\n\r\n\t\tvar face = new THREE.Face3( this.a, this.b, this.c );\r\n\r\n\t\tface.normal.copy( this.normal );\r\n\t\tface.color.copy( this.color );\r\n\r\n\t\tface.materialIndex = this.materialIndex;\r\n\r\n\t\tfor ( var i = 0, il = this.vertexNormals.length; i < il; i ++ ) {\r\n\r\n\t\t\tface.vertexNormals[ i ] = this.vertexNormals[ i ].clone();\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var i = 0, il = this.vertexColors.length; i < il; i ++ ) {\r\n\r\n\t\t\tface.vertexColors[ i ] = this.vertexColors[ i ].clone();\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var i = 0, il = this.vertexTangents.length; i < il; i ++ ) {\r\n\r\n\t\t\tface.vertexTangents[ i ] = this.vertexTangents[ i ].clone();\r\n\r\n\t\t}\r\n\r\n\t\treturn face;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/core/Face4.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Face4 = function ( a, b, c, d, normal, color, materialIndex ) {\r\n\r\n\tTHREE.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' )\r\n\treturn new THREE.Face3( a, b, c, normal, color, materialIndex );\r\n\r\n};\r\n\r\n// File:src/core/BufferAttribute.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.BufferAttribute = function ( array, itemSize ) {\r\n\r\n\tthis.array = array;\r\n\tthis.itemSize = itemSize;\r\n\r\n\tthis.needsUpdate = false;\r\n\r\n};\r\n\r\nTHREE.BufferAttribute.prototype = {\r\n\r\n\tconstructor: THREE.BufferAttribute,\r\n\r\n\tget length () {\r\n\r\n\t\treturn this.array.length;\r\n\r\n\t},\r\n\r\n\tcopyAt: function ( index1, attribute, index2 ) {\r\n\r\n\t\tindex1 *= this.itemSize;\r\n\t\tindex2 *= attribute.itemSize;\r\n\r\n\t\tfor ( var i = 0, l = this.itemSize; i < l; i ++ ) {\r\n\r\n\t\t\tthis.array[ index1 + i ] = attribute.array[ index2 + i ];\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tset: function ( value, offset ) {\r\n\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tthis.array.set( value, offset );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetX: function ( index, x ) {\r\n\r\n\t\tthis.array[ index * this.itemSize ] = x;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetY: function ( index, y ) {\r\n\r\n\t\tthis.array[ index * this.itemSize + 1 ] = y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetZ: function ( index, z ) {\r\n\r\n\t\tthis.array[ index * this.itemSize + 2 ] = z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetXY: function ( index, x, y ) {\r\n\r\n\t\tindex *= this.itemSize;\r\n\r\n\t\tthis.array[ index     ] = x;\r\n\t\tthis.array[ index + 1 ] = y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetXYZ: function ( index, x, y, z ) {\r\n\r\n\t\tindex *= this.itemSize;\r\n\r\n\t\tthis.array[ index     ] = x;\r\n\t\tthis.array[ index + 1 ] = y;\r\n\t\tthis.array[ index + 2 ] = z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetXYZW: function ( index, x, y, z, w ) {\r\n\r\n\t\tindex *= this.itemSize;\r\n\r\n\t\tthis.array[ index     ] = x;\r\n\t\tthis.array[ index + 1 ] = y;\r\n\t\tthis.array[ index + 2 ] = z;\r\n\t\tthis.array[ index + 3 ] = w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new THREE.BufferAttribute( new this.array.constructor( this.array ), this.itemSize );\r\n\r\n\t}\r\n\r\n};\r\n\r\n//\r\n\r\nTHREE.Int8Attribute = function ( data, itemSize ) {\r\n\r\n\tTHREE.warn( 'THREE.Int8Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );\r\n\treturn new THREE.BufferAttribute( data, itemSize );\r\n\r\n};\r\n\r\nTHREE.Uint8Attribute = function ( data, itemSize ) {\r\n\r\n\tTHREE.warn( 'THREE.Uint8Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );\r\n\treturn new THREE.BufferAttribute( data, itemSize );\r\n\r\n};\r\n\r\nTHREE.Uint8ClampedAttribute = function ( data, itemSize ) {\r\n\r\n\tTHREE.warn( 'THREE.Uint8ClampedAttribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );\r\n\treturn new THREE.BufferAttribute( data, itemSize );\r\n\r\n\r\n};\r\n\r\nTHREE.Int16Attribute = function ( data, itemSize ) {\r\n\r\n\tTHREE.warn( 'THREE.Int16Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );\r\n\treturn new THREE.BufferAttribute( data, itemSize );\r\n\r\n};\r\n\r\nTHREE.Uint16Attribute = function ( data, itemSize ) {\r\n\r\n\tTHREE.warn( 'THREE.Uint16Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );\r\n\treturn new THREE.BufferAttribute( data, itemSize );\r\n\r\n};\r\n\r\nTHREE.Int32Attribute = function ( data, itemSize ) {\r\n\r\n\tTHREE.warn( 'THREE.Int32Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );\r\n\treturn new THREE.BufferAttribute( data, itemSize );\r\n\r\n};\r\n\r\nTHREE.Uint32Attribute = function ( data, itemSize ) {\r\n\r\n\tTHREE.warn( 'THREE.Uint32Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );\r\n\treturn new THREE.BufferAttribute( data, itemSize );\r\n\r\n};\r\n\r\nTHREE.Float32Attribute = function ( data, itemSize ) {\r\n\r\n\tTHREE.warn( 'THREE.Float32Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );\r\n\treturn new THREE.BufferAttribute( data, itemSize );\r\n\r\n};\r\n\r\nTHREE.Float64Attribute = function ( data, itemSize ) {\r\n\r\n\tTHREE.warn( 'THREE.Float64Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );\r\n\treturn new THREE.BufferAttribute( data, itemSize );\r\n\r\n};\r\n\r\n// File:src/core/DynamicBufferAttribute.js\r\n\r\n/**\r\n * @author benaadams / https://twitter.com/ben_a_adams\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.DynamicBufferAttribute = function ( array, itemSize ) {\r\n\r\n\tTHREE.BufferAttribute.call( this, array, itemSize );\r\n\r\n\tthis.updateRange = { offset: 0, count: -1 };\r\n\r\n};\r\n\r\nTHREE.DynamicBufferAttribute.prototype = Object.create( THREE.BufferAttribute.prototype );\r\nTHREE.DynamicBufferAttribute.prototype.constructor = THREE.DynamicBufferAttribute;\r\n\r\nTHREE.DynamicBufferAttribute.prototype.clone = function () {\r\n\r\n\treturn new THREE.DynamicBufferAttribute( new this.array.constructor( this.array ), this.itemSize );\r\n\r\n};\r\n\r\n// File:src/core/BufferGeometry.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.BufferGeometry = function () {\r\n\r\n\tObject.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );\r\n\r\n\tthis.uuid = THREE.Math.generateUUID();\r\n\r\n\tthis.name = '';\r\n\tthis.type = 'BufferGeometry';\r\n\r\n\tthis.attributes = {};\r\n\tthis.attributesKeys = [];\r\n\r\n\tthis.drawcalls = [];\r\n\tthis.offsets = this.drawcalls; // backwards compatibility\r\n\r\n\tthis.boundingBox = null;\r\n\tthis.boundingSphere = null;\r\n\r\n};\r\n\r\nTHREE.BufferGeometry.prototype = {\r\n\r\n\tconstructor: THREE.BufferGeometry,\r\n\r\n\taddAttribute: function ( name, attribute ) {\r\n\r\n\t\tif ( attribute instanceof THREE.BufferAttribute === false ) {\r\n\r\n\t\t\tTHREE.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );\r\n\r\n\t\t\tthis.attributes[ name ] = { array: arguments[ 1 ], itemSize: arguments[ 2 ] };\r\n\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tthis.attributes[ name ] = attribute;\r\n\t\tthis.attributesKeys = Object.keys( this.attributes );\r\n\r\n\t},\r\n\r\n\tgetAttribute: function ( name ) {\r\n\r\n\t\treturn this.attributes[ name ];\r\n\r\n\t},\r\n\r\n\taddDrawCall: function ( start, count, indexOffset ) {\r\n\r\n\t\tthis.drawcalls.push( {\r\n\r\n\t\t\tstart: start,\r\n\t\t\tcount: count,\r\n\t\t\tindex: indexOffset !== undefined ? indexOffset : 0\r\n\r\n\t\t} );\r\n\r\n\t},\r\n\r\n\tapplyMatrix: function ( matrix ) {\r\n\r\n\t\tvar position = this.attributes.position;\r\n\r\n\t\tif ( position !== undefined ) {\r\n\r\n\t\t\tmatrix.applyToVector3Array( position.array );\r\n\t\t\tposition.needsUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t\tvar normal = this.attributes.normal;\r\n\r\n\t\tif ( normal !== undefined ) {\r\n\r\n\t\t\tvar normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );\r\n\r\n\t\t\tnormalMatrix.applyToVector3Array( normal.array );\r\n\t\t\tnormal.needsUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.boundingBox !== null ) {\r\n\r\n\t\t\tthis.computeBoundingBox();\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.boundingSphere !== null ) {\r\n\r\n\t\t\tthis.computeBoundingSphere();\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tcenter: function () {\r\n\r\n\t\tthis.computeBoundingBox();\r\n\r\n\t\tvar offset = this.boundingBox.center().negate();\r\n\r\n\t\tthis.applyMatrix( new THREE.Matrix4().setPosition( offset ) );\r\n\r\n\t\treturn offset;\r\n\r\n\t},\r\n\r\n\tfromGeometry: function ( geometry, settings ) {\r\n\r\n\t\tsettings = settings || { 'vertexColors': THREE.NoColors };\r\n\r\n\t\tvar vertices = geometry.vertices;\r\n\t\tvar faces = geometry.faces;\r\n\t\tvar faceVertexUvs = geometry.faceVertexUvs;\r\n\t\tvar vertexColors = settings.vertexColors;\r\n\t\tvar hasFaceVertexUv = faceVertexUvs[ 0 ].length > 0;\r\n\t\tvar hasFaceVertexNormals = faces[ 0 ].vertexNormals.length == 3;\r\n\r\n\t\tvar positions = new Float32Array( faces.length * 3 * 3 );\r\n\t\tthis.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );\r\n\r\n\t\tvar normals = new Float32Array( faces.length * 3 * 3 );\r\n\t\tthis.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );\r\n\r\n\t\tif ( vertexColors !== THREE.NoColors ) {\r\n\r\n\t\t\tvar colors = new Float32Array( faces.length * 3 * 3 );\r\n\t\t\tthis.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );\r\n\r\n\t\t}\r\n\r\n\t\tif ( hasFaceVertexUv === true ) {\r\n\r\n\t\t\tvar uvs = new Float32Array( faces.length * 3 * 2 );\r\n\t\t\tthis.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var i = 0, i2 = 0, i3 = 0; i < faces.length; i ++, i2 += 6, i3 += 9 ) {\r\n\r\n\t\t\tvar face = faces[ i ];\r\n\r\n\t\t\tvar a = vertices[ face.a ];\r\n\t\t\tvar b = vertices[ face.b ];\r\n\t\t\tvar c = vertices[ face.c ];\r\n\r\n\t\t\tpositions[ i3     ] = a.x;\r\n\t\t\tpositions[ i3 + 1 ] = a.y;\r\n\t\t\tpositions[ i3 + 2 ] = a.z;\r\n\r\n\t\t\tpositions[ i3 + 3 ] = b.x;\r\n\t\t\tpositions[ i3 + 4 ] = b.y;\r\n\t\t\tpositions[ i3 + 5 ] = b.z;\r\n\r\n\t\t\tpositions[ i3 + 6 ] = c.x;\r\n\t\t\tpositions[ i3 + 7 ] = c.y;\r\n\t\t\tpositions[ i3 + 8 ] = c.z;\r\n\r\n\t\t\tif ( hasFaceVertexNormals === true ) {\r\n\r\n\t\t\t\tvar na = face.vertexNormals[ 0 ];\r\n\t\t\t\tvar nb = face.vertexNormals[ 1 ];\r\n\t\t\t\tvar nc = face.vertexNormals[ 2 ];\r\n\r\n\t\t\t\tnormals[ i3     ] = na.x;\r\n\t\t\t\tnormals[ i3 + 1 ] = na.y;\r\n\t\t\t\tnormals[ i3 + 2 ] = na.z;\r\n\r\n\t\t\t\tnormals[ i3 + 3 ] = nb.x;\r\n\t\t\t\tnormals[ i3 + 4 ] = nb.y;\r\n\t\t\t\tnormals[ i3 + 5 ] = nb.z;\r\n\r\n\t\t\t\tnormals[ i3 + 6 ] = nc.x;\r\n\t\t\t\tnormals[ i3 + 7 ] = nc.y;\r\n\t\t\t\tnormals[ i3 + 8 ] = nc.z;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tvar n = face.normal;\r\n\r\n\t\t\t\tnormals[ i3     ] = n.x;\r\n\t\t\t\tnormals[ i3 + 1 ] = n.y;\r\n\t\t\t\tnormals[ i3 + 2 ] = n.z;\r\n\r\n\t\t\t\tnormals[ i3 + 3 ] = n.x;\r\n\t\t\t\tnormals[ i3 + 4 ] = n.y;\r\n\t\t\t\tnormals[ i3 + 5 ] = n.z;\r\n\r\n\t\t\t\tnormals[ i3 + 6 ] = n.x;\r\n\t\t\t\tnormals[ i3 + 7 ] = n.y;\r\n\t\t\t\tnormals[ i3 + 8 ] = n.z;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( vertexColors === THREE.FaceColors ) {\r\n\r\n\t\t\t\tvar fc = face.color;\r\n\r\n\t\t\t\tcolors[ i3     ] = fc.r;\r\n\t\t\t\tcolors[ i3 + 1 ] = fc.g;\r\n\t\t\t\tcolors[ i3 + 2 ] = fc.b;\r\n\r\n\t\t\t\tcolors[ i3 + 3 ] = fc.r;\r\n\t\t\t\tcolors[ i3 + 4 ] = fc.g;\r\n\t\t\t\tcolors[ i3 + 5 ] = fc.b;\r\n\r\n\t\t\t\tcolors[ i3 + 6 ] = fc.r;\r\n\t\t\t\tcolors[ i3 + 7 ] = fc.g;\r\n\t\t\t\tcolors[ i3 + 8 ] = fc.b;\r\n\r\n\t\t\t} else if ( vertexColors === THREE.VertexColors ) {\r\n\r\n\t\t\t\tvar vca = face.vertexColors[ 0 ];\r\n\t\t\t\tvar vcb = face.vertexColors[ 1 ];\r\n\t\t\t\tvar vcc = face.vertexColors[ 2 ];\r\n\r\n\t\t\t\tcolors[ i3     ] = vca.r;\r\n\t\t\t\tcolors[ i3 + 1 ] = vca.g;\r\n\t\t\t\tcolors[ i3 + 2 ] = vca.b;\r\n\r\n\t\t\t\tcolors[ i3 + 3 ] = vcb.r;\r\n\t\t\t\tcolors[ i3 + 4 ] = vcb.g;\r\n\t\t\t\tcolors[ i3 + 5 ] = vcb.b;\r\n\r\n\t\t\t\tcolors[ i3 + 6 ] = vcc.r;\r\n\t\t\t\tcolors[ i3 + 7 ] = vcc.g;\r\n\t\t\t\tcolors[ i3 + 8 ] = vcc.b;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( hasFaceVertexUv === true ) {\r\n\r\n\t\t\t\tvar uva = faceVertexUvs[ 0 ][ i ][ 0 ];\r\n\t\t\t\tvar uvb = faceVertexUvs[ 0 ][ i ][ 1 ];\r\n\t\t\t\tvar uvc = faceVertexUvs[ 0 ][ i ][ 2 ];\r\n\r\n\t\t\t\tuvs[ i2     ] = uva.x;\r\n\t\t\t\tuvs[ i2 + 1 ] = uva.y;\r\n\r\n\t\t\t\tuvs[ i2 + 2 ] = uvb.x;\r\n\t\t\t\tuvs[ i2 + 3 ] = uvb.y;\r\n\r\n\t\t\t\tuvs[ i2 + 4 ] = uvc.x;\r\n\t\t\t\tuvs[ i2 + 5 ] = uvc.y;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis.computeBoundingSphere()\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcomputeBoundingBox: function () {\r\n\r\n\t\tvar vector = new THREE.Vector3();\r\n\r\n\t\treturn function () {\r\n\r\n\t\t\tif ( this.boundingBox === null ) {\r\n\r\n\t\t\t\tthis.boundingBox = new THREE.Box3();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar positions = this.attributes.position.array;\r\n\r\n\t\t\tif ( positions ) {\r\n\r\n\t\t\t\tvar bb = this.boundingBox;\r\n\t\t\t\tbb.makeEmpty();\r\n\r\n\t\t\t\tfor ( var i = 0, il = positions.length; i < il; i += 3 ) {\r\n\r\n\t\t\t\t\tvector.set( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );\r\n\t\t\t\t\tbb.expandByPoint( vector );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( positions === undefined || positions.length === 0 ) {\r\n\r\n\t\t\t\tthis.boundingBox.min.set( 0, 0, 0 );\r\n\t\t\t\tthis.boundingBox.max.set( 0, 0, 0 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {\r\n\r\n\t\t\t\tTHREE.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}(),\r\n\r\n\tcomputeBoundingSphere: function () {\r\n\r\n\t\tvar box = new THREE.Box3();\r\n\t\tvar vector = new THREE.Vector3();\r\n\r\n\t\treturn function () {\r\n\r\n\t\t\tif ( this.boundingSphere === null ) {\r\n\r\n\t\t\t\tthis.boundingSphere = new THREE.Sphere();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar positions = this.attributes.position.array;\r\n\r\n\t\t\tif ( positions ) {\r\n\r\n\t\t\t\tbox.makeEmpty();\r\n\r\n\t\t\t\tvar center = this.boundingSphere.center;\r\n\r\n\t\t\t\tfor ( var i = 0, il = positions.length; i < il; i += 3 ) {\r\n\r\n\t\t\t\t\tvector.set( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );\r\n\t\t\t\t\tbox.expandByPoint( vector );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tbox.center( center );\r\n\r\n\t\t\t\t// hoping to find a boundingSphere with a radius smaller than the\r\n\t\t\t\t// boundingSphere of the boundingBox:  sqrt(3) smaller in the best case\r\n\r\n\t\t\t\tvar maxRadiusSq = 0;\r\n\r\n\t\t\t\tfor ( var i = 0, il = positions.length; i < il; i += 3 ) {\r\n\r\n\t\t\t\t\tvector.set( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );\r\n\t\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.boundingSphere.radius = Math.sqrt( maxRadiusSq );\r\n\r\n\t\t\t\tif ( isNaN( this.boundingSphere.radius ) ) {\r\n\r\n\t\t\t\t\tTHREE.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.' );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}(),\r\n\r\n\tcomputeFaceNormals: function () {\r\n\r\n\t\t// backwards compatibility\r\n\r\n\t},\r\n\r\n\tcomputeVertexNormals: function () {\r\n\r\n\t\tvar attributes = this.attributes;\r\n\r\n\t\tif ( attributes.position ) {\r\n\r\n\t\t\tvar positions = attributes.position.array;\r\n\r\n\t\t\tif ( attributes.normal === undefined ) {\r\n\r\n\t\t\t\tthis.addAttribute( 'normal', new THREE.BufferAttribute( new Float32Array( positions.length ), 3 ) );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// reset existing normals to zero\r\n\r\n\t\t\t\tvar normals = attributes.normal.array;\r\n\r\n\t\t\t\tfor ( var i = 0, il = normals.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tnormals[ i ] = 0;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar normals = attributes.normal.array;\r\n\r\n\t\t\tvar vA, vB, vC,\r\n\r\n\t\t\tpA = new THREE.Vector3(),\r\n\t\t\tpB = new THREE.Vector3(),\r\n\t\t\tpC = new THREE.Vector3(),\r\n\r\n\t\t\tcb = new THREE.Vector3(),\r\n\t\t\tab = new THREE.Vector3();\r\n\r\n\t\t\t// indexed elements\r\n\r\n\t\t\tif ( attributes.index ) {\r\n\r\n\t\t\t\tvar indices = attributes.index.array;\r\n\r\n\t\t\t\tvar offsets = ( this.offsets.length > 0 ? this.offsets : [ { start: 0, count: indices.length, index: 0 } ] );\r\n\r\n\t\t\t\tfor ( var j = 0, jl = offsets.length; j < jl; ++ j ) {\r\n\r\n\t\t\t\t\tvar start = offsets[ j ].start;\r\n\t\t\t\t\tvar count = offsets[ j ].count;\r\n\t\t\t\t\tvar index = offsets[ j ].index;\r\n\r\n\t\t\t\t\tfor ( var i = start, il = start + count; i < il; i += 3 ) {\r\n\r\n\t\t\t\t\t\tvA = ( index + indices[ i     ] ) * 3;\r\n\t\t\t\t\t\tvB = ( index + indices[ i + 1 ] ) * 3;\r\n\t\t\t\t\t\tvC = ( index + indices[ i + 2 ] ) * 3;\r\n\r\n\t\t\t\t\t\tpA.fromArray( positions, vA );\r\n\t\t\t\t\t\tpB.fromArray( positions, vB );\r\n\t\t\t\t\t\tpC.fromArray( positions, vC );\r\n\r\n\t\t\t\t\t\tcb.subVectors( pC, pB );\r\n\t\t\t\t\t\tab.subVectors( pA, pB );\r\n\t\t\t\t\t\tcb.cross( ab );\r\n\r\n\t\t\t\t\t\tnormals[ vA     ] += cb.x;\r\n\t\t\t\t\t\tnormals[ vA + 1 ] += cb.y;\r\n\t\t\t\t\t\tnormals[ vA + 2 ] += cb.z;\r\n\r\n\t\t\t\t\t\tnormals[ vB     ] += cb.x;\r\n\t\t\t\t\t\tnormals[ vB + 1 ] += cb.y;\r\n\t\t\t\t\t\tnormals[ vB + 2 ] += cb.z;\r\n\r\n\t\t\t\t\t\tnormals[ vC     ] += cb.x;\r\n\t\t\t\t\t\tnormals[ vC + 1 ] += cb.y;\r\n\t\t\t\t\t\tnormals[ vC + 2 ] += cb.z;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// non-indexed elements (unconnected triangle soup)\r\n\r\n\t\t\t\tfor ( var i = 0, il = positions.length; i < il; i += 9 ) {\r\n\r\n\t\t\t\t\tpA.fromArray( positions, i );\r\n\t\t\t\t\tpB.fromArray( positions, i + 3 );\r\n\t\t\t\t\tpC.fromArray( positions, i + 6 );\r\n\r\n\t\t\t\t\tcb.subVectors( pC, pB );\r\n\t\t\t\t\tab.subVectors( pA, pB );\r\n\t\t\t\t\tcb.cross( ab );\r\n\r\n\t\t\t\t\tnormals[ i     ] = cb.x;\r\n\t\t\t\t\tnormals[ i + 1 ] = cb.y;\r\n\t\t\t\t\tnormals[ i + 2 ] = cb.z;\r\n\r\n\t\t\t\t\tnormals[ i + 3 ] = cb.x;\r\n\t\t\t\t\tnormals[ i + 4 ] = cb.y;\r\n\t\t\t\t\tnormals[ i + 5 ] = cb.z;\r\n\r\n\t\t\t\t\tnormals[ i + 6 ] = cb.x;\r\n\t\t\t\t\tnormals[ i + 7 ] = cb.y;\r\n\t\t\t\t\tnormals[ i + 8 ] = cb.z;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.normalizeNormals();\r\n\r\n\t\t\tattributes.normal.needsUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tcomputeTangents: function () {\r\n\r\n\t\t// based on http://www.terathon.com/code/tangent.html\r\n\t\t// (per vertex tangents)\r\n\r\n\t\tif ( this.attributes.index === undefined ||\r\n\t\t\t this.attributes.position === undefined ||\r\n\t\t\t this.attributes.normal === undefined ||\r\n\t\t\t this.attributes.uv === undefined ) {\r\n\r\n\t\t\tTHREE.warn( 'THREE.BufferGeometry: Missing required attributes (index, position, normal or uv) in BufferGeometry.computeTangents()' );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tvar indices = this.attributes.index.array;\r\n\t\tvar positions = this.attributes.position.array;\r\n\t\tvar normals = this.attributes.normal.array;\r\n\t\tvar uvs = this.attributes.uv.array;\r\n\r\n\t\tvar nVertices = positions.length / 3;\r\n\r\n\t\tif ( this.attributes.tangent === undefined ) {\r\n\r\n\t\t\tthis.addAttribute( 'tangent', new THREE.BufferAttribute( new Float32Array( 4 * nVertices ), 4 ) );\r\n\r\n\t\t}\r\n\r\n\t\tvar tangents = this.attributes.tangent.array;\r\n\r\n\t\tvar tan1 = [], tan2 = [];\r\n\r\n\t\tfor ( var k = 0; k < nVertices; k ++ ) {\r\n\r\n\t\t\ttan1[ k ] = new THREE.Vector3();\r\n\t\t\ttan2[ k ] = new THREE.Vector3();\r\n\r\n\t\t}\r\n\r\n\t\tvar vA = new THREE.Vector3(),\r\n\t\t\tvB = new THREE.Vector3(),\r\n\t\t\tvC = new THREE.Vector3(),\r\n\r\n\t\t\tuvA = new THREE.Vector2(),\r\n\t\t\tuvB = new THREE.Vector2(),\r\n\t\t\tuvC = new THREE.Vector2(),\r\n\r\n\t\t\tx1, x2, y1, y2, z1, z2,\r\n\t\t\ts1, s2, t1, t2, r;\r\n\r\n\t\tvar sdir = new THREE.Vector3(), tdir = new THREE.Vector3();\r\n\r\n\t\tfunction handleTriangle( a, b, c ) {\r\n\r\n\t\t\tvA.fromArray( positions, a * 3 );\r\n\t\t\tvB.fromArray( positions, b * 3 );\r\n\t\t\tvC.fromArray( positions, c * 3 );\r\n\r\n\t\t\tuvA.fromArray( uvs, a * 2 );\r\n\t\t\tuvB.fromArray( uvs, b * 2 );\r\n\t\t\tuvC.fromArray( uvs, c * 2 );\r\n\r\n\t\t\tx1 = vB.x - vA.x;\r\n\t\t\tx2 = vC.x - vA.x;\r\n\r\n\t\t\ty1 = vB.y - vA.y;\r\n\t\t\ty2 = vC.y - vA.y;\r\n\r\n\t\t\tz1 = vB.z - vA.z;\r\n\t\t\tz2 = vC.z - vA.z;\r\n\r\n\t\t\ts1 = uvB.x - uvA.x;\r\n\t\t\ts2 = uvC.x - uvA.x;\r\n\r\n\t\t\tt1 = uvB.y - uvA.y;\r\n\t\t\tt2 = uvC.y - uvA.y;\r\n\r\n\t\t\tr = 1.0 / ( s1 * t2 - s2 * t1 );\r\n\r\n\t\t\tsdir.set(\r\n\t\t\t\t( t2 * x1 - t1 * x2 ) * r,\r\n\t\t\t\t( t2 * y1 - t1 * y2 ) * r,\r\n\t\t\t\t( t2 * z1 - t1 * z2 ) * r\r\n\t\t\t);\r\n\r\n\t\t\ttdir.set(\r\n\t\t\t\t( s1 * x2 - s2 * x1 ) * r,\r\n\t\t\t\t( s1 * y2 - s2 * y1 ) * r,\r\n\t\t\t\t( s1 * z2 - s2 * z1 ) * r\r\n\t\t\t);\r\n\r\n\t\t\ttan1[ a ].add( sdir );\r\n\t\t\ttan1[ b ].add( sdir );\r\n\t\t\ttan1[ c ].add( sdir );\r\n\r\n\t\t\ttan2[ a ].add( tdir );\r\n\t\t\ttan2[ b ].add( tdir );\r\n\t\t\ttan2[ c ].add( tdir );\r\n\r\n\t\t}\r\n\r\n\t\tvar i, il;\r\n\t\tvar j, jl;\r\n\t\tvar iA, iB, iC;\r\n\r\n\t\tif ( this.drawcalls.length === 0 ) {\r\n\r\n\t\t\tthis.addDrawCall( 0, indices.length, 0 );\r\n\r\n\t\t}\r\n\r\n\t\tvar drawcalls = this.drawcalls;\r\n\r\n\t\tfor ( j = 0, jl = drawcalls.length; j < jl; ++ j ) {\r\n\r\n\t\t\tvar start = drawcalls[ j ].start;\r\n\t\t\tvar count = drawcalls[ j ].count;\r\n\t\t\tvar index = drawcalls[ j ].index;\r\n\r\n\t\t\tfor ( i = start, il = start + count; i < il; i += 3 ) {\r\n\r\n\t\t\t\tiA = index + indices[ i ];\r\n\t\t\t\tiB = index + indices[ i + 1 ];\r\n\t\t\t\tiC = index + indices[ i + 2 ];\r\n\r\n\t\t\t\thandleTriangle( iA, iB, iC );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvar tmp = new THREE.Vector3(), tmp2 = new THREE.Vector3();\r\n\t\tvar n = new THREE.Vector3(), n2 = new THREE.Vector3();\r\n\t\tvar w, t, test;\r\n\r\n\t\tfunction handleVertex( v ) {\r\n\r\n\t\t\tn.fromArray( normals, v * 3 );\r\n\t\t\tn2.copy( n );\r\n\r\n\t\t\tt = tan1[ v ];\r\n\r\n\t\t\t// Gram-Schmidt orthogonalize\r\n\r\n\t\t\ttmp.copy( t );\r\n\t\t\ttmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();\r\n\r\n\t\t\t// Calculate handedness\r\n\r\n\t\t\ttmp2.crossVectors( n2, t );\r\n\t\t\ttest = tmp2.dot( tan2[ v ] );\r\n\t\t\tw = ( test < 0.0 ) ? - 1.0 : 1.0;\r\n\r\n\t\t\ttangents[ v * 4     ] = tmp.x;\r\n\t\t\ttangents[ v * 4 + 1 ] = tmp.y;\r\n\t\t\ttangents[ v * 4 + 2 ] = tmp.z;\r\n\t\t\ttangents[ v * 4 + 3 ] = w;\r\n\r\n\t\t}\r\n\r\n\t\tfor ( j = 0, jl = drawcalls.length; j < jl; ++ j ) {\r\n\r\n\t\t\tvar start = drawcalls[ j ].start;\r\n\t\t\tvar count = drawcalls[ j ].count;\r\n\t\t\tvar index = drawcalls[ j ].index;\r\n\r\n\t\t\tfor ( i = start, il = start + count; i < il; i += 3 ) {\r\n\r\n\t\t\t\tiA = index + indices[ i ];\r\n\t\t\t\tiB = index + indices[ i + 1 ];\r\n\t\t\t\tiC = index + indices[ i + 2 ];\r\n\r\n\t\t\t\thandleVertex( iA );\r\n\t\t\t\thandleVertex( iB );\r\n\t\t\t\thandleVertex( iC );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\t/*\r\n\tCompute the draw offset for large models by chunking the index buffer into chunks of 65k addressable vertices.\r\n\tThis method will effectively rewrite the index buffer and remap all attributes to match the new indices.\r\n\tWARNING: This method will also expand the vertex count to prevent sprawled triangles across draw offsets.\r\n\tsize - Defaults to 65535, but allows for larger or smaller chunks.\r\n\t*/\r\n\tcomputeOffsets: function ( size ) {\r\n\r\n\t\tif ( size === undefined ) size = 65535; // WebGL limits type of index buffer values to 16-bit.\r\n\r\n\t\tvar indices = this.attributes.index.array;\r\n\t\tvar vertices = this.attributes.position.array;\r\n\r\n\t\tvar facesCount = ( indices.length / 3 );\r\n\r\n\t\t/*\r\n\t\tconsole.log(\"Computing buffers in offsets of \"+size+\" -> indices:\"+indices.length+\" vertices:\"+vertices.length);\r\n\t\tconsole.log(\"Faces to process: \"+(indices.length/3));\r\n\t\tconsole.log(\"Reordering \"+verticesCount+\" vertices.\");\r\n\t\t*/\r\n\r\n\t\tvar sortedIndices = new Uint16Array( indices.length ); //16-bit buffers\r\n\t\tvar indexPtr = 0;\r\n\t\tvar vertexPtr = 0;\r\n\r\n\t\tvar offsets = [ { start:0, count:0, index:0 } ];\r\n\t\tvar offset = offsets[ 0 ];\r\n\r\n\t\tvar duplicatedVertices = 0;\r\n\t\tvar newVerticeMaps = 0;\r\n\t\tvar faceVertices = new Int32Array( 6 );\r\n\t\tvar vertexMap = new Int32Array( vertices.length );\r\n\t\tvar revVertexMap = new Int32Array( vertices.length );\r\n\t\tfor ( var j = 0; j < vertices.length; j ++ ) { vertexMap[ j ] = - 1; revVertexMap[ j ] = - 1; }\r\n\r\n\t\t/*\r\n\t\t\tTraverse every face and reorder vertices in the proper offsets of 65k.\r\n\t\t\tWe can have more than 65k entries in the index buffer per offset, but only reference 65k values.\r\n\t\t*/\r\n\t\tfor ( var findex = 0; findex < facesCount; findex ++ ) {\r\n\t\t\tnewVerticeMaps = 0;\r\n\r\n\t\t\tfor ( var vo = 0; vo < 3; vo ++ ) {\r\n\t\t\t\tvar vid = indices[ findex * 3 + vo ];\r\n\t\t\t\tif ( vertexMap[ vid ] == - 1 ) {\r\n\t\t\t\t\t//Unmapped vertice\r\n\t\t\t\t\tfaceVertices[ vo * 2 ] = vid;\r\n\t\t\t\t\tfaceVertices[ vo * 2 + 1 ] = - 1;\r\n\t\t\t\t\tnewVerticeMaps ++;\r\n\t\t\t\t} else if ( vertexMap[ vid ] < offset.index ) {\r\n\t\t\t\t\t//Reused vertices from previous block (duplicate)\r\n\t\t\t\t\tfaceVertices[ vo * 2 ] = vid;\r\n\t\t\t\t\tfaceVertices[ vo * 2 + 1 ] = - 1;\r\n\t\t\t\t\tduplicatedVertices ++;\r\n\t\t\t\t} else {\r\n\t\t\t\t\t//Reused vertice in the current block\r\n\t\t\t\t\tfaceVertices[ vo * 2 ] = vid;\r\n\t\t\t\t\tfaceVertices[ vo * 2 + 1 ] = vertexMap[ vid ];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tvar faceMax = vertexPtr + newVerticeMaps;\r\n\t\t\tif ( faceMax > ( offset.index + size ) ) {\r\n\t\t\t\tvar new_offset = { start:indexPtr, count:0, index:vertexPtr };\r\n\t\t\t\toffsets.push( new_offset );\r\n\t\t\t\toffset = new_offset;\r\n\r\n\t\t\t\t//Re-evaluate reused vertices in light of new offset.\r\n\t\t\t\tfor ( var v = 0; v < 6; v += 2 ) {\r\n\t\t\t\t\tvar new_vid = faceVertices[ v + 1 ];\r\n\t\t\t\t\tif ( new_vid > - 1 && new_vid < offset.index )\r\n\t\t\t\t\t\tfaceVertices[ v + 1 ] = - 1;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t//Reindex the face.\r\n\t\t\tfor ( var v = 0; v < 6; v += 2 ) {\r\n\t\t\t\tvar vid = faceVertices[ v ];\r\n\t\t\t\tvar new_vid = faceVertices[ v + 1 ];\r\n\r\n\t\t\t\tif ( new_vid === - 1 )\r\n\t\t\t\t\tnew_vid = vertexPtr ++;\r\n\r\n\t\t\t\tvertexMap[ vid ] = new_vid;\r\n\t\t\t\trevVertexMap[ new_vid ] = vid;\r\n\t\t\t\tsortedIndices[ indexPtr ++ ] = new_vid - offset.index; //XXX overflows at 16bit\r\n\t\t\t\toffset.count ++;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/* Move all attribute values to map to the new computed indices , also expand the vertice stack to match our new vertexPtr. */\r\n\t\tthis.reorderBuffers( sortedIndices, revVertexMap, vertexPtr );\r\n\t\tthis.offsets = offsets; // TODO: Deprecate\r\n\t\tthis.drawcalls = offsets;\r\n\r\n\t\t/*\r\n\t\tvar orderTime = Date.now();\r\n\t\tconsole.log(\"Reorder time: \"+(orderTime-s)+\"ms\");\r\n\t\tconsole.log(\"Duplicated \"+duplicatedVertices+\" vertices.\");\r\n\t\tconsole.log(\"Compute Buffers time: \"+(Date.now()-s)+\"ms\");\r\n\t\tconsole.log(\"Draw offsets: \"+offsets.length);\r\n\t\t*/\r\n\r\n\t\treturn offsets;\r\n\r\n\t},\r\n\r\n\tmerge: function ( geometry, offset ) {\r\n\r\n\t\tif ( geometry instanceof THREE.BufferGeometry === false ) {\r\n\r\n\t\t\tTHREE.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tvar attributes = this.attributes;\r\n\r\n\t\tfor ( var key in attributes ) {\r\n\r\n\t\t\tif ( geometry.attributes[ key ] === undefined ) continue;\r\n\r\n\t\t\tvar attribute1 = attributes[ key ];\r\n\t\t\tvar attributeArray1 = attribute1.array;\r\n\r\n\t\t\tvar attribute2 = geometry.attributes[ key ];\r\n\t\t\tvar attributeArray2 = attribute2.array;\r\n\r\n\t\t\tvar attributeSize = attribute2.itemSize;\r\n\r\n\t\t\tfor ( var i = 0, j = attributeSize * offset; i < attributeArray2.length; i ++, j ++ ) {\r\n\r\n\t\t\t\tattributeArray1[ j ] = attributeArray2[ i ];\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tnormalizeNormals: function () {\r\n\r\n\t\tvar normals = this.attributes.normal.array;\r\n\r\n\t\tvar x, y, z, n;\r\n\r\n\t\tfor ( var i = 0, il = normals.length; i < il; i += 3 ) {\r\n\r\n\t\t\tx = normals[ i ];\r\n\t\t\ty = normals[ i + 1 ];\r\n\t\t\tz = normals[ i + 2 ];\r\n\r\n\t\t\tn = 1.0 / Math.sqrt( x * x + y * y + z * z );\r\n\r\n\t\t\tnormals[ i     ] *= n;\r\n\t\t\tnormals[ i + 1 ] *= n;\r\n\t\t\tnormals[ i + 2 ] *= n;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\t/*\r\n\t\treoderBuffers:\r\n\t\tReorder attributes based on a new indexBuffer and indexMap.\r\n\t\tindexBuffer - Uint16Array of the new ordered indices.\r\n\t\tindexMap - Int32Array where the position is the new vertex ID and the value the old vertex ID for each vertex.\r\n\t\tvertexCount - Amount of total vertices considered in this reordering (in case you want to grow the vertice stack).\r\n\t*/\r\n\treorderBuffers: function ( indexBuffer, indexMap, vertexCount ) {\r\n\r\n\t\t/* Create a copy of all attributes for reordering. */\r\n\t\tvar sortedAttributes = {};\r\n\t\tfor ( var attr in this.attributes ) {\r\n\t\t\tif ( attr == 'index' )\r\n\t\t\t\tcontinue;\r\n\t\t\tvar sourceArray = this.attributes[ attr ].array;\r\n\t\t\tsortedAttributes[ attr ] = new sourceArray.constructor( this.attributes[ attr ].itemSize * vertexCount );\r\n\t\t}\r\n\r\n\t\t/* Move attribute positions based on the new index map */\r\n\t\tfor ( var new_vid = 0; new_vid < vertexCount; new_vid ++ ) {\r\n\t\t\tvar vid = indexMap[ new_vid ];\r\n\t\t\tfor ( var attr in this.attributes ) {\r\n\t\t\t\tif ( attr == 'index' )\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\tvar attrArray = this.attributes[ attr ].array;\r\n\t\t\t\tvar attrSize = this.attributes[ attr ].itemSize;\r\n\t\t\t\tvar sortedAttr = sortedAttributes[ attr ];\r\n\t\t\t\tfor ( var k = 0; k < attrSize; k ++ )\r\n\t\t\t\t\tsortedAttr[ new_vid * attrSize + k ] = attrArray[ vid * attrSize + k ];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/* Carry the new sorted buffers locally */\r\n\t\tthis.attributes[ 'index' ].array = indexBuffer;\r\n\t\tfor ( var attr in this.attributes ) {\r\n\t\t\tif ( attr == 'index' )\r\n\t\t\t\tcontinue;\r\n\t\t\tthis.attributes[ attr ].array = sortedAttributes[ attr ];\r\n\t\t\tthis.attributes[ attr ].numItems = this.attributes[ attr ].itemSize * vertexCount;\r\n\t\t}\r\n\t},\r\n\r\n\ttoJSON: function () {\r\n\r\n\t\tvar output = {\r\n\t\t\tmetadata: {\r\n\t\t\t\tversion: 4.0,\r\n\t\t\t\ttype: 'BufferGeometry',\r\n\t\t\t\tgenerator: 'BufferGeometryExporter'\r\n\t\t\t},\r\n\t\t\tuuid: this.uuid,\r\n\t\t\ttype: this.type,\r\n\t\t\tdata: {\r\n\t\t\t\tattributes: {}\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tvar attributes = this.attributes;\r\n\t\tvar offsets = this.offsets;\r\n\t\tvar boundingSphere = this.boundingSphere;\r\n\r\n\t\tfor ( var key in attributes ) {\r\n\r\n\t\t\tvar attribute = attributes[ key ];\r\n\r\n\t\t\tvar array = Array.prototype.slice.call( attribute.array );\r\n\r\n\t\t\toutput.data.attributes[ key ] = {\r\n\t\t\t\titemSize: attribute.itemSize,\r\n\t\t\t\ttype: attribute.array.constructor.name,\r\n\t\t\t\tarray: array\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( offsets.length > 0 ) {\r\n\r\n\t\t\toutput.data.offsets = JSON.parse( JSON.stringify( offsets ) );\r\n\r\n\t\t}\r\n\r\n\t\tif ( boundingSphere !== null ) {\r\n\r\n\t\t\toutput.data.boundingSphere = {\r\n\t\t\t\tcenter: boundingSphere.center.toArray(),\r\n\t\t\t\tradius: boundingSphere.radius\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn output;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\tvar geometry = new THREE.BufferGeometry();\r\n\r\n\t\tfor ( var attr in this.attributes ) {\r\n\r\n\t\t\tvar sourceAttr = this.attributes[ attr ];\r\n\t\t\tgeometry.addAttribute( attr, sourceAttr.clone() );\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var i = 0, il = this.offsets.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar offset = this.offsets[ i ];\r\n\r\n\t\t\tgeometry.offsets.push( {\r\n\r\n\t\t\t\tstart: offset.start,\r\n\t\t\t\tindex: offset.index,\r\n\t\t\t\tcount: offset.count\r\n\r\n\t\t\t} );\r\n\r\n\t\t}\r\n\r\n\t\treturn geometry;\r\n\r\n\t},\r\n\r\n\tdispose: function () {\r\n\r\n\t\tthis.dispatchEvent( { type: 'dispose' } );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.EventDispatcher.prototype.apply( THREE.BufferGeometry.prototype );\r\n\r\n// File:src/core/Geometry.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author kile / http://kile.stravaganza.org/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n * @author bhouston / http://exocortex.com\r\n */\r\n\r\nTHREE.Geometry = function () {\r\n\r\n\tObject.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );\r\n\r\n\tthis.uuid = THREE.Math.generateUUID();\r\n\r\n\tthis.name = '';\r\n\tthis.type = 'Geometry';\r\n\r\n\tthis.vertices = [];\r\n\tthis.colors = [];  // one-to-one vertex colors, used in Points and Line\r\n\r\n\tthis.faces = [];\r\n\r\n\tthis.faceVertexUvs = [ [] ];\r\n\r\n\tthis.morphTargets = [];\r\n\tthis.morphColors = [];\r\n\tthis.morphNormals = [];\r\n\r\n\tthis.skinWeights = [];\r\n\tthis.skinIndices = [];\r\n\r\n\tthis.lineDistances = [];\r\n\r\n\tthis.boundingBox = null;\r\n\tthis.boundingSphere = null;\r\n\r\n\tthis.hasTangents = false;\r\n\r\n\tthis.dynamic = true; // the intermediate typed arrays will be deleted when set to false\r\n\r\n\t// update flags\r\n\r\n\tthis.verticesNeedUpdate = false;\r\n\tthis.elementsNeedUpdate = false;\r\n\tthis.uvsNeedUpdate = false;\r\n\tthis.normalsNeedUpdate = false;\r\n\tthis.tangentsNeedUpdate = false;\r\n\tthis.colorsNeedUpdate = false;\r\n\tthis.lineDistancesNeedUpdate = false;\r\n\r\n\tthis.groupsNeedUpdate = false;\r\n\r\n};\r\n\r\nTHREE.Geometry.prototype = {\r\n\r\n\tconstructor: THREE.Geometry,\r\n\r\n\tapplyMatrix: function ( matrix ) {\r\n\r\n\t\tvar normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );\r\n\r\n\t\tfor ( var i = 0, il = this.vertices.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar vertex = this.vertices[ i ];\r\n\t\t\tvertex.applyMatrix4( matrix );\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var i = 0, il = this.faces.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar face = this.faces[ i ];\r\n\t\t\tface.normal.applyMatrix3( normalMatrix ).normalize();\r\n\r\n\t\t\tfor ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\tface.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.boundingBox !== null ) {\r\n\r\n\t\t\tthis.computeBoundingBox();\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.boundingSphere !== null ) {\r\n\r\n\t\t\tthis.computeBoundingSphere();\r\n\r\n\t\t}\r\n\r\n\t\tthis.verticesNeedUpdate = true;\r\n\t\tthis.normalsNeedUpdate = true;\r\n\r\n\t},\r\n\r\n\tfromBufferGeometry: function ( geometry ) {\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar attributes = geometry.attributes;\r\n\r\n\t\tvar vertices = attributes.position.array;\r\n\t\tvar indices = attributes.index !== undefined ? attributes.index.array : undefined;\r\n\t\tvar normals = attributes.normal !== undefined ? attributes.normal.array : undefined;\r\n\t\tvar colors = attributes.color !== undefined ? attributes.color.array : undefined;\r\n\t\tvar uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;\r\n\r\n\t\tvar tempNormals = [];\r\n\t\tvar tempUVs = [];\r\n\r\n\t\tfor ( var i = 0, j = 0; i < vertices.length; i += 3, j += 2 ) {\r\n\r\n\t\t\tscope.vertices.push( new THREE.Vector3( vertices[ i ], vertices[ i + 1 ], vertices[ i + 2 ] ) );\r\n\r\n\t\t\tif ( normals !== undefined ) {\r\n\r\n\t\t\t\ttempNormals.push( new THREE.Vector3( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( colors !== undefined ) {\r\n\r\n\t\t\t\tscope.colors.push( new THREE.Color( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( uvs !== undefined ) {\r\n\r\n\t\t\t\ttempUVs.push( new THREE.Vector2( uvs[ j ], uvs[ j + 1 ] ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvar addFace = function ( a, b, c ) {\r\n\r\n\t\t\tvar vertexNormals = normals !== undefined ? [ tempNormals[ a ].clone(), tempNormals[ b ].clone(), tempNormals[ c ].clone() ] : [];\r\n\t\t\tvar vertexColors = colors !== undefined ? [ scope.colors[ a ].clone(), scope.colors[ b ].clone(), scope.colors[ c ].clone() ] : [];\r\n\r\n\t\t\tscope.faces.push( new THREE.Face3( a, b, c, vertexNormals, vertexColors ) );\r\n\r\n\t\t\tif ( uvs !== undefined ) {\r\n\r\n\t\t\t\tscope.faceVertexUvs[ 0 ].push( [ tempUVs[ a ].clone(), tempUVs[ b ].clone(), tempUVs[ c ].clone() ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t\tif ( indices !== undefined ) {\r\n\r\n\t\t\tvar drawcalls = geometry.drawcalls;\r\n\r\n\t\t\tif ( drawcalls.length > 0 ) {\r\n\r\n\t\t\t\tfor ( var i = 0; i < drawcalls.length; i ++ ) {\r\n\r\n\t\t\t\t\tvar drawcall = drawcalls[ i ];\r\n\r\n\t\t\t\t\tvar start = drawcall.start;\r\n\t\t\t\t\tvar count = drawcall.count;\r\n\t\t\t\t\tvar index = drawcall.index;\r\n\r\n\t\t\t\t\tfor ( var j = start, jl = start + count; j < jl; j += 3 ) {\r\n\r\n\t\t\t\t\t\taddFace( index + indices[ j ], index + indices[ j + 1 ], index + indices[ j + 2 ] );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tfor ( var i = 0; i < indices.length; i += 3 ) {\r\n\r\n\t\t\t\t\taddFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tfor ( var i = 0; i < vertices.length / 3; i += 3 ) {\r\n\r\n\t\t\t\taddFace( i, i + 1, i + 2 );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis.computeFaceNormals();\r\n\r\n\t\tif ( geometry.boundingBox !== null ) {\r\n\r\n\t\t\tthis.boundingBox = geometry.boundingBox.clone();\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry.boundingSphere !== null ) {\r\n\r\n\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcenter: function () {\r\n\r\n\t\tthis.computeBoundingBox();\r\n\r\n\t\tvar offset = this.boundingBox.center().negate();\r\n\r\n\t\tthis.applyMatrix( new THREE.Matrix4().setPosition( offset ) );\r\n\r\n\t\treturn offset;\r\n\r\n\t},\r\n\r\n\tcomputeFaceNormals: function () {\r\n\r\n\t\tvar cb = new THREE.Vector3(), ab = new THREE.Vector3();\r\n\r\n\t\tfor ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\tvar face = this.faces[ f ];\r\n\r\n\t\t\tvar vA = this.vertices[ face.a ];\r\n\t\t\tvar vB = this.vertices[ face.b ];\r\n\t\t\tvar vC = this.vertices[ face.c ];\r\n\r\n\t\t\tcb.subVectors( vC, vB );\r\n\t\t\tab.subVectors( vA, vB );\r\n\t\t\tcb.cross( ab );\r\n\r\n\t\t\tcb.normalize();\r\n\r\n\t\t\tface.normal.copy( cb );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tcomputeVertexNormals: function ( areaWeighted ) {\r\n\r\n\t\tvar v, vl, f, fl, face, vertices;\r\n\r\n\t\tvertices = new Array( this.vertices.length );\r\n\r\n\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\r\n\r\n\t\t\tvertices[ v ] = new THREE.Vector3();\r\n\r\n\t\t}\r\n\r\n\t\tif ( areaWeighted ) {\r\n\r\n\t\t\t// vertex normals weighted by triangle areas\r\n\t\t\t// http://www.iquilezles.org/www/articles/normals/normals.htm\r\n\r\n\t\t\tvar vA, vB, vC;\r\n\t\t\tvar cb = new THREE.Vector3(), ab = new THREE.Vector3();\r\n\r\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tface = this.faces[ f ];\r\n\r\n\t\t\t\tvA = this.vertices[ face.a ];\r\n\t\t\t\tvB = this.vertices[ face.b ];\r\n\t\t\t\tvC = this.vertices[ face.c ];\r\n\r\n\t\t\t\tcb.subVectors( vC, vB );\r\n\t\t\t\tab.subVectors( vA, vB );\r\n\t\t\t\tcb.cross( ab );\r\n\r\n\t\t\t\tvertices[ face.a ].add( cb );\r\n\t\t\t\tvertices[ face.b ].add( cb );\r\n\t\t\t\tvertices[ face.c ].add( cb );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tface = this.faces[ f ];\r\n\r\n\t\t\t\tvertices[ face.a ].add( face.normal );\r\n\t\t\t\tvertices[ face.b ].add( face.normal );\r\n\t\t\t\tvertices[ face.c ].add( face.normal );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\r\n\r\n\t\t\tvertices[ v ].normalize();\r\n\r\n\t\t}\r\n\r\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\tface = this.faces[ f ];\r\n\r\n\t\t\tface.vertexNormals[ 0 ] = vertices[ face.a ].clone();\r\n\t\t\tface.vertexNormals[ 1 ] = vertices[ face.b ].clone();\r\n\t\t\tface.vertexNormals[ 2 ] = vertices[ face.c ].clone();\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tcomputeMorphNormals: function () {\r\n\r\n\t\tvar i, il, f, fl, face;\r\n\r\n\t\t// save original normals\r\n\t\t// - create temp variables on first access\r\n\t\t//   otherwise just copy (for faster repeated calls)\r\n\r\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\tface = this.faces[ f ];\r\n\r\n\t\t\tif ( ! face.__originalFaceNormal ) {\r\n\r\n\t\t\t\tface.__originalFaceNormal = face.normal.clone();\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tface.__originalFaceNormal.copy( face.normal );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];\r\n\r\n\t\t\tfor ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tif ( ! face.__originalVertexNormals[ i ] ) {\r\n\r\n\t\t\t\t\tface.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tface.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// use temp geometry to compute face and vertex normals for each morph\r\n\r\n\t\tvar tmpGeo = new THREE.Geometry();\r\n\t\ttmpGeo.faces = this.faces;\r\n\r\n\t\tfor ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {\r\n\r\n\t\t\t// create on first access\r\n\r\n\t\t\tif ( ! this.morphNormals[ i ] ) {\r\n\r\n\t\t\t\tthis.morphNormals[ i ] = {};\r\n\t\t\t\tthis.morphNormals[ i ].faceNormals = [];\r\n\t\t\t\tthis.morphNormals[ i ].vertexNormals = [];\r\n\r\n\t\t\t\tvar dstNormalsFace = this.morphNormals[ i ].faceNormals;\r\n\t\t\t\tvar dstNormalsVertex = this.morphNormals[ i ].vertexNormals;\r\n\r\n\t\t\t\tvar faceNormal, vertexNormals;\r\n\r\n\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\t\tfaceNormal = new THREE.Vector3();\r\n\t\t\t\t\tvertexNormals = { a: new THREE.Vector3(), b: new THREE.Vector3(), c: new THREE.Vector3() };\r\n\r\n\t\t\t\t\tdstNormalsFace.push( faceNormal );\r\n\t\t\t\t\tdstNormalsVertex.push( vertexNormals );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar morphNormals = this.morphNormals[ i ];\r\n\r\n\t\t\t// set vertices to morph target\r\n\r\n\t\t\ttmpGeo.vertices = this.morphTargets[ i ].vertices;\r\n\r\n\t\t\t// compute morph normals\r\n\r\n\t\t\ttmpGeo.computeFaceNormals();\r\n\t\t\ttmpGeo.computeVertexNormals();\r\n\r\n\t\t\t// store morph normals\r\n\r\n\t\t\tvar faceNormal, vertexNormals;\r\n\r\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tface = this.faces[ f ];\r\n\r\n\t\t\t\tfaceNormal = morphNormals.faceNormals[ f ];\r\n\t\t\t\tvertexNormals = morphNormals.vertexNormals[ f ];\r\n\r\n\t\t\t\tfaceNormal.copy( face.normal );\r\n\r\n\t\t\t\tvertexNormals.a.copy( face.vertexNormals[ 0 ] );\r\n\t\t\t\tvertexNormals.b.copy( face.vertexNormals[ 1 ] );\r\n\t\t\t\tvertexNormals.c.copy( face.vertexNormals[ 2 ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// restore original normals\r\n\r\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\tface = this.faces[ f ];\r\n\r\n\t\t\tface.normal = face.__originalFaceNormal;\r\n\t\t\tface.vertexNormals = face.__originalVertexNormals;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tcomputeTangents: function () {\r\n\r\n\t\t// based on http://www.terathon.com/code/tangent.html\r\n\t\t// tangents go to vertices\r\n\r\n\t\tvar f, fl, v, vl, i, vertexIndex,\r\n\t\t\tface, uv, vA, vB, vC, uvA, uvB, uvC,\r\n\t\t\tx1, x2, y1, y2, z1, z2,\r\n\t\t\ts1, s2, t1, t2, r, t, test,\r\n\t\t\ttan1 = [], tan2 = [],\r\n\t\t\tsdir = new THREE.Vector3(), tdir = new THREE.Vector3(),\r\n\t\t\ttmp = new THREE.Vector3(), tmp2 = new THREE.Vector3(),\r\n\t\t\tn = new THREE.Vector3(), w;\r\n\r\n\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\r\n\r\n\t\t\ttan1[ v ] = new THREE.Vector3();\r\n\t\t\ttan2[ v ] = new THREE.Vector3();\r\n\r\n\t\t}\r\n\r\n\t\tfunction handleTriangle( context, a, b, c, ua, ub, uc ) {\r\n\r\n\t\t\tvA = context.vertices[ a ];\r\n\t\t\tvB = context.vertices[ b ];\r\n\t\t\tvC = context.vertices[ c ];\r\n\r\n\t\t\tuvA = uv[ ua ];\r\n\t\t\tuvB = uv[ ub ];\r\n\t\t\tuvC = uv[ uc ];\r\n\r\n\t\t\tx1 = vB.x - vA.x;\r\n\t\t\tx2 = vC.x - vA.x;\r\n\t\t\ty1 = vB.y - vA.y;\r\n\t\t\ty2 = vC.y - vA.y;\r\n\t\t\tz1 = vB.z - vA.z;\r\n\t\t\tz2 = vC.z - vA.z;\r\n\r\n\t\t\ts1 = uvB.x - uvA.x;\r\n\t\t\ts2 = uvC.x - uvA.x;\r\n\t\t\tt1 = uvB.y - uvA.y;\r\n\t\t\tt2 = uvC.y - uvA.y;\r\n\r\n\t\t\tr = 1.0 / ( s1 * t2 - s2 * t1 );\r\n\t\t\tsdir.set( ( t2 * x1 - t1 * x2 ) * r,\r\n\t\t\t\t\t  ( t2 * y1 - t1 * y2 ) * r,\r\n\t\t\t\t\t  ( t2 * z1 - t1 * z2 ) * r );\r\n\t\t\ttdir.set( ( s1 * x2 - s2 * x1 ) * r,\r\n\t\t\t\t\t  ( s1 * y2 - s2 * y1 ) * r,\r\n\t\t\t\t\t  ( s1 * z2 - s2 * z1 ) * r );\r\n\r\n\t\t\ttan1[ a ].add( sdir );\r\n\t\t\ttan1[ b ].add( sdir );\r\n\t\t\ttan1[ c ].add( sdir );\r\n\r\n\t\t\ttan2[ a ].add( tdir );\r\n\t\t\ttan2[ b ].add( tdir );\r\n\t\t\ttan2[ c ].add( tdir );\r\n\r\n\t\t}\r\n\r\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\tface = this.faces[ f ];\r\n\t\t\tuv = this.faceVertexUvs[ 0 ][ f ]; // use UV layer 0 for tangents\r\n\r\n\t\t\thandleTriangle( this, face.a, face.b, face.c, 0, 1, 2 );\r\n\r\n\t\t}\r\n\r\n\t\tvar faceIndex = [ 'a', 'b', 'c', 'd' ];\r\n\r\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\tface = this.faces[ f ];\r\n\r\n\t\t\tfor ( i = 0; i < Math.min( face.vertexNormals.length, 3 ); i ++ ) {\r\n\r\n\t\t\t\tn.copy( face.vertexNormals[ i ] );\r\n\r\n\t\t\t\tvertexIndex = face[ faceIndex[ i ] ];\r\n\r\n\t\t\t\tt = tan1[ vertexIndex ];\r\n\r\n\t\t\t\t// Gram-Schmidt orthogonalize\r\n\r\n\t\t\t\ttmp.copy( t );\r\n\t\t\t\ttmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();\r\n\r\n\t\t\t\t// Calculate handedness\r\n\r\n\t\t\t\ttmp2.crossVectors( face.vertexNormals[ i ], t );\r\n\t\t\t\ttest = tmp2.dot( tan2[ vertexIndex ] );\r\n\t\t\t\tw = ( test < 0.0 ) ? - 1.0 : 1.0;\r\n\r\n\t\t\t\tface.vertexTangents[ i ] = new THREE.Vector4( tmp.x, tmp.y, tmp.z, w );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis.hasTangents = true;\r\n\r\n\t},\r\n\r\n\tcomputeLineDistances: function () {\r\n\r\n\t\tvar d = 0;\r\n\t\tvar vertices = this.vertices;\r\n\r\n\t\tfor ( var i = 0, il = vertices.length; i < il; i ++ ) {\r\n\r\n\t\t\tif ( i > 0 ) {\r\n\r\n\t\t\t\td += vertices[ i ].distanceTo( vertices[ i - 1 ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.lineDistances[ i ] = d;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tcomputeBoundingBox: function () {\r\n\r\n\t\tif ( this.boundingBox === null ) {\r\n\r\n\t\t\tthis.boundingBox = new THREE.Box3();\r\n\r\n\t\t}\r\n\r\n\t\tthis.boundingBox.setFromPoints( this.vertices );\r\n\r\n\t},\r\n\r\n\tcomputeBoundingSphere: function () {\r\n\r\n\t\tif ( this.boundingSphere === null ) {\r\n\r\n\t\t\tthis.boundingSphere = new THREE.Sphere();\r\n\r\n\t\t}\r\n\r\n\t\tthis.boundingSphere.setFromPoints( this.vertices );\r\n\r\n\t},\r\n\r\n\tmerge: function ( geometry, matrix, materialIndexOffset ) {\r\n\r\n\t\tif ( geometry instanceof THREE.Geometry === false ) {\r\n\r\n\t\t\tTHREE.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tvar normalMatrix,\r\n\t\tvertexOffset = this.vertices.length,\r\n\t\tvertices1 = this.vertices,\r\n\t\tvertices2 = geometry.vertices,\r\n\t\tfaces1 = this.faces,\r\n\t\tfaces2 = geometry.faces,\r\n\t\tuvs1 = this.faceVertexUvs[ 0 ],\r\n\t\tuvs2 = geometry.faceVertexUvs[ 0 ];\r\n\r\n\t\tif ( materialIndexOffset === undefined ) materialIndexOffset = 0;\r\n\r\n\t\tif ( matrix !== undefined ) {\r\n\r\n\t\t\tnormalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );\r\n\r\n\t\t}\r\n\r\n\t\t// vertices\r\n\r\n\t\tfor ( var i = 0, il = vertices2.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar vertex = vertices2[ i ];\r\n\r\n\t\t\tvar vertexCopy = vertex.clone();\r\n\r\n\t\t\tif ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );\r\n\r\n\t\t\tvertices1.push( vertexCopy );\r\n\r\n\t\t}\r\n\r\n\t\t// faces\r\n\r\n\t\tfor ( i = 0, il = faces2.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar face = faces2[ i ], faceCopy, normal, color,\r\n\t\t\tfaceVertexNormals = face.vertexNormals,\r\n\t\t\tfaceVertexColors = face.vertexColors;\r\n\r\n\t\t\tfaceCopy = new THREE.Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );\r\n\t\t\tfaceCopy.normal.copy( face.normal );\r\n\r\n\t\t\tif ( normalMatrix !== undefined ) {\r\n\r\n\t\t\t\tfaceCopy.normal.applyMatrix3( normalMatrix ).normalize();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\tnormal = faceVertexNormals[ j ].clone();\r\n\r\n\t\t\t\tif ( normalMatrix !== undefined ) {\r\n\r\n\t\t\t\t\tnormal.applyMatrix3( normalMatrix ).normalize();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfaceCopy.vertexNormals.push( normal );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfaceCopy.color.copy( face.color );\r\n\r\n\t\t\tfor ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\tcolor = faceVertexColors[ j ];\r\n\t\t\t\tfaceCopy.vertexColors.push( color.clone() );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfaceCopy.materialIndex = face.materialIndex + materialIndexOffset;\r\n\r\n\t\t\tfaces1.push( faceCopy );\r\n\r\n\t\t}\r\n\r\n\t\t// uvs\r\n\r\n\t\tfor ( i = 0, il = uvs2.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar uv = uvs2[ i ], uvCopy = [];\r\n\r\n\t\t\tif ( uv === undefined ) {\r\n\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var j = 0, jl = uv.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\tuvCopy.push( uv[ j ].clone() );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tuvs1.push( uvCopy );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tmergeMesh: function ( mesh ) {\r\n\r\n\t\tif ( mesh instanceof THREE.Mesh === false ) {\r\n\r\n\t\t\tTHREE.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tmesh.matrixAutoUpdate && mesh.updateMatrix();\r\n\r\n\t\tthis.merge( mesh.geometry, mesh.matrix );\r\n\r\n\t},\r\n\r\n\t/*\r\n\t * Checks for duplicate vertices with hashmap.\r\n\t * Duplicated vertices are removed\r\n\t * and faces' vertices are updated.\r\n\t */\r\n\r\n\tmergeVertices: function () {\r\n\r\n\t\tvar verticesMap = {}; // Hashmap for looking up vertice by position coordinates (and making sure they are unique)\r\n\t\tvar unique = [], changes = [];\r\n\r\n\t\tvar v, key;\r\n\t\tvar precisionPoints = 4; // number of decimal points, eg. 4 for epsilon of 0.0001\r\n\t\tvar precision = Math.pow( 10, precisionPoints );\r\n\t\tvar i, il, face;\r\n\t\tvar indices, j, jl;\r\n\r\n\t\tfor ( i = 0, il = this.vertices.length; i < il; i ++ ) {\r\n\r\n\t\t\tv = this.vertices[ i ];\r\n\t\t\tkey = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );\r\n\r\n\t\t\tif ( verticesMap[ key ] === undefined ) {\r\n\r\n\t\t\t\tverticesMap[ key ] = i;\r\n\t\t\t\tunique.push( this.vertices[ i ] );\r\n\t\t\t\tchanges[ i ] = unique.length - 1;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);\r\n\t\t\t\tchanges[ i ] = changes[ verticesMap[ key ] ];\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\r\n\t\t// if faces are completely degenerate after merging vertices, we\r\n\t\t// have to remove them from the geometry.\r\n\t\tvar faceIndicesToRemove = [];\r\n\r\n\t\tfor ( i = 0, il = this.faces.length; i < il; i ++ ) {\r\n\r\n\t\t\tface = this.faces[ i ];\r\n\r\n\t\t\tface.a = changes[ face.a ];\r\n\t\t\tface.b = changes[ face.b ];\r\n\t\t\tface.c = changes[ face.c ];\r\n\r\n\t\t\tindices = [ face.a, face.b, face.c ];\r\n\r\n\t\t\tvar dupIndex = - 1;\r\n\r\n\t\t\t// if any duplicate vertices are found in a Face3\r\n\t\t\t// we have to remove the face as nothing can be saved\r\n\t\t\tfor ( var n = 0; n < 3; n ++ ) {\r\n\t\t\t\tif ( indices[ n ] == indices[ ( n + 1 ) % 3 ] ) {\r\n\r\n\t\t\t\t\tdupIndex = n;\r\n\t\t\t\t\tfaceIndicesToRemove.push( i );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfor ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {\r\n\t\t\tvar idx = faceIndicesToRemove[ i ];\r\n\r\n\t\t\tthis.faces.splice( idx, 1 );\r\n\r\n\t\t\tfor ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\tthis.faceVertexUvs[ j ].splice( idx, 1 );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// Use unique set of vertices\r\n\r\n\t\tvar diff = this.vertices.length - unique.length;\r\n\t\tthis.vertices = unique;\r\n\t\treturn diff;\r\n\r\n\t},\r\n\r\n\ttoJSON: function () {\r\n\r\n\t\tvar output = {\r\n\t\t\tmetadata: {\r\n\t\t\t\tversion: 4.0,\r\n\t\t\t\ttype: 'BufferGeometry',\r\n\t\t\t\tgenerator: 'BufferGeometryExporter'\r\n\t\t\t},\r\n\t\t\tuuid: this.uuid,\r\n\t\t\ttype: this.type\r\n\t\t};\r\n\r\n\t\tif ( this.name !== \"\" ) output.name = this.name;\r\n\r\n\t\tif ( this.parameters !== undefined ) {\r\n\r\n\t\t\tvar parameters = this.parameters;\r\n\r\n\t\t\tfor ( var key in parameters ) {\r\n\r\n\t\t\t\tif ( parameters[ key ] !== undefined ) output[ key ] = parameters[ key ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn output;\r\n\r\n\t\t}\r\n\r\n\t\tvar vertices = [];\r\n\r\n\t\tfor ( var i = 0; i < this.vertices.length; i ++ ) {\r\n\r\n\t\t\tvar vertex = this.vertices[ i ];\r\n\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\r\n\r\n\t\t}\r\n\r\n\t\tvar faces = [];\r\n\t\tvar normals = [];\r\n\t\tvar normalsHash = {};\r\n\t\tvar colors = [];\r\n\t\tvar colorsHash = {};\r\n\t\tvar uvs = [];\r\n\t\tvar uvsHash = {};\r\n\r\n\t\tfor ( var i = 0; i < this.faces.length; i ++ ) {\r\n\r\n\t\t\tvar face = this.faces[ i ];\r\n\r\n\t\t\tvar hasMaterial = false; // face.materialIndex !== undefined;\r\n\t\t\tvar hasFaceUv = false; // deprecated\r\n\t\t\tvar hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;\r\n\t\t\tvar hasFaceNormal = face.normal.length() > 0;\r\n\t\t\tvar hasFaceVertexNormal = face.vertexNormals.length > 0;\r\n\t\t\tvar hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;\r\n\t\t\tvar hasFaceVertexColor = face.vertexColors.length > 0;\r\n\r\n\t\t\tvar faceType = 0;\r\n\r\n\t\t\tfaceType = setBit( faceType, 0, 0 );\r\n\t\t\tfaceType = setBit( faceType, 1, hasMaterial );\r\n\t\t\tfaceType = setBit( faceType, 2, hasFaceUv );\r\n\t\t\tfaceType = setBit( faceType, 3, hasFaceVertexUv );\r\n\t\t\tfaceType = setBit( faceType, 4, hasFaceNormal );\r\n\t\t\tfaceType = setBit( faceType, 5, hasFaceVertexNormal );\r\n\t\t\tfaceType = setBit( faceType, 6, hasFaceColor );\r\n\t\t\tfaceType = setBit( faceType, 7, hasFaceVertexColor );\r\n\r\n\t\t\tfaces.push( faceType );\r\n\t\t\tfaces.push( face.a, face.b, face.c );\r\n\r\n\r\n\t\t\t/*\r\n\t\t\tif ( hasMaterial ) {\r\n\r\n\t\t\t\tfaces.push( face.materialIndex );\r\n\r\n\t\t\t}\r\n\t\t\t*/\r\n\r\n\t\t\tif ( hasFaceVertexUv ) {\r\n\r\n\t\t\t\tvar faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];\r\n\r\n\t\t\t\tfaces.push(\r\n\t\t\t\t\tgetUvIndex( faceVertexUvs[ 0 ] ),\r\n\t\t\t\t\tgetUvIndex( faceVertexUvs[ 1 ] ),\r\n\t\t\t\t\tgetUvIndex( faceVertexUvs[ 2 ] )\r\n\t\t\t\t);\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( hasFaceNormal ) {\r\n\r\n\t\t\t\tfaces.push( getNormalIndex( face.normal ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( hasFaceVertexNormal ) {\r\n\r\n\t\t\t\tvar vertexNormals = face.vertexNormals;\r\n\r\n\t\t\t\tfaces.push(\r\n\t\t\t\t\tgetNormalIndex( vertexNormals[ 0 ] ),\r\n\t\t\t\t\tgetNormalIndex( vertexNormals[ 1 ] ),\r\n\t\t\t\t\tgetNormalIndex( vertexNormals[ 2 ] )\r\n\t\t\t\t);\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( hasFaceColor ) {\r\n\r\n\t\t\t\tfaces.push( getColorIndex( face.color ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( hasFaceVertexColor ) {\r\n\r\n\t\t\t\tvar vertexColors = face.vertexColors;\r\n\r\n\t\t\t\tfaces.push(\r\n\t\t\t\t\tgetColorIndex( vertexColors[ 0 ] ),\r\n\t\t\t\t\tgetColorIndex( vertexColors[ 1 ] ),\r\n\t\t\t\t\tgetColorIndex( vertexColors[ 2 ] )\r\n\t\t\t\t);\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction setBit( value, position, enabled ) {\r\n\r\n\t\t\treturn enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position) );\r\n\r\n\t\t}\r\n\r\n\t\tfunction getNormalIndex( normal ) {\r\n\r\n\t\t\tvar hash = normal.x.toString() + normal.y.toString() + normal.z.toString();\r\n\r\n\t\t\tif ( normalsHash[ hash ] !== undefined ) {\r\n\r\n\t\t\t\treturn normalsHash[ hash ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tnormalsHash[ hash ] = normals.length / 3;\r\n\t\t\tnormals.push( normal.x, normal.y, normal.z );\r\n\r\n\t\t\treturn normalsHash[ hash ];\r\n\r\n\t\t}\r\n\r\n\t\tfunction getColorIndex( color ) {\r\n\r\n\t\t\tvar hash = color.r.toString() + color.g.toString() + color.b.toString();\r\n\r\n\t\t\tif ( colorsHash[ hash ] !== undefined ) {\r\n\r\n\t\t\t\treturn colorsHash[ hash ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tcolorsHash[ hash ] = colors.length;\r\n\t\t\tcolors.push( color.getHex() );\r\n\r\n\t\t\treturn colorsHash[ hash ];\r\n\r\n\t\t}\r\n\r\n\t\tfunction getUvIndex( uv ) {\r\n\r\n\t\t\tvar hash = uv.x.toString() + uv.y.toString();\r\n\r\n\t\t\tif ( uvsHash[ hash ] !== undefined ) {\r\n\r\n\t\t\t\treturn uvsHash[ hash ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tuvsHash[ hash ] = uvs.length / 2;\r\n\t\t\tuvs.push( uv.x, uv.y );\r\n\r\n\t\t\treturn uvsHash[ hash ];\r\n\r\n\t\t}\r\n\r\n\t\toutput.data = {};\r\n\r\n\t\toutput.data.vertices = vertices;\r\n\t\toutput.data.normals = normals;\r\n\t\tif ( colors.length > 0 ) output.data.colors = colors;\r\n\t\tif ( uvs.length > 0 ) output.data.uvs = [ uvs ]; // temporal backward compatibility\r\n\t\toutput.data.faces = faces;\r\n\r\n\t\t//\r\n\r\n\t\treturn output;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\tvar geometry = new THREE.Geometry();\r\n\r\n\t\tvar vertices = this.vertices;\r\n\r\n\t\tfor ( var i = 0, il = vertices.length; i < il; i ++ ) {\r\n\r\n\t\t\tgeometry.vertices.push( vertices[ i ].clone() );\r\n\r\n\t\t}\r\n\r\n\t\tvar faces = this.faces;\r\n\r\n\t\tfor ( var i = 0, il = faces.length; i < il; i ++ ) {\r\n\r\n\t\t\tgeometry.faces.push( faces[ i ].clone() );\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var i = 0, il = this.faceVertexUvs.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar faceVertexUvs = this.faceVertexUvs[ i ];\r\n\r\n\t\t\tif ( geometry.faceVertexUvs[ i ] === undefined ) {\r\n\r\n\t\t\t\tgeometry.faceVertexUvs[ i ] = [];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\tvar uvs = faceVertexUvs[ j ], uvsCopy = [];\r\n\r\n\t\t\t\tfor ( var k = 0, kl = uvs.length; k < kl; k ++ ) {\r\n\r\n\t\t\t\t\tvar uv = uvs[ k ];\r\n\r\n\t\t\t\t\tuvsCopy.push( uv.clone() );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tgeometry.faceVertexUvs[ i ].push( uvsCopy );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn geometry;\r\n\r\n\t},\r\n\r\n\tdispose: function () {\r\n\r\n\t\tthis.dispatchEvent( { type: 'dispose' } );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.EventDispatcher.prototype.apply( THREE.Geometry.prototype );\r\n\r\nTHREE.GeometryIdCount = 0;\r\n\r\n// File:src/cameras/Camera.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author WestLangley / http://github.com/WestLangley\r\n*/\r\n\r\nTHREE.Camera = function () {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.type = 'Camera';\r\n\r\n\tthis.matrixWorldInverse = new THREE.Matrix4();\r\n\tthis.projectionMatrix = new THREE.Matrix4();\r\n\r\n};\r\n\r\nTHREE.Camera.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.Camera.prototype.constructor = THREE.Camera;\r\n\r\nTHREE.Camera.prototype.getWorldDirection = function () {\r\n\r\n\tvar quaternion = new THREE.Quaternion();\r\n\r\n\treturn function ( optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\r\n\t\tthis.getWorldQuaternion( quaternion );\r\n\r\n\t\treturn result.set( 0, 0, - 1 ).applyQuaternion( quaternion );\r\n\r\n\t}\r\n\r\n}();\r\n\r\nTHREE.Camera.prototype.lookAt = function () {\r\n\r\n\t// This routine does not support cameras with rotated and/or translated parent(s)\r\n\r\n\tvar m1 = new THREE.Matrix4();\r\n\r\n\treturn function ( vector ) {\r\n\r\n\t\tm1.lookAt( this.position, vector, this.up );\r\n\r\n\t\tthis.quaternion.setFromRotationMatrix( m1 );\r\n\r\n\t};\r\n\r\n}();\r\n\r\nTHREE.Camera.prototype.clone = function ( camera ) {\r\n\r\n\tif ( camera === undefined ) camera = new THREE.Camera();\r\n\r\n\tTHREE.Object3D.prototype.clone.call( this, camera );\r\n\r\n\tcamera.matrixWorldInverse.copy( this.matrixWorldInverse );\r\n\tcamera.projectionMatrix.copy( this.projectionMatrix );\r\n\r\n\treturn camera;\r\n};\r\n\r\n// File:src/cameras/CubeCamera.js\r\n\r\n/**\r\n * Camera for rendering cube maps\r\n *\t- renders scene into axis-aligned cube\r\n *\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.CubeCamera = function ( near, far, cubeResolution ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.type = 'CubeCamera';\r\n\r\n\tvar fov = 90, aspect = 1;\r\n\r\n\tvar cameraPX = new THREE.PerspectiveCamera( fov, aspect, near, far );\r\n\tcameraPX.up.set( 0, - 1, 0 );\r\n\tcameraPX.lookAt( new THREE.Vector3( 1, 0, 0 ) );\r\n\tthis.add( cameraPX );\r\n\r\n\tvar cameraNX = new THREE.PerspectiveCamera( fov, aspect, near, far );\r\n\tcameraNX.up.set( 0, - 1, 0 );\r\n\tcameraNX.lookAt( new THREE.Vector3( - 1, 0, 0 ) );\r\n\tthis.add( cameraNX );\r\n\r\n\tvar cameraPY = new THREE.PerspectiveCamera( fov, aspect, near, far );\r\n\tcameraPY.up.set( 0, 0, 1 );\r\n\tcameraPY.lookAt( new THREE.Vector3( 0, 1, 0 ) );\r\n\tthis.add( cameraPY );\r\n\r\n\tvar cameraNY = new THREE.PerspectiveCamera( fov, aspect, near, far );\r\n\tcameraNY.up.set( 0, 0, - 1 );\r\n\tcameraNY.lookAt( new THREE.Vector3( 0, - 1, 0 ) );\r\n\tthis.add( cameraNY );\r\n\r\n\tvar cameraPZ = new THREE.PerspectiveCamera( fov, aspect, near, far );\r\n\tcameraPZ.up.set( 0, - 1, 0 );\r\n\tcameraPZ.lookAt( new THREE.Vector3( 0, 0, 1 ) );\r\n\tthis.add( cameraPZ );\r\n\r\n\tvar cameraNZ = new THREE.PerspectiveCamera( fov, aspect, near, far );\r\n\tcameraNZ.up.set( 0, - 1, 0 );\r\n\tcameraNZ.lookAt( new THREE.Vector3( 0, 0, - 1 ) );\r\n\tthis.add( cameraNZ );\r\n\r\n\tthis.renderTarget = new THREE.WebGLRenderTargetCube( cubeResolution, cubeResolution, { format: THREE.RGBFormat, magFilter: THREE.LinearFilter, minFilter: THREE.LinearFilter } );\r\n\r\n\tthis.updateCubeMap = function ( renderer, scene ) {\r\n\r\n\t\tvar renderTarget = this.renderTarget;\r\n\t\tvar generateMipmaps = renderTarget.generateMipmaps;\r\n\r\n\t\trenderTarget.generateMipmaps = false;\r\n\r\n\t\trenderTarget.activeCubeFace = 0;\r\n\t\trenderer.render( scene, cameraPX, renderTarget );\r\n\r\n\t\trenderTarget.activeCubeFace = 1;\r\n\t\trenderer.render( scene, cameraNX, renderTarget );\r\n\r\n\t\trenderTarget.activeCubeFace = 2;\r\n\t\trenderer.render( scene, cameraPY, renderTarget );\r\n\r\n\t\trenderTarget.activeCubeFace = 3;\r\n\t\trenderer.render( scene, cameraNY, renderTarget );\r\n\r\n\t\trenderTarget.activeCubeFace = 4;\r\n\t\trenderer.render( scene, cameraPZ, renderTarget );\r\n\r\n\t\trenderTarget.generateMipmaps = generateMipmaps;\r\n\r\n\t\trenderTarget.activeCubeFace = 5;\r\n\t\trenderer.render( scene, cameraNZ, renderTarget );\r\n\r\n\t};\r\n\r\n};\r\n\r\nTHREE.CubeCamera.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.CubeCamera.prototype.constructor = THREE.CubeCamera;\r\n\r\n// File:src/cameras/OrthographicCamera.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.OrthographicCamera = function ( left, right, top, bottom, near, far ) {\r\n\r\n\tTHREE.Camera.call( this );\r\n\r\n\tthis.type = 'OrthographicCamera';\r\n\r\n\tthis.zoom = 1;\r\n\r\n\tthis.left = left;\r\n\tthis.right = right;\r\n\tthis.top = top;\r\n\tthis.bottom = bottom;\r\n\r\n\tthis.near = ( near !== undefined ) ? near : 0.1;\r\n\tthis.far = ( far !== undefined ) ? far : 2000;\r\n\r\n\tthis.updateProjectionMatrix();\r\n\r\n};\r\n\r\nTHREE.OrthographicCamera.prototype = Object.create( THREE.Camera.prototype );\r\nTHREE.OrthographicCamera.prototype.constructor = THREE.OrthographicCamera;\r\n\r\nTHREE.OrthographicCamera.prototype.updateProjectionMatrix = function () {\r\n\r\n\tvar dx = ( this.right - this.left ) / ( 2 * this.zoom );\r\n\tvar dy = ( this.top - this.bottom ) / ( 2 * this.zoom );\r\n\tvar cx = ( this.right + this.left ) / 2;\r\n\tvar cy = ( this.top + this.bottom ) / 2;\r\n\r\n\tthis.projectionMatrix.makeOrthographic( cx - dx, cx + dx, cy + dy, cy - dy, this.near, this.far );\r\n\r\n};\r\n\r\nTHREE.OrthographicCamera.prototype.clone = function () {\r\n\r\n\tvar camera = new THREE.OrthographicCamera();\r\n\r\n\tTHREE.Camera.prototype.clone.call( this, camera );\r\n\r\n\tcamera.zoom = this.zoom;\r\n\r\n\tcamera.left = this.left;\r\n\tcamera.right = this.right;\r\n\tcamera.top = this.top;\r\n\tcamera.bottom = this.bottom;\r\n\r\n\tcamera.near = this.near;\r\n\tcamera.far = this.far;\r\n\r\n\tcamera.projectionMatrix.copy( this.projectionMatrix );\r\n\r\n\treturn camera;\r\n};\r\n\r\n// File:src/cameras/PerspectiveCamera.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author greggman / http://games.greggman.com/\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n */\r\n\r\nTHREE.PerspectiveCamera = function ( fov, aspect, near, far ) {\r\n\r\n\tTHREE.Camera.call( this );\r\n\r\n\tthis.type = 'PerspectiveCamera';\r\n\r\n\tthis.zoom = 1;\r\n\r\n\tthis.fov = fov !== undefined ? fov : 50;\r\n\tthis.aspect = aspect !== undefined ? aspect : 1;\r\n\tthis.near = near !== undefined ? near : 0.1;\r\n\tthis.far = far !== undefined ? far : 2000;\r\n\r\n\tthis.updateProjectionMatrix();\r\n\r\n};\r\n\r\nTHREE.PerspectiveCamera.prototype = Object.create( THREE.Camera.prototype );\r\nTHREE.PerspectiveCamera.prototype.constructor = THREE.PerspectiveCamera;\r\n\r\n\r\n/**\r\n * Uses Focal Length (in mm) to estimate and set FOV\r\n * 35mm (fullframe) camera is used if frame size is not specified;\r\n * Formula based on http://www.bobatkins.com/photography/technical/field_of_view.html\r\n */\r\n\r\nTHREE.PerspectiveCamera.prototype.setLens = function ( focalLength, frameHeight ) {\r\n\r\n\tif ( frameHeight === undefined ) frameHeight = 24;\r\n\r\n\tthis.fov = 2 * THREE.Math.radToDeg( Math.atan( frameHeight / ( focalLength * 2 ) ) );\r\n\tthis.updateProjectionMatrix();\r\n\r\n}\r\n\r\n\r\n/**\r\n * Sets an offset in a larger frustum. This is useful for multi-window or\r\n * multi-monitor/multi-machine setups.\r\n *\r\n * For example, if you have 3x2 monitors and each monitor is 1920x1080 and\r\n * the monitors are in grid like this\r\n *\r\n *   +---+---+---+\r\n *   | A | B | C |\r\n *   +---+---+---+\r\n *   | D | E | F |\r\n *   +---+---+---+\r\n *\r\n * then for each monitor you would call it like this\r\n *\r\n *   var w = 1920;\r\n *   var h = 1080;\r\n *   var fullWidth = w * 3;\r\n *   var fullHeight = h * 2;\r\n *\r\n *   --A--\r\n *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );\r\n *   --B--\r\n *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );\r\n *   --C--\r\n *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );\r\n *   --D--\r\n *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );\r\n *   --E--\r\n *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );\r\n *   --F--\r\n *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );\r\n *\r\n *   Note there is no reason monitors have to be the same size or in a grid.\r\n */\r\n\r\nTHREE.PerspectiveCamera.prototype.setViewOffset = function ( fullWidth, fullHeight, x, y, width, height ) {\r\n\r\n\tthis.fullWidth = fullWidth;\r\n\tthis.fullHeight = fullHeight;\r\n\tthis.x = x;\r\n\tthis.y = y;\r\n\tthis.width = width;\r\n\tthis.height = height;\r\n\r\n\tthis.updateProjectionMatrix();\r\n\r\n};\r\n\r\n\r\nTHREE.PerspectiveCamera.prototype.updateProjectionMatrix = function () {\r\n\r\n\tvar fov = THREE.Math.radToDeg( 2 * Math.atan( Math.tan( THREE.Math.degToRad( this.fov ) * 0.5 ) / this.zoom ) );\r\n\r\n\tif ( this.fullWidth ) {\r\n\r\n\t\tvar aspect = this.fullWidth / this.fullHeight;\r\n\t\tvar top = Math.tan( THREE.Math.degToRad( fov * 0.5 ) ) * this.near;\r\n\t\tvar bottom = - top;\r\n\t\tvar left = aspect * bottom;\r\n\t\tvar right = aspect * top;\r\n\t\tvar width = Math.abs( right - left );\r\n\t\tvar height = Math.abs( top - bottom );\r\n\r\n\t\tthis.projectionMatrix.makeFrustum(\r\n\t\t\tleft + this.x * width / this.fullWidth,\r\n\t\t\tleft + ( this.x + this.width ) * width / this.fullWidth,\r\n\t\t\ttop - ( this.y + this.height ) * height / this.fullHeight,\r\n\t\t\ttop - this.y * height / this.fullHeight,\r\n\t\t\tthis.near,\r\n\t\t\tthis.far\r\n\t\t);\r\n\r\n\t} else {\r\n\r\n\t\tthis.projectionMatrix.makePerspective( fov, this.aspect, this.near, this.far );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.PerspectiveCamera.prototype.clone = function () {\r\n\r\n\tvar camera = new THREE.PerspectiveCamera();\r\n\r\n\tTHREE.Camera.prototype.clone.call( this, camera );\r\n\r\n\tcamera.zoom = this.zoom;\r\n\r\n\tcamera.fov = this.fov;\r\n\tcamera.aspect = this.aspect;\r\n\tcamera.near = this.near;\r\n\tcamera.far = this.far;\r\n\r\n\tcamera.projectionMatrix.copy( this.projectionMatrix );\r\n\r\n\treturn camera;\r\n\r\n};\r\n\r\n// File:src/lights/Light.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Light = function ( color ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.type = 'Light';\r\n\t\r\n\tthis.color = new THREE.Color( color );\r\n\r\n};\r\n\r\nTHREE.Light.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.Light.prototype.constructor = THREE.Light;\r\n\r\nTHREE.Light.prototype.clone = function ( light ) {\r\n\r\n\tif ( light === undefined ) light = new THREE.Light();\r\n\r\n\tTHREE.Object3D.prototype.clone.call( this, light );\r\n\r\n\tlight.color.copy( this.color );\r\n\r\n\treturn light;\r\n\r\n};\r\n\r\n// File:src/lights/AmbientLight.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.AmbientLight = function ( color ) {\r\n\r\n\tTHREE.Light.call( this, color );\r\n\r\n\tthis.type = 'AmbientLight';\r\n\r\n};\r\n\r\nTHREE.AmbientLight.prototype = Object.create( THREE.Light.prototype );\r\nTHREE.AmbientLight.prototype.constructor = THREE.AmbientLight;\r\n\r\nTHREE.AmbientLight.prototype.clone = function () {\r\n\r\n\tvar light = new THREE.AmbientLight();\r\n\r\n\tTHREE.Light.prototype.clone.call( this, light );\r\n\r\n\treturn light;\r\n\r\n};\r\n\r\n// File:src/lights/AreaLight.js\r\n\r\n/**\r\n * @author MPanknin / http://www.redplant.de/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.AreaLight = function ( color, intensity ) {\r\n\r\n\tTHREE.Light.call( this, color );\r\n\r\n\tthis.type = 'AreaLight';\r\n\r\n\tthis.normal = new THREE.Vector3( 0, - 1, 0 );\r\n\tthis.right = new THREE.Vector3( 1, 0, 0 );\r\n\r\n\tthis.intensity = ( intensity !== undefined ) ? intensity : 1;\r\n\r\n\tthis.width = 1.0;\r\n\tthis.height = 1.0;\r\n\r\n\tthis.constantAttenuation = 1.5;\r\n\tthis.linearAttenuation = 0.5;\r\n\tthis.quadraticAttenuation = 0.1;\r\n\r\n};\r\n\r\nTHREE.AreaLight.prototype = Object.create( THREE.Light.prototype );\r\nTHREE.AreaLight.prototype.constructor = THREE.AreaLight;\r\n\r\n\r\n// File:src/lights/DirectionalLight.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.DirectionalLight = function ( color, intensity ) {\r\n\r\n\tTHREE.Light.call( this, color );\r\n\r\n\tthis.type = 'DirectionalLight';\r\n\r\n\tthis.position.set( 0, 1, 0 );\r\n\tthis.target = new THREE.Object3D();\r\n\r\n\tthis.intensity = ( intensity !== undefined ) ? intensity : 1;\r\n\r\n\tthis.castShadow = false;\r\n\tthis.onlyShadow = false;\r\n\r\n\t//\r\n\r\n\tthis.shadowCameraNear = 50;\r\n\tthis.shadowCameraFar = 5000;\r\n\r\n\tthis.shadowCameraLeft = - 500;\r\n\tthis.shadowCameraRight = 500;\r\n\tthis.shadowCameraTop = 500;\r\n\tthis.shadowCameraBottom = - 500;\r\n\r\n\tthis.shadowCameraVisible = false;\r\n\r\n\tthis.shadowBias = 0;\r\n\tthis.shadowDarkness = 0.5;\r\n\r\n\tthis.shadowMapWidth = 512;\r\n\tthis.shadowMapHeight = 512;\r\n\r\n\t//\r\n\r\n\tthis.shadowCascade = false;\r\n\r\n\tthis.shadowCascadeOffset = new THREE.Vector3( 0, 0, - 1000 );\r\n\tthis.shadowCascadeCount = 2;\r\n\r\n\tthis.shadowCascadeBias = [ 0, 0, 0 ];\r\n\tthis.shadowCascadeWidth = [ 512, 512, 512 ];\r\n\tthis.shadowCascadeHeight = [ 512, 512, 512 ];\r\n\r\n\tthis.shadowCascadeNearZ = [ - 1.000, 0.990, 0.998 ];\r\n\tthis.shadowCascadeFarZ  = [ 0.990, 0.998, 1.000 ];\r\n\r\n\tthis.shadowCascadeArray = [];\r\n\r\n\t//\r\n\r\n\tthis.shadowMap = null;\r\n\tthis.shadowMapSize = null;\r\n\tthis.shadowCamera = null;\r\n\tthis.shadowMatrix = null;\r\n\r\n};\r\n\r\nTHREE.DirectionalLight.prototype = Object.create( THREE.Light.prototype );\r\nTHREE.DirectionalLight.prototype.constructor = THREE.DirectionalLight;\r\n\r\nTHREE.DirectionalLight.prototype.clone = function () {\r\n\r\n\tvar light = new THREE.DirectionalLight();\r\n\r\n\tTHREE.Light.prototype.clone.call( this, light );\r\n\r\n\tlight.target = this.target.clone();\r\n\r\n\tlight.intensity = this.intensity;\r\n\r\n\tlight.castShadow = this.castShadow;\r\n\tlight.onlyShadow = this.onlyShadow;\r\n\r\n\t//\r\n\r\n\tlight.shadowCameraNear = this.shadowCameraNear;\r\n\tlight.shadowCameraFar = this.shadowCameraFar;\r\n\r\n\tlight.shadowCameraLeft = this.shadowCameraLeft;\r\n\tlight.shadowCameraRight = this.shadowCameraRight;\r\n\tlight.shadowCameraTop = this.shadowCameraTop;\r\n\tlight.shadowCameraBottom = this.shadowCameraBottom;\r\n\r\n\tlight.shadowCameraVisible = this.shadowCameraVisible;\r\n\r\n\tlight.shadowBias = this.shadowBias;\r\n\tlight.shadowDarkness = this.shadowDarkness;\r\n\r\n\tlight.shadowMapWidth = this.shadowMapWidth;\r\n\tlight.shadowMapHeight = this.shadowMapHeight;\r\n\r\n\t//\r\n\r\n\tlight.shadowCascade = this.shadowCascade;\r\n\r\n\tlight.shadowCascadeOffset.copy( this.shadowCascadeOffset );\r\n\tlight.shadowCascadeCount = this.shadowCascadeCount;\r\n\r\n\tlight.shadowCascadeBias = this.shadowCascadeBias.slice( 0 );\r\n\tlight.shadowCascadeWidth = this.shadowCascadeWidth.slice( 0 );\r\n\tlight.shadowCascadeHeight = this.shadowCascadeHeight.slice( 0 );\r\n\r\n\tlight.shadowCascadeNearZ = this.shadowCascadeNearZ.slice( 0 );\r\n\tlight.shadowCascadeFarZ  = this.shadowCascadeFarZ.slice( 0 );\r\n\r\n\treturn light;\r\n\r\n};\r\n\r\n// File:src/lights/HemisphereLight.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.HemisphereLight = function ( skyColor, groundColor, intensity ) {\r\n\r\n\tTHREE.Light.call( this, skyColor );\r\n\r\n\tthis.type = 'HemisphereLight';\r\n\r\n\tthis.position.set( 0, 100, 0 );\r\n\r\n\tthis.groundColor = new THREE.Color( groundColor );\r\n\tthis.intensity = ( intensity !== undefined ) ? intensity : 1;\r\n\r\n};\r\n\r\nTHREE.HemisphereLight.prototype = Object.create( THREE.Light.prototype );\r\nTHREE.HemisphereLight.prototype.constructor = THREE.HemisphereLight;\r\n\r\nTHREE.HemisphereLight.prototype.clone = function () {\r\n\r\n\tvar light = new THREE.HemisphereLight();\r\n\r\n\tTHREE.Light.prototype.clone.call( this, light );\r\n\r\n\tlight.groundColor.copy( this.groundColor );\r\n\tlight.intensity = this.intensity;\r\n\r\n\treturn light;\r\n\r\n};\r\n\r\n// File:src/lights/PointLight.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.PointLight = function ( color, intensity, distance, decay ) {\r\n\r\n\tTHREE.Light.call( this, color );\r\n\r\n\tthis.type = 'PointLight';\r\n\r\n\tthis.intensity = ( intensity !== undefined ) ? intensity : 1;\r\n\tthis.distance = ( distance !== undefined ) ? distance : 0;\r\n\tthis.decay = ( decay !== undefined ) ? decay : 1;\t// for physically correct lights, should be 2.\r\n\r\n};\r\n\r\nTHREE.PointLight.prototype = Object.create( THREE.Light.prototype );\r\nTHREE.PointLight.prototype.constructor = THREE.PointLight;\r\n\r\nTHREE.PointLight.prototype.clone = function () {\r\n\r\n\tvar light = new THREE.PointLight();\r\n\r\n\tTHREE.Light.prototype.clone.call( this, light );\r\n\r\n\tlight.intensity = this.intensity;\r\n\tlight.distance = this.distance;\r\n\tlight.decay = this.decay;\r\n\r\n\treturn light;\r\n\r\n};\r\n\r\n// File:src/lights/SpotLight.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.SpotLight = function ( color, intensity, distance, angle, exponent, decay ) {\r\n\r\n\tTHREE.Light.call( this, color );\r\n\r\n\tthis.type = 'SpotLight';\r\n\r\n\tthis.position.set( 0, 1, 0 );\r\n\tthis.target = new THREE.Object3D();\r\n\r\n\tthis.intensity = ( intensity !== undefined ) ? intensity : 1;\r\n\tthis.distance = ( distance !== undefined ) ? distance : 0;\r\n\tthis.angle = ( angle !== undefined ) ? angle : Math.PI / 3;\r\n\tthis.exponent = ( exponent !== undefined ) ? exponent : 10;\r\n\tthis.decay = ( decay !== undefined ) ? decay : 1;\t// for physically correct lights, should be 2.\r\n\r\n\tthis.castShadow = false;\r\n\tthis.onlyShadow = false;\r\n\r\n\t//\r\n\r\n\tthis.shadowCameraNear = 50;\r\n\tthis.shadowCameraFar = 5000;\r\n\tthis.shadowCameraFov = 50;\r\n\r\n\tthis.shadowCameraVisible = false;\r\n\r\n\tthis.shadowBias = 0;\r\n\tthis.shadowDarkness = 0.5;\r\n\r\n\tthis.shadowMapWidth = 512;\r\n\tthis.shadowMapHeight = 512;\r\n\r\n\t//\r\n\r\n\tthis.shadowMap = null;\r\n\tthis.shadowMapSize = null;\r\n\tthis.shadowCamera = null;\r\n\tthis.shadowMatrix = null;\r\n\r\n};\r\n\r\nTHREE.SpotLight.prototype = Object.create( THREE.Light.prototype );\r\nTHREE.SpotLight.prototype.constructor = THREE.SpotLight;\r\n\r\nTHREE.SpotLight.prototype.clone = function () {\r\n\r\n\tvar light = new THREE.SpotLight();\r\n\r\n\tTHREE.Light.prototype.clone.call( this, light );\r\n\r\n\tlight.target = this.target.clone();\r\n\r\n\tlight.intensity = this.intensity;\r\n\tlight.distance = this.distance;\r\n\tlight.angle = this.angle;\r\n\tlight.exponent = this.exponent;\r\n\tlight.decay = this.decay;\r\n\r\n\tlight.castShadow = this.castShadow;\r\n\tlight.onlyShadow = this.onlyShadow;\r\n\r\n\t//\r\n\r\n\tlight.shadowCameraNear = this.shadowCameraNear;\r\n\tlight.shadowCameraFar = this.shadowCameraFar;\r\n\tlight.shadowCameraFov = this.shadowCameraFov;\r\n\r\n\tlight.shadowCameraVisible = this.shadowCameraVisible;\r\n\r\n\tlight.shadowBias = this.shadowBias;\r\n\tlight.shadowDarkness = this.shadowDarkness;\r\n\r\n\tlight.shadowMapWidth = this.shadowMapWidth;\r\n\tlight.shadowMapHeight = this.shadowMapHeight;\r\n\r\n\treturn light;\r\n\r\n};\r\n\r\n// File:src/loaders/Cache.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Cache = {\r\n\r\n\tfiles: {},\r\n\r\n\tadd: function ( key, file ) {\r\n\r\n\t\t// console.log( 'THREE.Cache', 'Adding key:', key );\r\n\r\n\t\tthis.files[ key ] = file;\r\n\r\n\t},\r\n\r\n\tget: function ( key ) {\r\n\r\n\t\t// console.log( 'THREE.Cache', 'Checking key:', key );\r\n\r\n\t\treturn this.files[ key ];\r\n\r\n\t},\r\n\r\n\tremove: function ( key ) {\r\n\r\n\t\tdelete this.files[ key ];\r\n\r\n\t},\r\n\r\n\tclear: function () {\r\n\r\n\t\tthis.files = {}\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/loaders/Loader.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Loader = function ( showStatus ) {\r\n\r\n\tthis.showStatus = showStatus;\r\n\tthis.statusDomElement = showStatus ? THREE.Loader.prototype.addStatusElement() : null;\r\n\r\n\tthis.imageLoader = new THREE.ImageLoader();\r\n\r\n\tthis.onLoadStart = function () {};\r\n\tthis.onLoadProgress = function () {};\r\n\tthis.onLoadComplete = function () {};\r\n\r\n};\r\n\r\nTHREE.Loader.prototype = {\r\n\r\n\tconstructor: THREE.Loader,\r\n\r\n\tcrossOrigin: undefined,\r\n\r\n\taddStatusElement: function () {\r\n\r\n\t\tvar e = document.createElement( 'div' );\r\n\r\n\t\te.style.position = 'absolute';\r\n\t\te.style.right = '0px';\r\n\t\te.style.top = '0px';\r\n\t\te.style.fontSize = '0.8em';\r\n\t\te.style.textAlign = 'left';\r\n\t\te.style.background = 'rgba(0,0,0,0.25)';\r\n\t\te.style.color = '#fff';\r\n\t\te.style.width = '120px';\r\n\t\te.style.padding = '0.5em 0.5em 0.5em 0.5em';\r\n\t\te.style.zIndex = 1000;\r\n\r\n\t\te.innerHTML = 'Loading ...';\r\n\r\n\t\treturn e;\r\n\r\n\t},\r\n\r\n\tupdateProgress: function ( progress ) {\r\n\r\n\t\tvar message = 'Loaded ';\r\n\r\n\t\tif ( progress.total ) {\r\n\r\n\t\t\tmessage += ( 100 * progress.loaded / progress.total ).toFixed( 0 ) + '%';\r\n\r\n\r\n\t\t} else {\r\n\r\n\t\t\tmessage += ( progress.loaded / 1024 ).toFixed( 2 ) + ' KB';\r\n\r\n\t\t}\r\n\r\n\t\tthis.statusDomElement.innerHTML = message;\r\n\r\n\t},\r\n\r\n\textractUrlBase: function ( url ) {\r\n\r\n\t\tvar parts = url.split( '/' );\r\n\r\n\t\tif ( parts.length === 1 ) return './';\r\n\r\n\t\tparts.pop();\r\n\r\n\t\treturn parts.join( '/' ) + '/';\r\n\r\n\t},\r\n\r\n\tinitMaterials: function ( materials, texturePath ) {\r\n\r\n\t\tvar array = [];\r\n\r\n\t\tfor ( var i = 0; i < materials.length; ++ i ) {\r\n\r\n\t\t\tarray[ i ] = this.createMaterial( materials[ i ], texturePath );\r\n\r\n\t\t}\r\n\r\n\t\treturn array;\r\n\r\n\t},\r\n\r\n\tneedsTangents: function ( materials ) {\r\n\r\n\t\tfor ( var i = 0, il = materials.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar m = materials[ i ];\r\n\r\n\t\t\tif ( m instanceof THREE.ShaderMaterial ) return true;\r\n\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\r\n\t},\r\n\r\n\tcreateMaterial: function ( m, texturePath ) {\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tfunction nearest_pow2( n ) {\r\n\r\n\t\t\tvar l = Math.log( n ) / Math.LN2;\r\n\t\t\treturn Math.pow( 2, Math.round(  l ) );\r\n\r\n\t\t}\r\n\r\n\t\tfunction create_texture( where, name, sourceFile, repeat, offset, wrap, anisotropy ) {\r\n\r\n\t\t\tvar fullPath = texturePath + sourceFile;\r\n\r\n\t\t\tvar texture;\r\n\r\n\t\t\tvar loader = THREE.Loader.Handlers.get( fullPath );\r\n\r\n\t\t\tif ( loader !== null ) {\r\n\r\n\t\t\t\ttexture = loader.load( fullPath );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\ttexture = new THREE.Texture();\r\n\r\n\t\t\t\tloader = scope.imageLoader;\r\n\t\t\t\tloader.crossOrigin = scope.crossOrigin;\r\n\t\t\t\tloader.load( fullPath, function ( image ) {\r\n\r\n\t\t\t\t\tif ( THREE.Math.isPowerOfTwo( image.width ) === false ||\r\n\t\t\t\t\t\t THREE.Math.isPowerOfTwo( image.height ) === false ) {\r\n\r\n\t\t\t\t\t\tvar width = nearest_pow2( image.width );\r\n\t\t\t\t\t\tvar height = nearest_pow2( image.height );\r\n\r\n\t\t\t\t\t\tvar canvas = document.createElement( 'canvas' );\r\n\t\t\t\t\t\tcanvas.width = width;\r\n\t\t\t\t\t\tcanvas.height = height;\r\n\r\n\t\t\t\t\t\tvar context = canvas.getContext( '2d' );\r\n\t\t\t\t\t\tcontext.drawImage( image, 0, 0, width, height );\r\n\r\n\t\t\t\t\t\ttexture.image = canvas;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\ttexture.image = image;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\ttexture.needsUpdate = true;\r\n\r\n\t\t\t\t} );\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttexture.sourceFile = sourceFile;\r\n\r\n\t\t\tif ( repeat ) {\r\n\r\n\t\t\t\ttexture.repeat.set( repeat[ 0 ], repeat[ 1 ] );\r\n\r\n\t\t\t\tif ( repeat[ 0 ] !== 1 ) texture.wrapS = THREE.RepeatWrapping;\r\n\t\t\t\tif ( repeat[ 1 ] !== 1 ) texture.wrapT = THREE.RepeatWrapping;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( offset ) {\r\n\r\n\t\t\t\ttexture.offset.set( offset[ 0 ], offset[ 1 ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( wrap ) {\r\n\r\n\t\t\t\tvar wrapMap = {\r\n\t\t\t\t\t'repeat': THREE.RepeatWrapping,\r\n\t\t\t\t\t'mirror': THREE.MirroredRepeatWrapping\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( wrapMap[ wrap[ 0 ] ] !== undefined ) texture.wrapS = wrapMap[ wrap[ 0 ] ];\r\n\t\t\t\tif ( wrapMap[ wrap[ 1 ] ] !== undefined ) texture.wrapT = wrapMap[ wrap[ 1 ] ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( anisotropy ) {\r\n\r\n\t\t\t\ttexture.anisotropy = anisotropy;\r\n\r\n\t\t\t}\r\n\r\n\t\t\twhere[ name ] = texture;\r\n\r\n\t\t}\r\n\r\n\t\tfunction rgb2hex( rgb ) {\r\n\r\n\t\t\treturn ( rgb[ 0 ] * 255 << 16 ) + ( rgb[ 1 ] * 255 << 8 ) + rgb[ 2 ] * 255;\r\n\r\n\t\t}\r\n\r\n\t\t// defaults\r\n\r\n\t\tvar mtype = 'MeshLambertMaterial';\r\n\t\tvar mpars = { color: 0xeeeeee, opacity: 1.0, map: null, lightMap: null, normalMap: null, bumpMap: null, wireframe: false };\r\n\r\n\t\t// parameters from model file\r\n\r\n\t\tif ( m.shading ) {\r\n\r\n\t\t\tvar shading = m.shading.toLowerCase();\r\n\r\n\t\t\tif ( shading === 'phong' ) mtype = 'MeshPhongMaterial';\r\n\t\t\telse if ( shading === 'basic' ) mtype = 'MeshBasicMaterial';\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.blending !== undefined && THREE[ m.blending ] !== undefined ) {\r\n\r\n\t\t\tmpars.blending = THREE[ m.blending ];\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.transparent !== undefined ) {\r\n\r\n\t\t\tmpars.transparent = m.transparent;\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.opacity !== undefined && m.opacity < 1.0 ) {\r\n\r\n\t\t\tmpars.transparent = true;\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.depthTest !== undefined ) {\r\n\r\n\t\t\tmpars.depthTest = m.depthTest;\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.depthWrite !== undefined ) {\r\n\r\n\t\t\tmpars.depthWrite = m.depthWrite;\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.visible !== undefined ) {\r\n\r\n\t\t\tmpars.visible = m.visible;\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.flipSided !== undefined ) {\r\n\r\n\t\t\tmpars.side = THREE.BackSide;\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.doubleSided !== undefined ) {\r\n\r\n\t\t\tmpars.side = THREE.DoubleSide;\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.wireframe !== undefined ) {\r\n\r\n\t\t\tmpars.wireframe = m.wireframe;\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.vertexColors !== undefined ) {\r\n\r\n\t\t\tif ( m.vertexColors === 'face' ) {\r\n\r\n\t\t\t\tmpars.vertexColors = THREE.FaceColors;\r\n\r\n\t\t\t} else if ( m.vertexColors ) {\r\n\r\n\t\t\t\tmpars.vertexColors = THREE.VertexColors;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// colors\r\n\r\n\t\tif ( m.colorDiffuse ) {\r\n\r\n\t\t\tmpars.color = rgb2hex( m.colorDiffuse );\r\n\r\n\t\t} else if ( m.DbgColor ) {\r\n\r\n\t\t\tmpars.color = m.DbgColor;\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.colorSpecular ) {\r\n\r\n\t\t\tmpars.specular = rgb2hex( m.colorSpecular );\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.colorEmissive ) {\r\n\r\n\t\t\tmpars.emissive = rgb2hex( m.colorEmissive );\r\n\r\n\t\t}\r\n\r\n\t\t// modifiers\r\n\r\n\t\tif ( m.transparency !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.Loader: transparency has been renamed to opacity' );\r\n\t\t\tm.opacity = m.transparency;\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.opacity !== undefined ) {\r\n\r\n\t\t\tmpars.opacity = m.opacity;\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.specularCoef ) {\r\n\r\n\t\t\tmpars.shininess = m.specularCoef;\r\n\r\n\t\t}\r\n\r\n\t\t// textures\r\n\r\n\t\tif ( m.mapDiffuse && texturePath ) {\r\n\r\n\t\t\tcreate_texture( mpars, 'map', m.mapDiffuse, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.mapLight && texturePath ) {\r\n\r\n\t\t\tcreate_texture( mpars, 'lightMap', m.mapLight, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.mapBump && texturePath ) {\r\n\r\n\t\t\tcreate_texture( mpars, 'bumpMap', m.mapBump, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.mapNormal && texturePath ) {\r\n\r\n\t\t\tcreate_texture( mpars, 'normalMap', m.mapNormal, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.mapSpecular && texturePath ) {\r\n\r\n\t\t\tcreate_texture( mpars, 'specularMap', m.mapSpecular, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.mapAlpha && texturePath ) {\r\n\r\n\t\t\tcreate_texture( mpars, 'alphaMap', m.mapAlpha, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tif ( m.mapBumpScale ) {\r\n\r\n\t\t\tmpars.bumpScale = m.mapBumpScale;\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.mapNormalFactor ) {\r\n\r\n\t\t\tmpars.normalScale = new THREE.Vector2( m.mapNormalFactor, m.mapNormalFactor );\r\n\r\n\t\t}\r\n\r\n\t\tvar material = new THREE[ mtype ]( mpars );\r\n\r\n\t\tif ( m.DbgName !== undefined ) material.name = m.DbgName;\r\n\r\n\t\treturn material;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.Loader.Handlers = {\r\n\r\n\thandlers: [],\r\n\r\n\tadd: function ( regex, loader ) {\r\n\r\n\t\tthis.handlers.push( regex, loader );\r\n\r\n\t},\r\n\r\n\tget: function ( file ) {\r\n\r\n\t\tfor ( var i = 0, l = this.handlers.length; i < l; i += 2 ) {\r\n\r\n\t\t\tvar regex = this.handlers[ i ];\r\n\t\t\tvar loader  = this.handlers[ i + 1 ];\r\n\r\n\t\t\tif ( regex.test( file ) ) {\r\n\r\n\t\t\t\treturn loader;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn null;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/loaders/XHRLoader.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.XHRLoader = function ( manager ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\r\n};\r\n\r\nTHREE.XHRLoader.prototype = {\r\n\r\n\tconstructor: THREE.XHRLoader,\r\n\r\n\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar cached = THREE.Cache.get( url );\r\n\r\n\t\tif ( cached !== undefined ) {\r\n\r\n\t\t\tif ( onLoad ) onLoad( cached );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tvar request = new XMLHttpRequest();\r\n\t\trequest.open( 'GET', url, true );\r\n\r\n\t\trequest.addEventListener( 'load', function ( event ) {\r\n\r\n\t\t\tTHREE.Cache.add( url, this.response );\r\n\r\n\t\t\tif ( onLoad ) onLoad( this.response );\r\n\r\n\t\t\tscope.manager.itemEnd( url );\r\n\r\n\t\t}, false );\r\n\r\n\t\tif ( onProgress !== undefined ) {\r\n\r\n\t\t\trequest.addEventListener( 'progress', function ( event ) {\r\n\r\n\t\t\t\tonProgress( event );\r\n\r\n\t\t\t}, false );\r\n\r\n\t\t}\r\n\r\n\t\tif ( onError !== undefined ) {\r\n\r\n\t\t\trequest.addEventListener( 'error', function ( event ) {\r\n\r\n\t\t\t\tonError( event );\r\n\r\n\t\t\t}, false );\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.crossOrigin !== undefined ) request.crossOrigin = this.crossOrigin;\r\n\t\tif ( this.responseType !== undefined ) request.responseType = this.responseType;\r\n\r\n\t\trequest.send( null );\r\n\r\n\t\tscope.manager.itemStart( url );\r\n\r\n\t},\r\n\r\n\tsetResponseType: function ( value ) {\r\n\r\n\t\tthis.responseType = value;\r\n\r\n\t},\r\n\r\n\tsetCrossOrigin: function ( value ) {\r\n\r\n\t\tthis.crossOrigin = value;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/loaders/ImageLoader.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.ImageLoader = function ( manager ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\r\n};\r\n\r\nTHREE.ImageLoader.prototype = {\r\n\r\n\tconstructor: THREE.ImageLoader,\r\n\r\n\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar cached = THREE.Cache.get( url );\r\n\r\n\t\tif ( cached !== undefined ) {\r\n\r\n\t\t\tonLoad( cached );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tvar image = document.createElement( 'img' );\r\n\r\n\t\timage.addEventListener( 'load', function ( event ) {\r\n\r\n\t\t\tTHREE.Cache.add( url, this );\r\n\r\n\t\t\tif ( onLoad ) onLoad( this );\r\n\t\t\t\r\n\t\t\tscope.manager.itemEnd( url );\r\n\r\n\t\t}, false );\r\n\r\n\t\tif ( onProgress !== undefined ) {\r\n\r\n\t\t\timage.addEventListener( 'progress', function ( event ) {\r\n\r\n\t\t\t\tonProgress( event );\r\n\r\n\t\t\t}, false );\r\n\r\n\t\t}\r\n\r\n\t\tif ( onError !== undefined ) {\r\n\r\n\t\t\timage.addEventListener( 'error', function ( event ) {\r\n\r\n\t\t\t\tonError( event );\r\n\r\n\t\t\t}, false );\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;\r\n\r\n\t\timage.src = url;\r\n\r\n\t\tscope.manager.itemStart( url );\r\n\r\n\t\treturn image;\r\n\r\n\t},\r\n\r\n\tsetCrossOrigin: function ( value ) {\r\n\r\n\t\tthis.crossOrigin = value;\r\n\r\n\t}\r\n\r\n}\r\n\r\n// File:src/loaders/JSONLoader.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.JSONLoader = function ( showStatus ) {\r\n\r\n\tTHREE.Loader.call( this, showStatus );\r\n\r\n\tthis.withCredentials = false;\r\n\r\n};\r\n\r\nTHREE.JSONLoader.prototype = Object.create( THREE.Loader.prototype );\r\nTHREE.JSONLoader.prototype.constructor = THREE.JSONLoader;\r\n\r\nTHREE.JSONLoader.prototype.load = function ( url, callback, texturePath ) {\r\n\r\n\t// todo: unify load API to for easier SceneLoader use\r\n\r\n\ttexturePath = texturePath && ( typeof texturePath === 'string' ) ? texturePath : this.extractUrlBase( url );\r\n\r\n\tthis.onLoadStart();\r\n\tthis.loadAjaxJSON( this, url, callback, texturePath );\r\n\r\n};\r\n\r\nTHREE.JSONLoader.prototype.loadAjaxJSON = function ( context, url, callback, texturePath, callbackProgress ) {\r\n\r\n\tvar xhr = new XMLHttpRequest();\r\n\r\n\tvar length = 0;\r\n\r\n\txhr.onreadystatechange = function () {\r\n\r\n\t\tif ( xhr.readyState === xhr.DONE ) {\r\n\r\n\t\t\tif ( xhr.status === 200 || xhr.status === 0 ) {\r\n\r\n\t\t\t\tif ( xhr.responseText ) {\r\n\r\n\t\t\t\t\tvar json = JSON.parse( xhr.responseText );\r\n\t\t\t\t\tvar metadata = json.metadata;\r\n\r\n\t\t\t\t\tif ( metadata !== undefined ) {\r\n\r\n\t\t\t\t\t\tif ( metadata.type === 'object' ) {\r\n\r\n\t\t\t\t\t\t\tTHREE.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.' );\r\n\t\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif ( metadata.type === 'scene' ) {\r\n\r\n\t\t\t\t\t\t\tTHREE.error( 'THREE.JSONLoader: ' + url + ' seems to be a Scene. Use THREE.SceneLoader instead.' );\r\n\t\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tvar result = context.parse( json, texturePath );\r\n\t\t\t\t\tcallback( result.geometry, result.materials );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tTHREE.error( 'THREE.JSONLoader: ' + url + ' seems to be unreachable or the file is empty.' );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// in context of more complex asset initialization\r\n\t\t\t\t// do not block on single failed file\r\n\t\t\t\t// maybe should go even one more level up\r\n\r\n\t\t\t\tcontext.onLoadComplete();\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tTHREE.error( 'THREE.JSONLoader: Couldn\\'t load ' + url + ' (' + xhr.status + ')' );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( xhr.readyState === xhr.LOADING ) {\r\n\r\n\t\t\tif ( callbackProgress ) {\r\n\r\n\t\t\t\tif ( length === 0 ) {\r\n\r\n\t\t\t\t\tlength = xhr.getResponseHeader( 'Content-Length' );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tcallbackProgress( { total: length, loaded: xhr.responseText.length } );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( xhr.readyState === xhr.HEADERS_RECEIVED ) {\r\n\r\n\t\t\tif ( callbackProgress !== undefined ) {\r\n\r\n\t\t\t\tlength = xhr.getResponseHeader( 'Content-Length' );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\txhr.open( 'GET', url, true );\r\n\txhr.withCredentials = this.withCredentials;\r\n\txhr.send( null );\r\n\r\n};\r\n\r\nTHREE.JSONLoader.prototype.parse = function ( json, texturePath ) {\r\n\r\n\tvar geometry = new THREE.Geometry(),\r\n\tscale = ( json.scale !== undefined ) ? 1.0 / json.scale : 1.0;\r\n\r\n\tparseModel( scale );\r\n\r\n\tparseSkin();\r\n\tparseMorphing( scale );\r\n\r\n\tgeometry.computeFaceNormals();\r\n\tgeometry.computeBoundingSphere();\r\n\r\n\tfunction parseModel( scale ) {\r\n\r\n\t\tfunction isBitSet( value, position ) {\r\n\r\n\t\t\treturn value & ( 1 << position );\r\n\r\n\t\t}\r\n\r\n\t\tvar i, j, fi,\r\n\r\n\t\toffset, zLength,\r\n\r\n\t\tcolorIndex, normalIndex, uvIndex, materialIndex,\r\n\r\n\t\ttype,\r\n\t\tisQuad,\r\n\t\thasMaterial,\r\n\t\thasFaceVertexUv,\r\n\t\thasFaceNormal, hasFaceVertexNormal,\r\n\t\thasFaceColor, hasFaceVertexColor,\r\n\r\n\t\tvertex, face, faceA, faceB, hex, normal,\r\n\r\n\t\tuvLayer, uv, u, v,\r\n\r\n\t\tfaces = json.faces,\r\n\t\tvertices = json.vertices,\r\n\t\tnormals = json.normals,\r\n\t\tcolors = json.colors,\r\n\r\n\t\tnUvLayers = 0;\r\n\r\n\t\tif ( json.uvs !== undefined ) {\r\n\r\n\t\t\t// disregard empty arrays\r\n\r\n\t\t\tfor ( i = 0; i < json.uvs.length; i ++ ) {\r\n\r\n\t\t\t\tif ( json.uvs[ i ].length ) nUvLayers ++;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( i = 0; i < nUvLayers; i ++ ) {\r\n\r\n\t\t\t\tgeometry.faceVertexUvs[ i ] = [];\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\toffset = 0;\r\n\t\tzLength = vertices.length;\r\n\r\n\t\twhile ( offset < zLength ) {\r\n\r\n\t\t\tvertex = new THREE.Vector3();\r\n\r\n\t\t\tvertex.x = vertices[ offset ++ ] * scale;\r\n\t\t\tvertex.y = vertices[ offset ++ ] * scale;\r\n\t\t\tvertex.z = vertices[ offset ++ ] * scale;\r\n\r\n\t\t\tgeometry.vertices.push( vertex );\r\n\r\n\t\t}\r\n\r\n\t\toffset = 0;\r\n\t\tzLength = faces.length;\r\n\r\n\t\twhile ( offset < zLength ) {\r\n\r\n\t\t\ttype = faces[ offset ++ ];\r\n\r\n\r\n\t\t\tisQuad              = isBitSet( type, 0 );\r\n\t\t\thasMaterial         = isBitSet( type, 1 );\r\n\t\t\thasFaceVertexUv     = isBitSet( type, 3 );\r\n\t\t\thasFaceNormal       = isBitSet( type, 4 );\r\n\t\t\thasFaceVertexNormal = isBitSet( type, 5 );\r\n\t\t\thasFaceColor\t     = isBitSet( type, 6 );\r\n\t\t\thasFaceVertexColor  = isBitSet( type, 7 );\r\n\r\n\t\t\t// console.log(\"type\", type, \"bits\", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);\r\n\r\n\t\t\tif ( isQuad ) {\r\n\r\n\t\t\t\tfaceA = new THREE.Face3();\r\n\t\t\t\tfaceA.a = faces[ offset ];\r\n\t\t\t\tfaceA.b = faces[ offset + 1 ];\r\n\t\t\t\tfaceA.c = faces[ offset + 3 ];\r\n\r\n\t\t\t\tfaceB = new THREE.Face3();\r\n\t\t\t\tfaceB.a = faces[ offset + 1 ];\r\n\t\t\t\tfaceB.b = faces[ offset + 2 ];\r\n\t\t\t\tfaceB.c = faces[ offset + 3 ];\r\n\r\n\t\t\t\toffset += 4;\r\n\r\n\t\t\t\tif ( hasMaterial ) {\r\n\r\n\t\t\t\t\tmaterialIndex = faces[ offset ++ ];\r\n\t\t\t\t\tfaceA.materialIndex = materialIndex;\r\n\t\t\t\t\tfaceB.materialIndex = materialIndex;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// to get face <=> uv index correspondence\r\n\r\n\t\t\t\tfi = geometry.faces.length;\r\n\r\n\t\t\t\tif ( hasFaceVertexUv ) {\r\n\r\n\t\t\t\t\tfor ( i = 0; i < nUvLayers; i ++ ) {\r\n\r\n\t\t\t\t\t\tuvLayer = json.uvs[ i ];\r\n\r\n\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ] = [];\r\n\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi + 1 ] = []\r\n\r\n\t\t\t\t\t\tfor ( j = 0; j < 4; j ++ ) {\r\n\r\n\t\t\t\t\t\t\tuvIndex = faces[ offset ++ ];\r\n\r\n\t\t\t\t\t\t\tu = uvLayer[ uvIndex * 2 ];\r\n\t\t\t\t\t\t\tv = uvLayer[ uvIndex * 2 + 1 ];\r\n\r\n\t\t\t\t\t\t\tuv = new THREE.Vector2( u, v );\r\n\r\n\t\t\t\t\t\t\tif ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );\r\n\t\t\t\t\t\t\tif ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( hasFaceNormal ) {\r\n\r\n\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\r\n\r\n\t\t\t\t\tfaceA.normal.set(\r\n\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\tnormals[ normalIndex ]\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t\tfaceB.normal.copy( faceA.normal );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( hasFaceVertexNormal ) {\r\n\r\n\t\t\t\t\tfor ( i = 0; i < 4; i ++ ) {\r\n\r\n\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\r\n\r\n\t\t\t\t\t\tnormal = new THREE.Vector3(\r\n\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\t\tnormals[ normalIndex ]\r\n\t\t\t\t\t\t);\r\n\r\n\r\n\t\t\t\t\t\tif ( i !== 2 ) faceA.vertexNormals.push( normal );\r\n\t\t\t\t\t\tif ( i !== 0 ) faceB.vertexNormals.push( normal );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\r\n\t\t\t\tif ( hasFaceColor ) {\r\n\r\n\t\t\t\t\tcolorIndex = faces[ offset ++ ];\r\n\t\t\t\t\thex = colors[ colorIndex ];\r\n\r\n\t\t\t\t\tfaceA.color.setHex( hex );\r\n\t\t\t\t\tfaceB.color.setHex( hex );\r\n\r\n\t\t\t\t}\r\n\r\n\r\n\t\t\t\tif ( hasFaceVertexColor ) {\r\n\r\n\t\t\t\t\tfor ( i = 0; i < 4; i ++ ) {\r\n\r\n\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\r\n\t\t\t\t\t\thex = colors[ colorIndex ];\r\n\r\n\t\t\t\t\t\tif ( i !== 2 ) faceA.vertexColors.push( new THREE.Color( hex ) );\r\n\t\t\t\t\t\tif ( i !== 0 ) faceB.vertexColors.push( new THREE.Color( hex ) );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tgeometry.faces.push( faceA );\r\n\t\t\t\tgeometry.faces.push( faceB );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tface = new THREE.Face3();\r\n\t\t\t\tface.a = faces[ offset ++ ];\r\n\t\t\t\tface.b = faces[ offset ++ ];\r\n\t\t\t\tface.c = faces[ offset ++ ];\r\n\r\n\t\t\t\tif ( hasMaterial ) {\r\n\r\n\t\t\t\t\tmaterialIndex = faces[ offset ++ ];\r\n\t\t\t\t\tface.materialIndex = materialIndex;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// to get face <=> uv index correspondence\r\n\r\n\t\t\t\tfi = geometry.faces.length;\r\n\r\n\t\t\t\tif ( hasFaceVertexUv ) {\r\n\r\n\t\t\t\t\tfor ( i = 0; i < nUvLayers; i ++ ) {\r\n\r\n\t\t\t\t\t\tuvLayer = json.uvs[ i ];\r\n\r\n\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ] = [];\r\n\r\n\t\t\t\t\t\tfor ( j = 0; j < 3; j ++ ) {\r\n\r\n\t\t\t\t\t\t\tuvIndex = faces[ offset ++ ];\r\n\r\n\t\t\t\t\t\t\tu = uvLayer[ uvIndex * 2 ];\r\n\t\t\t\t\t\t\tv = uvLayer[ uvIndex * 2 + 1 ];\r\n\r\n\t\t\t\t\t\t\tuv = new THREE.Vector2( u, v );\r\n\r\n\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ].push( uv );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( hasFaceNormal ) {\r\n\r\n\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\r\n\r\n\t\t\t\t\tface.normal.set(\r\n\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\tnormals[ normalIndex ]\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( hasFaceVertexNormal ) {\r\n\r\n\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\r\n\r\n\t\t\t\t\t\tnormal = new THREE.Vector3(\r\n\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\t\tnormals[ normalIndex ]\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\tface.vertexNormals.push( normal );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\r\n\t\t\t\tif ( hasFaceColor ) {\r\n\r\n\t\t\t\t\tcolorIndex = faces[ offset ++ ];\r\n\t\t\t\t\tface.color.setHex( colors[ colorIndex ] );\r\n\r\n\t\t\t\t}\r\n\r\n\r\n\t\t\t\tif ( hasFaceVertexColor ) {\r\n\r\n\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\r\n\t\t\t\t\t\tface.vertexColors.push( new THREE.Color( colors[ colorIndex ] ) );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tgeometry.faces.push( face );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction parseSkin() {\r\n\t\tvar influencesPerVertex = ( json.influencesPerVertex !== undefined ) ? json.influencesPerVertex : 2;\r\n\r\n\t\tif ( json.skinWeights ) {\r\n\r\n\t\t\tfor ( var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex ) {\r\n\r\n\t\t\t\tvar x =                               json.skinWeights[ i     ];\r\n\t\t\t\tvar y = ( influencesPerVertex > 1 ) ? json.skinWeights[ i + 1 ] : 0;\r\n\t\t\t\tvar z = ( influencesPerVertex > 2 ) ? json.skinWeights[ i + 2 ] : 0;\r\n\t\t\t\tvar w = ( influencesPerVertex > 3 ) ? json.skinWeights[ i + 3 ] : 0;\r\n\r\n\t\t\t\tgeometry.skinWeights.push( new THREE.Vector4( x, y, z, w ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( json.skinIndices ) {\r\n\r\n\t\t\tfor ( var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex ) {\r\n\r\n\t\t\t\tvar a =                               json.skinIndices[ i     ];\r\n\t\t\t\tvar b = ( influencesPerVertex > 1 ) ? json.skinIndices[ i + 1 ] : 0;\r\n\t\t\t\tvar c = ( influencesPerVertex > 2 ) ? json.skinIndices[ i + 2 ] : 0;\r\n\t\t\t\tvar d = ( influencesPerVertex > 3 ) ? json.skinIndices[ i + 3 ] : 0;\r\n\r\n\t\t\t\tgeometry.skinIndices.push( new THREE.Vector4( a, b, c, d ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tgeometry.bones = json.bones;\r\n\r\n\t\tif ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {\r\n\r\n\t\t\tTHREE.warn( 'THREE.JSONLoader: When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +\r\n\t\t\t\t\tgeometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );\r\n\r\n\t\t}\r\n\r\n\r\n\t\t// could change this to json.animations[0] or remove completely\r\n\r\n\t\tgeometry.animation = json.animation;\r\n\t\tgeometry.animations = json.animations;\r\n\r\n\t};\r\n\r\n\tfunction parseMorphing( scale ) {\r\n\r\n\t\tif ( json.morphTargets !== undefined ) {\r\n\r\n\t\t\tvar i, l, v, vl, dstVertices, srcVertices;\r\n\r\n\t\t\tfor ( i = 0, l = json.morphTargets.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tgeometry.morphTargets[ i ] = {};\r\n\t\t\t\tgeometry.morphTargets[ i ].name = json.morphTargets[ i ].name;\r\n\t\t\t\tgeometry.morphTargets[ i ].vertices = [];\r\n\r\n\t\t\t\tdstVertices = geometry.morphTargets[ i ].vertices;\r\n\t\t\t\tsrcVertices = json.morphTargets [ i ].vertices;\r\n\r\n\t\t\t\tfor ( v = 0, vl = srcVertices.length; v < vl; v += 3 ) {\r\n\r\n\t\t\t\t\tvar vertex = new THREE.Vector3();\r\n\t\t\t\t\tvertex.x = srcVertices[ v ] * scale;\r\n\t\t\t\t\tvertex.y = srcVertices[ v + 1 ] * scale;\r\n\t\t\t\t\tvertex.z = srcVertices[ v + 2 ] * scale;\r\n\r\n\t\t\t\t\tdstVertices.push( vertex );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( json.morphColors !== undefined ) {\r\n\r\n\t\t\tvar i, l, c, cl, dstColors, srcColors, color;\r\n\r\n\t\t\tfor ( i = 0, l = json.morphColors.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tgeometry.morphColors[ i ] = {};\r\n\t\t\t\tgeometry.morphColors[ i ].name = json.morphColors[ i ].name;\r\n\t\t\t\tgeometry.morphColors[ i ].colors = [];\r\n\r\n\t\t\t\tdstColors = geometry.morphColors[ i ].colors;\r\n\t\t\t\tsrcColors = json.morphColors [ i ].colors;\r\n\r\n\t\t\t\tfor ( c = 0, cl = srcColors.length; c < cl; c += 3 ) {\r\n\r\n\t\t\t\t\tcolor = new THREE.Color( 0xffaa00 );\r\n\t\t\t\t\tcolor.setRGB( srcColors[ c ], srcColors[ c + 1 ], srcColors[ c + 2 ] );\r\n\t\t\t\t\tdstColors.push( color );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tif ( json.materials === undefined || json.materials.length === 0 ) {\r\n\r\n\t\treturn { geometry: geometry };\r\n\r\n\t} else {\r\n\r\n\t\tvar materials = this.initMaterials( json.materials, texturePath );\r\n\r\n\t\tif ( this.needsTangents( materials ) ) {\r\n\r\n\t\t\tgeometry.computeTangents();\r\n\r\n\t\t}\r\n\r\n\t\treturn { geometry: geometry, materials: materials };\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/loaders/LoadingManager.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.LoadingManager = function ( onLoad, onProgress, onError ) {\r\n\r\n\tvar scope = this;\r\n\r\n\tvar loaded = 0, total = 0;\r\n\r\n\tthis.onLoad = onLoad;\r\n\tthis.onProgress = onProgress;\r\n\tthis.onError = onError;\r\n\r\n\tthis.itemStart = function ( url ) {\r\n\r\n\t\ttotal ++;\r\n\r\n\t};\r\n\r\n\tthis.itemEnd = function ( url ) {\r\n\r\n\t\tloaded ++;\r\n\r\n\t\tif ( scope.onProgress !== undefined ) {\r\n\r\n\t\t\tscope.onProgress( url, loaded, total );\r\n\r\n\t\t}\r\n\r\n\t\tif ( loaded === total && scope.onLoad !== undefined ) {\r\n\r\n\t\t\tscope.onLoad();\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n};\r\n\r\nTHREE.DefaultLoadingManager = new THREE.LoadingManager();\r\n\r\n// File:src/loaders/BufferGeometryLoader.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.BufferGeometryLoader = function ( manager ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\r\n};\r\n\r\nTHREE.BufferGeometryLoader.prototype = {\r\n\r\n\tconstructor: THREE.BufferGeometryLoader,\r\n\r\n\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar loader = new THREE.XHRLoader( scope.manager );\r\n\t\tloader.setCrossOrigin( this.crossOrigin );\r\n\t\tloader.load( url, function ( text ) {\r\n\r\n\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\r\n\r\n\t\t}, onProgress, onError );\r\n\r\n\t},\r\n\r\n\tsetCrossOrigin: function ( value ) {\r\n\r\n\t\tthis.crossOrigin = value;\r\n\r\n\t},\r\n\r\n\tparse: function ( json ) {\r\n\r\n\t\tvar geometry = new THREE.BufferGeometry();\r\n\r\n\t\tvar attributes = json.data.attributes;\r\n\r\n\t\tfor ( var key in attributes ) {\r\n\r\n\t\t\tvar attribute = attributes[ key ];\r\n\t\t\tvar typedArray = new self[ attribute.type ]( attribute.array );\r\n\r\n\t\t\tgeometry.addAttribute( key, new THREE.BufferAttribute( typedArray, attribute.itemSize ) );\r\n\r\n\t\t}\r\n\r\n\t\tvar offsets = json.data.offsets;\r\n\r\n\t\tif ( offsets !== undefined ) {\r\n\r\n\t\t\tgeometry.offsets = JSON.parse( JSON.stringify( offsets ) );\r\n\r\n\t\t}\r\n\r\n\t\tvar boundingSphere = json.data.boundingSphere;\r\n\r\n\t\tif ( boundingSphere !== undefined ) {\r\n\r\n\t\t\tvar center = new THREE.Vector3();\r\n\r\n\t\t\tif ( boundingSphere.center !== undefined ) {\r\n\r\n\t\t\t\tcenter.fromArray( boundingSphere.center );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeometry.boundingSphere = new THREE.Sphere( center, boundingSphere.radius );\r\n\r\n\t\t}\r\n\r\n\t\treturn geometry;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/loaders/MaterialLoader.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.MaterialLoader = function ( manager ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\r\n};\r\n\r\nTHREE.MaterialLoader.prototype = {\r\n\r\n\tconstructor: THREE.MaterialLoader,\r\n\r\n\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar loader = new THREE.XHRLoader( scope.manager );\r\n\t\tloader.setCrossOrigin( this.crossOrigin );\r\n\t\tloader.load( url, function ( text ) {\r\n\r\n\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\r\n\r\n\t\t}, onProgress, onError );\r\n\r\n\t},\r\n\r\n\tsetCrossOrigin: function ( value ) {\r\n\r\n\t\tthis.crossOrigin = value;\r\n\r\n\t},\r\n\r\n\tparse: function ( json ) {\r\n\r\n\t\tvar material = new THREE[ json.type ];\r\n\r\n\t\tif ( json.color !== undefined ) material.color.setHex( json.color );\r\n\t\tif ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );\r\n\t\tif ( json.specular !== undefined ) material.specular.setHex( json.specular );\r\n\t\tif ( json.shininess !== undefined ) material.shininess = json.shininess;\r\n\t\tif ( json.uniforms !== undefined ) material.uniforms = json.uniforms;\r\n\t\tif ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;\r\n\t\tif ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;\r\n\t\tif ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;\r\n\t\tif ( json.shading !== undefined ) material.shading = json.shading;\r\n\t\tif ( json.blending !== undefined ) material.blending = json.blending;\r\n\t\tif ( json.side !== undefined ) material.side = json.side;\r\n\t\tif ( json.opacity !== undefined ) material.opacity = json.opacity;\r\n\t\tif ( json.transparent !== undefined ) material.transparent = json.transparent;\r\n\t\tif ( json.wireframe !== undefined ) material.wireframe = json.wireframe;\r\n\r\n\t\t// for PointCloudMaterial\r\n\t\tif ( json.size !== undefined ) material.size = json.size;\r\n\t\tif ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;\r\n\r\n\t\tif ( json.materials !== undefined ) {\r\n\r\n\t\t\tfor ( var i = 0, l = json.materials.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tmaterial.materials.push( this.parse( json.materials[ i ] ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn material;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/loaders/ObjectLoader.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.ObjectLoader = function ( manager ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\tthis.texturePath = '';\r\n\r\n};\r\n\r\nTHREE.ObjectLoader.prototype = {\r\n\r\n\tconstructor: THREE.ObjectLoader,\r\n\r\n\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tif ( this.texturePath === '' ) {\r\n\r\n\t\t\tthis.texturePath = url.substring( 0, url.lastIndexOf( '/' ) + 1 );\r\n\r\n\t\t}\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar loader = new THREE.XHRLoader( scope.manager );\r\n\t\tloader.setCrossOrigin( this.crossOrigin );\r\n\t\tloader.load( url, function ( text ) {\r\n\r\n\t\t\tscope.parse( JSON.parse( text ), onLoad );\r\n\r\n\t\t}, onProgress, onError );\r\n\r\n\t},\r\n\r\n\tsetTexturePath: function ( value ) {\r\n\r\n\t\tthis.texturePath = value;\r\n\r\n\t},\r\n\r\n\tsetCrossOrigin: function ( value ) {\r\n\r\n\t\tthis.crossOrigin = value;\r\n\r\n\t},\r\n\r\n\tparse: function ( json, onLoad ) {\r\n\r\n\t\tvar geometries = this.parseGeometries( json.geometries );\r\n\r\n\t\tvar images = this.parseImages( json.images, function () {\r\n\r\n\t\t\tif ( onLoad !== undefined ) onLoad( object );\r\n\r\n\t\t} );\r\n\t\tvar textures  = this.parseTextures( json.textures, images );\r\n\t\tvar materials = this.parseMaterials( json.materials, textures );\r\n\t\tvar object = this.parseObject( json.object, geometries, materials );\r\n\r\n\t\tif ( json.images === undefined || json.images.length === 0 ) {\r\n\r\n\t\t\tif ( onLoad !== undefined ) onLoad( object );\r\n\r\n\t\t}\r\n\r\n\t\treturn object;\r\n\r\n\t},\r\n\r\n\tparseGeometries: function ( json ) {\r\n\r\n\t\tvar geometries = {};\r\n\r\n\t\tif ( json !== undefined ) {\r\n\r\n\t\t\tvar geometryLoader = new THREE.JSONLoader();\r\n\t\t\tvar bufferGeometryLoader = new THREE.BufferGeometryLoader();\r\n\r\n\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar geometry;\r\n\t\t\t\tvar data = json[ i ];\r\n\r\n\t\t\t\tswitch ( data.type ) {\r\n\r\n\t\t\t\t\tcase 'PlaneGeometry':\r\n\t\t\t\t\tcase 'PlaneBufferGeometry':\r\n\r\n\t\t\t\t\t\tgeometry = new THREE[ data.type ](\r\n\t\t\t\t\t\t\tdata.width,\r\n\t\t\t\t\t\t\tdata.height,\r\n\t\t\t\t\t\t\tdata.widthSegments,\r\n\t\t\t\t\t\t\tdata.heightSegments\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'BoxGeometry':\r\n\t\t\t\t\tcase 'CubeGeometry': // backwards compatible\r\n\r\n\t\t\t\t\t\tgeometry = new THREE.BoxGeometry(\r\n\t\t\t\t\t\t\tdata.width,\r\n\t\t\t\t\t\t\tdata.height,\r\n\t\t\t\t\t\t\tdata.depth,\r\n\t\t\t\t\t\t\tdata.widthSegments,\r\n\t\t\t\t\t\t\tdata.heightSegments,\r\n\t\t\t\t\t\t\tdata.depthSegments\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'CircleGeometry':\r\n\r\n\t\t\t\t\t\tgeometry = new THREE.CircleGeometry(\r\n\t\t\t\t\t\t\tdata.radius,\r\n\t\t\t\t\t\t\tdata.segments\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'CylinderGeometry':\r\n\r\n\t\t\t\t\t\tgeometry = new THREE.CylinderGeometry(\r\n\t\t\t\t\t\t\tdata.radiusTop,\r\n\t\t\t\t\t\t\tdata.radiusBottom,\r\n\t\t\t\t\t\t\tdata.height,\r\n\t\t\t\t\t\t\tdata.radialSegments,\r\n\t\t\t\t\t\t\tdata.heightSegments,\r\n\t\t\t\t\t\t\tdata.openEnded\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'SphereGeometry':\r\n\r\n\t\t\t\t\t\tgeometry = new THREE.SphereGeometry(\r\n\t\t\t\t\t\t\tdata.radius,\r\n\t\t\t\t\t\t\tdata.widthSegments,\r\n\t\t\t\t\t\t\tdata.heightSegments,\r\n\t\t\t\t\t\t\tdata.phiStart,\r\n\t\t\t\t\t\t\tdata.phiLength,\r\n\t\t\t\t\t\t\tdata.thetaStart,\r\n\t\t\t\t\t\t\tdata.thetaLength\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'IcosahedronGeometry':\r\n\r\n\t\t\t\t\t\tgeometry = new THREE.IcosahedronGeometry(\r\n\t\t\t\t\t\t\tdata.radius,\r\n\t\t\t\t\t\t\tdata.detail\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'TorusGeometry':\r\n\r\n\t\t\t\t\t\tgeometry = new THREE.TorusGeometry(\r\n\t\t\t\t\t\t\tdata.radius,\r\n\t\t\t\t\t\t\tdata.tube,\r\n\t\t\t\t\t\t\tdata.radialSegments,\r\n\t\t\t\t\t\t\tdata.tubularSegments,\r\n\t\t\t\t\t\t\tdata.arc\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'TorusKnotGeometry':\r\n\r\n\t\t\t\t\t\tgeometry = new THREE.TorusKnotGeometry(\r\n\t\t\t\t\t\t\tdata.radius,\r\n\t\t\t\t\t\t\tdata.tube,\r\n\t\t\t\t\t\t\tdata.radialSegments,\r\n\t\t\t\t\t\t\tdata.tubularSegments,\r\n\t\t\t\t\t\t\tdata.p,\r\n\t\t\t\t\t\t\tdata.q,\r\n\t\t\t\t\t\t\tdata.heightScale\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'BufferGeometry':\r\n\r\n\t\t\t\t\t\tgeometry = bufferGeometryLoader.parse( data );\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'Geometry':\r\n\r\n\t\t\t\t\t\tgeometry = geometryLoader.parse( data.data ).geometry;\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tgeometry.uuid = data.uuid;\r\n\r\n\t\t\t\tif ( data.name !== undefined ) geometry.name = data.name;\r\n\r\n\t\t\t\tgeometries[ data.uuid ] = geometry;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn geometries;\r\n\r\n\t},\r\n\r\n\tparseMaterials: function ( json, textures ) {\r\n\r\n\t\tvar materials = {};\r\n\r\n\t\tif ( json !== undefined ) {\r\n\r\n\t\t\tvar getTexture = function ( name ) {\r\n\r\n\t\t\t\tif ( textures[ name ] === undefined ) {\r\n\r\n\t\t\t\t\tTHREE.warn( 'THREE.ObjectLoader: Undefined texture', name );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn textures[ name ];\r\n\r\n\t\t\t};\r\n\r\n\t\t\tvar loader = new THREE.MaterialLoader();\r\n\r\n\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar data = json[ i ];\r\n\t\t\t\tvar material = loader.parse( data );\r\n\r\n\t\t\t\tmaterial.uuid = data.uuid;\r\n\r\n\t\t\t\tif ( data.name !== undefined ) material.name = data.name;\r\n\r\n\t\t\t\tif ( data.map !== undefined ) {\r\n\r\n\t\t\t\t\tmaterial.map = getTexture( data.map );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( data.bumpMap !== undefined ) {\r\n\r\n\t\t\t\t\tmaterial.bumpMap = getTexture( data.bumpMap );\r\n\t\t\t\t\tif ( data.bumpScale ) {\r\n\t\t\t\t\t\tmaterial.bumpScale = new THREE.Vector2( data.bumpScale, data.bumpScale );\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( data.alphaMap !== undefined ) {\r\n\r\n\t\t\t\t\tmaterial.alphaMap = getTexture( data.alphaMap );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( data.envMap !== undefined ) {\r\n\r\n\t\t\t\t\tmaterial.envMap = getTexture( data.envMap );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( data.normalMap !== undefined ) {\r\n\r\n\t\t\t\t\tmaterial.normalMap = getTexture( data.normalMap );\r\n\t\t\t\t\tif ( data.normalScale ) {\r\n\t\t\t\t\t\tmaterial.normalScale = new THREE.Vector2( data.normalScale, data.normalScale );\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( data.lightMap !== undefined ) {\r\n\r\n\t\t\t\t\tmaterial.lightMap = getTexture( data.lightMap );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( data.specularMap !== undefined ) {\r\n\r\n\t\t\t\t\tmaterial.specularMap = getTexture( data.specularMap );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tmaterials[ data.uuid ] = material;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn materials;\r\n\r\n\t},\r\n\r\n\tparseImages: function ( json, onLoad ) {\r\n\r\n\t\tvar scope = this;\r\n\t\tvar images = {};\r\n\r\n\t\tif ( json !== undefined && json.length > 0 ) {\r\n\r\n\t\t\tvar manager = new THREE.LoadingManager( onLoad );\r\n\r\n\t\t\tvar loader = new THREE.ImageLoader( manager );\r\n\t\t\tloader.setCrossOrigin( this.crossOrigin );\r\n\r\n\t\t\tvar loadImage = function ( url ) {\r\n\r\n\t\t\t\tscope.manager.itemStart( url );\r\n\r\n\t\t\t\treturn loader.load( url, function () {\r\n\r\n\t\t\t\t\tscope.manager.itemEnd( url );\r\n\r\n\t\t\t\t} );\r\n\r\n\t\t\t};\r\n\r\n\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar image = json[ i ];\r\n\t\t\t\tvar path = /^(\\/\\/)|([a-z]+:(\\/\\/)?)/i.test( image.url ) ? image.url : scope.texturePath + image.url;\r\n\r\n\t\t\t\timages[ image.uuid ] = loadImage( path );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn images;\r\n\r\n\t},\r\n\r\n\tparseTextures: function ( json, images ) {\r\n\r\n\t\tvar textures = {};\r\n\r\n\t\tif ( json !== undefined ) {\r\n\r\n\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar data = json[ i ];\r\n\r\n\t\t\t\tif ( data.image === undefined ) {\r\n\r\n\t\t\t\t\tTHREE.warn( 'THREE.ObjectLoader: No \"image\" speficied for', data.uuid );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( images[ data.image ] === undefined ) {\r\n\r\n\t\t\t\t\tTHREE.warn( 'THREE.ObjectLoader: Undefined image', data.image );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar texture = new THREE.Texture( images[ data.image ] );\r\n\t\t\t\ttexture.needsUpdate = true;\r\n\r\n\t\t\t\ttexture.uuid = data.uuid;\r\n\r\n\t\t\t\tif ( data.name !== undefined ) texture.name = data.name;\r\n\t\t\t\tif ( data.repeat !== undefined ) texture.repeat = new THREE.Vector2( data.repeat[ 0 ], data.repeat[ 1 ] );\r\n\t\t\t\tif ( data.minFilter !== undefined ) texture.minFilter = THREE[ data.minFilter ];\r\n\t\t\t\tif ( data.magFilter !== undefined ) texture.magFilter = THREE[ data.magFilter ];\r\n\t\t\t\tif ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;\r\n\t\t\t\tif ( data.wrap instanceof Array ) {\r\n\r\n\t\t\t\t\ttexture.wrapS = THREE[ data.wrap[ 0 ] ];\r\n\t\t\t\t\ttexture.wrapT = THREE[ data.wrap[ 1 ] ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttextures[ data.uuid ] = texture;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn textures;\r\n\r\n\t},\r\n\r\n\tparseObject: function () {\r\n\r\n\t\tvar matrix = new THREE.Matrix4();\r\n\r\n\t\treturn function ( data, geometries, materials ) {\r\n\r\n\t\t\tvar object;\r\n\r\n\t\t\tvar getGeometry = function ( name ) {\r\n\r\n\t\t\t\tif ( geometries[ name ] === undefined ) {\r\n\r\n\t\t\t\t\tTHREE.warn( 'THREE.ObjectLoader: Undefined geometry', name );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn geometries[ name ];\r\n\r\n\t\t\t};\r\n\r\n\t\t\tvar getMaterial = function ( name ) {\r\n\r\n\t\t\t\tif ( materials[ name ] === undefined ) {\r\n\r\n\t\t\t\t\tTHREE.warn( 'THREE.ObjectLoader: Undefined material', name );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn materials[ name ];\r\n\r\n\t\t\t};\r\n\r\n\t\t\tswitch ( data.type ) {\r\n\r\n\t\t\t\tcase 'Scene':\r\n\r\n\t\t\t\t\tobject = new THREE.Scene();\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'PerspectiveCamera':\r\n\r\n\t\t\t\t\tobject = new THREE.PerspectiveCamera( data.fov, data.aspect, data.near, data.far );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'OrthographicCamera':\r\n\r\n\t\t\t\t\tobject = new THREE.OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'AmbientLight':\r\n\r\n\t\t\t\t\tobject = new THREE.AmbientLight( data.color );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'DirectionalLight':\r\n\r\n\t\t\t\t\tobject = new THREE.DirectionalLight( data.color, data.intensity );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'PointLight':\r\n\r\n\t\t\t\t\tobject = new THREE.PointLight( data.color, data.intensity, data.distance, data.decay );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'SpotLight':\r\n\r\n\t\t\t\t\tobject = new THREE.SpotLight( data.color, data.intensity, data.distance, data.angle, data.exponent, data.decay );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'HemisphereLight':\r\n\r\n\t\t\t\t\tobject = new THREE.HemisphereLight( data.color, data.groundColor, data.intensity );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'Mesh':\r\n\r\n\t\t\t\t\tobject = new THREE.Mesh( getGeometry( data.geometry ), getMaterial( data.material ) );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'Line':\r\n\r\n\t\t\t\t\tobject = new THREE.Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'PointCloud':\r\n\r\n\t\t\t\t\tobject = new THREE.PointCloud( getGeometry( data.geometry ), getMaterial( data.material ) );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'Sprite':\r\n\r\n\t\t\t\t\tobject = new THREE.Sprite( getMaterial( data.material ) );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'Group':\r\n\r\n\t\t\t\t\tobject = new THREE.Group();\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tdefault:\r\n\r\n\t\t\t\t\tobject = new THREE.Object3D();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tobject.uuid = data.uuid;\r\n\r\n\t\t\tif ( data.name !== undefined ) object.name = data.name;\r\n\t\t\tif ( data.matrix !== undefined ) {\r\n\r\n\t\t\t\tmatrix.fromArray( data.matrix );\r\n\t\t\t\tmatrix.decompose( object.position, object.quaternion, object.scale );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tif ( data.position !== undefined ) object.position.fromArray( data.position );\r\n\t\t\t\tif ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );\r\n\t\t\t\tif ( data.scale !== undefined ) object.scale.fromArray( data.scale );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( data.visible !== undefined ) object.visible = data.visible;\r\n\t\t\tif ( data.userData !== undefined ) object.userData = data.userData;\r\n\r\n\t\t\tif ( data.children !== undefined ) {\r\n\r\n\t\t\t\tfor ( var child in data.children ) {\r\n\r\n\t\t\t\t\tobject.add( this.parseObject( data.children[ child ], geometries, materials ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn object;\r\n\r\n\t\t}\r\n\r\n\t}()\r\n\r\n};\r\n\r\n// File:src/loaders/TextureLoader.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.TextureLoader = function ( manager ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\r\n};\r\n\r\nTHREE.TextureLoader.prototype = {\r\n\r\n\tconstructor: THREE.TextureLoader,\r\n\r\n\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar loader = new THREE.ImageLoader( scope.manager );\r\n\t\tloader.setCrossOrigin( this.crossOrigin );\r\n\t\tloader.load( url, function ( image ) {\r\n\r\n\t\t\tvar texture = new THREE.Texture( image );\r\n\t\t\ttexture.needsUpdate = true;\r\n\r\n\t\t\tif ( onLoad !== undefined ) {\r\n\r\n\t\t\t\tonLoad( texture );\r\n\r\n\t\t\t}\r\n\r\n\t\t}, onProgress, onError );\r\n\r\n\t},\r\n\r\n\tsetCrossOrigin: function ( value ) {\r\n\r\n\t\tthis.crossOrigin = value;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/loaders/BinaryTextureLoader.js\r\n\r\n/**\r\n * @author Nikos M. / https://github.com/foo123/\r\n *\r\n * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)\r\n */\r\n\r\nTHREE.DataTextureLoader = THREE.BinaryTextureLoader = function () {\r\n\r\n\t// override in sub classes\r\n\tthis._parser = null;\r\n\r\n};\r\n\r\nTHREE.BinaryTextureLoader.prototype = {\r\n\r\n\tconstructor: THREE.BinaryTextureLoader,\r\n\r\n\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar texture = new THREE.DataTexture( );\r\n\r\n\t\tvar loader = new THREE.XHRLoader();\r\n\t\tloader.setResponseType( 'arraybuffer' );\r\n\r\n\t\tloader.load( url, function ( buffer ) {\r\n\r\n\t\t\tvar texData = scope._parser( buffer );\r\n\r\n\t\t\tif ( !texData ) return;\r\n\r\n\t\t\tif ( undefined !== texData.image ) {\r\n\r\n\t\t\t\ttexture.image = texData.image;\r\n\r\n\t\t\t} else if ( undefined !== texData.data ) {\r\n\r\n\t\t\t\ttexture.image.width = texData.width;\r\n\t\t\t\ttexture.image.height = texData.height;\r\n\t\t\t\ttexture.image.data = texData.data;\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttexture.wrapS = undefined !== texData.wrapS ? texData.wrapS : THREE.ClampToEdgeWrapping;\r\n\t\t\ttexture.wrapT = undefined !== texData.wrapT ? texData.wrapT : THREE.ClampToEdgeWrapping;\r\n\r\n\t\t\ttexture.magFilter = undefined !== texData.magFilter ? texData.magFilter : THREE.LinearFilter;\r\n\t\t\ttexture.minFilter = undefined !== texData.minFilter ? texData.minFilter : THREE.LinearMipMapLinearFilter;\r\n\r\n\t\t\ttexture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;\r\n\r\n\t\t\tif ( undefined !== texData.format ) {\r\n\r\n\t\t\t\ttexture.format = texData.format;\r\n\r\n\t\t\t}\r\n\t\t\tif ( undefined !== texData.type ) {\r\n\r\n\t\t\t\ttexture.type = texData.type;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( undefined !== texData.mipmaps ) {\r\n\r\n\t\t\t\ttexture.mipmaps = texData.mipmaps;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( 1 === texData.mipmapCount ) {\r\n\r\n\t\t\t\ttexture.minFilter = THREE.LinearFilter;\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttexture.needsUpdate = true;\r\n\r\n\t\t\tif ( onLoad ) onLoad( texture, texData );\r\n\r\n\t\t}, onProgress, onError );\r\n\r\n\r\n\t\treturn texture;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/loaders/CompressedTextureLoader.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n *\r\n * Abstract Base class to block based textures loader (dds, pvr, ...)\r\n */\r\n\r\nTHREE.CompressedTextureLoader = function () {\r\n\r\n\t// override in sub classes\r\n\tthis._parser = null;\r\n\r\n};\r\n\r\n\r\nTHREE.CompressedTextureLoader.prototype = {\r\n\r\n\tconstructor: THREE.CompressedTextureLoader,\r\n\r\n\tload: function ( url, onLoad, onError ) {\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar images = [];\r\n\r\n\t\tvar texture = new THREE.CompressedTexture();\r\n\t\ttexture.image = images;\r\n\r\n\t\tvar loader = new THREE.XHRLoader();\r\n\t\tloader.setResponseType( 'arraybuffer' );\r\n\r\n\t\tif ( url instanceof Array ) {\r\n\r\n\t\t\tvar loaded = 0;\r\n\r\n\t\t\tvar loadTexture = function ( i ) {\r\n\r\n\t\t\t\tloader.load( url[ i ], function ( buffer ) {\r\n\r\n\t\t\t\t\tvar texDatas = scope._parser( buffer, true );\r\n\r\n\t\t\t\t\timages[ i ] = {\r\n\t\t\t\t\t\twidth: texDatas.width,\r\n\t\t\t\t\t\theight: texDatas.height,\r\n\t\t\t\t\t\tformat: texDatas.format,\r\n\t\t\t\t\t\tmipmaps: texDatas.mipmaps\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\tloaded += 1;\r\n\r\n\t\t\t\t\tif ( loaded === 6 ) {\r\n\r\n\t\t\t\t\t\tif (texDatas.mipmapCount == 1)\r\n \t\t\t\t\t\t\ttexture.minFilter = THREE.LinearFilter;\r\n\r\n\t\t\t\t\t\ttexture.format = texDatas.format;\r\n\t\t\t\t\t\ttexture.needsUpdate = true;\r\n\r\n\t\t\t\t\t\tif ( onLoad ) onLoad( texture );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} );\r\n\r\n\t\t\t};\r\n\r\n\t\t\tfor ( var i = 0, il = url.length; i < il; ++ i ) {\r\n\r\n\t\t\t\tloadTexture( i );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// compressed cubemap texture stored in a single DDS file\r\n\r\n\t\t\tloader.load( url, function ( buffer ) {\r\n\r\n\t\t\t\tvar texDatas = scope._parser( buffer, true );\r\n\r\n\t\t\t\tif ( texDatas.isCubemap ) {\r\n\r\n\t\t\t\t\tvar faces = texDatas.mipmaps.length / texDatas.mipmapCount;\r\n\r\n\t\t\t\t\tfor ( var f = 0; f < faces; f ++ ) {\r\n\r\n\t\t\t\t\t\timages[ f ] = { mipmaps : [] };\r\n\r\n\t\t\t\t\t\tfor ( var i = 0; i < texDatas.mipmapCount; i ++ ) {\r\n\r\n\t\t\t\t\t\t\timages[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );\r\n\t\t\t\t\t\t\timages[ f ].format = texDatas.format;\r\n\t\t\t\t\t\t\timages[ f ].width = texDatas.width;\r\n\t\t\t\t\t\t\timages[ f ].height = texDatas.height;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\ttexture.image.width = texDatas.width;\r\n\t\t\t\t\ttexture.image.height = texDatas.height;\r\n\t\t\t\t\ttexture.mipmaps = texDatas.mipmaps;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( texDatas.mipmapCount === 1 ) {\r\n\r\n\t\t\t\t\ttexture.minFilter = THREE.LinearFilter;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttexture.format = texDatas.format;\r\n\t\t\t\ttexture.needsUpdate = true;\r\n\r\n\t\t\t\tif ( onLoad ) onLoad( texture );\r\n\r\n\t\t\t} );\r\n\r\n\t\t}\r\n\r\n\t\treturn texture;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/materials/Material.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Material = function () {\r\n\r\n\tObject.defineProperty( this, 'id', { value: THREE.MaterialIdCount ++ } );\r\n\r\n\tthis.uuid = THREE.Math.generateUUID();\r\n\r\n\tthis.name = '';\r\n\tthis.type = 'Material';\r\n\r\n\tthis.side = THREE.FrontSide;\r\n\r\n\tthis.opacity = 1;\r\n\tthis.transparent = false;\r\n\r\n\tthis.blending = THREE.NormalBlending;\r\n\r\n\tthis.blendSrc = THREE.SrcAlphaFactor;\r\n\tthis.blendDst = THREE.OneMinusSrcAlphaFactor;\r\n\tthis.blendEquation = THREE.AddEquation;\r\n\tthis.blendSrcAlpha = null;\r\n\tthis.blendDstAlpha = null;\r\n\tthis.blendEquationAlpha = null;\r\n\r\n\tthis.depthTest = true;\r\n\tthis.depthWrite = true;\r\n\r\n\tthis.colorWrite = true;\r\n\r\n\tthis.polygonOffset = false;\r\n\tthis.polygonOffsetFactor = 0;\r\n\tthis.polygonOffsetUnits = 0;\r\n\r\n\tthis.alphaTest = 0;\r\n\r\n\tthis.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer\r\n\r\n\tthis.visible = true;\r\n\r\n\tthis._needsUpdate = true;\r\n\r\n};\r\n\r\nTHREE.Material.prototype = {\r\n\r\n\tconstructor: THREE.Material,\r\n\r\n\tget needsUpdate () {\r\n\r\n\t\treturn this._needsUpdate;\r\n\r\n\t},\r\n\r\n\tset needsUpdate ( value ) {\r\n\r\n\t\tif ( value === true ) this.update();\r\n\r\n\t\tthis._needsUpdate = value;\r\n\r\n\t},\r\n\r\n\tsetValues: function ( values ) {\r\n\r\n\t\tif ( values === undefined ) return;\r\n\r\n\t\tfor ( var key in values ) {\r\n\r\n\t\t\tvar newValue = values[ key ];\r\n\r\n\t\t\tif ( newValue === undefined ) {\r\n\r\n\t\t\t\tTHREE.warn( \"THREE.Material: '\" + key + \"' parameter is undefined.\" );\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( key in this ) {\r\n\r\n\t\t\t\tvar currentValue = this[ key ];\r\n\r\n\t\t\t\tif ( currentValue instanceof THREE.Color ) {\r\n\r\n\t\t\t\t\tcurrentValue.set( newValue );\r\n\r\n\t\t\t\t} else if ( currentValue instanceof THREE.Vector3 && newValue instanceof THREE.Vector3 ) {\r\n\r\n\t\t\t\t\tcurrentValue.copy( newValue );\r\n\r\n\t\t\t\t} else if ( key == 'overdraw' ) {\r\n\r\n\t\t\t\t\t// ensure overdraw is backwards-compatable with legacy boolean type\r\n\t\t\t\t\tthis[ key ] = Number( newValue );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tthis[ key ] = newValue;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\ttoJSON: function () {\r\n\r\n\t\tvar output = {\r\n\t\t\tmetadata: {\r\n\t\t\t\tversion: 4.2,\r\n\t\t\t\ttype: 'material',\r\n\t\t\t\tgenerator: 'MaterialExporter'\r\n\t\t\t},\r\n\t\t\tuuid: this.uuid,\r\n\t\t\ttype: this.type\r\n\t\t};\r\n\r\n\t\tif ( this.name !== \"\" ) output.name = this.name;\r\n\r\n\t\tif ( this instanceof THREE.MeshBasicMaterial ) {\r\n\r\n\t\t\toutput.color = this.color.getHex();\r\n\t\t\tif ( this.vertexColors !== THREE.NoColors ) output.vertexColors = this.vertexColors;\r\n\t\t\tif ( this.blending !== THREE.NormalBlending ) output.blending = this.blending;\r\n\t\t\tif ( this.side !== THREE.FrontSide ) output.side = this.side;\r\n\r\n\t\t} else if ( this instanceof THREE.MeshLambertMaterial ) {\r\n\r\n\t\t\toutput.color = this.color.getHex();\r\n\t\t\toutput.emissive = this.emissive.getHex();\r\n\t\t\tif ( this.vertexColors !== THREE.NoColors ) output.vertexColors = this.vertexColors;\r\n\t\t\tif ( this.shading !== THREE.SmoothShading ) output.shading = this.shading;\r\n\t\t\tif ( this.blending !== THREE.NormalBlending ) output.blending = this.blending;\r\n\t\t\tif ( this.side !== THREE.FrontSide ) output.side = this.side;\r\n\r\n\t\t} else if ( this instanceof THREE.MeshPhongMaterial ) {\r\n\r\n\t\t\toutput.color = this.color.getHex();\r\n\t\t\toutput.emissive = this.emissive.getHex();\r\n\t\t\toutput.specular = this.specular.getHex();\r\n\t\t\toutput.shininess = this.shininess;\r\n\t\t\tif ( this.vertexColors !== THREE.NoColors ) output.vertexColors = this.vertexColors;\r\n\t\t\tif ( this.shading !== THREE.SmoothShading ) output.shading = this.shading;\r\n\t\t\tif ( this.blending !== THREE.NormalBlending ) output.blending = this.blending;\r\n\t\t\tif ( this.side !== THREE.FrontSide ) output.side = this.side;\r\n\r\n\t\t} else if ( this instanceof THREE.MeshNormalMaterial ) {\r\n\r\n\t\t\tif ( this.blending !== THREE.NormalBlending ) output.blending = this.blending;\r\n\t\t\tif ( this.side !== THREE.FrontSide ) output.side = this.side;\r\n\r\n\t\t} else if ( this instanceof THREE.MeshDepthMaterial ) {\r\n\r\n\t\t\tif ( this.blending !== THREE.NormalBlending ) output.blending = this.blending;\r\n\t\t\tif ( this.side !== THREE.FrontSide ) output.side = this.side;\r\n\r\n\t\t} else if ( this instanceof THREE.PointCloudMaterial ) {\r\n\r\n\t\t\toutput.size  = this.size;\r\n\t\t\toutput.sizeAttenuation = this.sizeAttenuation;\r\n\t\t\toutput.color = this.color.getHex();\r\n\r\n\t\t\tif ( this.vertexColors !== THREE.NoColors ) output.vertexColors = this.vertexColors;\r\n\t\t\tif ( this.blending !== THREE.NormalBlending ) output.blending = this.blending;\r\n\r\n\t\t} else if ( this instanceof THREE.ShaderMaterial ) {\r\n\r\n\t\t\toutput.uniforms = this.uniforms;\r\n\t\t\toutput.vertexShader = this.vertexShader;\r\n\t\t\toutput.fragmentShader = this.fragmentShader;\r\n\r\n\t\t} else if ( this instanceof THREE.SpriteMaterial ) {\r\n\r\n\t\t\toutput.color = this.color.getHex();\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.opacity < 1 ) output.opacity = this.opacity;\r\n\t\tif ( this.transparent !== false ) output.transparent = this.transparent;\r\n\t\tif ( this.wireframe !== false ) output.wireframe = this.wireframe;\r\n\r\n\t\treturn output;\r\n\r\n\t},\r\n\r\n\tclone: function ( material ) {\r\n\r\n\t\tif ( material === undefined ) material = new THREE.Material();\r\n\r\n\t\tmaterial.name = this.name;\r\n\r\n\t\tmaterial.side = this.side;\r\n\r\n\t\tmaterial.opacity = this.opacity;\r\n\t\tmaterial.transparent = this.transparent;\r\n\r\n\t\tmaterial.blending = this.blending;\r\n\r\n\t\tmaterial.blendSrc = this.blendSrc;\r\n\t\tmaterial.blendDst = this.blendDst;\r\n\t\tmaterial.blendEquation = this.blendEquation;\r\n\t\tmaterial.blendSrcAlpha = this.blendSrcAlpha;\r\n\t\tmaterial.blendDstAlpha = this.blendDstAlpha;\r\n\t\tmaterial.blendEquationAlpha = this.blendEquationAlpha;\r\n\r\n\t\tmaterial.depthTest = this.depthTest;\r\n\t\tmaterial.depthWrite = this.depthWrite;\r\n\r\n\t\tmaterial.polygonOffset = this.polygonOffset;\r\n\t\tmaterial.polygonOffsetFactor = this.polygonOffsetFactor;\r\n\t\tmaterial.polygonOffsetUnits = this.polygonOffsetUnits;\r\n\r\n\t\tmaterial.alphaTest = this.alphaTest;\r\n\r\n\t\tmaterial.overdraw = this.overdraw;\r\n\r\n\t\tmaterial.visible = this.visible;\r\n\r\n\t\treturn material;\r\n\r\n\t},\r\n\r\n\tupdate: function () {\r\n\r\n\t\tthis.dispatchEvent( { type: 'update' } );\r\n\r\n\t},\r\n\r\n\tdispose: function () {\r\n\r\n\t\tthis.dispatchEvent( { type: 'dispose' } );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.EventDispatcher.prototype.apply( THREE.Material.prototype );\r\n\r\nTHREE.MaterialIdCount = 0;\r\n\r\n// File:src/materials/LineBasicMaterial.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  opacity: <float>,\r\n *\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  linewidth: <float>,\r\n *  linecap: \"round\",\r\n *  linejoin: \"round\",\r\n *\r\n *  vertexColors: <bool>\r\n *\r\n *  fog: <bool>\r\n * }\r\n */\r\n\r\nTHREE.LineBasicMaterial = function ( parameters ) {\r\n\r\n\tTHREE.Material.call( this );\r\n\r\n\tthis.type = 'LineBasicMaterial';\r\n\r\n\tthis.color = new THREE.Color( 0xffffff );\r\n\r\n\tthis.linewidth = 1;\r\n\tthis.linecap = 'round';\r\n\tthis.linejoin = 'round';\r\n\r\n\tthis.vertexColors = THREE.NoColors;\r\n\r\n\tthis.fog = true;\r\n\r\n\tthis.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.LineBasicMaterial.prototype = Object.create( THREE.Material.prototype );\r\nTHREE.LineBasicMaterial.prototype.constructor = THREE.LineBasicMaterial;\r\n\r\nTHREE.LineBasicMaterial.prototype.clone = function () {\r\n\r\n\tvar material = new THREE.LineBasicMaterial();\r\n\r\n\tTHREE.Material.prototype.clone.call( this, material );\r\n\r\n\tmaterial.color.copy( this.color );\r\n\r\n\tmaterial.linewidth = this.linewidth;\r\n\tmaterial.linecap = this.linecap;\r\n\tmaterial.linejoin = this.linejoin;\r\n\r\n\tmaterial.vertexColors = this.vertexColors;\r\n\r\n\tmaterial.fog = this.fog;\r\n\r\n\treturn material;\r\n\r\n};\r\n\r\n// File:src/materials/LineDashedMaterial.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  opacity: <float>,\r\n *\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  linewidth: <float>,\r\n *\r\n *  scale: <float>,\r\n *  dashSize: <float>,\r\n *  gapSize: <float>,\r\n *\r\n *  vertexColors: <bool>\r\n *\r\n *  fog: <bool>\r\n * }\r\n */\r\n\r\nTHREE.LineDashedMaterial = function ( parameters ) {\r\n\r\n\tTHREE.Material.call( this );\r\n\r\n\tthis.type = 'LineDashedMaterial';\r\n\r\n\tthis.color = new THREE.Color( 0xffffff );\r\n\r\n\tthis.linewidth = 1;\r\n\r\n\tthis.scale = 1;\r\n\tthis.dashSize = 3;\r\n\tthis.gapSize = 1;\r\n\r\n\tthis.vertexColors = false;\r\n\r\n\tthis.fog = true;\r\n\r\n\tthis.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.LineDashedMaterial.prototype = Object.create( THREE.Material.prototype );\r\nTHREE.LineDashedMaterial.prototype.constructor = THREE.LineDashedMaterial;\r\n\r\nTHREE.LineDashedMaterial.prototype.clone = function () {\r\n\r\n\tvar material = new THREE.LineDashedMaterial();\r\n\r\n\tTHREE.Material.prototype.clone.call( this, material );\r\n\r\n\tmaterial.color.copy( this.color );\r\n\r\n\tmaterial.linewidth = this.linewidth;\r\n\r\n\tmaterial.scale = this.scale;\r\n\tmaterial.dashSize = this.dashSize;\r\n\tmaterial.gapSize = this.gapSize;\r\n\r\n\tmaterial.vertexColors = this.vertexColors;\r\n\r\n\tmaterial.fog = this.fog;\r\n\r\n\treturn material;\r\n\r\n};\r\n\r\n// File:src/materials/MeshBasicMaterial.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  opacity: <float>,\r\n *  map: new THREE.Texture( <Image> ),\r\n *\r\n *  lightMap: new THREE.Texture( <Image> ),\r\n *\r\n *  specularMap: new THREE.Texture( <Image> ),\r\n *\r\n *  alphaMap: new THREE.Texture( <Image> ),\r\n *\r\n *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\r\n *  combine: THREE.Multiply,\r\n *  reflectivity: <float>,\r\n *  refractionRatio: <float>,\r\n *\r\n *  shading: THREE.SmoothShading,\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  wireframe: <boolean>,\r\n *  wireframeLinewidth: <float>,\r\n *\r\n *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,\r\n *\r\n *  skinning: <bool>,\r\n *  morphTargets: <bool>,\r\n *\r\n *  fog: <bool>\r\n * }\r\n */\r\n\r\nTHREE.MeshBasicMaterial = function ( parameters ) {\r\n\r\n\tTHREE.Material.call( this );\r\n\r\n\tthis.type = 'MeshBasicMaterial';\r\n\r\n\tthis.color = new THREE.Color( 0xffffff ); // emissive\r\n\r\n\tthis.map = null;\r\n\r\n\tthis.lightMap = null;\r\n\r\n\tthis.specularMap = null;\r\n\r\n\tthis.alphaMap = null;\r\n\r\n\tthis.envMap = null;\r\n\tthis.combine = THREE.MultiplyOperation;\r\n\tthis.reflectivity = 1;\r\n\tthis.refractionRatio = 0.98;\r\n\r\n\tthis.fog = true;\r\n\r\n\tthis.shading = THREE.SmoothShading;\r\n\r\n\tthis.wireframe = false;\r\n\tthis.wireframeLinewidth = 1;\r\n\tthis.wireframeLinecap = 'round';\r\n\tthis.wireframeLinejoin = 'round';\r\n\r\n\tthis.vertexColors = THREE.NoColors;\r\n\r\n\tthis.skinning = false;\r\n\tthis.morphTargets = false;\r\n\r\n\tthis.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.MeshBasicMaterial.prototype = Object.create( THREE.Material.prototype );\r\nTHREE.MeshBasicMaterial.prototype.constructor = THREE.MeshBasicMaterial;\r\n\r\nTHREE.MeshBasicMaterial.prototype.clone = function () {\r\n\r\n\tvar material = new THREE.MeshBasicMaterial();\r\n\r\n\tTHREE.Material.prototype.clone.call( this, material );\r\n\r\n\tmaterial.color.copy( this.color );\r\n\r\n\tmaterial.map = this.map;\r\n\r\n\tmaterial.lightMap = this.lightMap;\r\n\r\n\tmaterial.specularMap = this.specularMap;\r\n\r\n\tmaterial.alphaMap = this.alphaMap;\r\n\r\n\tmaterial.envMap = this.envMap;\r\n\tmaterial.combine = this.combine;\r\n\tmaterial.reflectivity = this.reflectivity;\r\n\tmaterial.refractionRatio = this.refractionRatio;\r\n\r\n\tmaterial.fog = this.fog;\r\n\r\n\tmaterial.shading = this.shading;\r\n\r\n\tmaterial.wireframe = this.wireframe;\r\n\tmaterial.wireframeLinewidth = this.wireframeLinewidth;\r\n\tmaterial.wireframeLinecap = this.wireframeLinecap;\r\n\tmaterial.wireframeLinejoin = this.wireframeLinejoin;\r\n\r\n\tmaterial.vertexColors = this.vertexColors;\r\n\r\n\tmaterial.skinning = this.skinning;\r\n\tmaterial.morphTargets = this.morphTargets;\r\n\r\n\treturn material;\r\n\r\n};\r\n\r\n// File:src/materials/MeshLambertMaterial.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  emissive: <hex>,\r\n *  opacity: <float>,\r\n *\r\n *  map: new THREE.Texture( <Image> ),\r\n *\r\n *  lightMap: new THREE.Texture( <Image> ),\r\n *\r\n *  specularMap: new THREE.Texture( <Image> ),\r\n *\r\n *  alphaMap: new THREE.Texture( <Image> ),\r\n *\r\n *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\r\n *  combine: THREE.Multiply,\r\n *  reflectivity: <float>,\r\n *  refractionRatio: <float>,\r\n *\r\n *  shading: THREE.SmoothShading,\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  wireframe: <boolean>,\r\n *  wireframeLinewidth: <float>,\r\n *\r\n *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,\r\n *\r\n *  skinning: <bool>,\r\n *  morphTargets: <bool>,\r\n *  morphNormals: <bool>,\r\n *\r\n *\tfog: <bool>\r\n * }\r\n */\r\n\r\nTHREE.MeshLambertMaterial = function ( parameters ) {\r\n\r\n\tTHREE.Material.call( this );\r\n\r\n\tthis.type = 'MeshLambertMaterial';\r\n\r\n\tthis.color = new THREE.Color( 0xffffff ); // diffuse\r\n\tthis.emissive = new THREE.Color( 0x000000 );\r\n\r\n\tthis.wrapAround = false;\r\n\tthis.wrapRGB = new THREE.Vector3( 1, 1, 1 );\r\n\r\n\tthis.map = null;\r\n\r\n\tthis.lightMap = null;\r\n\r\n\tthis.specularMap = null;\r\n\r\n\tthis.alphaMap = null;\r\n\r\n\tthis.envMap = null;\r\n\tthis.combine = THREE.MultiplyOperation;\r\n\tthis.reflectivity = 1;\r\n\tthis.refractionRatio = 0.98;\r\n\r\n\tthis.fog = true;\r\n\r\n\tthis.shading = THREE.SmoothShading;\r\n\r\n\tthis.wireframe = false;\r\n\tthis.wireframeLinewidth = 1;\r\n\tthis.wireframeLinecap = 'round';\r\n\tthis.wireframeLinejoin = 'round';\r\n\r\n\tthis.vertexColors = THREE.NoColors;\r\n\r\n\tthis.skinning = false;\r\n\tthis.morphTargets = false;\r\n\tthis.morphNormals = false;\r\n\r\n\tthis.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.MeshLambertMaterial.prototype = Object.create( THREE.Material.prototype );\r\nTHREE.MeshLambertMaterial.prototype.constructor = THREE.MeshLambertMaterial;\r\n\r\nTHREE.MeshLambertMaterial.prototype.clone = function () {\r\n\r\n\tvar material = new THREE.MeshLambertMaterial();\r\n\r\n\tTHREE.Material.prototype.clone.call( this, material );\r\n\r\n\tmaterial.color.copy( this.color );\r\n\tmaterial.emissive.copy( this.emissive );\r\n\r\n\tmaterial.wrapAround = this.wrapAround;\r\n\tmaterial.wrapRGB.copy( this.wrapRGB );\r\n\r\n\tmaterial.map = this.map;\r\n\r\n\tmaterial.lightMap = this.lightMap;\r\n\r\n\tmaterial.specularMap = this.specularMap;\r\n\r\n\tmaterial.alphaMap = this.alphaMap;\r\n\r\n\tmaterial.envMap = this.envMap;\r\n\tmaterial.combine = this.combine;\r\n\tmaterial.reflectivity = this.reflectivity;\r\n\tmaterial.refractionRatio = this.refractionRatio;\r\n\r\n\tmaterial.fog = this.fog;\r\n\r\n\tmaterial.shading = this.shading;\r\n\r\n\tmaterial.wireframe = this.wireframe;\r\n\tmaterial.wireframeLinewidth = this.wireframeLinewidth;\r\n\tmaterial.wireframeLinecap = this.wireframeLinecap;\r\n\tmaterial.wireframeLinejoin = this.wireframeLinejoin;\r\n\r\n\tmaterial.vertexColors = this.vertexColors;\r\n\r\n\tmaterial.skinning = this.skinning;\r\n\tmaterial.morphTargets = this.morphTargets;\r\n\tmaterial.morphNormals = this.morphNormals;\r\n\r\n\treturn material;\r\n\r\n};\r\n\r\n// File:src/materials/MeshPhongMaterial.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  emissive: <hex>,\r\n *  specular: <hex>,\r\n *  shininess: <float>,\r\n *  opacity: <float>,\r\n *\r\n *  map: new THREE.Texture( <Image> ),\r\n *\r\n *  lightMap: new THREE.Texture( <Image> ),\r\n *\r\n *  bumpMap: new THREE.Texture( <Image> ),\r\n *  bumpScale: <float>,\r\n *\r\n *  normalMap: new THREE.Texture( <Image> ),\r\n *  normalScale: <Vector2>,\r\n *\r\n *  specularMap: new THREE.Texture( <Image> ),\r\n *\r\n *  alphaMap: new THREE.Texture( <Image> ),\r\n *\r\n *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\r\n *  combine: THREE.Multiply,\r\n *  reflectivity: <float>,\r\n *  refractionRatio: <float>,\r\n *\r\n *  shading: THREE.SmoothShading,\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  wireframe: <boolean>,\r\n *  wireframeLinewidth: <float>,\r\n *\r\n *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,\r\n *\r\n *  skinning: <bool>,\r\n *  morphTargets: <bool>,\r\n *  morphNormals: <bool>,\r\n *\r\n *\tfog: <bool>\r\n * }\r\n */\r\n\r\nTHREE.MeshPhongMaterial = function ( parameters ) {\r\n\r\n\tTHREE.Material.call( this );\r\n\r\n\tthis.type = 'MeshPhongMaterial';\r\n\r\n\tthis.color = new THREE.Color( 0xffffff ); // diffuse\r\n\tthis.emissive = new THREE.Color( 0x000000 );\r\n\tthis.specular = new THREE.Color( 0x111111 );\r\n\tthis.shininess = 30;\r\n\r\n\tthis.metal = false;\r\n\r\n\tthis.wrapAround = false;\r\n\tthis.wrapRGB = new THREE.Vector3( 1, 1, 1 );\r\n\r\n\tthis.map = null;\r\n\r\n\tthis.lightMap = null;\r\n\r\n\tthis.bumpMap = null;\r\n\tthis.bumpScale = 1;\r\n\r\n\tthis.normalMap = null;\r\n\tthis.normalScale = new THREE.Vector2( 1, 1 );\r\n\r\n\tthis.specularMap = null;\r\n\r\n\tthis.alphaMap = null;\r\n\r\n\tthis.envMap = null;\r\n\tthis.combine = THREE.MultiplyOperation;\r\n\tthis.reflectivity = 1;\r\n\tthis.refractionRatio = 0.98;\r\n\r\n\tthis.fog = true;\r\n\r\n\tthis.shading = THREE.SmoothShading;\r\n\r\n\tthis.wireframe = false;\r\n\tthis.wireframeLinewidth = 1;\r\n\tthis.wireframeLinecap = 'round';\r\n\tthis.wireframeLinejoin = 'round';\r\n\r\n\tthis.vertexColors = THREE.NoColors;\r\n\r\n\tthis.skinning = false;\r\n\tthis.morphTargets = false;\r\n\tthis.morphNormals = false;\r\n\r\n\tthis.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.MeshPhongMaterial.prototype = Object.create( THREE.Material.prototype );\r\nTHREE.MeshPhongMaterial.prototype.constructor = THREE.MeshPhongMaterial;\r\n\r\nTHREE.MeshPhongMaterial.prototype.clone = function () {\r\n\r\n\tvar material = new THREE.MeshPhongMaterial();\r\n\r\n\tTHREE.Material.prototype.clone.call( this, material );\r\n\r\n\tmaterial.color.copy( this.color );\r\n\tmaterial.emissive.copy( this.emissive );\r\n\tmaterial.specular.copy( this.specular );\r\n\tmaterial.shininess = this.shininess;\r\n\r\n\tmaterial.metal = this.metal;\r\n\r\n\tmaterial.wrapAround = this.wrapAround;\r\n\tmaterial.wrapRGB.copy( this.wrapRGB );\r\n\r\n\tmaterial.map = this.map;\r\n\r\n\tmaterial.lightMap = this.lightMap;\r\n\r\n\tmaterial.bumpMap = this.bumpMap;\r\n\tmaterial.bumpScale = this.bumpScale;\r\n\r\n\tmaterial.normalMap = this.normalMap;\r\n\tmaterial.normalScale.copy( this.normalScale );\r\n\r\n\tmaterial.specularMap = this.specularMap;\r\n\r\n\tmaterial.alphaMap = this.alphaMap;\r\n\r\n\tmaterial.envMap = this.envMap;\r\n\tmaterial.combine = this.combine;\r\n\tmaterial.reflectivity = this.reflectivity;\r\n\tmaterial.refractionRatio = this.refractionRatio;\r\n\r\n\tmaterial.fog = this.fog;\r\n\r\n\tmaterial.shading = this.shading;\r\n\r\n\tmaterial.wireframe = this.wireframe;\r\n\tmaterial.wireframeLinewidth = this.wireframeLinewidth;\r\n\tmaterial.wireframeLinecap = this.wireframeLinecap;\r\n\tmaterial.wireframeLinejoin = this.wireframeLinejoin;\r\n\r\n\tmaterial.vertexColors = this.vertexColors;\r\n\r\n\tmaterial.skinning = this.skinning;\r\n\tmaterial.morphTargets = this.morphTargets;\r\n\tmaterial.morphNormals = this.morphNormals;\r\n\r\n\treturn material;\r\n\r\n};\r\n\r\n// File:src/materials/MeshDepthMaterial.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  opacity: <float>,\r\n *\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  wireframe: <boolean>,\r\n *  wireframeLinewidth: <float>\r\n * }\r\n */\r\n\r\nTHREE.MeshDepthMaterial = function ( parameters ) {\r\n\r\n\tTHREE.Material.call( this );\r\n\r\n\tthis.type = 'MeshDepthMaterial';\r\n\r\n\tthis.morphTargets = false;\r\n\tthis.wireframe = false;\r\n\tthis.wireframeLinewidth = 1;\r\n\r\n\tthis.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.MeshDepthMaterial.prototype = Object.create( THREE.Material.prototype );\r\nTHREE.MeshDepthMaterial.prototype.constructor = THREE.MeshDepthMaterial;\r\n\r\nTHREE.MeshDepthMaterial.prototype.clone = function () {\r\n\r\n\tvar material = new THREE.MeshDepthMaterial();\r\n\r\n\tTHREE.Material.prototype.clone.call( this, material );\r\n\r\n\tmaterial.wireframe = this.wireframe;\r\n\tmaterial.wireframeLinewidth = this.wireframeLinewidth;\r\n\r\n\treturn material;\r\n\r\n};\r\n\r\n// File:src/materials/MeshNormalMaterial.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n *\r\n * parameters = {\r\n *  opacity: <float>,\r\n *\r\n *  shading: THREE.FlatShading,\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  wireframe: <boolean>,\r\n *  wireframeLinewidth: <float>\r\n * }\r\n */\r\n\r\nTHREE.MeshNormalMaterial = function ( parameters ) {\r\n\r\n\tTHREE.Material.call( this, parameters );\r\n\r\n\tthis.type = 'MeshNormalMaterial';\r\n\r\n\tthis.wireframe = false;\r\n\tthis.wireframeLinewidth = 1;\r\n\r\n\tthis.morphTargets = false;\r\n\r\n\tthis.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.MeshNormalMaterial.prototype = Object.create( THREE.Material.prototype );\r\nTHREE.MeshNormalMaterial.prototype.constructor = THREE.MeshNormalMaterial;\r\n\r\nTHREE.MeshNormalMaterial.prototype.clone = function () {\r\n\r\n\tvar material = new THREE.MeshNormalMaterial();\r\n\r\n\tTHREE.Material.prototype.clone.call( this, material );\r\n\r\n\tmaterial.wireframe = this.wireframe;\r\n\tmaterial.wireframeLinewidth = this.wireframeLinewidth;\r\n\r\n\treturn material;\r\n\r\n};\r\n\r\n// File:src/materials/MeshFaceMaterial.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.MeshFaceMaterial = function ( materials ) {\r\n\r\n\tthis.uuid = THREE.Math.generateUUID();\r\n\r\n\tthis.type = 'MeshFaceMaterial';\r\n\t\r\n\tthis.materials = materials instanceof Array ? materials : [];\r\n\r\n};\r\n\r\nTHREE.MeshFaceMaterial.prototype = {\r\n\r\n\tconstructor: THREE.MeshFaceMaterial,\r\n\r\n\ttoJSON: function () {\r\n\r\n\t\tvar output = {\r\n\t\t\tmetadata: {\r\n\t\t\t\tversion: 4.2,\r\n\t\t\t\ttype: 'material',\r\n\t\t\t\tgenerator: 'MaterialExporter'\r\n\t\t\t},\r\n\t\t\tuuid: this.uuid,\r\n\t\t\ttype: this.type,\r\n\t\t\tmaterials: []\r\n\t\t};\r\n\r\n\t\tfor ( var i = 0, l = this.materials.length; i < l; i ++ ) {\r\n\r\n\t\t\toutput.materials.push( this.materials[ i ].toJSON() );\r\n\r\n\t\t}\r\n\r\n\t\treturn output;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\tvar material = new THREE.MeshFaceMaterial();\r\n\r\n\t\tfor ( var i = 0; i < this.materials.length; i ++ ) {\r\n\r\n\t\t\tmaterial.materials.push( this.materials[ i ].clone() );\r\n\r\n\t\t}\r\n\r\n\t\treturn material;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/materials/PointCloudMaterial.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  opacity: <float>,\r\n *  map: new THREE.Texture( <Image> ),\r\n *\r\n *  size: <float>,\r\n *  sizeAttenuation: <bool>,\r\n *\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  vertexColors: <bool>,\r\n *\r\n *  fog: <bool>\r\n * }\r\n */\r\n\r\nTHREE.PointCloudMaterial = function ( parameters ) {\r\n\r\n\tTHREE.Material.call( this );\r\n\r\n\tthis.type = 'PointCloudMaterial';\r\n\r\n\tthis.color = new THREE.Color( 0xffffff );\r\n\r\n\tthis.map = null;\r\n\r\n\tthis.size = 1;\r\n\tthis.sizeAttenuation = true;\r\n\r\n\tthis.vertexColors = THREE.NoColors;\r\n\r\n\tthis.fog = true;\r\n\r\n\tthis.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.PointCloudMaterial.prototype = Object.create( THREE.Material.prototype );\r\nTHREE.PointCloudMaterial.prototype.constructor = THREE.PointCloudMaterial;\r\n\r\nTHREE.PointCloudMaterial.prototype.clone = function () {\r\n\r\n\tvar material = new THREE.PointCloudMaterial();\r\n\r\n\tTHREE.Material.prototype.clone.call( this, material );\r\n\r\n\tmaterial.color.copy( this.color );\r\n\r\n\tmaterial.map = this.map;\r\n\r\n\tmaterial.size = this.size;\r\n\tmaterial.sizeAttenuation = this.sizeAttenuation;\r\n\r\n\tmaterial.vertexColors = this.vertexColors;\r\n\r\n\tmaterial.fog = this.fog;\r\n\r\n\treturn material;\r\n\r\n};\r\n\r\n// backwards compatibility\r\n\r\nTHREE.ParticleBasicMaterial = function ( parameters ) {\r\n\r\n\tTHREE.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointCloudMaterial.' );\r\n\treturn new THREE.PointCloudMaterial( parameters );\r\n\r\n};\r\n\r\nTHREE.ParticleSystemMaterial = function ( parameters ) {\r\n\r\n\tTHREE.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointCloudMaterial.' );\r\n\treturn new THREE.PointCloudMaterial( parameters );\r\n\r\n};\r\n\r\n// File:src/materials/ShaderMaterial.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  defines: { \"label\" : \"value\" },\r\n *  uniforms: { \"parameter1\": { type: \"f\", value: 1.0 }, \"parameter2\": { type: \"i\" value2: 2 } },\r\n *\r\n *  fragmentShader: <string>,\r\n *  vertexShader: <string>,\r\n *\r\n *  shading: THREE.SmoothShading,\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  wireframe: <boolean>,\r\n *  wireframeLinewidth: <float>,\r\n *\r\n *  lights: <bool>,\r\n *\r\n *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,\r\n *\r\n *  skinning: <bool>,\r\n *  morphTargets: <bool>,\r\n *  morphNormals: <bool>,\r\n *\r\n *\tfog: <bool>\r\n * }\r\n */\r\n\r\nTHREE.ShaderMaterial = function ( parameters ) {\r\n\r\n\tTHREE.Material.call( this );\r\n\r\n\tthis.type = 'ShaderMaterial';\r\n\r\n\tthis.defines = {};\r\n\tthis.uniforms = {};\r\n\tthis.attributes = null;\r\n\r\n\tthis.vertexShader = 'void main() {\\n\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}';\r\n\tthis.fragmentShader = 'void main() {\\n\\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\\n}';\r\n\r\n\tthis.shading = THREE.SmoothShading;\r\n\r\n\tthis.linewidth = 1;\r\n\r\n\tthis.wireframe = false;\r\n\tthis.wireframeLinewidth = 1;\r\n\r\n\tthis.fog = false; // set to use scene fog\r\n\r\n\tthis.lights = false; // set to use scene lights\r\n\r\n\tthis.vertexColors = THREE.NoColors; // set to use \"color\" attribute stream\r\n\r\n\tthis.skinning = false; // set to use skinning attribute streams\r\n\r\n\tthis.morphTargets = false; // set to use morph targets\r\n\tthis.morphNormals = false; // set to use morph normals\r\n\r\n\t// When rendered geometry doesn't include these attributes but the material does,\r\n\t// use these default values in WebGL. This avoids errors when buffer data is missing.\r\n\tthis.defaultAttributeValues = {\r\n\t\t'color': [ 1, 1, 1 ],\r\n\t\t'uv': [ 0, 0 ],\r\n\t\t'uv2': [ 0, 0 ]\r\n\t};\r\n\r\n\tthis.index0AttributeName = undefined;\r\n\r\n\tthis.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.ShaderMaterial.prototype = Object.create( THREE.Material.prototype );\r\nTHREE.ShaderMaterial.prototype.constructor = THREE.ShaderMaterial;\r\n\r\nTHREE.ShaderMaterial.prototype.clone = function () {\r\n\r\n\tvar material = new THREE.ShaderMaterial();\r\n\r\n\tTHREE.Material.prototype.clone.call( this, material );\r\n\r\n\tmaterial.fragmentShader = this.fragmentShader;\r\n\tmaterial.vertexShader = this.vertexShader;\r\n\r\n\tmaterial.uniforms = THREE.UniformsUtils.clone( this.uniforms );\r\n\r\n\tmaterial.attributes = this.attributes;\r\n\tmaterial.defines = this.defines;\r\n\r\n\tmaterial.shading = this.shading;\r\n\r\n\tmaterial.wireframe = this.wireframe;\r\n\tmaterial.wireframeLinewidth = this.wireframeLinewidth;\r\n\r\n\tmaterial.fog = this.fog;\r\n\r\n\tmaterial.lights = this.lights;\r\n\r\n\tmaterial.vertexColors = this.vertexColors;\r\n\r\n\tmaterial.skinning = this.skinning;\r\n\r\n\tmaterial.morphTargets = this.morphTargets;\r\n\tmaterial.morphNormals = this.morphNormals;\r\n\r\n\treturn material;\r\n\r\n};\r\n\r\n// File:src/materials/RawShaderMaterial.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.RawShaderMaterial = function ( parameters ) {\r\n\r\n\tTHREE.ShaderMaterial.call( this, parameters );\r\n\r\n\tthis.type = 'RawShaderMaterial';\r\n\r\n};\r\n\r\nTHREE.RawShaderMaterial.prototype = Object.create( THREE.ShaderMaterial.prototype );\r\nTHREE.RawShaderMaterial.prototype.constructor = THREE.RawShaderMaterial;\r\n\r\nTHREE.RawShaderMaterial.prototype.clone = function () {\r\n\r\n\tvar material = new THREE.RawShaderMaterial();\r\n\r\n\tTHREE.ShaderMaterial.prototype.clone.call( this, material );\r\n\r\n\treturn material;\r\n\r\n};\r\n\r\n// File:src/materials/SpriteMaterial.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  opacity: <float>,\r\n *  map: new THREE.Texture( <Image> ),\r\n *\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *\tuvOffset: new THREE.Vector2(),\r\n *\tuvScale: new THREE.Vector2(),\r\n *\r\n *  fog: <bool>\r\n * }\r\n */\r\n\r\nTHREE.SpriteMaterial = function ( parameters ) {\r\n\r\n\tTHREE.Material.call( this );\r\n\r\n\tthis.type = 'SpriteMaterial';\r\n\r\n\tthis.color = new THREE.Color( 0xffffff );\r\n\tthis.map = null;\r\n\r\n\tthis.rotation = 0;\r\n\r\n\tthis.fog = false;\r\n\r\n\t// set parameters\r\n\r\n\tthis.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.SpriteMaterial.prototype = Object.create( THREE.Material.prototype );\r\nTHREE.SpriteMaterial.prototype.constructor = THREE.SpriteMaterial;\r\n\r\nTHREE.SpriteMaterial.prototype.clone = function () {\r\n\r\n\tvar material = new THREE.SpriteMaterial();\r\n\r\n\tTHREE.Material.prototype.clone.call( this, material );\r\n\r\n\tmaterial.color.copy( this.color );\r\n\tmaterial.map = this.map;\r\n\r\n\tmaterial.rotation = this.rotation;\r\n\r\n\tmaterial.fog = this.fog;\r\n\r\n\treturn material;\r\n\r\n};\r\n\r\n// File:src/textures/Texture.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author szimek / https://github.com/szimek/\r\n */\r\n\r\nTHREE.Texture = function ( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\r\n\r\n\tObject.defineProperty( this, 'id', { value: THREE.TextureIdCount ++ } );\r\n\r\n\tthis.uuid = THREE.Math.generateUUID();\r\n\r\n\tthis.name = '';\r\n\tthis.sourceFile = '';\r\n\r\n\tthis.image = image !== undefined ? image : THREE.Texture.DEFAULT_IMAGE;\r\n\tthis.mipmaps = [];\r\n\r\n\tthis.mapping = mapping !== undefined ? mapping : THREE.Texture.DEFAULT_MAPPING;\r\n\r\n\tthis.wrapS = wrapS !== undefined ? wrapS : THREE.ClampToEdgeWrapping;\r\n\tthis.wrapT = wrapT !== undefined ? wrapT : THREE.ClampToEdgeWrapping;\r\n\r\n\tthis.magFilter = magFilter !== undefined ? magFilter : THREE.LinearFilter;\r\n\tthis.minFilter = minFilter !== undefined ? minFilter : THREE.LinearMipMapLinearFilter;\r\n\r\n\tthis.anisotropy = anisotropy !== undefined ? anisotropy : 1;\r\n\r\n\tthis.format = format !== undefined ? format : THREE.RGBAFormat;\r\n\tthis.type = type !== undefined ? type : THREE.UnsignedByteType;\r\n\r\n\tthis.offset = new THREE.Vector2( 0, 0 );\r\n\tthis.repeat = new THREE.Vector2( 1, 1 );\r\n\r\n\tthis.generateMipmaps = true;\r\n\tthis.premultiplyAlpha = false;\r\n\tthis.flipY = true;\r\n\tthis.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)\r\n\r\n\tthis._needsUpdate = false;\r\n\tthis.onUpdate = null;\r\n\r\n};\r\n\r\nTHREE.Texture.DEFAULT_IMAGE = undefined;\r\nTHREE.Texture.DEFAULT_MAPPING = THREE.UVMapping;\r\n\r\nTHREE.Texture.prototype = {\r\n\r\n\tconstructor: THREE.Texture,\r\n\r\n\tget needsUpdate () {\r\n\r\n\t\treturn this._needsUpdate;\r\n\r\n\t},\r\n\r\n\tset needsUpdate ( value ) {\r\n\r\n\t\tif ( value === true ) this.update();\r\n\r\n\t\tthis._needsUpdate = value;\r\n\r\n\t},\r\n\r\n\tclone: function ( texture ) {\r\n\r\n\t\tif ( texture === undefined ) texture = new THREE.Texture();\r\n\r\n\t\ttexture.image = this.image;\r\n\t\ttexture.mipmaps = this.mipmaps.slice( 0 );\r\n\r\n\t\ttexture.mapping = this.mapping;\r\n\r\n\t\ttexture.wrapS = this.wrapS;\r\n\t\ttexture.wrapT = this.wrapT;\r\n\r\n\t\ttexture.magFilter = this.magFilter;\r\n\t\ttexture.minFilter = this.minFilter;\r\n\r\n\t\ttexture.anisotropy = this.anisotropy;\r\n\r\n\t\ttexture.format = this.format;\r\n\t\ttexture.type = this.type;\r\n\r\n\t\ttexture.offset.copy( this.offset );\r\n\t\ttexture.repeat.copy( this.repeat );\r\n\r\n\t\ttexture.generateMipmaps = this.generateMipmaps;\r\n\t\ttexture.premultiplyAlpha = this.premultiplyAlpha;\r\n\t\ttexture.flipY = this.flipY;\r\n\t\ttexture.unpackAlignment = this.unpackAlignment;\r\n\r\n\t\treturn texture;\r\n\r\n\t},\r\n\r\n\tupdate: function () {\r\n\r\n\t\tthis.dispatchEvent( { type: 'update' } );\r\n\r\n\t},\r\n\r\n\tdispose: function () {\r\n\r\n\t\tthis.dispatchEvent( { type: 'dispose' } );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.EventDispatcher.prototype.apply( THREE.Texture.prototype );\r\n\r\nTHREE.TextureIdCount = 0;\r\n\r\n// File:src/textures/CubeTexture.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.CubeTexture = function ( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\r\n\r\n\tmapping = mapping !== undefined ? mapping : THREE.CubeReflectionMapping;\r\n\t\r\n\tTHREE.Texture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\r\n\r\n\tthis.images = images;\r\n\r\n};\r\n\r\nTHREE.CubeTexture.prototype = Object.create( THREE.Texture.prototype );\r\nTHREE.CubeTexture.prototype.constructor = THREE.CubeTexture;\r\n\r\nTHREE.CubeTexture.clone = function ( texture ) {\r\n\r\n\tif ( texture === undefined ) texture = new THREE.CubeTexture();\r\n\r\n\tTHREE.Texture.prototype.clone.call( this, texture );\r\n\r\n\ttexture.images = this.images;\r\n\r\n\treturn texture;\r\n\r\n};\r\n\r\n// File:src/textures/CompressedTexture.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.CompressedTexture = function ( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {\r\n\r\n\tTHREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\r\n\r\n\tthis.image = { width: width, height: height };\r\n\tthis.mipmaps = mipmaps;\r\n\r\n\t// no flipping for cube textures\r\n\t// (also flipping doesn't work for compressed textures )\r\n\r\n\tthis.flipY = false;\r\n\r\n\t// can't generate mipmaps for compressed textures\r\n\t// mips must be embedded in DDS files\r\n\r\n\tthis.generateMipmaps = false;\r\n\r\n};\r\n\r\nTHREE.CompressedTexture.prototype = Object.create( THREE.Texture.prototype );\r\nTHREE.CompressedTexture.prototype.constructor = THREE.CompressedTexture;\r\n\r\nTHREE.CompressedTexture.prototype.clone = function () {\r\n\r\n\tvar texture = new THREE.CompressedTexture();\r\n\r\n\tTHREE.Texture.prototype.clone.call( this, texture );\r\n\r\n\treturn texture;\r\n\r\n};\r\n\r\n// File:src/textures/DataTexture.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.DataTexture = function ( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {\r\n\r\n\tTHREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\r\n\r\n\tthis.image = { data: data, width: width, height: height };\r\n\r\n};\r\n\r\nTHREE.DataTexture.prototype = Object.create( THREE.Texture.prototype );\r\nTHREE.DataTexture.prototype.constructor = THREE.DataTexture;\r\n\r\nTHREE.DataTexture.prototype.clone = function () {\r\n\r\n\tvar texture = new THREE.DataTexture();\r\n\r\n\tTHREE.Texture.prototype.clone.call( this, texture );\r\n\r\n\treturn texture;\r\n\r\n};\r\n\r\n// File:src/textures/VideoTexture.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.VideoTexture = function ( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\r\n\r\n\tTHREE.Texture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\r\n\r\n\tthis.generateMipmaps = false;\r\n\r\n\tvar scope = this;\r\n\r\n\tvar update = function () {\r\n\r\n\t\trequestAnimationFrame( update );\r\n\r\n\t\tif ( video.readyState === video.HAVE_ENOUGH_DATA ) {\r\n\r\n\t\t\tscope.needsUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tupdate();\r\n\r\n};\r\n\r\nTHREE.VideoTexture.prototype = Object.create( THREE.Texture.prototype );\r\nTHREE.VideoTexture.prototype.constructor = THREE.VideoTexture;\r\n\r\n// File:src/objects/Group.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Group = function () {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.type = 'Group';\r\n\r\n};\r\n\r\nTHREE.Group.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.Group.prototype.constructor = THREE.Group;\r\n\r\n// File:src/objects/PointCloud.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.PointCloud = function ( geometry, material ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.type = 'PointCloud';\r\n\r\n\tthis.geometry = geometry !== undefined ? geometry : new THREE.Geometry();\r\n\tthis.material = material !== undefined ? material : new THREE.PointCloudMaterial( { color: Math.random() * 0xffffff } );\r\n\r\n};\r\n\r\nTHREE.PointCloud.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.PointCloud.prototype.constructor = THREE.PointCloud;\r\n\r\nTHREE.PointCloud.prototype.raycast = ( function () {\r\n\r\n\tvar inverseMatrix = new THREE.Matrix4();\r\n\tvar ray = new THREE.Ray();\r\n\r\n\treturn function ( raycaster, intersects ) {\r\n\r\n\t\tvar object = this;\r\n\t\tvar geometry = object.geometry;\r\n\t\tvar threshold = raycaster.params.PointCloud.threshold;\r\n\r\n\t\tinverseMatrix.getInverse( this.matrixWorld );\r\n\t\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\r\n\r\n\t\tif ( geometry.boundingBox !== null ) {\r\n\r\n\t\t\tif ( ray.isIntersectionBox( geometry.boundingBox ) === false ) {\r\n\r\n\t\t\t\treturn;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvar localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );\r\n\t\tvar position = new THREE.Vector3();\r\n\r\n\t\tvar testPoint = function ( point, index ) {\r\n\r\n\t\t\tvar rayPointDistance = ray.distanceToPoint( point );\r\n\r\n\t\t\tif ( rayPointDistance < localThreshold ) {\r\n\r\n\t\t\t\tvar intersectPoint = ray.closestPointToPoint( point );\r\n\t\t\t\tintersectPoint.applyMatrix4( object.matrixWorld );\r\n\r\n\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( intersectPoint );\r\n\r\n\t\t\t\tintersects.push( {\r\n\r\n\t\t\t\t\tdistance: distance,\r\n\t\t\t\t\tdistanceToRay: rayPointDistance,\r\n\t\t\t\t\tpoint: intersectPoint.clone(),\r\n\t\t\t\t\tindex: index,\r\n\t\t\t\t\tface: null,\r\n\t\t\t\t\tobject: object\r\n\r\n\t\t\t\t} );\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t\tif ( geometry instanceof THREE.BufferGeometry ) {\r\n\r\n\t\t\tvar attributes = geometry.attributes;\r\n\t\t\tvar positions = attributes.position.array;\r\n\r\n\t\t\tif ( attributes.index !== undefined ) {\r\n\r\n\t\t\t\tvar indices = attributes.index.array;\r\n\t\t\t\tvar offsets = geometry.offsets;\r\n\r\n\t\t\t\tif ( offsets.length === 0 ) {\r\n\r\n\t\t\t\t\tvar offset = {\r\n\t\t\t\t\t\tstart: 0,\r\n\t\t\t\t\t\tcount: indices.length,\r\n\t\t\t\t\t\tindex: 0\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\toffsets = [ offset ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor ( var oi = 0, ol = offsets.length; oi < ol; ++ oi ) {\r\n\r\n\t\t\t\t\tvar start = offsets[ oi ].start;\r\n\t\t\t\t\tvar count = offsets[ oi ].count;\r\n\t\t\t\t\tvar index = offsets[ oi ].index;\r\n\r\n\t\t\t\t\tfor ( var i = start, il = start + count; i < il; i ++ ) {\r\n\r\n\t\t\t\t\t\tvar a = index + indices[ i ];\r\n\r\n\t\t\t\t\t\tposition.fromArray( positions, a * 3 );\r\n\r\n\t\t\t\t\t\ttestPoint( position, a );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tvar pointCount = positions.length / 3;\r\n\r\n\t\t\t\tfor ( var i = 0; i < pointCount; i ++ ) {\r\n\r\n\t\t\t\t\tposition.set(\r\n\t\t\t\t\t\tpositions[ 3 * i ],\r\n\t\t\t\t\t\tpositions[ 3 * i + 1 ],\r\n\t\t\t\t\t\tpositions[ 3 * i + 2 ]\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t\ttestPoint( position, i );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tvar vertices = this.geometry.vertices;\r\n\r\n\t\t\tfor ( var i = 0; i < vertices.length; i ++ ) {\r\n\r\n\t\t\t\ttestPoint( vertices[ i ], i );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n}() );\r\n\r\nTHREE.PointCloud.prototype.clone = function ( object ) {\r\n\r\n\tif ( object === undefined ) object = new THREE.PointCloud( this.geometry, this.material );\r\n\r\n\tTHREE.Object3D.prototype.clone.call( this, object );\r\n\r\n\treturn object;\r\n\r\n};\r\n\r\n// Backwards compatibility\r\n\r\nTHREE.ParticleSystem = function ( geometry, material ) {\r\n\r\n\tTHREE.warn( 'THREE.ParticleSystem has been renamed to THREE.PointCloud.' );\r\n\treturn new THREE.PointCloud( geometry, material );\r\n\r\n};\r\n\r\n// File:src/objects/Line.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Line = function ( geometry, material, mode ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.type = 'Line';\r\n\r\n\tthis.geometry = geometry !== undefined ? geometry : new THREE.Geometry();\r\n\tthis.material = material !== undefined ? material : new THREE.LineBasicMaterial( { color: Math.random() * 0xffffff } );\r\n\r\n\tthis.mode = mode !== undefined ? mode : THREE.LineStrip;\r\n\r\n};\r\n\r\nTHREE.LineStrip = 0;\r\nTHREE.LinePieces = 1;\r\n\r\nTHREE.Line.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.Line.prototype.constructor = THREE.Line;\r\n\r\nTHREE.Line.prototype.raycast = ( function () {\r\n\r\n\tvar inverseMatrix = new THREE.Matrix4();\r\n\tvar ray = new THREE.Ray();\r\n\tvar sphere = new THREE.Sphere();\r\n\r\n\treturn function ( raycaster, intersects ) {\r\n\r\n\t\tvar precision = raycaster.linePrecision;\r\n\t\tvar precisionSq = precision * precision;\r\n\r\n\t\tvar geometry = this.geometry;\r\n\r\n\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\r\n\r\n\t\t// Checking boundingSphere distance to ray\r\n\r\n\t\tsphere.copy( geometry.boundingSphere );\r\n\t\tsphere.applyMatrix4( this.matrixWorld );\r\n\r\n\t\tif ( raycaster.ray.isIntersectionSphere( sphere ) === false ) {\r\n\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tinverseMatrix.getInverse( this.matrixWorld );\r\n\t\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\r\n\r\n\t\tvar vStart = new THREE.Vector3();\r\n\t\tvar vEnd = new THREE.Vector3();\r\n\t\tvar interSegment = new THREE.Vector3();\r\n\t\tvar interRay = new THREE.Vector3();\r\n\t\tvar step = this.mode === THREE.LineStrip ? 1 : 2;\r\n\r\n\t\tif ( geometry instanceof THREE.BufferGeometry ) {\r\n\r\n\t\t\tvar attributes = geometry.attributes;\r\n\r\n\t\t\tif ( attributes.index !== undefined ) {\r\n\r\n\t\t\t\tvar indices = attributes.index.array;\r\n\t\t\t\tvar positions = attributes.position.array;\r\n\t\t\t\tvar offsets = geometry.offsets;\r\n\r\n\t\t\t\tif ( offsets.length === 0 ) {\r\n\r\n\t\t\t\t\toffsets = [ { start: 0, count: indices.length, index: 0 } ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor ( var oi = 0; oi < offsets.length; oi ++) {\r\n\r\n\t\t\t\t\tvar start = offsets[ oi ].start;\r\n\t\t\t\t\tvar count = offsets[ oi ].count;\r\n\t\t\t\t\tvar index = offsets[ oi ].index;\r\n\r\n\t\t\t\t\tfor ( var i = start; i < start + count - 1; i += step ) {\r\n\r\n\t\t\t\t\t\tvar a = index + indices[ i ];\r\n\t\t\t\t\t\tvar b = index + indices[ i + 1 ];\r\n\r\n\t\t\t\t\t\tvStart.fromArray( positions, a * 3 );\r\n\t\t\t\t\t\tvEnd.fromArray( positions, b * 3 );\r\n\r\n\t\t\t\t\t\tvar distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );\r\n\r\n\t\t\t\t\t\tif ( distSq > precisionSq ) continue;\r\n\r\n\t\t\t\t\t\tvar distance = ray.origin.distanceTo( interRay );\r\n\r\n\t\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\r\n\r\n\t\t\t\t\t\tintersects.push( {\r\n\r\n\t\t\t\t\t\t\tdistance: distance,\r\n\t\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\r\n\t\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\r\n\t\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\r\n\t\t\t\t\t\t\tindex: i,\r\n\t\t\t\t\t\t\toffsetIndex: oi,\r\n\t\t\t\t\t\t\tface: null,\r\n\t\t\t\t\t\t\tfaceIndex: null,\r\n\t\t\t\t\t\t\tobject: this\r\n\r\n\t\t\t\t\t\t} );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tvar positions = attributes.position.array;\r\n\r\n\t\t\t\tfor ( var i = 0; i < positions.length / 3 - 1; i += step ) {\r\n\r\n\t\t\t\t\tvStart.fromArray( positions, 3 * i );\r\n\t\t\t\t\tvEnd.fromArray( positions, 3 * i + 3 );\r\n\r\n\t\t\t\t\tvar distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );\r\n\r\n\t\t\t\t\tif ( distSq > precisionSq ) continue;\r\n\r\n\t\t\t\t\tvar distance = ray.origin.distanceTo( interRay );\r\n\r\n\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\r\n\r\n\t\t\t\t\tintersects.push( {\r\n\r\n\t\t\t\t\t\tdistance: distance,\r\n\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\r\n\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\r\n\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\r\n\t\t\t\t\t\tindex: i,\r\n\t\t\t\t\t\tface: null,\r\n\t\t\t\t\t\tfaceIndex: null,\r\n\t\t\t\t\t\tobject: this\r\n\r\n\t\t\t\t\t} );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( geometry instanceof THREE.Geometry ) {\r\n\r\n\t\t\tvar vertices = geometry.vertices;\r\n\t\t\tvar nbVertices = vertices.length;\r\n\r\n\t\t\tfor ( var i = 0; i < nbVertices - 1; i += step ) {\r\n\r\n\t\t\t\tvar distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );\r\n\r\n\t\t\t\tif ( distSq > precisionSq ) continue;\r\n\r\n\t\t\t\tvar distance = ray.origin.distanceTo( interRay );\r\n\r\n\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\r\n\r\n\t\t\t\tintersects.push( {\r\n\r\n\t\t\t\t\tdistance: distance,\r\n\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\r\n\t\t\t\t\t// point: raycaster.ray.at( distance ),\r\n\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\r\n\t\t\t\t\tindex: i,\r\n\t\t\t\t\tface: null,\r\n\t\t\t\t\tfaceIndex: null,\r\n\t\t\t\t\tobject: this\r\n\r\n\t\t\t\t} );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n}() );\r\n\r\nTHREE.Line.prototype.clone = function ( object ) {\r\n\r\n\tif ( object === undefined ) object = new THREE.Line( this.geometry, this.material, this.mode );\r\n\r\n\tTHREE.Object3D.prototype.clone.call( this, object );\r\n\r\n\treturn object;\r\n\r\n};\r\n\r\n// File:src/objects/Mesh.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author jonobr1 / http://jonobr1.com/\r\n */\r\n\r\nTHREE.Mesh = function ( geometry, material ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.type = 'Mesh';\r\n\t\r\n\tthis.geometry = geometry !== undefined ? geometry : new THREE.Geometry();\r\n\tthis.material = material !== undefined ? material : new THREE.MeshBasicMaterial( { color: Math.random() * 0xffffff } );\r\n\r\n\tthis.updateMorphTargets();\r\n\r\n};\r\n\r\nTHREE.Mesh.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.Mesh.prototype.constructor = THREE.Mesh;\r\n\r\nTHREE.Mesh.prototype.updateMorphTargets = function () {\r\n\r\n\tif ( this.geometry.morphTargets !== undefined && this.geometry.morphTargets.length > 0 ) {\r\n\r\n\t\tthis.morphTargetBase = - 1;\r\n\t\tthis.morphTargetForcedOrder = [];\r\n\t\tthis.morphTargetInfluences = [];\r\n\t\tthis.morphTargetDictionary = {};\r\n\r\n\t\tfor ( var m = 0, ml = this.geometry.morphTargets.length; m < ml; m ++ ) {\r\n\r\n\t\t\tthis.morphTargetInfluences.push( 0 );\r\n\t\t\tthis.morphTargetDictionary[ this.geometry.morphTargets[ m ].name ] = m;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.Mesh.prototype.getMorphTargetIndexByName = function ( name ) {\r\n\r\n\tif ( this.morphTargetDictionary[ name ] !== undefined ) {\r\n\r\n\t\treturn this.morphTargetDictionary[ name ];\r\n\r\n\t}\r\n\r\n\tTHREE.warn( 'THREE.Mesh.getMorphTargetIndexByName: morph target ' + name + ' does not exist. Returning 0.' );\r\n\r\n\treturn 0;\r\n\r\n};\r\n\r\n\r\nTHREE.Mesh.prototype.raycast = ( function () {\r\n\r\n\tvar inverseMatrix = new THREE.Matrix4();\r\n\tvar ray = new THREE.Ray();\r\n\tvar sphere = new THREE.Sphere();\r\n\r\n\tvar vA = new THREE.Vector3();\r\n\tvar vB = new THREE.Vector3();\r\n\tvar vC = new THREE.Vector3();\r\n\r\n\treturn function ( raycaster, intersects ) {\r\n\r\n\t\tvar geometry = this.geometry;\r\n\r\n\t\t// Checking boundingSphere distance to ray\r\n\r\n\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\r\n\r\n\t\tsphere.copy( geometry.boundingSphere );\r\n\t\tsphere.applyMatrix4( this.matrixWorld );\r\n\r\n\t\tif ( raycaster.ray.isIntersectionSphere( sphere ) === false ) {\r\n\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\t// Check boundingBox before continuing\r\n\r\n\t\tinverseMatrix.getInverse( this.matrixWorld );\r\n\t\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\r\n\r\n\t\tif ( geometry.boundingBox !== null ) {\r\n\r\n\t\t\tif ( ray.isIntersectionBox( geometry.boundingBox ) === false ) {\r\n\r\n\t\t\t\treturn;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry instanceof THREE.BufferGeometry ) {\r\n\r\n\t\t\tvar material = this.material;\r\n\r\n\t\t\tif ( material === undefined ) return;\r\n\r\n\t\t\tvar attributes = geometry.attributes;\r\n\r\n\t\t\tvar a, b, c;\r\n\t\t\tvar precision = raycaster.precision;\r\n\r\n\t\t\tif ( attributes.index !== undefined ) {\r\n\r\n\t\t\t\tvar indices = attributes.index.array;\r\n\t\t\t\tvar positions = attributes.position.array;\r\n\t\t\t\tvar offsets = geometry.offsets;\r\n\r\n\t\t\t\tif ( offsets.length === 0 ) {\r\n\r\n\t\t\t\t\toffsets = [ { start: 0, count: indices.length, index: 0 } ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor ( var oi = 0, ol = offsets.length; oi < ol; ++ oi ) {\r\n\r\n\t\t\t\t\tvar start = offsets[ oi ].start;\r\n\t\t\t\t\tvar count = offsets[ oi ].count;\r\n\t\t\t\t\tvar index = offsets[ oi ].index;\r\n\r\n\t\t\t\t\tfor ( var i = start, il = start + count; i < il; i += 3 ) {\r\n\r\n\t\t\t\t\t\ta = index + indices[ i ];\r\n\t\t\t\t\t\tb = index + indices[ i + 1 ];\r\n\t\t\t\t\t\tc = index + indices[ i + 2 ];\r\n\r\n\t\t\t\t\t\tvA.fromArray( positions, a * 3 );\r\n\t\t\t\t\t\tvB.fromArray( positions, b * 3 );\r\n\t\t\t\t\t\tvC.fromArray( positions, c * 3 );\r\n\r\n\t\t\t\t\t\tif ( material.side === THREE.BackSide ) {\r\n\r\n\t\t\t\t\t\t\tvar intersectionPoint = ray.intersectTriangle( vC, vB, vA, true );\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tvar intersectionPoint = ray.intersectTriangle( vA, vB, vC, material.side !== THREE.DoubleSide );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif ( intersectionPoint === null ) continue;\r\n\r\n\t\t\t\t\t\tintersectionPoint.applyMatrix4( this.matrixWorld );\r\n\r\n\t\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( intersectionPoint );\r\n\r\n\t\t\t\t\t\tif ( distance < precision || distance < raycaster.near || distance > raycaster.far ) continue;\r\n\r\n\t\t\t\t\t\tintersects.push( {\r\n\r\n\t\t\t\t\t\t\tdistance: distance,\r\n\t\t\t\t\t\t\tpoint: intersectionPoint,\r\n\t\t\t\t\t\t\tface: new THREE.Face3( a, b, c, THREE.Triangle.normal( vA, vB, vC ) ),\r\n\t\t\t\t\t\t\tfaceIndex: null,\r\n\t\t\t\t\t\t\tobject: this\r\n\r\n\t\t\t\t\t\t} );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tvar positions = attributes.position.array;\r\n\r\n\t\t\t\tfor ( var i = 0, j = 0, il = positions.length; i < il; i += 3, j += 9 ) {\r\n\r\n\t\t\t\t\ta = i;\r\n\t\t\t\t\tb = i + 1;\r\n\t\t\t\t\tc = i + 2;\r\n\r\n\t\t\t\t\tvA.fromArray( positions, j );\r\n\t\t\t\t\tvB.fromArray( positions, j + 3 );\r\n\t\t\t\t\tvC.fromArray( positions, j + 6 );\r\n\r\n\t\t\t\t\tif ( material.side === THREE.BackSide ) {\r\n\r\n\t\t\t\t\t\tvar intersectionPoint = ray.intersectTriangle( vC, vB, vA, true );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tvar intersectionPoint = ray.intersectTriangle( vA, vB, vC, material.side !== THREE.DoubleSide );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( intersectionPoint === null ) continue;\r\n\r\n\t\t\t\t\tintersectionPoint.applyMatrix4( this.matrixWorld );\r\n\r\n\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( intersectionPoint );\r\n\r\n\t\t\t\t\tif ( distance < precision || distance < raycaster.near || distance > raycaster.far ) continue;\r\n\r\n\t\t\t\t\tintersects.push( {\r\n\r\n\t\t\t\t\t\tdistance: distance,\r\n\t\t\t\t\t\tpoint: intersectionPoint,\r\n\t\t\t\t\t\tface: new THREE.Face3( a, b, c, THREE.Triangle.normal( vA, vB, vC ) ),\r\n\t\t\t\t\t\tfaceIndex: null,\r\n\t\t\t\t\t\tobject: this\r\n\r\n\t\t\t\t\t} );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( geometry instanceof THREE.Geometry ) {\r\n\r\n\t\t\tvar isFaceMaterial = this.material instanceof THREE.MeshFaceMaterial;\r\n\t\t\tvar objectMaterials = isFaceMaterial === true ? this.material.materials : null;\r\n\r\n\t\t\tvar a, b, c;\r\n\t\t\tvar precision = raycaster.precision;\r\n\r\n\t\t\tvar vertices = geometry.vertices;\r\n\r\n\t\t\tfor ( var f = 0, fl = geometry.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tvar face = geometry.faces[ f ];\r\n\r\n\t\t\t\tvar material = isFaceMaterial === true ? objectMaterials[ face.materialIndex ] : this.material;\r\n\r\n\t\t\t\tif ( material === undefined ) continue;\r\n\r\n\t\t\t\ta = vertices[ face.a ];\r\n\t\t\t\tb = vertices[ face.b ];\r\n\t\t\t\tc = vertices[ face.c ];\r\n\r\n\t\t\t\tif ( material.morphTargets === true ) {\r\n\r\n\t\t\t\t\tvar morphTargets = geometry.morphTargets;\r\n\t\t\t\t\tvar morphInfluences = this.morphTargetInfluences;\r\n\r\n\t\t\t\t\tvA.set( 0, 0, 0 );\r\n\t\t\t\t\tvB.set( 0, 0, 0 );\r\n\t\t\t\t\tvC.set( 0, 0, 0 );\r\n\r\n\t\t\t\t\tfor ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {\r\n\r\n\t\t\t\t\t\tvar influence = morphInfluences[ t ];\r\n\r\n\t\t\t\t\t\tif ( influence === 0 ) continue;\r\n\r\n\t\t\t\t\t\tvar targets = morphTargets[ t ].vertices;\r\n\r\n\t\t\t\t\t\tvA.x += ( targets[ face.a ].x - a.x ) * influence;\r\n\t\t\t\t\t\tvA.y += ( targets[ face.a ].y - a.y ) * influence;\r\n\t\t\t\t\t\tvA.z += ( targets[ face.a ].z - a.z ) * influence;\r\n\r\n\t\t\t\t\t\tvB.x += ( targets[ face.b ].x - b.x ) * influence;\r\n\t\t\t\t\t\tvB.y += ( targets[ face.b ].y - b.y ) * influence;\r\n\t\t\t\t\t\tvB.z += ( targets[ face.b ].z - b.z ) * influence;\r\n\r\n\t\t\t\t\t\tvC.x += ( targets[ face.c ].x - c.x ) * influence;\r\n\t\t\t\t\t\tvC.y += ( targets[ face.c ].y - c.y ) * influence;\r\n\t\t\t\t\t\tvC.z += ( targets[ face.c ].z - c.z ) * influence;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tvA.add( a );\r\n\t\t\t\t\tvB.add( b );\r\n\t\t\t\t\tvC.add( c );\r\n\r\n\t\t\t\t\ta = vA;\r\n\t\t\t\t\tb = vB;\r\n\t\t\t\t\tc = vC;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( material.side === THREE.BackSide ) {\r\n\r\n\t\t\t\t\tvar intersectionPoint = ray.intersectTriangle( c, b, a, true );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tvar intersectionPoint = ray.intersectTriangle( a, b, c, material.side !== THREE.DoubleSide );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( intersectionPoint === null ) continue;\r\n\r\n\t\t\t\tintersectionPoint.applyMatrix4( this.matrixWorld );\r\n\r\n\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( intersectionPoint );\r\n\r\n\t\t\t\tif ( distance < precision || distance < raycaster.near || distance > raycaster.far ) continue;\r\n\r\n\t\t\t\tintersects.push( {\r\n\r\n\t\t\t\t\tdistance: distance,\r\n\t\t\t\t\tpoint: intersectionPoint,\r\n\t\t\t\t\tface: face,\r\n\t\t\t\t\tfaceIndex: f,\r\n\t\t\t\t\tobject: this\r\n\r\n\t\t\t\t} );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n}() );\r\n\r\nTHREE.Mesh.prototype.clone = function ( object, recursive ) {\r\n\r\n\tif ( object === undefined ) object = new THREE.Mesh( this.geometry, this.material );\r\n\r\n\tTHREE.Object3D.prototype.clone.call( this, object, recursive );\r\n\r\n\treturn object;\r\n\r\n};\r\n\r\n// File:src/objects/Bone.js\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author ikerr / http://verold.com\r\n */\r\n\r\nTHREE.Bone = function ( skin ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.type = 'Bone';\r\n\r\n\tthis.skin = skin;\r\n\r\n};\r\n\r\nTHREE.Bone.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.Bone.prototype.constructor = THREE.Bone;\r\n\r\n// File:src/objects/Skeleton.js\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author michael guerrero / http://realitymeltdown.com\r\n * @author ikerr / http://verold.com\r\n */\r\n\r\nTHREE.Skeleton = function ( bones, boneInverses, useVertexTexture ) {\r\n\r\n\tthis.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;\r\n\r\n\tthis.identityMatrix = new THREE.Matrix4();\r\n\r\n\t// copy the bone array\r\n\r\n\tbones = bones || [];\r\n\r\n\tthis.bones = bones.slice( 0 );\r\n\r\n\t// create a bone texture or an array of floats\r\n\r\n\tif ( this.useVertexTexture ) {\r\n\r\n\t\t// layout (1 matrix = 4 pixels)\r\n\t\t//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)\r\n\t\t//  with  8x8  pixel texture max   16 bones  (8 * 8  / 4)\r\n\t\t//       16x16 pixel texture max   64 bones (16 * 16 / 4)\r\n\t\t//       32x32 pixel texture max  256 bones (32 * 32 / 4)\r\n\t\t//       64x64 pixel texture max 1024 bones (64 * 64 / 4)\r\n\r\n\t\tvar size;\r\n\r\n\t\tif ( this.bones.length > 256 )\r\n\t\t\tsize = 64;\r\n\t\telse if ( this.bones.length > 64 )\r\n\t\t\tsize = 32;\r\n\t\telse if ( this.bones.length > 16 )\r\n\t\t\tsize = 16;\r\n\t\telse\r\n\t\t\tsize = 8;\r\n\r\n\t\tthis.boneTextureWidth = size;\r\n\t\tthis.boneTextureHeight = size;\r\n\r\n\t\tthis.boneMatrices = new Float32Array( this.boneTextureWidth * this.boneTextureHeight * 4 ); // 4 floats per RGBA pixel\r\n\t\tthis.boneTexture = new THREE.DataTexture( this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType );\r\n\t\tthis.boneTexture.minFilter = THREE.NearestFilter;\r\n\t\tthis.boneTexture.magFilter = THREE.NearestFilter;\r\n\t\tthis.boneTexture.generateMipmaps = false;\r\n\t\tthis.boneTexture.flipY = false;\r\n\r\n\t} else {\r\n\r\n\t\tthis.boneMatrices = new Float32Array( 16 * this.bones.length );\r\n\r\n\t}\r\n\r\n\t// use the supplied bone inverses or calculate the inverses\r\n\r\n\tif ( boneInverses === undefined ) {\r\n\r\n\t\tthis.calculateInverses();\r\n\r\n\t} else {\r\n\r\n\t\tif ( this.bones.length === boneInverses.length ) {\r\n\r\n\t\t\tthis.boneInverses = boneInverses.slice( 0 );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tTHREE.warn( 'THREE.Skeleton bonInverses is the wrong length.' );\r\n\r\n\t\t\tthis.boneInverses = [];\r\n\r\n\t\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\r\n\r\n\t\t\t\tthis.boneInverses.push( new THREE.Matrix4() );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.Skeleton.prototype.calculateInverses = function () {\r\n\r\n\tthis.boneInverses = [];\r\n\r\n\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\r\n\r\n\t\tvar inverse = new THREE.Matrix4();\r\n\r\n\t\tif ( this.bones[ b ] ) {\r\n\r\n\t\t\tinverse.getInverse( this.bones[ b ].matrixWorld );\r\n\r\n\t\t}\r\n\r\n\t\tthis.boneInverses.push( inverse );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.Skeleton.prototype.pose = function () {\r\n\r\n\tvar bone;\r\n\r\n\t// recover the bind-time world matrices\r\n\r\n\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\r\n\r\n\t\tbone = this.bones[ b ];\r\n\r\n\t\tif ( bone ) {\r\n\r\n\t\t\tbone.matrixWorld.getInverse( this.boneInverses[ b ] );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// compute the local matrices, positions, rotations and scales\r\n\r\n\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\r\n\r\n\t\tbone = this.bones[ b ];\r\n\r\n\t\tif ( bone ) {\r\n\r\n\t\t\tif ( bone.parent ) {\r\n\r\n\t\t\t\tbone.matrix.getInverse( bone.parent.matrixWorld );\r\n\t\t\t\tbone.matrix.multiply( bone.matrixWorld );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tbone.matrix.copy( bone.matrixWorld );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tbone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.Skeleton.prototype.update = ( function () {\r\n\r\n\tvar offsetMatrix = new THREE.Matrix4();\r\n\t\r\n\treturn function () {\r\n\r\n\t\t// flatten bone matrices to array\r\n\r\n\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\r\n\r\n\t\t\t// compute the offset between the current and the original transform\r\n\r\n\t\t\tvar matrix = this.bones[ b ] ? this.bones[ b ].matrixWorld : this.identityMatrix;\r\n\r\n\t\t\toffsetMatrix.multiplyMatrices( matrix, this.boneInverses[ b ] );\r\n\t\t\toffsetMatrix.flattenToArrayOffset( this.boneMatrices, b * 16 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.useVertexTexture ) {\r\n\r\n\t\t\tthis.boneTexture.needsUpdate = true;\r\n\r\n\t\t}\r\n\t\t\r\n\t};\r\n\r\n} )();\r\n\r\n\r\n// File:src/objects/SkinnedMesh.js\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author ikerr / http://verold.com\r\n */\r\n\r\nTHREE.SkinnedMesh = function ( geometry, material, useVertexTexture ) {\r\n\r\n\tTHREE.Mesh.call( this, geometry, material );\r\n\r\n\tthis.type = 'SkinnedMesh';\r\n\r\n\tthis.bindMode = \"attached\";\r\n\tthis.bindMatrix = new THREE.Matrix4();\r\n\tthis.bindMatrixInverse = new THREE.Matrix4();\r\n\r\n\t// init bones\r\n\r\n\t// TODO: remove bone creation as there is no reason (other than\r\n\t// convenience) for THREE.SkinnedMesh to do this.\r\n\r\n\tvar bones = [];\r\n\r\n\tif ( this.geometry && this.geometry.bones !== undefined ) {\r\n\r\n\t\tvar bone, gbone, p, q, s;\r\n\r\n\t\tfor ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {\r\n\r\n\t\t\tgbone = this.geometry.bones[ b ];\r\n\r\n\t\t\tp = gbone.pos;\r\n\t\t\tq = gbone.rotq;\r\n\t\t\ts = gbone.scl;\r\n\r\n\t\t\tbone = new THREE.Bone( this );\r\n\t\t\tbones.push( bone );\r\n\r\n\t\t\tbone.name = gbone.name;\r\n\t\t\tbone.position.set( p[ 0 ], p[ 1 ], p[ 2 ] );\r\n\t\t\tbone.quaternion.set( q[ 0 ], q[ 1 ], q[ 2 ], q[ 3 ] );\r\n\r\n\t\t\tif ( s !== undefined ) {\r\n\r\n\t\t\t\tbone.scale.set( s[ 0 ], s[ 1 ], s[ 2 ] );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tbone.scale.set( 1, 1, 1 );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {\r\n\r\n\t\t\tgbone = this.geometry.bones[ b ];\r\n\r\n\t\t\tif ( gbone.parent !== - 1 ) {\r\n\r\n\t\t\t\tbones[ gbone.parent ].add( bones[ b ] );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis.add( bones[ b ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tthis.normalizeSkinWeights();\r\n\r\n\tthis.updateMatrixWorld( true );\r\n\tthis.bind( new THREE.Skeleton( bones, undefined, useVertexTexture ) );\r\n\r\n};\r\n\r\n\r\nTHREE.SkinnedMesh.prototype = Object.create( THREE.Mesh.prototype );\r\nTHREE.SkinnedMesh.prototype.constructor = THREE.SkinnedMesh;\r\n\r\nTHREE.SkinnedMesh.prototype.bind = function( skeleton, bindMatrix ) {\r\n\r\n\tthis.skeleton = skeleton;\r\n\r\n\tif ( bindMatrix === undefined ) {\r\n\r\n\t\tthis.updateMatrixWorld( true );\r\n\r\n\t\tbindMatrix = this.matrixWorld;\r\n\r\n\t}\r\n\r\n\tthis.bindMatrix.copy( bindMatrix );\r\n\tthis.bindMatrixInverse.getInverse( bindMatrix );\r\n\r\n};\r\n\r\nTHREE.SkinnedMesh.prototype.pose = function () {\r\n\r\n\tthis.skeleton.pose();\r\n\r\n};\r\n\r\nTHREE.SkinnedMesh.prototype.normalizeSkinWeights = function () {\r\n\r\n\tif ( this.geometry instanceof THREE.Geometry ) {\r\n\r\n\t\tfor ( var i = 0; i < this.geometry.skinIndices.length; i ++ ) {\r\n\r\n\t\t\tvar sw = this.geometry.skinWeights[ i ];\r\n\r\n\t\t\tvar scale = 1.0 / sw.lengthManhattan();\r\n\r\n\t\t\tif ( scale !== Infinity ) {\r\n\r\n\t\t\t\tsw.multiplyScalar( scale );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tsw.set( 1 ); // this will be normalized by the shader anyway\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t} else {\r\n\r\n\t\t// skinning weights assumed to be normalized for THREE.BufferGeometry\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.SkinnedMesh.prototype.updateMatrixWorld = function( force ) {\r\n\r\n\tTHREE.Mesh.prototype.updateMatrixWorld.call( this, true );\r\n\r\n\tif ( this.bindMode === \"attached\" ) {\r\n\r\n\t\tthis.bindMatrixInverse.getInverse( this.matrixWorld );\r\n\r\n\t} else if ( this.bindMode === \"detached\" ) {\r\n\r\n\t\tthis.bindMatrixInverse.getInverse( this.bindMatrix );\r\n\r\n\t} else {\r\n\r\n\t\tTHREE.warn( 'THREE.SkinnedMesh unreckognized bindMode: ' + this.bindMode );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.SkinnedMesh.prototype.clone = function( object ) {\r\n\r\n\tif ( object === undefined ) {\r\n\r\n\t\tobject = new THREE.SkinnedMesh( this.geometry, this.material, this.useVertexTexture );\r\n\r\n\t}\r\n\r\n\tTHREE.Mesh.prototype.clone.call( this, object );\r\n\r\n\treturn object;\r\n\r\n};\r\n\r\n\r\n// File:src/objects/MorphAnimMesh.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.MorphAnimMesh = function ( geometry, material ) {\r\n\r\n\tTHREE.Mesh.call( this, geometry, material );\r\n\r\n\tthis.type = 'MorphAnimMesh';\r\n\r\n\t// API\r\n\r\n\tthis.duration = 1000; // milliseconds\r\n\tthis.mirroredLoop = false;\r\n\tthis.time = 0;\r\n\r\n\t// internals\r\n\r\n\tthis.lastKeyframe = 0;\r\n\tthis.currentKeyframe = 0;\r\n\r\n\tthis.direction = 1;\r\n\tthis.directionBackwards = false;\r\n\r\n\tthis.setFrameRange( 0, this.geometry.morphTargets.length - 1 );\r\n\r\n};\r\n\r\nTHREE.MorphAnimMesh.prototype = Object.create( THREE.Mesh.prototype );\r\nTHREE.MorphAnimMesh.prototype.constructor = THREE.MorphAnimMesh;\r\n\r\nTHREE.MorphAnimMesh.prototype.setFrameRange = function ( start, end ) {\r\n\r\n\tthis.startKeyframe = start;\r\n\tthis.endKeyframe = end;\r\n\r\n\tthis.length = this.endKeyframe - this.startKeyframe + 1;\r\n\r\n};\r\n\r\nTHREE.MorphAnimMesh.prototype.setDirectionForward = function () {\r\n\r\n\tthis.direction = 1;\r\n\tthis.directionBackwards = false;\r\n\r\n};\r\n\r\nTHREE.MorphAnimMesh.prototype.setDirectionBackward = function () {\r\n\r\n\tthis.direction = - 1;\r\n\tthis.directionBackwards = true;\r\n\r\n};\r\n\r\nTHREE.MorphAnimMesh.prototype.parseAnimations = function () {\r\n\r\n\tvar geometry = this.geometry;\r\n\r\n\tif ( ! geometry.animations ) geometry.animations = {};\r\n\r\n\tvar firstAnimation, animations = geometry.animations;\r\n\r\n\tvar pattern = /([a-z]+)_?(\\d+)/;\r\n\r\n\tfor ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {\r\n\r\n\t\tvar morph = geometry.morphTargets[ i ];\r\n\t\tvar parts = morph.name.match( pattern );\r\n\r\n\t\tif ( parts && parts.length > 1 ) {\r\n\r\n\t\t\tvar label = parts[ 1 ];\r\n\r\n\t\t\tif ( ! animations[ label ] ) animations[ label ] = { start: Infinity, end: - Infinity };\r\n\r\n\t\t\tvar animation = animations[ label ];\r\n\r\n\t\t\tif ( i < animation.start ) animation.start = i;\r\n\t\t\tif ( i > animation.end ) animation.end = i;\r\n\r\n\t\t\tif ( ! firstAnimation ) firstAnimation = label;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tgeometry.firstAnimation = firstAnimation;\r\n\r\n};\r\n\r\nTHREE.MorphAnimMesh.prototype.setAnimationLabel = function ( label, start, end ) {\r\n\r\n\tif ( ! this.geometry.animations ) this.geometry.animations = {};\r\n\r\n\tthis.geometry.animations[ label ] = { start: start, end: end };\r\n\r\n};\r\n\r\nTHREE.MorphAnimMesh.prototype.playAnimation = function ( label, fps ) {\r\n\r\n\tvar animation = this.geometry.animations[ label ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\tthis.setFrameRange( animation.start, animation.end );\r\n\t\tthis.duration = 1000 * ( ( animation.end - animation.start ) / fps );\r\n\t\tthis.time = 0;\r\n\r\n\t} else {\r\n\r\n\t\tTHREE.warn( 'THREE.MorphAnimMesh: animation[' + label + '] undefined in .playAnimation()' );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.MorphAnimMesh.prototype.updateAnimation = function ( delta ) {\r\n\r\n\tvar frameTime = this.duration / this.length;\r\n\r\n\tthis.time += this.direction * delta;\r\n\r\n\tif ( this.mirroredLoop ) {\r\n\r\n\t\tif ( this.time > this.duration || this.time < 0 ) {\r\n\r\n\t\t\tthis.direction *= - 1;\r\n\r\n\t\t\tif ( this.time > this.duration ) {\r\n\r\n\t\t\t\tthis.time = this.duration;\r\n\t\t\t\tthis.directionBackwards = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( this.time < 0 ) {\r\n\r\n\t\t\t\tthis.time = 0;\r\n\t\t\t\tthis.directionBackwards = false;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t} else {\r\n\r\n\t\tthis.time = this.time % this.duration;\r\n\r\n\t\tif ( this.time < 0 ) this.time += this.duration;\r\n\r\n\t}\r\n\r\n\tvar keyframe = this.startKeyframe + THREE.Math.clamp( Math.floor( this.time / frameTime ), 0, this.length - 1 );\r\n\r\n\tif ( keyframe !== this.currentKeyframe ) {\r\n\r\n\t\tthis.morphTargetInfluences[ this.lastKeyframe ] = 0;\r\n\t\tthis.morphTargetInfluences[ this.currentKeyframe ] = 1;\r\n\r\n\t\tthis.morphTargetInfluences[ keyframe ] = 0;\r\n\r\n\t\tthis.lastKeyframe = this.currentKeyframe;\r\n\t\tthis.currentKeyframe = keyframe;\r\n\r\n\t}\r\n\r\n\tvar mix = ( this.time % frameTime ) / frameTime;\r\n\r\n\tif ( this.directionBackwards ) {\r\n\r\n\t\tmix = 1 - mix;\r\n\r\n\t}\r\n\r\n\tthis.morphTargetInfluences[ this.currentKeyframe ] = mix;\r\n\tthis.morphTargetInfluences[ this.lastKeyframe ] = 1 - mix;\r\n\r\n};\r\n\r\nTHREE.MorphAnimMesh.prototype.interpolateTargets = function ( a, b, t ) {\r\n\r\n\tvar influences = this.morphTargetInfluences;\r\n\r\n\tfor ( var i = 0, l = influences.length; i < l; i ++ ) {\r\n\r\n\t\tinfluences[ i ] = 0;\r\n\r\n\t}\r\n\r\n\tif ( a > -1 ) influences[ a ] = 1 - t;\r\n\tif ( b > -1 ) influences[ b ] = t;\r\n\r\n};\r\n\r\nTHREE.MorphAnimMesh.prototype.clone = function ( object ) {\r\n\r\n\tif ( object === undefined ) object = new THREE.MorphAnimMesh( this.geometry, this.material );\r\n\r\n\tobject.duration = this.duration;\r\n\tobject.mirroredLoop = this.mirroredLoop;\r\n\tobject.time = this.time;\r\n\r\n\tobject.lastKeyframe = this.lastKeyframe;\r\n\tobject.currentKeyframe = this.currentKeyframe;\r\n\r\n\tobject.direction = this.direction;\r\n\tobject.directionBackwards = this.directionBackwards;\r\n\r\n\tTHREE.Mesh.prototype.clone.call( this, object );\r\n\r\n\treturn object;\r\n\r\n};\r\n\r\n// File:src/objects/LOD.js\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.LOD = function () {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.objects = [];\r\n\r\n};\r\n\r\n\r\nTHREE.LOD.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.LOD.prototype.constructor = THREE.LOD;\r\n\r\nTHREE.LOD.prototype.addLevel = function ( object, distance ) {\r\n\r\n\tif ( distance === undefined ) distance = 0;\r\n\r\n\tdistance = Math.abs( distance );\r\n\r\n\tfor ( var l = 0; l < this.objects.length; l ++ ) {\r\n\r\n\t\tif ( distance < this.objects[ l ].distance ) {\r\n\r\n\t\t\tbreak;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tthis.objects.splice( l, 0, { distance: distance, object: object } );\r\n\tthis.add( object );\r\n\r\n};\r\n\r\nTHREE.LOD.prototype.getObjectForDistance = function ( distance ) {\r\n\r\n\tfor ( var i = 1, l = this.objects.length; i < l; i ++ ) {\r\n\r\n\t\tif ( distance < this.objects[ i ].distance ) {\r\n\r\n\t\t\tbreak;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn this.objects[ i - 1 ].object;\r\n\r\n};\r\n\r\nTHREE.LOD.prototype.raycast = ( function () {\r\n\r\n\tvar matrixPosition = new THREE.Vector3();\r\n\r\n\treturn function ( raycaster, intersects ) {\r\n\r\n\t\tmatrixPosition.setFromMatrixPosition( this.matrixWorld );\r\n\r\n\t\tvar distance = raycaster.ray.origin.distanceTo( matrixPosition );\r\n\r\n\t\tthis.getObjectForDistance( distance ).raycast( raycaster, intersects );\r\n\r\n\t};\r\n\r\n}() );\r\n\r\nTHREE.LOD.prototype.update = function () {\r\n\r\n\tvar v1 = new THREE.Vector3();\r\n\tvar v2 = new THREE.Vector3();\r\n\r\n\treturn function ( camera ) {\r\n\r\n\t\tif ( this.objects.length > 1 ) {\r\n\r\n\t\t\tv1.setFromMatrixPosition( camera.matrixWorld );\r\n\t\t\tv2.setFromMatrixPosition( this.matrixWorld );\r\n\r\n\t\t\tvar distance = v1.distanceTo( v2 );\r\n\r\n\t\t\tthis.objects[ 0 ].object.visible = true;\r\n\r\n\t\t\tfor ( var i = 1, l = this.objects.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tif ( distance >= this.objects[ i ].distance ) {\r\n\r\n\t\t\t\t\tthis.objects[ i - 1 ].object.visible = false;\r\n\t\t\t\t\tthis.objects[ i     ].object.visible = true;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( ; i < l; i ++ ) {\r\n\r\n\t\t\t\tthis.objects[ i ].object.visible = false;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n}();\r\n\r\nTHREE.LOD.prototype.clone = function ( object ) {\r\n\r\n\tif ( object === undefined ) object = new THREE.LOD();\r\n\r\n\tTHREE.Object3D.prototype.clone.call( this, object );\r\n\r\n\tfor ( var i = 0, l = this.objects.length; i < l; i ++ ) {\r\n\t\tvar x = this.objects[ i ].object.clone();\r\n\t\tx.visible = i === 0;\r\n\t\tobject.addLevel( x, this.objects[ i ].distance );\r\n\t}\r\n\r\n\treturn object;\r\n\r\n};\r\n\r\n// File:src/objects/Sprite.js\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Sprite = ( function () {\r\n\r\n\tvar indices = new Uint16Array( [ 0, 1, 2,  0, 2, 3 ] );\r\n\tvar vertices = new Float32Array( [ - 0.5, - 0.5, 0,   0.5, - 0.5, 0,   0.5, 0.5, 0,   - 0.5, 0.5, 0 ] );\r\n\tvar uvs = new Float32Array( [ 0, 0,   1, 0,   1, 1,   0, 1 ] );\r\n\r\n\tvar geometry = new THREE.BufferGeometry();\r\n\tgeometry.addAttribute( 'index', new THREE.BufferAttribute( indices, 1 ) );\r\n\tgeometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\r\n\tgeometry.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );\r\n\r\n\treturn function ( material ) {\r\n\r\n\t\tTHREE.Object3D.call( this );\r\n\r\n\t\tthis.type = 'Sprite';\r\n\r\n\t\tthis.geometry = geometry;\r\n\t\tthis.material = ( material !== undefined ) ? material : new THREE.SpriteMaterial();\r\n\r\n\t};\r\n\r\n} )();\r\n\r\nTHREE.Sprite.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.Sprite.prototype.constructor = THREE.Sprite;\r\n\r\nTHREE.Sprite.prototype.raycast = ( function () {\r\n\r\n\tvar matrixPosition = new THREE.Vector3();\r\n\r\n\treturn function ( raycaster, intersects ) {\r\n\r\n\t\tmatrixPosition.setFromMatrixPosition( this.matrixWorld );\r\n\r\n\t\tvar distance = raycaster.ray.distanceToPoint( matrixPosition );\r\n\r\n\t\tif ( distance > this.scale.x ) {\r\n\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tintersects.push( {\r\n\r\n\t\t\tdistance: distance,\r\n\t\t\tpoint: this.position,\r\n\t\t\tface: null,\r\n\t\t\tobject: this\r\n\r\n\t\t} );\r\n\r\n\t};\r\n\r\n}() );\r\n\r\nTHREE.Sprite.prototype.clone = function ( object ) {\r\n\r\n\tif ( object === undefined ) object = new THREE.Sprite( this.material );\r\n\r\n\tTHREE.Object3D.prototype.clone.call( this, object );\r\n\r\n\treturn object;\r\n\r\n};\r\n\r\n// Backwards compatibility\r\n\r\nTHREE.Particle = THREE.Sprite;\r\n\r\n// File:src/objects/LensFlare.js\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.LensFlare = function ( texture, size, distance, blending, color ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.lensFlares = [];\r\n\r\n\tthis.positionScreen = new THREE.Vector3();\r\n\tthis.customUpdateCallback = undefined;\r\n\r\n\tif ( texture !== undefined ) {\r\n\r\n\t\tthis.add( texture, size, distance, blending, color );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.LensFlare.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.LensFlare.prototype.constructor = THREE.LensFlare;\r\n\r\n\r\n/*\r\n * Add: adds another flare\r\n */\r\n\r\nTHREE.LensFlare.prototype.add = function ( texture, size, distance, blending, color, opacity ) {\r\n\r\n\tif ( size === undefined ) size = - 1;\r\n\tif ( distance === undefined ) distance = 0;\r\n\tif ( opacity === undefined ) opacity = 1;\r\n\tif ( color === undefined ) color = new THREE.Color( 0xffffff );\r\n\tif ( blending === undefined ) blending = THREE.NormalBlending;\r\n\r\n\tdistance = Math.min( distance, Math.max( 0, distance ) );\r\n\r\n\tthis.lensFlares.push( {\r\n\t\ttexture: texture, \t\t\t// THREE.Texture\r\n\t\tsize: size, \t\t\t\t// size in pixels (-1 = use texture.width)\r\n\t\tdistance: distance, \t\t// distance (0-1) from light source (0=at light source)\r\n\t\tx: 0, y: 0, z: 0,\t\t\t// screen position (-1 => 1) z = 0 is ontop z = 1 is back\r\n\t\tscale: 1, \t\t\t\t\t// scale\r\n\t\trotation: 1, \t\t\t\t// rotation\r\n\t\topacity: opacity,\t\t\t// opacity\r\n\t\tcolor: color,\t\t\t\t// color\r\n\t\tblending: blending\t\t\t// blending\r\n\t} );\r\n\r\n};\r\n\r\n/*\r\n * Update lens flares update positions on all flares based on the screen position\r\n * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.\r\n */\r\n\r\nTHREE.LensFlare.prototype.updateLensFlares = function () {\r\n\r\n\tvar f, fl = this.lensFlares.length;\r\n\tvar flare;\r\n\tvar vecX = - this.positionScreen.x * 2;\r\n\tvar vecY = - this.positionScreen.y * 2;\r\n\r\n\tfor ( f = 0; f < fl; f ++ ) {\r\n\r\n\t\tflare = this.lensFlares[ f ];\r\n\r\n\t\tflare.x = this.positionScreen.x + vecX * flare.distance;\r\n\t\tflare.y = this.positionScreen.y + vecY * flare.distance;\r\n\r\n\t\tflare.wantedRotation = flare.x * Math.PI * 0.25;\r\n\t\tflare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;\r\n\r\n\t}\r\n\r\n};\r\n\r\n\r\n// File:src/scenes/Scene.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Scene = function () {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.type = 'Scene';\r\n\r\n\tthis.fog = null;\r\n\tthis.overrideMaterial = null;\r\n\r\n\tthis.autoUpdate = true; // checked by the renderer\r\n\r\n};\r\n\r\nTHREE.Scene.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.Scene.prototype.constructor = THREE.Scene;\r\n\r\nTHREE.Scene.prototype.clone = function ( object ) {\r\n\r\n\tif ( object === undefined ) object = new THREE.Scene();\r\n\r\n\tTHREE.Object3D.prototype.clone.call( this, object );\r\n\r\n\tif ( this.fog !== null ) object.fog = this.fog.clone();\r\n\tif ( this.overrideMaterial !== null ) object.overrideMaterial = this.overrideMaterial.clone();\r\n\r\n\tobject.autoUpdate = this.autoUpdate;\r\n\tobject.matrixAutoUpdate = this.matrixAutoUpdate;\r\n\r\n\treturn object;\r\n\r\n};\r\n\r\n// File:src/scenes/Fog.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Fog = function ( color, near, far ) {\r\n\r\n\tthis.name = '';\r\n\r\n\tthis.color = new THREE.Color( color );\r\n\r\n\tthis.near = ( near !== undefined ) ? near : 1;\r\n\tthis.far = ( far !== undefined ) ? far : 1000;\r\n\r\n};\r\n\r\nTHREE.Fog.prototype.clone = function () {\r\n\r\n\treturn new THREE.Fog( this.color.getHex(), this.near, this.far );\r\n\r\n};\r\n\r\n// File:src/scenes/FogExp2.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.FogExp2 = function ( color, density ) {\r\n\r\n\tthis.name = '';\r\n\r\n\tthis.color = new THREE.Color( color );\r\n\tthis.density = ( density !== undefined ) ? density : 0.00025;\r\n\r\n};\r\n\r\nTHREE.FogExp2.prototype.clone = function () {\r\n\r\n\treturn new THREE.FogExp2( this.color.getHex(), this.density );\r\n\r\n};\r\n\r\n// File:src/renderers/shaders/ShaderChunk.js\r\n\r\nTHREE.ShaderChunk = {};\r\n\r\n// File:src/renderers/shaders/ShaderChunk/common.glsl\r\n\r\nTHREE.ShaderChunk[ 'common'] = \"#define PI 3.14159\\n#define PI2 6.28318\\n#define RECIPROCAL_PI2 0.15915494\\n#define LOG2 1.442695\\n#define EPSILON 1e-6\\n\\nfloat square( in float a ) { return a*a; }\\nvec2  square( in vec2 a )  { return vec2( a.x*a.x, a.y*a.y ); }\\nvec3  square( in vec3 a )  { return vec3( a.x*a.x, a.y*a.y, a.z*a.z ); }\\nvec4  square( in vec4 a )  { return vec4( a.x*a.x, a.y*a.y, a.z*a.z, a.w*a.w ); }\\nfloat saturate( in float a ) { return clamp( a, 0.0, 1.0 ); }\\nvec2  saturate( in vec2 a )  { return clamp( a, 0.0, 1.0 ); }\\nvec3  saturate( in vec3 a )  { return clamp( a, 0.0, 1.0 ); }\\nvec4  saturate( in vec4 a )  { return clamp( a, 0.0, 1.0 ); }\\nfloat average( in float a ) { return a; }\\nfloat average( in vec2 a )  { return ( a.x + a.y) * 0.5; }\\nfloat average( in vec3 a )  { return ( a.x + a.y + a.z) / 3.0; }\\nfloat average( in vec4 a )  { return ( a.x + a.y + a.z + a.w) * 0.25; }\\nfloat whiteCompliment( in float a ) { return saturate( 1.0 - a ); }\\nvec2  whiteCompliment( in vec2 a )  { return saturate( vec2(1.0) - a ); }\\nvec3  whiteCompliment( in vec3 a )  { return saturate( vec3(1.0) - a ); }\\nvec4  whiteCompliment( in vec4 a )  { return saturate( vec4(1.0) - a ); }\\nvec3 transformDirection( in vec3 normal, in mat4 matrix ) {\\n\treturn normalize( ( matrix * vec4( normal, 0.0 ) ).xyz );\\n}\\n// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations\\nvec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {\\n\treturn normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );\\n}\\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal) {\\n\tfloat distance = dot( planeNormal, point-pointOnPlane );\\n\treturn point - distance * planeNormal;\\n}\\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\\n}\\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\treturn pointOnLine + lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) );\\n}\\nfloat calcLightAttenuation( float lightDistance, float cutoffDistance, float decayExponent ) {\\n\tif ( decayExponent > 0.0 ) {\\n\t  return pow( saturate( 1.0 - lightDistance / cutoffDistance ), decayExponent );\\n\t}\\n\treturn 1.0;\\n}\\n\\nvec3 inputToLinear( in vec3 a ) {\\n#ifdef GAMMA_INPUT\\n\treturn pow( a, vec3( float( GAMMA_FACTOR ) ) );\\n#else\\n\treturn a;\\n#endif\\n}\\nvec3 linearToOutput( in vec3 a ) {\\n#ifdef GAMMA_OUTPUT\\n\treturn pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );\\n#else\\n\treturn a;\\n#endif\\n}\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/alphatest_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'alphatest_fragment'] = \"#ifdef ALPHATEST\\n\\n\tif ( diffuseColor.a < ALPHATEST ) discard;\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/lights_lambert_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'lights_lambert_vertex'] = \"vLightFront = vec3( 0.0 );\\n\\n#ifdef DOUBLE_SIDED\\n\\n\tvLightBack = vec3( 0.0 );\\n\\n#endif\\n\\ntransformedNormal = normalize( transformedNormal );\\n\\n#if MAX_DIR_LIGHTS > 0\\n\\nfor( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\\n\\n\tvec3 dirVector = transformDirection( directionalLightDirection[ i ], viewMatrix );\\n\\n\tfloat dotProduct = dot( transformedNormal, dirVector );\\n\tvec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );\\n\\n\t#ifdef DOUBLE_SIDED\\n\\n\t\tvec3 directionalLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\\n\\n\t\t#ifdef WRAP_AROUND\\n\\n\t\t\tvec3 directionalLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\\n\\n\t\t#endif\\n\\n\t#endif\\n\\n\t#ifdef WRAP_AROUND\\n\\n\t\tvec3 directionalLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\\n\t\tdirectionalLightWeighting = mix( directionalLightWeighting, directionalLightWeightingHalf, wrapRGB );\\n\\n\t\t#ifdef DOUBLE_SIDED\\n\\n\t\t\tdirectionalLightWeightingBack = mix( directionalLightWeightingBack, directionalLightWeightingHalfBack, wrapRGB );\\n\\n\t\t#endif\\n\\n\t#endif\\n\\n\tvLightFront += directionalLightColor[ i ] * directionalLightWeighting;\\n\\n\t#ifdef DOUBLE_SIDED\\n\\n\t\tvLightBack += directionalLightColor[ i ] * directionalLightWeightingBack;\\n\\n\t#endif\\n\\n}\\n\\n#endif\\n\\n#if MAX_POINT_LIGHTS > 0\\n\\n\tfor( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\\n\\n\t\tvec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\\n\t\tvec3 lVector = lPosition.xyz - mvPosition.xyz;\\n\\n\t\tfloat attenuation = calcLightAttenuation( length( lVector ), pointLightDistance[ i ], pointLightDecay[ i ] );\\n\\n\t\tlVector = normalize( lVector );\\n\t\tfloat dotProduct = dot( transformedNormal, lVector );\\n\\n\t\tvec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );\\n\\n\t\t#ifdef DOUBLE_SIDED\\n\\n\t\t\tvec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\\n\\n\t\t\t#ifdef WRAP_AROUND\\n\\n\t\t\t\tvec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\\n\\n\t\t\t#endif\\n\\n\t\t#endif\\n\\n\t\t#ifdef WRAP_AROUND\\n\\n\t\t\tvec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\\n\t\t\tpointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );\\n\\n\t\t\t#ifdef DOUBLE_SIDED\\n\\n\t\t\t\tpointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );\\n\\n\t\t\t#endif\\n\\n\t\t#endif\\n\\n\t\tvLightFront += pointLightColor[ i ] * pointLightWeighting * attenuation;\\n\\n\t\t#ifdef DOUBLE_SIDED\\n\\n\t\t\tvLightBack += pointLightColor[ i ] * pointLightWeightingBack * attenuation;\\n\\n\t\t#endif\\n\\n\t}\\n\\n#endif\\n\\n#if MAX_SPOT_LIGHTS > 0\\n\\n\tfor( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\\n\\n\t\tvec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\\n\t\tvec3 lVector = lPosition.xyz - mvPosition.xyz;\\n\\n\t\tfloat spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - worldPosition.xyz ) );\\n\\n\t\tif ( spotEffect > spotLightAngleCos[ i ] ) {\\n\\n\t\t\tspotEffect = max( pow( max( spotEffect, 0.0 ), spotLightExponent[ i ] ), 0.0 );\\n\\n\t\t\tfloat attenuation = calcLightAttenuation( length( lVector ), spotLightDistance[ i ], spotLightDecay[ i ] );\\n\\n\t\t\tlVector = normalize( lVector );\\n\\n\t\t\tfloat dotProduct = dot( transformedNormal, lVector );\\n\t\t\tvec3 spotLightWeighting = vec3( max( dotProduct, 0.0 ) );\\n\\n\t\t\t#ifdef DOUBLE_SIDED\\n\\n\t\t\t\tvec3 spotLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\\n\\n\t\t\t\t#ifdef WRAP_AROUND\\n\\n\t\t\t\t\tvec3 spotLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\\n\\n\t\t\t\t#endif\\n\\n\t\t\t#endif\\n\\n\t\t\t#ifdef WRAP_AROUND\\n\\n\t\t\t\tvec3 spotLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\\n\t\t\t\tspotLightWeighting = mix( spotLightWeighting, spotLightWeightingHalf, wrapRGB );\\n\\n\t\t\t\t#ifdef DOUBLE_SIDED\\n\\n\t\t\t\t\tspotLightWeightingBack = mix( spotLightWeightingBack, spotLightWeightingHalfBack, wrapRGB );\\n\\n\t\t\t\t#endif\\n\\n\t\t\t#endif\\n\\n\t\t\tvLightFront += spotLightColor[ i ] * spotLightWeighting * attenuation * spotEffect;\\n\\n\t\t\t#ifdef DOUBLE_SIDED\\n\\n\t\t\t\tvLightBack += spotLightColor[ i ] * spotLightWeightingBack * attenuation * spotEffect;\\n\\n\t\t\t#endif\\n\\n\t\t}\\n\\n\t}\\n\\n#endif\\n\\n#if MAX_HEMI_LIGHTS > 0\\n\\n\tfor( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\\n\\n\t\tvec3 lVector = transformDirection( hemisphereLightDirection[ i ], viewMatrix );\\n\\n\t\tfloat dotProduct = dot( transformedNormal, lVector );\\n\\n\t\tfloat hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\\n\t\tfloat hemiDiffuseWeightBack = -0.5 * dotProduct + 0.5;\\n\\n\t\tvLightFront += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\\n\\n\t\t#ifdef DOUBLE_SIDED\\n\\n\t\t\tvLightBack += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeightBack );\\n\\n\t\t#endif\\n\\n\t}\\n\\n#endif\\n\\nvLightFront += ambientLightColor;\\n\\n#ifdef DOUBLE_SIDED\\n\\n\tvLightBack += ambientLightColor;\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/map_particle_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'map_particle_pars_fragment'] = \"#ifdef USE_MAP\\n\\n\tuniform vec4 offsetRepeat;\\n\tuniform sampler2D map;\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/default_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'default_vertex'] = \"#ifdef USE_SKINNING\\n\\n\tvec4 mvPosition = modelViewMatrix * skinned;\\n\\n#elif defined( USE_MORPHTARGETS )\\n\\n\tvec4 mvPosition = modelViewMatrix * vec4( morphed, 1.0 );\\n\\n#else\\n\\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\\n\\n#endif\\n\\ngl_Position = projectionMatrix * mvPosition;\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/map_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'map_pars_fragment'] = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\\n\\n\tvarying vec2 vUv;\\n\\n#endif\\n\\n#ifdef USE_MAP\\n\\n\tuniform sampler2D map;\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/skinnormal_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'skinnormal_vertex'] = \"#ifdef USE_SKINNING\\n\\n\tmat4 skinMatrix = mat4( 0.0 );\\n\tskinMatrix += skinWeight.x * boneMatX;\\n\tskinMatrix += skinWeight.y * boneMatY;\\n\tskinMatrix += skinWeight.z * boneMatZ;\\n\tskinMatrix += skinWeight.w * boneMatW;\\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\\n\\n\t#ifdef USE_MORPHNORMALS\\n\\n\tvec4 skinnedNormal = skinMatrix * vec4( morphedNormal, 0.0 );\\n\\n\t#else\\n\\n\tvec4 skinnedNormal = skinMatrix * vec4( normal, 0.0 );\\n\\n\t#endif\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'logdepthbuf_pars_vertex'] = \"#ifdef USE_LOGDEPTHBUF\\n\\n\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\n\t\tvarying float vFragDepth;\\n\\n\t#endif\\n\\n\tuniform float logDepthBufFC;\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/lightmap_pars_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'lightmap_pars_vertex'] = \"#ifdef USE_LIGHTMAP\\n\\n\tvarying vec2 vUv2;\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/lights_phong_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'lights_phong_fragment'] = \"#ifndef FLAT_SHADED\\n\\n\tvec3 normal = normalize( vNormal );\\n\\n\t#ifdef DOUBLE_SIDED\\n\\n\t\tnormal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\\n\\n\t#endif\\n\\n#else\\n\\n\tvec3 fdx = dFdx( vViewPosition );\\n\tvec3 fdy = dFdy( vViewPosition );\\n\tvec3 normal = normalize( cross( fdx, fdy ) );\\n\\n#endif\\n\\nvec3 viewPosition = normalize( vViewPosition );\\n\\n#ifdef USE_NORMALMAP\\n\\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\\n\\n#elif defined( USE_BUMPMAP )\\n\\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\\n\\n#endif\\n\\nvec3 totalDiffuseLight = vec3( 0.0 );\\nvec3 totalSpecularLight = vec3( 0.0 );\\n\\n#if MAX_POINT_LIGHTS > 0\\n\\n\tfor ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\\n\\n\t\tvec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\\n\t\tvec3 lVector = lPosition.xyz + vViewPosition.xyz;\\n\\n\t\tfloat attenuation = calcLightAttenuation( length( lVector ), pointLightDistance[ i ], pointLightDecay[ i ] );\\n\\n\t\tlVector = normalize( lVector );\\n\\n\t\t// diffuse\\n\\n\t\tfloat dotProduct = dot( normal, lVector );\\n\\n\t\t#ifdef WRAP_AROUND\\n\\n\t\t\tfloat pointDiffuseWeightFull = max( dotProduct, 0.0 );\\n\t\t\tfloat pointDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\\n\\n\t\t\tvec3 pointDiffuseWeight = mix( vec3( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );\\n\\n\t\t#else\\n\\n\t\t\tfloat pointDiffuseWeight = max( dotProduct, 0.0 );\\n\\n\t\t#endif\\n\\n\t\ttotalDiffuseLight += pointLightColor[ i ] * pointDiffuseWeight * attenuation;\\n\\n\t\t\t\t// specular\\n\\n\t\tvec3 pointHalfVector = normalize( lVector + viewPosition );\\n\t\tfloat pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\\n\t\tfloat pointSpecularWeight = specularStrength * max( pow( pointDotNormalHalf, shininess ), 0.0 );\\n\\n\t\tfloat specularNormalization = ( shininess + 2.0 ) / 8.0;\\n\\n\t\tvec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, pointHalfVector ), 0.0 ), 5.0 );\\n\t\ttotalSpecularLight += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * attenuation * specularNormalization;\\n\\n\t}\\n\\n#endif\\n\\n#if MAX_SPOT_LIGHTS > 0\\n\\n\tfor ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\\n\\n\t\tvec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\\n\t\tvec3 lVector = lPosition.xyz + vViewPosition.xyz;\\n\\n\t\tfloat attenuation = calcLightAttenuation( length( lVector ), spotLightDistance[ i ], spotLightDecay[ i ] );\\n\\n\t\tlVector = normalize( lVector );\\n\\n\t\tfloat spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );\\n\\n\t\tif ( spotEffect > spotLightAngleCos[ i ] ) {\\n\\n\t\t\tspotEffect = max( pow( max( spotEffect, 0.0 ), spotLightExponent[ i ] ), 0.0 );\\n\\n\t\t\t// diffuse\\n\\n\t\t\tfloat dotProduct = dot( normal, lVector );\\n\\n\t\t\t#ifdef WRAP_AROUND\\n\\n\t\t\t\tfloat spotDiffuseWeightFull = max( dotProduct, 0.0 );\\n\t\t\t\tfloat spotDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\\n\\n\t\t\t\tvec3 spotDiffuseWeight = mix( vec3( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );\\n\\n\t\t\t#else\\n\\n\t\t\t\tfloat spotDiffuseWeight = max( dotProduct, 0.0 );\\n\\n\t\t\t#endif\\n\\n\t\t\ttotalDiffuseLight += spotLightColor[ i ] * spotDiffuseWeight * attenuation * spotEffect;\\n\\n\t\t\t// specular\\n\\n\t\t\tvec3 spotHalfVector = normalize( lVector + viewPosition );\\n\t\t\tfloat spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );\\n\t\t\tfloat spotSpecularWeight = specularStrength * max( pow( spotDotNormalHalf, shininess ), 0.0 );\\n\\n\t\t\tfloat specularNormalization = ( shininess + 2.0 ) / 8.0;\\n\\n\t\t\tvec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, spotHalfVector ), 0.0 ), 5.0 );\\n\t\t\ttotalSpecularLight += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * attenuation * specularNormalization * spotEffect;\\n\\n\t\t}\\n\\n\t}\\n\\n#endif\\n\\n#if MAX_DIR_LIGHTS > 0\\n\\n\tfor( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\\n\\n\t\tvec3 dirVector = transformDirection( directionalLightDirection[ i ], viewMatrix );\\n\\n\t\t// diffuse\\n\\n\t\tfloat dotProduct = dot( normal, dirVector );\\n\\n\t\t#ifdef WRAP_AROUND\\n\\n\t\t\tfloat dirDiffuseWeightFull = max( dotProduct, 0.0 );\\n\t\t\tfloat dirDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\\n\\n\t\t\tvec3 dirDiffuseWeight = mix( vec3( dirDiffuseWeightFull ), vec3( dirDiffuseWeightHalf ), wrapRGB );\\n\\n\t\t#else\\n\\n\t\t\tfloat dirDiffuseWeight = max( dotProduct, 0.0 );\\n\\n\t\t#endif\\n\\n\t\ttotalDiffuseLight += directionalLightColor[ i ] * dirDiffuseWeight;\\n\\n\t\t// specular\\n\\n\t\tvec3 dirHalfVector = normalize( dirVector + viewPosition );\\n\t\tfloat dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\\n\t\tfloat dirSpecularWeight = specularStrength * max( pow( dirDotNormalHalf, shininess ), 0.0 );\\n\\n\t\t/*\\n\t\t// fresnel term from skin shader\\n\t\tconst float F0 = 0.128;\\n\\n\t\tfloat base = 1.0 - dot( viewPosition, dirHalfVector );\\n\t\tfloat exponential = pow( base, 5.0 );\\n\\n\t\tfloat fresnel = exponential + F0 * ( 1.0 - exponential );\\n\t\t*/\\n\\n\t\t/*\\n\t\t// fresnel term from fresnel shader\\n\t\tconst float mFresnelBias = 0.08;\\n\t\tconst float mFresnelScale = 0.3;\\n\t\tconst float mFresnelPower = 5.0;\\n\\n\t\tfloat fresnel = mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( -viewPosition ), normal ), mFresnelPower );\\n\t\t*/\\n\\n\t\tfloat specularNormalization = ( shininess + 2.0 ) / 8.0;\\n\\n\t\t// \t\tdirSpecular += specular * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization * fresnel;\\n\\n\t\tvec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( dirVector, dirHalfVector ), 0.0 ), 5.0 );\\n\t\ttotalSpecularLight += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\\n\\n\\n\t}\\n\\n#endif\\n\\n#if MAX_HEMI_LIGHTS > 0\\n\\n\tfor( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\\n\\n\t\tvec3 lVector = transformDirection( hemisphereLightDirection[ i ], viewMatrix );\\n\\n\t\t// diffuse\\n\\n\t\tfloat dotProduct = dot( normal, lVector );\\n\t\tfloat hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\\n\\n\t\tvec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\\n\\n\t\ttotalDiffuseLight += hemiColor;\\n\\n\t\t// specular (sky light)\\n\\n\t\tvec3 hemiHalfVectorSky = normalize( lVector + viewPosition );\\n\t\tfloat hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;\\n\t\tfloat hemiSpecularWeightSky = specularStrength * max( pow( max( hemiDotNormalHalfSky, 0.0 ), shininess ), 0.0 );\\n\\n\t\t// specular (ground light)\\n\\n\t\tvec3 lVectorGround = -lVector;\\n\\n\t\tvec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );\\n\t\tfloat hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;\\n\t\tfloat hemiSpecularWeightGround = specularStrength * max( pow( max( hemiDotNormalHalfGround, 0.0 ), shininess ), 0.0 );\\n\\n\t\tfloat dotProductGround = dot( normal, lVectorGround );\\n\\n\t\tfloat specularNormalization = ( shininess + 2.0 ) / 8.0;\\n\\n\t\tvec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, hemiHalfVectorSky ), 0.0 ), 5.0 );\\n\t\tvec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 0.0 ), 5.0 );\\n\t\ttotalSpecularLight += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );\\n\\n\t}\\n\\n#endif\\n\\n#ifdef METAL\\n\\n\toutgoingLight += diffuseColor.rgb * ( totalDiffuseLight + ambientLightColor ) * specular + totalSpecularLight + emissive;\\n\\n#else\\n\\n\toutgoingLight += diffuseColor.rgb * ( totalDiffuseLight + ambientLightColor ) + totalSpecularLight + emissive;\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/fog_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'fog_pars_fragment'] = \"#ifdef USE_FOG\\n\\n\tuniform vec3 fogColor;\\n\\n\t#ifdef FOG_EXP2\\n\\n\t\tuniform float fogDensity;\\n\\n\t#else\\n\\n\t\tuniform float fogNear;\\n\t\tuniform float fogFar;\\n\t#endif\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/morphnormal_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'morphnormal_vertex'] = \"#ifdef USE_MORPHNORMALS\\n\\n\tvec3 morphedNormal = vec3( 0.0 );\\n\\n\tmorphedNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\\n\tmorphedNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\\n\tmorphedNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\\n\tmorphedNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\\n\\n\tmorphedNormal += normal;\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/envmap_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'envmap_pars_fragment'] = \"#ifdef USE_ENVMAP\\n\\n\tuniform float reflectivity;\\n\t#ifdef ENVMAP_TYPE_CUBE\\n\t\tuniform samplerCube envMap;\\n\t#else\\n\t\tuniform sampler2D envMap;\\n\t#endif\\n\tuniform float flipEnvMap;\\n\\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\\n\t\tuniform float refractionRatio;\\n\\n\t#else\\n\\n\t\tvarying vec3 vReflect;\\n\\n\t#endif\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/logdepthbuf_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'logdepthbuf_fragment'] = \"#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\\n\\n\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/normalmap_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'normalmap_pars_fragment'] = \"#ifdef USE_NORMALMAP\\n\\n\tuniform sampler2D normalMap;\\n\tuniform vec2 normalScale;\\n\\n\t// Per-Pixel Tangent Space Normal Mapping\\n\t// http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\\n\\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\\n\\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\\n\t\tvec2 st0 = dFdx( vUv.st );\\n\t\tvec2 st1 = dFdy( vUv.st );\\n\\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\\n\t\tvec3 N = normalize( surf_norm );\\n\\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\\n\t\tmapN.xy = normalScale * mapN.xy;\\n\t\tmat3 tsn = mat3( S, T, N );\\n\t\treturn normalize( tsn * mapN );\\n\\n\t}\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/lights_phong_pars_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'lights_phong_pars_vertex'] = \"#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\\n\\n\tvarying vec3 vWorldPosition;\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/lightmap_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'lightmap_pars_fragment'] = \"#ifdef USE_LIGHTMAP\\n\\n\tvarying vec2 vUv2;\\n\tuniform sampler2D lightMap;\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/shadowmap_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'shadowmap_vertex'] = \"#ifdef USE_SHADOWMAP\\n\\n\tfor( int i = 0; i < MAX_SHADOWS; i ++ ) {\\n\\n\t\tvShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\\n\\n\t}\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/lights_phong_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'lights_phong_vertex'] = \"#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\\n\\n\tvWorldPosition = worldPosition.xyz;\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/map_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'map_fragment'] = \"#ifdef USE_MAP\\n\\n\tvec4 texelColor = texture2D( map, vUv );\\n\\n\ttexelColor.xyz = inputToLinear( texelColor.xyz );\\n\\n\tdiffuseColor *= texelColor;\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/lightmap_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'lightmap_vertex'] = \"#ifdef USE_LIGHTMAP\\n\\n\tvUv2 = uv2;\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/map_particle_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'map_particle_fragment'] = \"#ifdef USE_MAP\\n\\n\tdiffuseColor *= texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/color_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'color_pars_fragment'] = \"#ifdef USE_COLOR\\n\\n\tvarying vec3 vColor;\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/color_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'color_vertex'] = \"#ifdef USE_COLOR\\n\\n\tvColor.xyz = inputToLinear( color.xyz );\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/skinning_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'skinning_vertex'] = \"#ifdef USE_SKINNING\\n\\n\t#ifdef USE_MORPHTARGETS\\n\\n\tvec4 skinVertex = bindMatrix * vec4( morphed, 1.0 );\\n\\n\t#else\\n\\n\tvec4 skinVertex = bindMatrix * vec4( position, 1.0 );\\n\\n\t#endif\\n\\n\tvec4 skinned = vec4( 0.0 );\\n\tskinned += boneMatX * skinVertex * skinWeight.x;\\n\tskinned += boneMatY * skinVertex * skinWeight.y;\\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\\n\tskinned += boneMatW * skinVertex * skinWeight.w;\\n\tskinned  = bindMatrixInverse * skinned;\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/envmap_pars_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'envmap_pars_vertex'] = \"#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\\n\\n\tvarying vec3 vReflect;\\n\\n\tuniform float refractionRatio;\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/linear_to_gamma_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'linear_to_gamma_fragment'] = \"\\n\toutgoingLight = linearToOutput( outgoingLight );\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/color_pars_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'color_pars_vertex'] = \"#ifdef USE_COLOR\\n\\n\tvarying vec3 vColor;\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/lights_lambert_pars_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'lights_lambert_pars_vertex'] = \"uniform vec3 ambientLightColor;\\n\\n#if MAX_DIR_LIGHTS > 0\\n\\n\tuniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\\n\tuniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\\n\\n#endif\\n\\n#if MAX_HEMI_LIGHTS > 0\\n\\n\tuniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\\n\tuniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\\n\tuniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\\n\\n#endif\\n\\n#if MAX_POINT_LIGHTS > 0\\n\\n\tuniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\\n\tuniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\\n\tuniform float pointLightDistance[ MAX_POINT_LIGHTS ];\\n\tuniform float pointLightDecay[ MAX_POINT_LIGHTS ];\\n\\n#endif\\n\\n#if MAX_SPOT_LIGHTS > 0\\n\\n\tuniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\\n\tuniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\\n\tuniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\\n\tuniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\\n\tuniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\\n\tuniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\\n\tuniform float spotLightDecay[ MAX_SPOT_LIGHTS ];\\n\\n#endif\\n\\n#ifdef WRAP_AROUND\\n\\n\tuniform vec3 wrapRGB;\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/map_pars_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'map_pars_vertex'] = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\\n\\n\tvarying vec2 vUv;\\n\tuniform vec4 offsetRepeat;\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/envmap_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'envmap_fragment'] = \"#ifdef USE_ENVMAP\\n\\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\\n\\n\t\t// Transforming Normal Vectors with the Inverse Transformation\\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\\n\\n\t\t#ifdef ENVMAP_MODE_REFLECTION\\n\\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\\n\\n\t\t#else\\n\\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\\n\\n\t\t#endif\\n\\n\t#else\\n\\n\t\tvec3 reflectVec = vReflect;\\n\\n\t#endif\\n\\n\t#ifdef DOUBLE_SIDED\\n\t\tfloat flipNormal = ( -1.0 + 2.0 * float( gl_FrontFacing ) );\\n\t#else\\n\t\tfloat flipNormal = 1.0;\\n\t#endif\\n\\n\t#ifdef ENVMAP_TYPE_CUBE\\n\t\tvec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\\n\\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\\n\t\tvec2 sampleUV;\\n\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\\n\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\\n\\n\t#elif defined( ENVMAP_TYPE_SPHERE )\\n\t\tvec3 reflectView = flipNormal * normalize((viewMatrix * vec4( reflectVec, 0.0 )).xyz + vec3(0.0,0.0,1.0));\\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\\n\t#endif\\n\\n\tenvColor.xyz = inputToLinear( envColor.xyz );\\n\\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\\n\\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\\n\\n\t#elif defined( ENVMAP_BLENDING_MIX )\\n\\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\\n\\n\t#elif defined( ENVMAP_BLENDING_ADD )\\n\\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\\n\\n\t#endif\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/specularmap_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'specularmap_pars_fragment'] = \"#ifdef USE_SPECULARMAP\\n\\n\tuniform sampler2D specularMap;\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/logdepthbuf_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'logdepthbuf_vertex'] = \"#ifdef USE_LOGDEPTHBUF\\n\\n\tgl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\\n\\n\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\n\t\tvFragDepth = 1.0 + gl_Position.w;\\n\\n#else\\n\\n\t\tgl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\\n\\n\t#endif\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/morphtarget_pars_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'morphtarget_pars_vertex'] = \"#ifdef USE_MORPHTARGETS\\n\\n\t#ifndef USE_MORPHNORMALS\\n\\n\tuniform float morphTargetInfluences[ 8 ];\\n\\n\t#else\\n\\n\tuniform float morphTargetInfluences[ 4 ];\\n\\n\t#endif\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/specularmap_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'specularmap_fragment'] = \"float specularStrength;\\n\\n#ifdef USE_SPECULARMAP\\n\\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\\n\tspecularStrength = texelSpecular.r;\\n\\n#else\\n\\n\tspecularStrength = 1.0;\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/fog_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'fog_fragment'] = \"#ifdef USE_FOG\\n\\n\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\n\t\tfloat depth = gl_FragDepthEXT / gl_FragCoord.w;\\n\\n\t#else\\n\\n\t\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\\n\\n\t#endif\\n\\n\t#ifdef FOG_EXP2\\n\\n\t\tfloat fogFactor = exp2( - square( fogDensity ) * square( depth ) * LOG2 );\\n\t\tfogFactor = whiteCompliment( fogFactor );\\n\\n\t#else\\n\\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, depth );\\n\\n\t#endif\\n\t\\n\toutgoingLight = mix( outgoingLight, fogColor, fogFactor );\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/bumpmap_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'bumpmap_pars_fragment'] = \"#ifdef USE_BUMPMAP\\n\\n\tuniform sampler2D bumpMap;\\n\tuniform float bumpScale;\\n\\n\t// Derivative maps - bump mapping unparametrized surfaces by Morten Mikkelsen\\n\t// http://mmikkelsen3d.blogspot.sk/2011/07/derivative-maps.html\\n\\n\t// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\\n\\n\tvec2 dHdxy_fwd() {\\n\\n\t\tvec2 dSTdx = dFdx( vUv );\\n\t\tvec2 dSTdy = dFdy( vUv );\\n\\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\\n\\n\t\treturn vec2( dBx, dBy );\\n\\n\t}\\n\\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\\n\\n\t\tvec3 vSigmaX = dFdx( surf_pos );\\n\t\tvec3 vSigmaY = dFdy( surf_pos );\\n\t\tvec3 vN = surf_norm;\t\t// normalized\\n\\n\t\tvec3 R1 = cross( vSigmaY, vN );\\n\t\tvec3 R2 = cross( vN, vSigmaX );\\n\\n\t\tfloat fDet = dot( vSigmaX, R1 );\\n\\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\\n\\n\t}\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/defaultnormal_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'defaultnormal_vertex'] = \"#ifdef USE_SKINNING\\n\\n\tvec3 objectNormal = skinnedNormal.xyz;\\n\\n#elif defined( USE_MORPHNORMALS )\\n\\n\tvec3 objectNormal = morphedNormal;\\n\\n#else\\n\\n\tvec3 objectNormal = normal;\\n\\n#endif\\n\\n#ifdef FLIP_SIDED\\n\\n\tobjectNormal = -objectNormal;\\n\\n#endif\\n\\nvec3 transformedNormal = normalMatrix * objectNormal;\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/lights_phong_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'lights_phong_pars_fragment'] = \"uniform vec3 ambientLightColor;\\n\\n#if MAX_DIR_LIGHTS > 0\\n\\n\tuniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\\n\tuniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\\n\\n#endif\\n\\n#if MAX_HEMI_LIGHTS > 0\\n\\n\tuniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\\n\tuniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\\n\tuniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\\n\\n#endif\\n\\n#if MAX_POINT_LIGHTS > 0\\n\\n\tuniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\\n\\n\tuniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\\n\tuniform float pointLightDistance[ MAX_POINT_LIGHTS ];\\n\tuniform float pointLightDecay[ MAX_POINT_LIGHTS ];\\n\\n#endif\\n\\n#if MAX_SPOT_LIGHTS > 0\\n\\n\tuniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\\n\tuniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\\n\tuniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\\n\tuniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\\n\tuniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\\n\tuniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\\n\tuniform float spotLightDecay[ MAX_SPOT_LIGHTS ];\\n\\n#endif\\n\\n#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\\n\\n\tvarying vec3 vWorldPosition;\\n\\n#endif\\n\\n#ifdef WRAP_AROUND\\n\\n\tuniform vec3 wrapRGB;\\n\\n#endif\\n\\nvarying vec3 vViewPosition;\\n\\n#ifndef FLAT_SHADED\\n\\n\tvarying vec3 vNormal;\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/skinbase_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'skinbase_vertex'] = \"#ifdef USE_SKINNING\\n\\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/map_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'map_vertex'] = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\\n\\n\tvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/lightmap_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'lightmap_fragment'] = \"#ifdef USE_LIGHTMAP\\n\\n\toutgoingLight *= diffuseColor.xyz * texture2D( lightMap, vUv2 ).xyz;\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'shadowmap_pars_vertex'] = \"#ifdef USE_SHADOWMAP\\n\\n\tvarying vec4 vShadowCoord[ MAX_SHADOWS ];\\n\tuniform mat4 shadowMatrix[ MAX_SHADOWS ];\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/color_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'color_fragment'] = \"#ifdef USE_COLOR\\n\\n\tdiffuseColor.rgb *= vColor;\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/morphtarget_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'morphtarget_vertex'] = \"#ifdef USE_MORPHTARGETS\\n\\n\tvec3 morphed = vec3( 0.0 );\\n\tmorphed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\\n\tmorphed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\\n\tmorphed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\\n\tmorphed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\\n\\n\t#ifndef USE_MORPHNORMALS\\n\\n\tmorphed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\\n\tmorphed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\\n\tmorphed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\\n\tmorphed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\\n\\n\t#endif\\n\\n\tmorphed += position;\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/envmap_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'envmap_vertex'] = \"#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\\n\\n\tvec3 worldNormal = transformDirection( objectNormal, modelMatrix );\\n\\n\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\\n\\n\t#ifdef ENVMAP_MODE_REFLECTION\\n\\n\t\tvReflect = reflect( cameraToVertex, worldNormal );\\n\\n\t#else\\n\\n\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\\n\\n\t#endif\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/shadowmap_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'shadowmap_fragment'] = \"#ifdef USE_SHADOWMAP\\n\\n\t#ifdef SHADOWMAP_DEBUG\\n\\n\t\tvec3 frustumColors[3];\\n\t\tfrustumColors[0] = vec3( 1.0, 0.5, 0.0 );\\n\t\tfrustumColors[1] = vec3( 0.0, 1.0, 0.8 );\\n\t\tfrustumColors[2] = vec3( 0.0, 0.5, 1.0 );\\n\\n\t#endif\\n\\n\t#ifdef SHADOWMAP_CASCADE\\n\\n\t\tint inFrustumCount = 0;\\n\\n\t#endif\\n\\n\tfloat fDepth;\\n\tvec3 shadowColor = vec3( 1.0 );\\n\\n\tfor( int i = 0; i < MAX_SHADOWS; i ++ ) {\\n\\n\t\tvec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;\\n\\n\t\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\\n\t\t\t\t// if ( all( something, something ) ) using this instead\\n\\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\\n\t\tbool inFrustum = all( inFrustumVec );\\n\\n\t\t\t\t// don't shadow pixels outside of light frustum\\n\t\t\t\t// use just first frustum (for cascades)\\n\t\t\t\t// don't shadow pixels behind far plane of light frustum\\n\\n\t\t#ifdef SHADOWMAP_CASCADE\\n\\n\t\t\tinFrustumCount += int( inFrustum );\\n\t\t\tbvec3 frustumTestVec = bvec3( inFrustum, inFrustumCount == 1, shadowCoord.z <= 1.0 );\\n\\n\t\t#else\\n\\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\\n\\n\t\t#endif\\n\\n\t\tbool frustumTest = all( frustumTestVec );\\n\\n\t\tif ( frustumTest ) {\\n\\n\t\t\tshadowCoord.z += shadowBias[ i ];\\n\\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\\n\\n\t\t\t\t\t\t// Percentage-close filtering\\n\t\t\t\t\t\t// (9 pixel kernel)\\n\t\t\t\t\t\t// http://fabiensanglard.net/shadowmappingPCF/\\n\\n\t\t\t\tfloat shadow = 0.0;\\n\\n\t\t/*\\n\t\t\t\t\t\t// nested loops breaks shader compiler / validator on some ATI cards when using OpenGL\\n\t\t\t\t\t\t// must enroll loop manually\\n\\n\t\t\t\tfor ( float y = -1.25; y <= 1.25; y += 1.25 )\\n\t\t\t\t\tfor ( float x = -1.25; x <= 1.25; x += 1.25 ) {\\n\\n\t\t\t\t\t\tvec4 rgbaDepth = texture2D( shadowMap[ i ], vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy );\\n\\n\t\t\t\t\t\t\t\t// doesn't seem to produce any noticeable visual difference compared to simple texture2D lookup\\n\t\t\t\t\t\t\t\t//vec4 rgbaDepth = texture2DProj( shadowMap[ i ], vec4( vShadowCoord[ i ].w * ( vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy ), 0.05, vShadowCoord[ i ].w ) );\\n\\n\t\t\t\t\t\tfloat fDepth = unpackDepth( rgbaDepth );\\n\\n\t\t\t\t\t\tif ( fDepth < shadowCoord.z )\\n\t\t\t\t\t\t\tshadow += 1.0;\\n\\n\t\t\t\t}\\n\\n\t\t\t\tshadow /= 9.0;\\n\\n\t\t*/\\n\\n\t\t\t\tconst float shadowDelta = 1.0 / 9.0;\\n\\n\t\t\t\tfloat xPixelOffset = 1.0 / shadowMapSize[ i ].x;\\n\t\t\t\tfloat yPixelOffset = 1.0 / shadowMapSize[ i ].y;\\n\\n\t\t\t\tfloat dx0 = -1.25 * xPixelOffset;\\n\t\t\t\tfloat dy0 = -1.25 * yPixelOffset;\\n\t\t\t\tfloat dx1 = 1.25 * xPixelOffset;\\n\t\t\t\tfloat dy1 = 1.25 * yPixelOffset;\\n\\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\n\\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\n\\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\n\\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\n\\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\n\\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\n\\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\n\\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\n\\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\n\\n\t\t\t\tshadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\\n\\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\\n\\n\t\t\t\t\t\t// Percentage-close filtering\\n\t\t\t\t\t\t// (9 pixel kernel)\\n\t\t\t\t\t\t// http://fabiensanglard.net/shadowmappingPCF/\\n\\n\t\t\t\tfloat shadow = 0.0;\\n\\n\t\t\t\tfloat xPixelOffset = 1.0 / shadowMapSize[ i ].x;\\n\t\t\t\tfloat yPixelOffset = 1.0 / shadowMapSize[ i ].y;\\n\\n\t\t\t\tfloat dx0 = -1.0 * xPixelOffset;\\n\t\t\t\tfloat dy0 = -1.0 * yPixelOffset;\\n\t\t\t\tfloat dx1 = 1.0 * xPixelOffset;\\n\t\t\t\tfloat dy1 = 1.0 * yPixelOffset;\\n\\n\t\t\t\tmat3 shadowKernel;\\n\t\t\t\tmat3 depthKernel;\\n\\n\t\t\t\tdepthKernel[0][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\\n\t\t\t\tdepthKernel[0][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\\n\t\t\t\tdepthKernel[0][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\\n\t\t\t\tdepthKernel[1][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\\n\t\t\t\tdepthKernel[1][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\\n\t\t\t\tdepthKernel[1][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\\n\t\t\t\tdepthKernel[2][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\\n\t\t\t\tdepthKernel[2][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\\n\t\t\t\tdepthKernel[2][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\\n\\n\t\t\t\tvec3 shadowZ = vec3( shadowCoord.z );\\n\t\t\t\tshadowKernel[0] = vec3(lessThan(depthKernel[0], shadowZ ));\\n\t\t\t\tshadowKernel[0] *= vec3(0.25);\\n\\n\t\t\t\tshadowKernel[1] = vec3(lessThan(depthKernel[1], shadowZ ));\\n\t\t\t\tshadowKernel[1] *= vec3(0.25);\\n\\n\t\t\t\tshadowKernel[2] = vec3(lessThan(depthKernel[2], shadowZ ));\\n\t\t\t\tshadowKernel[2] *= vec3(0.25);\\n\\n\t\t\t\tvec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[i].xy );\\n\\n\t\t\t\tshadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );\\n\t\t\t\tshadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );\\n\\n\t\t\t\tvec4 shadowValues;\\n\t\t\t\tshadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );\\n\t\t\t\tshadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );\\n\t\t\t\tshadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );\\n\t\t\t\tshadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );\\n\\n\t\t\t\tshadow = dot( shadowValues, vec4( 1.0 ) );\\n\\n\t\t\t\tshadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\\n\\n\t\t\t#else\\n\\n\t\t\t\tvec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );\\n\t\t\t\tfloat fDepth = unpackDepth( rgbaDepth );\\n\\n\t\t\t\tif ( fDepth < shadowCoord.z )\\n\\n\t\t// spot with multiple shadows is darker\\n\\n\t\t\t\t\tshadowColor = shadowColor * vec3( 1.0 - shadowDarkness[ i ] );\\n\\n\t\t// spot with multiple shadows has the same color as single shadow spot\\n\\n\t\t// \t\t\t\t\tshadowColor = min( shadowColor, vec3( shadowDarkness[ i ] ) );\\n\\n\t\t\t#endif\\n\\n\t\t}\\n\\n\\n\t\t#ifdef SHADOWMAP_DEBUG\\n\\n\t\t\t#ifdef SHADOWMAP_CASCADE\\n\\n\t\t\t\tif ( inFrustum && inFrustumCount == 1 ) outgoingLight *= frustumColors[ i ];\\n\\n\t\t\t#else\\n\\n\t\t\t\tif ( inFrustum ) outgoingLight *= frustumColors[ i ];\\n\\n\t\t\t#endif\\n\\n\t\t#endif\\n\\n\t}\\n\\n\t// NOTE: I am unsure if this is correct in linear space.  -bhouston, Dec 29, 2014\\n\tshadowColor = inputToLinear( shadowColor );\\n\\n\toutgoingLight = outgoingLight * shadowColor;\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/worldpos_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'worldpos_vertex'] = \"#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\\n\\n\t#ifdef USE_SKINNING\\n\\n\t\tvec4 worldPosition = modelMatrix * skinned;\\n\\n\t#elif defined( USE_MORPHTARGETS )\\n\\n\t\tvec4 worldPosition = modelMatrix * vec4( morphed, 1.0 );\\n\\n\t#else\\n\\n\t\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\\n\\n\t#endif\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'shadowmap_pars_fragment'] = \"#ifdef USE_SHADOWMAP\\n\\n\tuniform sampler2D shadowMap[ MAX_SHADOWS ];\\n\tuniform vec2 shadowMapSize[ MAX_SHADOWS ];\\n\\n\tuniform float shadowDarkness[ MAX_SHADOWS ];\\n\tuniform float shadowBias[ MAX_SHADOWS ];\\n\\n\tvarying vec4 vShadowCoord[ MAX_SHADOWS ];\\n\\n\tfloat unpackDepth( const in vec4 rgba_depth ) {\\n\\n\t\tconst vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\\n\t\tfloat depth = dot( rgba_depth, bit_shift );\\n\t\treturn depth;\\n\\n\t}\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/skinning_pars_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'skinning_pars_vertex'] = \"#ifdef USE_SKINNING\\n\\n\tuniform mat4 bindMatrix;\\n\tuniform mat4 bindMatrixInverse;\\n\\n\t#ifdef BONE_TEXTURE\\n\\n\t\tuniform sampler2D boneTexture;\\n\t\tuniform int boneTextureWidth;\\n\t\tuniform int boneTextureHeight;\\n\\n\t\tmat4 getBoneMatrix( const in float i ) {\\n\\n\t\t\tfloat j = i * 4.0;\\n\t\t\tfloat x = mod( j, float( boneTextureWidth ) );\\n\t\t\tfloat y = floor( j / float( boneTextureWidth ) );\\n\\n\t\t\tfloat dx = 1.0 / float( boneTextureWidth );\\n\t\t\tfloat dy = 1.0 / float( boneTextureHeight );\\n\\n\t\t\ty = dy * ( y + 0.5 );\\n\\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\\n\\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\\n\\n\t\t\treturn bone;\\n\\n\t\t}\\n\\n\t#else\\n\\n\t\tuniform mat4 boneGlobalMatrices[ MAX_BONES ];\\n\\n\t\tmat4 getBoneMatrix( const in float i ) {\\n\\n\t\t\tmat4 bone = boneGlobalMatrices[ int(i) ];\\n\t\t\treturn bone;\\n\\n\t\t}\\n\\n\t#endif\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'logdepthbuf_pars_fragment'] = \"#ifdef USE_LOGDEPTHBUF\\n\\n\tuniform float logDepthBufFC;\\n\\n\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\n\t\t#extension GL_EXT_frag_depth : enable\\n\t\tvarying float vFragDepth;\\n\\n\t#endif\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/alphamap_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'alphamap_fragment'] = \"#ifdef USE_ALPHAMAP\\n\\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/alphamap_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'alphamap_pars_fragment'] = \"#ifdef USE_ALPHAMAP\\n\\n\tuniform sampler2D alphaMap;\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/UniformsUtils.js\r\n\r\n/**\r\n * Uniform Utilities\r\n */\r\n\r\nTHREE.UniformsUtils = {\r\n\r\n\tmerge: function ( uniforms ) {\r\n\r\n\t\tvar merged = {};\r\n\r\n\t\tfor ( var u = 0; u < uniforms.length; u ++ ) {\r\n\r\n\t\t\tvar tmp = this.clone( uniforms[ u ] );\r\n\r\n\t\t\tfor ( var p in tmp ) {\r\n\r\n\t\t\t\tmerged[ p ] = tmp[ p ];\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn merged;\r\n\r\n\t},\r\n\r\n\tclone: function ( uniforms_src ) {\r\n\r\n\t\tvar uniforms_dst = {};\r\n\r\n\t\tfor ( var u in uniforms_src ) {\r\n\r\n\t\t\tuniforms_dst[ u ] = {};\r\n\r\n\t\t\tfor ( var p in uniforms_src[ u ] ) {\r\n\r\n\t\t\t\tvar parameter_src = uniforms_src[ u ][ p ];\r\n\r\n\t\t\t\tif ( parameter_src instanceof THREE.Color ||\r\n\t\t\t\t\t parameter_src instanceof THREE.Vector2 ||\r\n\t\t\t\t\t parameter_src instanceof THREE.Vector3 ||\r\n\t\t\t\t\t parameter_src instanceof THREE.Vector4 ||\r\n\t\t\t\t\t parameter_src instanceof THREE.Matrix4 ||\r\n\t\t\t\t\t parameter_src instanceof THREE.Texture ) {\r\n\r\n\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src.clone();\r\n\r\n\t\t\t\t} else if ( parameter_src instanceof Array ) {\r\n\r\n\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src.slice();\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn uniforms_dst;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/renderers/shaders/UniformsLib.js\r\n\r\n/**\r\n * Uniforms library for shared webgl shaders\r\n */\r\n\r\nTHREE.UniformsLib = {\r\n\r\n\tcommon: {\r\n\r\n\t\t\"diffuse\" : { type: \"c\", value: new THREE.Color( 0xeeeeee ) },\r\n\t\t\"opacity\" : { type: \"f\", value: 1.0 },\r\n\r\n\t\t\"map\" : { type: \"t\", value: null },\r\n\t\t\"offsetRepeat\" : { type: \"v4\", value: new THREE.Vector4( 0, 0, 1, 1 ) },\r\n\r\n\t\t\"lightMap\" : { type: \"t\", value: null },\r\n\t\t\"specularMap\" : { type: \"t\", value: null },\r\n\t\t\"alphaMap\" : { type: \"t\", value: null },\r\n\r\n\t\t\"envMap\" : { type: \"t\", value: null },\r\n\t\t\"flipEnvMap\" : { type: \"f\", value: - 1 },\r\n\t\t\"reflectivity\" : { type: \"f\", value: 1.0 },\r\n\t\t\"refractionRatio\" : { type: \"f\", value: 0.98 },\r\n\r\n\t\t\"morphTargetInfluences\" : { type: \"f\", value: 0 }\r\n\r\n\t},\r\n\r\n\tbump: {\r\n\r\n\t\t\"bumpMap\" : { type: \"t\", value: null },\r\n\t\t\"bumpScale\" : { type: \"f\", value: 1 }\r\n\r\n\t},\r\n\r\n\tnormalmap: {\r\n\r\n\t\t\"normalMap\" : { type: \"t\", value: null },\r\n\t\t\"normalScale\" : { type: \"v2\", value: new THREE.Vector2( 1, 1 ) }\r\n\t},\r\n\r\n\tfog : {\r\n\r\n\t\t\"fogDensity\" : { type: \"f\", value: 0.00025 },\r\n\t\t\"fogNear\" : { type: \"f\", value: 1 },\r\n\t\t\"fogFar\" : { type: \"f\", value: 2000 },\r\n\t\t\"fogColor\" : { type: \"c\", value: new THREE.Color( 0xffffff ) }\r\n\r\n\t},\r\n\r\n\tlights: {\r\n\r\n\t\t\"ambientLightColor\" : { type: \"fv\", value: [] },\r\n\r\n\t\t\"directionalLightDirection\" : { type: \"fv\", value: [] },\r\n\t\t\"directionalLightColor\" : { type: \"fv\", value: [] },\r\n\r\n\t\t\"hemisphereLightDirection\" : { type: \"fv\", value: [] },\r\n\t\t\"hemisphereLightSkyColor\" : { type: \"fv\", value: [] },\r\n\t\t\"hemisphereLightGroundColor\" : { type: \"fv\", value: [] },\r\n\r\n\t\t\"pointLightColor\" : { type: \"fv\", value: [] },\r\n\t\t\"pointLightPosition\" : { type: \"fv\", value: [] },\r\n\t\t\"pointLightDistance\" : { type: \"fv1\", value: [] },\r\n\t\t\"pointLightDecay\" : { type: \"fv1\", value: [] },\r\n\r\n\t\t\"spotLightColor\" : { type: \"fv\", value: [] },\r\n\t\t\"spotLightPosition\" : { type: \"fv\", value: [] },\r\n\t\t\"spotLightDirection\" : { type: \"fv\", value: [] },\r\n\t\t\"spotLightDistance\" : { type: \"fv1\", value: [] },\r\n\t\t\"spotLightAngleCos\" : { type: \"fv1\", value: [] },\r\n\t\t\"spotLightExponent\" : { type: \"fv1\", value: [] },\r\n\t\t\"spotLightDecay\" : { type: \"fv1\", value: [] }\r\n\r\n\t},\r\n\r\n\tparticle: {\r\n\r\n\t\t\"psColor\" : { type: \"c\", value: new THREE.Color( 0xeeeeee ) },\r\n\t\t\"opacity\" : { type: \"f\", value: 1.0 },\r\n\t\t\"size\" : { type: \"f\", value: 1.0 },\r\n\t\t\"scale\" : { type: \"f\", value: 1.0 },\r\n\t\t\"map\" : { type: \"t\", value: null },\r\n\t\t\"offsetRepeat\" : { type: \"v4\", value: new THREE.Vector4( 0, 0, 1, 1 ) },\r\n\r\n\t\t\"fogDensity\" : { type: \"f\", value: 0.00025 },\r\n\t\t\"fogNear\" : { type: \"f\", value: 1 },\r\n\t\t\"fogFar\" : { type: \"f\", value: 2000 },\r\n\t\t\"fogColor\" : { type: \"c\", value: new THREE.Color( 0xffffff ) }\r\n\r\n\t},\r\n\r\n\tshadowmap: {\r\n\r\n\t\t\"shadowMap\": { type: \"tv\", value: [] },\r\n\t\t\"shadowMapSize\": { type: \"v2v\", value: [] },\r\n\r\n\t\t\"shadowBias\" : { type: \"fv1\", value: [] },\r\n\t\t\"shadowDarkness\": { type: \"fv1\", value: [] },\r\n\r\n\t\t\"shadowMatrix\" : { type: \"m4v\", value: [] }\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/renderers/shaders/ShaderLib.js\r\n\r\n/**\r\n * Webgl Shader Library for three.js\r\n *\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author mikael emtinger / http://gomo.se/\r\n */\r\n\r\n\r\nTHREE.ShaderLib = {\r\n\r\n\t'basic': {\r\n\r\n\t\tuniforms: THREE.UniformsUtils.merge( [\r\n\r\n\t\t\tTHREE.UniformsLib[ \"common\" ],\r\n\t\t\tTHREE.UniformsLib[ \"fog\" ],\r\n\t\t\tTHREE.UniformsLib[ \"shadowmap\" ]\r\n\r\n\t\t] ),\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"map_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"lightmap_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"envmap_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"color_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"morphtarget_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"skinning_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_pars_vertex\" ],\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"map_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"lightmap_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"color_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"skinbase_vertex\" ],\r\n\r\n\t\t\t\"\t#ifdef USE_ENVMAP\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"morphnormal_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"skinnormal_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"defaultnormal_vertex\" ],\r\n\r\n\t\t\t\"\t#endif\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"morphtarget_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"skinning_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"default_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_vertex\" ],\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"worldpos_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"envmap_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_vertex\" ],\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\"),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"uniform vec3 diffuse;\",\r\n\t\t\t\"uniform float opacity;\",\r\n\r\n\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"color_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"map_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"alphamap_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"lightmap_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"envmap_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"fog_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"specularmap_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_pars_fragment\" ],\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\"\tvec3 outgoingLight = vec3( 0.0 );\",\t// outgoing light does not have an alpha, the surface does\r\n\t\t\t\"\tvec4 diffuseColor = vec4( diffuse, opacity );\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"map_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"color_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"alphamap_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"alphatest_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"specularmap_fragment\" ],\r\n\r\n\t\t\t\"\toutgoingLight = diffuseColor.rgb;\", // simple shader\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"lightmap_fragment\" ],\t\t// TODO: Light map on an otherwise unlit surface doesn't make sense.\r\n\t\t\t\tTHREE.ShaderChunk[ \"envmap_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_fragment\" ],\t\t// TODO: Shadows on an otherwise unlit surface doesn't make sense.\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"linear_to_gamma_fragment\" ],\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"fog_fragment\" ],\r\n\r\n\t\t\t\"\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\",\t// TODO, this should be pre-multiplied to allow for bright highlights on very transparent objects\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\")\r\n\r\n\t},\r\n\r\n\t'lambert': {\r\n\r\n\t\tuniforms: THREE.UniformsUtils.merge( [\r\n\r\n\t\t\tTHREE.UniformsLib[ \"common\" ],\r\n\t\t\tTHREE.UniformsLib[ \"fog\" ],\r\n\t\t\tTHREE.UniformsLib[ \"lights\" ],\r\n\t\t\tTHREE.UniformsLib[ \"shadowmap\" ],\r\n\r\n\t\t\t{\r\n\t\t\t\t\"emissive\" : { type: \"c\", value: new THREE.Color( 0x000000 ) },\r\n\t\t\t\t\"wrapRGB\"  : { type: \"v3\", value: new THREE.Vector3( 1, 1, 1 ) }\r\n\t\t\t}\r\n\r\n\t\t] ),\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t\"#define LAMBERT\",\r\n\r\n\t\t\t\"varying vec3 vLightFront;\",\r\n\r\n\t\t\t\"#ifdef DOUBLE_SIDED\",\r\n\r\n\t\t\t\"\tvarying vec3 vLightBack;\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"map_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"lightmap_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"envmap_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"lights_lambert_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"color_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"morphtarget_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"skinning_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_pars_vertex\" ],\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"map_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"lightmap_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"color_vertex\" ],\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"morphnormal_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"skinbase_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"skinnormal_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"defaultnormal_vertex\" ],\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"morphtarget_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"skinning_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"default_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_vertex\" ],\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"worldpos_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"envmap_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"lights_lambert_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_vertex\" ],\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\"),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"uniform vec3 diffuse;\",\r\n\t\t\t\"uniform vec3 emissive;\",\r\n\t\t\t\"uniform float opacity;\",\r\n\r\n\t\t\t\"varying vec3 vLightFront;\",\r\n\r\n\t\t\t\"#ifdef DOUBLE_SIDED\",\r\n\r\n\t\t\t\"\tvarying vec3 vLightBack;\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"color_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"map_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"alphamap_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"lightmap_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"envmap_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"fog_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"specularmap_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_pars_fragment\" ],\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\"\tvec3 outgoingLight = vec3( 0.0 );\",\t// outgoing light does not have an alpha, the surface does\r\n\t\t\t\"\tvec4 diffuseColor = vec4( diffuse, opacity );\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"map_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"color_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"alphamap_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"alphatest_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"specularmap_fragment\" ],\r\n\r\n\t\t\t\"\t#ifdef DOUBLE_SIDED\",\r\n\r\n\t\t\t\t\t//\"float isFront = float( gl_FrontFacing );\",\r\n\t\t\t\t\t//\"gl_FragColor.xyz *= isFront * vLightFront + ( 1.0 - isFront ) * vLightBack;\",\r\n\r\n\t\t\t\"\t\tif ( gl_FrontFacing )\",\r\n\t\t\t\"\t\t\toutgoingLight += diffuseColor.rgb * vLightFront + emissive;\",\r\n\t\t\t\"\t\telse\",\r\n\t\t\t\"\t\t\toutgoingLight += diffuseColor.rgb * vLightBack + emissive;\",\r\n\r\n\t\t\t\"\t#else\",\r\n\r\n\t\t\t\"\t\toutgoingLight += diffuseColor.rgb * vLightFront + emissive;\",\r\n\r\n\t\t\t\"\t#endif\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"lightmap_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"envmap_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_fragment\" ],\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"linear_to_gamma_fragment\" ],\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"fog_fragment\" ],\r\n\r\n\t\t\t\"\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\",\t// TODO, this should be pre-multiplied to allow for bright highlights on very transparent objects\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\")\r\n\r\n\t},\r\n\r\n\t'phong': {\r\n\r\n\t\tuniforms: THREE.UniformsUtils.merge( [\r\n\r\n\t\t\tTHREE.UniformsLib[ \"common\" ],\r\n\t\t\tTHREE.UniformsLib[ \"bump\" ],\r\n\t\t\tTHREE.UniformsLib[ \"normalmap\" ],\r\n\t\t\tTHREE.UniformsLib[ \"fog\" ],\r\n\t\t\tTHREE.UniformsLib[ \"lights\" ],\r\n\t\t\tTHREE.UniformsLib[ \"shadowmap\" ],\r\n\r\n\t\t\t{\r\n\t\t\t\t\"emissive\" : { type: \"c\", value: new THREE.Color( 0x000000 ) },\r\n\t\t\t\t\"specular\" : { type: \"c\", value: new THREE.Color( 0x111111 ) },\r\n\t\t\t\t\"shininess\": { type: \"f\", value: 30 },\r\n\t\t\t\t\"wrapRGB\"  : { type: \"v3\", value: new THREE.Vector3( 1, 1, 1 ) }\r\n\t\t\t}\r\n\r\n\t\t] ),\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t\"#define PHONG\",\r\n\r\n\t\t\t\"varying vec3 vViewPosition;\",\r\n\r\n\t\t\t\"#ifndef FLAT_SHADED\",\r\n\r\n\t\t\t\"\tvarying vec3 vNormal;\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"map_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"lightmap_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"envmap_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"lights_phong_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"color_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"morphtarget_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"skinning_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_pars_vertex\" ],\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"map_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"lightmap_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"color_vertex\" ],\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"morphnormal_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"skinbase_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"skinnormal_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"defaultnormal_vertex\" ],\r\n\r\n\t\t\t\"#ifndef FLAT_SHADED\", // Normal computed with derivatives when FLAT_SHADED\r\n\r\n\t\t\t\"\tvNormal = normalize( transformedNormal );\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"morphtarget_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"skinning_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"default_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_vertex\" ],\r\n\r\n\t\t\t\"\tvViewPosition = -mvPosition.xyz;\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"worldpos_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"envmap_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"lights_phong_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_vertex\" ],\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\"),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"#define PHONG\",\r\n\r\n\t\t\t\"uniform vec3 diffuse;\",\r\n\t\t\t\"uniform vec3 emissive;\",\r\n\t\t\t\"uniform vec3 specular;\",\r\n\t\t\t\"uniform float shininess;\",\r\n\t\t\t\"uniform float opacity;\",\r\n\r\n\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"color_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"map_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"alphamap_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"lightmap_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"envmap_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"fog_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"lights_phong_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"bumpmap_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"normalmap_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"specularmap_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_pars_fragment\" ],\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\"\tvec3 outgoingLight = vec3( 0.0 );\",\t// outgoing light does not have an alpha, the surface does\r\n\t\t\t\"\tvec4 diffuseColor = vec4( diffuse, opacity );\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"map_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"color_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"alphamap_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"alphatest_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"specularmap_fragment\" ],\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"lights_phong_fragment\" ],\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"lightmap_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"envmap_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_fragment\" ],\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"linear_to_gamma_fragment\" ],\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"fog_fragment\" ],\r\n\r\n\t\t\t\"\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\",\t// TODO, this should be pre-multiplied to allow for bright highlights on very transparent objects\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\")\r\n\r\n\t},\r\n\r\n\t'particle_basic': {\r\n\r\n\t\tuniforms: THREE.UniformsUtils.merge( [\r\n\r\n\t\t\tTHREE.UniformsLib[ \"particle\" ],\r\n\t\t\tTHREE.UniformsLib[ \"shadowmap\" ]\r\n\r\n\t\t] ),\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t\"uniform float size;\",\r\n\t\t\t\"uniform float scale;\",\r\n\r\n\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"color_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_pars_vertex\" ],\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"color_vertex\" ],\r\n\r\n\t\t\t\"\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\t\"\t#ifdef USE_SIZEATTENUATION\",\r\n\t\t\t\"\t\tgl_PointSize = size * ( scale / length( mvPosition.xyz ) );\",\r\n\t\t\t\"\t#else\",\r\n\t\t\t\"\t\tgl_PointSize = size;\",\r\n\t\t\t\"\t#endif\",\r\n\r\n\t\t\t\"\tgl_Position = projectionMatrix * mvPosition;\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"worldpos_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_vertex\" ],\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\"),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"uniform vec3 psColor;\",\r\n\t\t\t\"uniform float opacity;\",\r\n\r\n\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"color_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"map_particle_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"fog_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_pars_fragment\" ],\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\"\tvec3 outgoingLight = vec3( 0.0 );\",\t// outgoing light does not have an alpha, the surface does\r\n\t\t\t\"\tvec4 diffuseColor = vec4( psColor, opacity );\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"map_particle_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"color_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"alphatest_fragment\" ],\r\n\r\n\t\t\t\"\toutgoingLight = diffuseColor.rgb;\", // simple shader\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"fog_fragment\" ],\r\n\r\n\t\t\t\"\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\",\t// TODO, this should be pre-multiplied to allow for bright highlights on very transparent objects\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\")\r\n\r\n\t},\r\n\r\n\t'dashed': {\r\n\r\n\t\tuniforms: THREE.UniformsUtils.merge( [\r\n\r\n\t\t\tTHREE.UniformsLib[ \"common\" ],\r\n\t\t\tTHREE.UniformsLib[ \"fog\" ],\r\n\r\n\t\t\t{\r\n\t\t\t\t\"scale\"    : { type: \"f\", value: 1 },\r\n\t\t\t\t\"dashSize\" : { type: \"f\", value: 1 },\r\n\t\t\t\t\"totalSize\": { type: \"f\", value: 2 }\r\n\t\t\t}\r\n\r\n\t\t] ),\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t\"uniform float scale;\",\r\n\t\t\t\"attribute float lineDistance;\",\r\n\r\n\t\t\t\"varying float vLineDistance;\",\r\n\r\n\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"color_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_pars_vertex\" ],\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"color_vertex\" ],\r\n\r\n\t\t\t\"\tvLineDistance = scale * lineDistance;\",\r\n\r\n\t\t\t\"\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\",\r\n\t\t\t\"\tgl_Position = projectionMatrix * mvPosition;\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_vertex\" ],\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\"),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"uniform vec3 diffuse;\",\r\n\t\t\t\"uniform float opacity;\",\r\n\r\n\t\t\t\"uniform float dashSize;\",\r\n\t\t\t\"uniform float totalSize;\",\r\n\r\n\t\t\t\"varying float vLineDistance;\",\r\n\r\n\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"color_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"fog_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_pars_fragment\" ],\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\"\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\",\r\n\r\n\t\t\t\"\t\tdiscard;\",\r\n\r\n\t\t\t\"\t}\",\r\n\r\n\t\t\t\"\tvec3 outgoingLight = vec3( 0.0 );\",\t// outgoing light does not have an alpha, the surface does\r\n\t\t\t\"\tvec4 diffuseColor = vec4( diffuse, opacity );\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"color_fragment\" ],\r\n\r\n\t\t\t\"\toutgoingLight = diffuseColor.rgb;\", // simple shader\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"fog_fragment\" ],\r\n\r\n\t\t\t\"\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\",\t// TODO, this should be pre-multiplied to allow for bright highlights on very transparent objects\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\")\r\n\r\n\t},\r\n\r\n\t'depth': {\r\n\r\n\t\tuniforms: {\r\n\r\n\t\t\t\"mNear\": { type: \"f\", value: 1.0 },\r\n\t\t\t\"mFar\" : { type: \"f\", value: 2000.0 },\r\n\t\t\t\"opacity\" : { type: \"f\", value: 1.0 }\r\n\r\n\t\t},\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"morphtarget_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_pars_vertex\" ],\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"morphtarget_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"default_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_vertex\" ],\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\"),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"uniform float mNear;\",\r\n\t\t\t\"uniform float mFar;\",\r\n\t\t\t\"uniform float opacity;\",\r\n\r\n\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_pars_fragment\" ],\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_fragment\" ],\r\n\r\n\t\t\t\"\t#ifdef USE_LOGDEPTHBUF_EXT\",\r\n\r\n\t\t\t\"\t\tfloat depth = gl_FragDepthEXT / gl_FragCoord.w;\",\r\n\r\n\t\t\t\"\t#else\",\r\n\r\n\t\t\t\"\t\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\",\r\n\r\n\t\t\t\"\t#endif\",\r\n\r\n\t\t\t\"\tfloat color = 1.0 - smoothstep( mNear, mFar, depth );\",\r\n\t\t\t\"\tgl_FragColor = vec4( vec3( color ), opacity );\",   // TODO, this should be pre-multiplied to allow for bright highlights on very transparent objects\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\")\r\n\r\n\t},\r\n\r\n\t'normal': {\r\n\r\n\t\tuniforms: {\r\n\r\n\t\t\t\"opacity\" : { type: \"f\", value: 1.0 }\r\n\r\n\t\t},\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t\"varying vec3 vNormal;\",\r\n\r\n\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"morphtarget_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_pars_vertex\" ],\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\"\tvNormal = normalize( normalMatrix * normal );\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"morphtarget_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"default_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_vertex\" ],\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\"),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"uniform float opacity;\",\r\n\t\t\t\"varying vec3 vNormal;\",\r\n\r\n\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_pars_fragment\" ],\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\"\tgl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_fragment\" ],\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\")\r\n\r\n\t},\r\n\r\n\t/* -------------------------------------------------------------------------\r\n\t//\tCube map shader\r\n\t ------------------------------------------------------------------------- */\r\n\r\n\t'cube': {\r\n\r\n\t\tuniforms: { \"tCube\": { type: \"t\", value: null },\r\n\t\t\t\t\t\"tFlip\": { type: \"f\", value: - 1 } },\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t\"varying vec3 vWorldPosition;\",\r\n\r\n\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_pars_vertex\" ],\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\"\tvWorldPosition = transformDirection( position, modelMatrix );\",\r\n\r\n\t\t\t\"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_vertex\" ],\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\"),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"uniform samplerCube tCube;\",\r\n\t\t\t\"uniform float tFlip;\",\r\n\r\n\t\t\t\"varying vec3 vWorldPosition;\",\r\n\r\n\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_pars_fragment\" ],\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\"\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_fragment\" ],\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\")\r\n\r\n\t},\r\n\r\n\t/* -------------------------------------------------------------------------\r\n\t//\tCube map shader\r\n\t ------------------------------------------------------------------------- */\r\n\r\n\t'equirect': {\r\n\r\n\t\tuniforms: { \"tEquirect\": { type: \"t\", value: null },\r\n\t\t\t\t\t\"tFlip\": { type: \"f\", value: - 1 } },\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t\"varying vec3 vWorldPosition;\",\r\n\r\n\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_pars_vertex\" ],\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\"\tvWorldPosition = transformDirection( position, modelMatrix );\",\r\n\r\n\t\t\t\"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_vertex\" ],\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\"),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"uniform sampler2D tEquirect;\",\r\n\t\t\t\"uniform float tFlip;\",\r\n\r\n\t\t\t\"varying vec3 vWorldPosition;\",\r\n\r\n\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_pars_fragment\" ],\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t// \"\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\",\r\n\t\t\t\t\"vec3 direction = normalize( vWorldPosition );\",\r\n\t\t\t\t\"vec2 sampleUV;\",\r\n\t\t\t\t\"sampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );\",\r\n\t\t\t\t\"sampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\",\r\n\t\t\t\t\"gl_FragColor = texture2D( tEquirect, sampleUV );\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_fragment\" ],\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\")\r\n\r\n\t},\r\n\r\n\t/* Depth encoding into RGBA texture\r\n\t *\r\n\t * based on SpiderGL shadow map example\r\n\t * http://spidergl.org/example.php?id=6\r\n\t *\r\n\t * originally from\r\n\t * http://www.gamedev.net/topic/442138-packing-a-float-into-a-a8r8g8b8-texture-shader/page__whichpage__1%25EF%25BF%25BD\r\n\t *\r\n\t * see also\r\n\t * http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/\r\n\t */\r\n\r\n\t'depthRGBA': {\r\n\r\n\t\tuniforms: {},\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"morphtarget_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"skinning_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_pars_vertex\" ],\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"skinbase_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"morphtarget_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"skinning_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"default_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_vertex\" ],\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\"),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_pars_fragment\" ],\r\n\r\n\t\t\t\"vec4 pack_depth( const in float depth ) {\",\r\n\r\n\t\t\t\"\tconst vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );\",\r\n\t\t\t\"\tconst vec4 bit_mask = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );\",\r\n\t\t\t\"\tvec4 res = mod( depth * bit_shift * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );\", // \"\tvec4 res = fract( depth * bit_shift );\",\r\n\t\t\t\"\tres -= res.xxyz * bit_mask;\",\r\n\t\t\t\"\treturn res;\",\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_fragment\" ],\r\n\r\n\t\t\t\"\t#ifdef USE_LOGDEPTHBUF_EXT\",\r\n\r\n\t\t\t\"\t\tgl_FragData[ 0 ] = pack_depth( gl_FragDepthEXT );\",\r\n\r\n\t\t\t\"\t#else\",\r\n\r\n\t\t\t\"\t\tgl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );\",\r\n\r\n\t\t\t\"\t#endif\",\r\n\r\n\t\t\t\t//\"gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z / gl_FragCoord.w );\",\r\n\t\t\t\t//\"float z = ( ( gl_FragCoord.z / gl_FragCoord.w ) - 3.0 ) / ( 4000.0 - 3.0 );\",\r\n\t\t\t\t//\"gl_FragData[ 0 ] = pack_depth( z );\",\r\n\t\t\t\t//\"gl_FragData[ 0 ] = vec4( z, z, z, 1.0 );\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\")\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/renderers/WebGLRenderer.js\r\n\r\n/**\r\n * @author supereggbert / http://www.paulbrunt.co.uk/\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author szimek / https://github.com/szimek/\r\n */\r\n\r\nTHREE.WebGLRenderer = function ( parameters ) {\r\n\r\n\tconsole.log( 'THREE.WebGLRenderer', THREE.REVISION );\r\n\r\n\tparameters = parameters || {};\r\n\r\n\tvar _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElement( 'canvas' ),\r\n\t_context = parameters.context !== undefined ? parameters.context : null,\r\n\r\n\tpixelRatio = 1,\r\n\r\n\t_precision = parameters.precision !== undefined ? parameters.precision : 'highp',\r\n\r\n\t_alpha = parameters.alpha !== undefined ? parameters.alpha : false,\r\n\t_depth = parameters.depth !== undefined ? parameters.depth : true,\r\n\t_stencil = parameters.stencil !== undefined ? parameters.stencil : true,\r\n\t_antialias = parameters.antialias !== undefined ? parameters.antialias : false,\r\n\t_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,\r\n\t_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,\r\n\t_logarithmicDepthBuffer = parameters.logarithmicDepthBuffer !== undefined ? parameters.logarithmicDepthBuffer : false,\r\n\r\n\t_clearColor = new THREE.Color( 0x000000 ),\r\n\t_clearAlpha = 0;\r\n\r\n\tvar lights = [];\r\n\r\n\tvar _webglObjects = {};\r\n\tvar _webglObjectsImmediate = [];\r\n\r\n\tvar opaqueObjects = [];\r\n\tvar transparentObjects = [];\r\n\r\n\tvar sprites = [];\r\n\tvar lensFlares = [];\r\n\r\n\t// public properties\r\n\r\n\tthis.domElement = _canvas;\r\n\tthis.context = null;\r\n\r\n\t// clearing\r\n\r\n\tthis.autoClear = true;\r\n\tthis.autoClearColor = true;\r\n\tthis.autoClearDepth = true;\r\n\tthis.autoClearStencil = true;\r\n\r\n\t// scene graph\r\n\r\n\tthis.sortObjects = true;\r\n\r\n\t// physically based shading\r\n\r\n\tthis.gammaFactor = 2.0;\t// for backwards compatibility\r\n\tthis.gammaInput = false;\r\n\tthis.gammaOutput = false;\r\n\r\n\t// shadow map\r\n\r\n\tthis.shadowMapEnabled = false;\r\n\tthis.shadowMapType = THREE.PCFShadowMap;\r\n\tthis.shadowMapCullFace = THREE.CullFaceFront;\r\n\tthis.shadowMapDebug = false;\r\n\tthis.shadowMapCascade = false;\r\n\r\n\t// morphs\r\n\r\n\tthis.maxMorphTargets = 8;\r\n\tthis.maxMorphNormals = 4;\r\n\r\n\t// flags\r\n\r\n\tthis.autoScaleCubemaps = true;\r\n\r\n\t// info\r\n\r\n\tthis.info = {\r\n\r\n\t\tmemory: {\r\n\r\n\t\t\tprograms: 0,\r\n\t\t\tgeometries: 0,\r\n\t\t\ttextures: 0\r\n\r\n\t\t},\r\n\r\n\t\trender: {\r\n\r\n\t\t\tcalls: 0,\r\n\t\t\tvertices: 0,\r\n\t\t\tfaces: 0,\r\n\t\t\tpoints: 0\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t// internal properties\r\n\r\n\tvar _this = this,\r\n\r\n\t_programs = [],\r\n\r\n\t// internal state cache\r\n\r\n\t_currentProgram = null,\r\n\t_currentFramebuffer = null,\r\n\t_currentMaterialId = - 1,\r\n\t_currentGeometryProgram = '',\r\n\t_currentCamera = null,\r\n\r\n\t_usedTextureUnits = 0,\r\n\r\n\t_viewportX = 0,\r\n\t_viewportY = 0,\r\n\t_viewportWidth = _canvas.width,\r\n\t_viewportHeight = _canvas.height,\r\n\t_currentWidth = 0,\r\n\t_currentHeight = 0,\r\n\r\n\t// frustum\r\n\r\n\t_frustum = new THREE.Frustum(),\r\n\r\n\t // camera matrices cache\r\n\r\n\t_projScreenMatrix = new THREE.Matrix4(),\r\n\r\n\t_vector3 = new THREE.Vector3(),\r\n\r\n\t// light arrays cache\r\n\r\n\t_direction = new THREE.Vector3(),\r\n\r\n\t_lightsNeedUpdate = true,\r\n\r\n\t_lights = {\r\n\r\n\t\tambient: [ 0, 0, 0 ],\r\n\t\tdirectional: { length: 0, colors:[], positions: [] },\r\n\t\tpoint: { length: 0, colors: [], positions: [], distances: [], decays: [] },\r\n\t\tspot: { length: 0, colors: [], positions: [], distances: [], directions: [], anglesCos: [], exponents: [], decays: [] },\r\n\t\themi: { length: 0, skyColors: [], groundColors: [], positions: [] }\r\n\r\n\t};\r\n\r\n\t// initialize\r\n\r\n\tvar _gl;\r\n\r\n\ttry {\r\n\r\n\t\tvar attributes = {\r\n\t\t\talpha: _alpha,\r\n\t\t\tdepth: _depth,\r\n\t\t\tstencil: _stencil,\r\n\t\t\tantialias: _antialias,\r\n\t\t\tpremultipliedAlpha: _premultipliedAlpha,\r\n\t\t\tpreserveDrawingBuffer: _preserveDrawingBuffer\r\n\t\t};\r\n\r\n\t\t_gl = _context || _canvas.getContext( 'webgl', attributes ) || _canvas.getContext( 'experimental-webgl', attributes );\r\n\r\n\t\tif ( _gl === null ) {\r\n\r\n\t\t\tif ( _canvas.getContext( 'webgl') !== null ) {\r\n\r\n\t\t\t\tthrow 'Error creating WebGL context with your selected attributes.';\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthrow 'Error creating WebGL context.';\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t_canvas.addEventListener( 'webglcontextlost', function ( event ) {\r\n\r\n\t\t\tevent.preventDefault();\r\n\r\n\t\t\tresetGLState();\r\n\t\t\tsetDefaultGLState();\r\n\r\n\t\t\t_webglObjects = {};\r\n\r\n\t\t}, false);\r\n\r\n\t} catch ( error ) {\r\n\r\n\t\tTHREE.error( 'THREE.WebGLRenderer: ' + error );\r\n\r\n\t}\r\n\r\n\tvar state = new THREE.WebGLState( _gl, paramThreeToGL );\r\n\r\n\tif ( _gl.getShaderPrecisionFormat === undefined ) {\r\n\r\n\t\t_gl.getShaderPrecisionFormat = function () {\r\n\r\n\t\t\treturn {\r\n\t\t\t\t'rangeMin': 1,\r\n\t\t\t\t'rangeMax': 1,\r\n\t\t\t\t'precision': 1\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tvar extensions = new THREE.WebGLExtensions( _gl );\r\n\r\n\textensions.get( 'OES_texture_float' );\r\n\textensions.get( 'OES_texture_float_linear' );\r\n\textensions.get( 'OES_texture_half_float' );\r\n\textensions.get( 'OES_texture_half_float_linear' );\r\n\textensions.get( 'OES_standard_derivatives' );\r\n\r\n\tif ( _logarithmicDepthBuffer ) {\r\n\r\n\t\textensions.get( 'EXT_frag_depth' );\r\n\r\n\t}\r\n\r\n\t//\r\n\r\n\tvar glClearColor = function ( r, g, b, a ) {\r\n\r\n\t\tif ( _premultipliedAlpha === true ) {\r\n\r\n\t\t\tr *= a; g *= a; b *= a;\r\n\r\n\t\t}\r\n\r\n\t\t_gl.clearColor( r, g, b, a );\r\n\r\n\t};\r\n\r\n\tvar setDefaultGLState = function () {\r\n\r\n\t\t_gl.clearColor( 0, 0, 0, 1 );\r\n\t\t_gl.clearDepth( 1 );\r\n\t\t_gl.clearStencil( 0 );\r\n\r\n\t\t_gl.enable( _gl.DEPTH_TEST );\r\n\t\t_gl.depthFunc( _gl.LEQUAL );\r\n\r\n\t\t_gl.frontFace( _gl.CCW );\r\n\t\t_gl.cullFace( _gl.BACK );\r\n\t\t_gl.enable( _gl.CULL_FACE );\r\n\r\n\t\t_gl.enable( _gl.BLEND );\r\n\t\t_gl.blendEquation( _gl.FUNC_ADD );\r\n\t\t_gl.blendFunc( _gl.SRC_ALPHA, _gl.ONE_MINUS_SRC_ALPHA );\r\n\r\n\t\t_gl.viewport( _viewportX, _viewportY, _viewportWidth, _viewportHeight );\r\n\r\n\t\tglClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\r\n\r\n\t};\r\n\r\n\tvar resetGLState = function () {\r\n\r\n\t\t_currentProgram = null;\r\n\t\t_currentCamera = null;\r\n\r\n\t\t_currentGeometryProgram = '';\r\n\t\t_currentMaterialId = - 1;\r\n\r\n\t\t_lightsNeedUpdate = true;\r\n\r\n\t\tstate.reset();\r\n\r\n\t};\r\n\r\n\tsetDefaultGLState();\r\n\r\n\tthis.context = _gl;\r\n\tthis.state = state;\r\n\r\n\t// GPU capabilities\r\n\r\n\tvar _maxTextures = _gl.getParameter( _gl.MAX_TEXTURE_IMAGE_UNITS );\r\n\tvar _maxVertexTextures = _gl.getParameter( _gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );\r\n\tvar _maxTextureSize = _gl.getParameter( _gl.MAX_TEXTURE_SIZE );\r\n\tvar _maxCubemapSize = _gl.getParameter( _gl.MAX_CUBE_MAP_TEXTURE_SIZE );\r\n\r\n\tvar _supportsVertexTextures = _maxVertexTextures > 0;\r\n\tvar _supportsBoneTextures = _supportsVertexTextures && extensions.get( 'OES_texture_float' );\r\n\r\n\t//\r\n\r\n\tvar _vertexShaderPrecisionHighpFloat = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.HIGH_FLOAT );\r\n\tvar _vertexShaderPrecisionMediumpFloat = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.MEDIUM_FLOAT );\r\n\r\n\tvar _fragmentShaderPrecisionHighpFloat = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.HIGH_FLOAT );\r\n\tvar _fragmentShaderPrecisionMediumpFloat = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.MEDIUM_FLOAT );\r\n\r\n\tvar getCompressedTextureFormats = ( function () {\r\n\r\n\t\tvar array;\r\n\r\n\t\treturn function () {\r\n\r\n\t\t\tif ( array !== undefined ) {\r\n\r\n\t\t\t\treturn array;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tarray = [];\r\n\r\n\t\t\tif ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) || extensions.get( 'WEBGL_compressed_texture_s3tc' ) ) {\r\n\r\n\t\t\t\tvar formats = _gl.getParameter( _gl.COMPRESSED_TEXTURE_FORMATS );\r\n\r\n\t\t\t\tfor ( var i = 0; i < formats.length; i ++ ) {\r\n\r\n\t\t\t\t\tarray.push( formats[ i ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn array;\r\n\r\n\t\t};\r\n\r\n\t} )();\r\n\r\n\t// clamp precision to maximum available\r\n\r\n\tvar highpAvailable = _vertexShaderPrecisionHighpFloat.precision > 0 && _fragmentShaderPrecisionHighpFloat.precision > 0;\r\n\tvar mediumpAvailable = _vertexShaderPrecisionMediumpFloat.precision > 0 && _fragmentShaderPrecisionMediumpFloat.precision > 0;\r\n\r\n\tif ( _precision === 'highp' && ! highpAvailable ) {\r\n\r\n\t\tif ( mediumpAvailable ) {\r\n\r\n\t\t\t_precision = 'mediump';\r\n\t\t\tTHREE.warn( 'THREE.WebGLRenderer: highp not supported, using mediump.' );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t_precision = 'lowp';\r\n\t\t\tTHREE.warn( 'THREE.WebGLRenderer: highp and mediump not supported, using lowp.' );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tif ( _precision === 'mediump' && ! mediumpAvailable ) {\r\n\r\n\t\t_precision = 'lowp';\r\n\t\tTHREE.warn( 'THREE.WebGLRenderer: mediump not supported, using lowp.' );\r\n\r\n\t}\r\n\r\n\t// Plugins\r\n\r\n\tvar shadowMapPlugin = new THREE.ShadowMapPlugin( this, lights, _webglObjects, _webglObjectsImmediate );\r\n\r\n\tvar spritePlugin = new THREE.SpritePlugin( this, sprites );\r\n\tvar lensFlarePlugin = new THREE.LensFlarePlugin( this, lensFlares );\r\n\r\n\t// API\r\n\r\n\tthis.getContext = function () {\r\n\r\n\t\treturn _gl;\r\n\r\n\t};\r\n\r\n\tthis.forceContextLoss = function () {\r\n\r\n\t\textensions.get( 'WEBGL_lose_context' ).loseContext();\r\n\r\n\t};\r\n\r\n\tthis.supportsVertexTextures = function () {\r\n\r\n\t\treturn _supportsVertexTextures;\r\n\r\n\t};\r\n\r\n\tthis.supportsFloatTextures = function () {\r\n\r\n\t\treturn extensions.get( 'OES_texture_float' );\r\n\r\n\t};\r\n\r\n\tthis.supportsHalfFloatTextures = function () {\r\n\r\n\t\treturn extensions.get( 'OES_texture_half_float' );\r\n\r\n\t};\r\n\r\n\tthis.supportsStandardDerivatives = function () {\r\n\r\n\t\treturn extensions.get( 'OES_standard_derivatives' );\r\n\r\n\t};\r\n\r\n\tthis.supportsCompressedTextureS3TC = function () {\r\n\r\n\t\treturn extensions.get( 'WEBGL_compressed_texture_s3tc' );\r\n\r\n\t};\r\n\r\n\tthis.supportsCompressedTexturePVRTC = function () {\r\n\r\n\t\treturn extensions.get( 'WEBGL_compressed_texture_pvrtc' );\r\n\r\n\t};\r\n\r\n\tthis.supportsBlendMinMax = function () {\r\n\r\n\t\treturn extensions.get( 'EXT_blend_minmax' );\r\n\r\n\t};\r\n\r\n\tthis.getMaxAnisotropy = ( function () {\r\n\r\n\t\tvar value;\r\n\r\n\t\treturn function () {\r\n\r\n\t\t\tif ( value !== undefined ) {\r\n\r\n\t\t\t\treturn value;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar extension = extensions.get( 'EXT_texture_filter_anisotropic' );\r\n\r\n\t\t\tvalue = extension !== null ? _gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT ) : 0;\r\n\r\n\t\t\treturn value;\r\n\r\n\t\t}\r\n\r\n\t} )();\r\n\r\n\tthis.getPrecision = function () {\r\n\r\n\t\treturn _precision;\r\n\r\n\t};\r\n\r\n\tthis.getPixelRatio = function () {\r\n\r\n\t\treturn pixelRatio;\r\n\r\n\t};\r\n\r\n\tthis.setPixelRatio = function ( value ) {\r\n\r\n\t\tpixelRatio = value;\r\n\r\n\t};\r\n\r\n\tthis.setSize = function ( width, height, updateStyle ) {\r\n\r\n\t\t_canvas.width = width * pixelRatio;\r\n\t\t_canvas.height = height * pixelRatio;\r\n\r\n\t\tif ( updateStyle !== false ) {\r\n\r\n\t\t\t_canvas.style.width = width + 'px';\r\n\t\t\t_canvas.style.height = height + 'px';\r\n\r\n\t\t}\r\n\r\n\t\tthis.setViewport( 0, 0, width, height );\r\n\r\n\t};\r\n\r\n\tthis.setViewport = function ( x, y, width, height ) {\r\n\r\n\t\t_viewportX = x * pixelRatio;\r\n\t\t_viewportY = y * pixelRatio;\r\n\r\n\t\t_viewportWidth = width * pixelRatio;\r\n\t\t_viewportHeight = height * pixelRatio;\r\n\r\n\t\t_gl.viewport( _viewportX, _viewportY, _viewportWidth, _viewportHeight );\r\n\r\n\t};\r\n\r\n\tthis.setScissor = function ( x, y, width, height ) {\r\n\r\n\t\t_gl.scissor(\r\n\t\t\tx * pixelRatio,\r\n\t\t\ty * pixelRatio,\r\n\t\t\twidth * pixelRatio,\r\n\t\t\theight * pixelRatio\r\n\t\t);\r\n\r\n\t};\r\n\r\n\tthis.enableScissorTest = function ( enable ) {\r\n\r\n\t\tenable ? _gl.enable( _gl.SCISSOR_TEST ) : _gl.disable( _gl.SCISSOR_TEST );\r\n\r\n\t};\r\n\r\n\t// Clearing\r\n\r\n\tthis.getClearColor = function () {\r\n\r\n\t\treturn _clearColor;\r\n\r\n\t};\r\n\r\n\tthis.setClearColor = function ( color, alpha ) {\r\n\r\n\t\t_clearColor.set( color );\r\n\r\n\t\t_clearAlpha = alpha !== undefined ? alpha : 1;\r\n\r\n\t\tglClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\r\n\r\n\t};\r\n\r\n\tthis.getClearAlpha = function () {\r\n\r\n\t\treturn _clearAlpha;\r\n\r\n\t};\r\n\r\n\tthis.setClearAlpha = function ( alpha ) {\r\n\r\n\t\t_clearAlpha = alpha;\r\n\r\n\t\tglClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\r\n\r\n\t};\r\n\r\n\tthis.clear = function ( color, depth, stencil ) {\r\n\r\n\t\tvar bits = 0;\r\n\r\n\t\tif ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;\r\n\t\tif ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;\r\n\t\tif ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;\r\n\r\n\t\t_gl.clear( bits );\r\n\r\n\t};\r\n\r\n\tthis.clearColor = function () {\r\n\r\n\t\t_gl.clear( _gl.COLOR_BUFFER_BIT );\r\n\r\n\t};\r\n\r\n\tthis.clearDepth = function () {\r\n\r\n\t\t_gl.clear( _gl.DEPTH_BUFFER_BIT );\r\n\r\n\t};\r\n\r\n\tthis.clearStencil = function () {\r\n\r\n\t\t_gl.clear( _gl.STENCIL_BUFFER_BIT );\r\n\r\n\t};\r\n\r\n\tthis.clearTarget = function ( renderTarget, color, depth, stencil ) {\r\n\r\n\t\tthis.setRenderTarget( renderTarget );\r\n\t\tthis.clear( color, depth, stencil );\r\n\r\n\t};\r\n\r\n\t// Reset\r\n\r\n\tthis.resetGLState = resetGLState;\r\n\r\n\t// Buffer allocation\r\n\r\n\tfunction createParticleBuffers ( geometry ) {\r\n\r\n\t\tgeometry.__webglVertexBuffer = _gl.createBuffer();\r\n\t\tgeometry.__webglColorBuffer = _gl.createBuffer();\r\n\r\n\t\t_this.info.memory.geometries ++;\r\n\r\n\t};\r\n\r\n\tfunction createLineBuffers ( geometry ) {\r\n\r\n\t\tgeometry.__webglVertexBuffer = _gl.createBuffer();\r\n\t\tgeometry.__webglColorBuffer = _gl.createBuffer();\r\n\t\tgeometry.__webglLineDistanceBuffer = _gl.createBuffer();\r\n\r\n\t\t_this.info.memory.geometries ++;\r\n\r\n\t};\r\n\r\n\tfunction createMeshBuffers ( geometryGroup ) {\r\n\r\n\t\tgeometryGroup.__webglVertexBuffer = _gl.createBuffer();\r\n\t\tgeometryGroup.__webglNormalBuffer = _gl.createBuffer();\r\n\t\tgeometryGroup.__webglTangentBuffer = _gl.createBuffer();\r\n\t\tgeometryGroup.__webglColorBuffer = _gl.createBuffer();\r\n\t\tgeometryGroup.__webglUVBuffer = _gl.createBuffer();\r\n\t\tgeometryGroup.__webglUV2Buffer = _gl.createBuffer();\r\n\r\n\t\tgeometryGroup.__webglSkinIndicesBuffer = _gl.createBuffer();\r\n\t\tgeometryGroup.__webglSkinWeightsBuffer = _gl.createBuffer();\r\n\r\n\t\tgeometryGroup.__webglFaceBuffer = _gl.createBuffer();\r\n\t\tgeometryGroup.__webglLineBuffer = _gl.createBuffer();\r\n\r\n\t\tvar numMorphTargets = geometryGroup.numMorphTargets;\r\n\r\n\t\tif ( numMorphTargets ) {\r\n\r\n\t\t\tgeometryGroup.__webglMorphTargetsBuffers = [];\r\n\r\n\t\t\tfor ( var m = 0, ml = numMorphTargets; m < ml; m ++ ) {\r\n\r\n\t\t\t\tgeometryGroup.__webglMorphTargetsBuffers.push( _gl.createBuffer() );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvar numMorphNormals = geometryGroup.numMorphNormals;\r\n\r\n\t\tif ( numMorphNormals ) {\r\n\r\n\t\t\tgeometryGroup.__webglMorphNormalsBuffers = [];\r\n\r\n\t\t\tfor ( var m = 0, ml = numMorphNormals; m < ml; m ++ ) {\r\n\r\n\t\t\t\tgeometryGroup.__webglMorphNormalsBuffers.push( _gl.createBuffer() );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t_this.info.memory.geometries ++;\r\n\r\n\t};\r\n\r\n\t// Events\r\n\r\n\tvar onObjectRemoved = function ( event ) {\r\n\r\n\t\tvar object = event.target;\r\n\r\n\t\tobject.traverse( function ( child ) {\r\n\r\n\t\t\tchild.removeEventListener( 'remove', onObjectRemoved );\r\n\r\n\t\t\tremoveObject( child );\r\n\r\n\t\t} );\r\n\r\n\t};\r\n\r\n\tvar onGeometryDispose = function ( event ) {\r\n\r\n\t\tvar geometry = event.target;\r\n\r\n\t\tgeometry.removeEventListener( 'dispose', onGeometryDispose );\r\n\r\n\t\tdeallocateGeometry( geometry );\r\n\r\n\t};\r\n\r\n\tvar onTextureDispose = function ( event ) {\r\n\r\n\t\tvar texture = event.target;\r\n\r\n\t\ttexture.removeEventListener( 'dispose', onTextureDispose );\r\n\r\n\t\tdeallocateTexture( texture );\r\n\r\n\t\t_this.info.memory.textures --;\r\n\r\n\r\n\t};\r\n\r\n\tvar onRenderTargetDispose = function ( event ) {\r\n\r\n\t\tvar renderTarget = event.target;\r\n\r\n\t\trenderTarget.removeEventListener( 'dispose', onRenderTargetDispose );\r\n\r\n\t\tdeallocateRenderTarget( renderTarget );\r\n\r\n\t\t_this.info.memory.textures --;\r\n\r\n\t};\r\n\r\n\tvar onMaterialDispose = function ( event ) {\r\n\r\n\t\tvar material = event.target;\r\n\r\n\t\tmaterial.removeEventListener( 'dispose', onMaterialDispose );\r\n\r\n\t\tdeallocateMaterial( material );\r\n\r\n\t};\r\n\r\n\t// Buffer deallocation\r\n\r\n\tvar deleteBuffers = function ( geometry ) {\r\n\r\n\t\tvar buffers = [\r\n\t\t\t'__webglVertexBuffer',\r\n\t\t\t'__webglNormalBuffer',\r\n\t\t\t'__webglTangentBuffer',\r\n\t\t\t'__webglColorBuffer',\r\n\t\t\t'__webglUVBuffer',\r\n\t\t\t'__webglUV2Buffer',\r\n\r\n\t\t\t'__webglSkinIndicesBuffer',\r\n\t\t\t'__webglSkinWeightsBuffer',\r\n\r\n\t\t\t'__webglFaceBuffer',\r\n\t\t\t'__webglLineBuffer',\r\n\r\n\t\t\t'__webglLineDistanceBuffer'\r\n\t\t];\r\n\r\n\t\tfor ( var i = 0, l = buffers.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar name = buffers[ i ];\r\n\r\n\t\t\tif ( geometry[ name ] !== undefined ) {\r\n\r\n\t\t\t\t_gl.deleteBuffer( geometry[ name ] );\r\n\r\n\t\t\t\tdelete geometry[ name ];\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// custom attributes\r\n\r\n\t\tif ( geometry.__webglCustomAttributesList !== undefined ) {\r\n\r\n\t\t\tfor ( var name in geometry.__webglCustomAttributesList ) {\r\n\r\n\t\t\t\t_gl.deleteBuffer( geometry.__webglCustomAttributesList[ name ].buffer );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tdelete geometry.__webglCustomAttributesList;\r\n\r\n\t\t}\r\n\r\n\t\t_this.info.memory.geometries --;\r\n\r\n\t};\r\n\r\n\tvar deallocateGeometry = function ( geometry ) {\r\n\r\n\t\tdelete geometry.__webglInit;\r\n\r\n\t\tif ( geometry instanceof THREE.BufferGeometry ) {\r\n\r\n\t\t\tfor ( var name in geometry.attributes ) {\r\n\r\n\t\t\t\tvar attribute = geometry.attributes[ name ];\r\n\r\n\t\t\t\tif ( attribute.buffer !== undefined ) {\r\n\r\n\t\t\t\t\t_gl.deleteBuffer( attribute.buffer );\r\n\r\n\t\t\t\t\tdelete attribute.buffer;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_this.info.memory.geometries --;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tvar geometryGroupsList = geometryGroups[ geometry.id ];\r\n\r\n\t\t\tif ( geometryGroupsList !== undefined ) {\r\n\r\n\t\t\t\tfor ( var i = 0, l = geometryGroupsList.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\tvar geometryGroup = geometryGroupsList[ i ];\r\n\r\n\t\t\t\t\tif ( geometryGroup.numMorphTargets !== undefined ) {\r\n\r\n\t\t\t\t\t\tfor ( var m = 0, ml = geometryGroup.numMorphTargets; m < ml; m ++ ) {\r\n\r\n\t\t\t\t\t\t\t_gl.deleteBuffer( geometryGroup.__webglMorphTargetsBuffers[ m ] );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tdelete geometryGroup.__webglMorphTargetsBuffers;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( geometryGroup.numMorphNormals !== undefined ) {\r\n\r\n\t\t\t\t\t\tfor ( var m = 0, ml = geometryGroup.numMorphNormals; m < ml; m ++ ) {\r\n\r\n\t\t\t\t\t\t\t_gl.deleteBuffer( geometryGroup.__webglMorphNormalsBuffers[ m ] );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tdelete geometryGroup.__webglMorphNormalsBuffers;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tdeleteBuffers( geometryGroup );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tdelete geometryGroups[ geometry.id ];\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tdeleteBuffers( geometry );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// TOFIX: Workaround for deleted geometry being currently bound\r\n\r\n\t\t_currentGeometryProgram = '';\r\n\r\n\t};\r\n\r\n\tvar deallocateTexture = function ( texture ) {\r\n\r\n\t\tif ( texture.image && texture.image.__webglTextureCube ) {\r\n\r\n\t\t\t// cube texture\r\n\r\n\t\t\t_gl.deleteTexture( texture.image.__webglTextureCube );\r\n\r\n\t\t\tdelete texture.image.__webglTextureCube;\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// 2D texture\r\n\r\n\t\t\tif ( texture.__webglInit === undefined ) return;\r\n\r\n\t\t\t_gl.deleteTexture( texture.__webglTexture );\r\n\r\n\t\t\tdelete texture.__webglTexture;\r\n\t\t\tdelete texture.__webglInit;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tvar deallocateRenderTarget = function ( renderTarget ) {\r\n\r\n\t\tif ( ! renderTarget || renderTarget.__webglTexture === undefined ) return;\r\n\r\n\t\t_gl.deleteTexture( renderTarget.__webglTexture );\r\n\r\n\t\tdelete renderTarget.__webglTexture;\r\n\r\n\t\tif ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {\r\n\r\n\t\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\t\t_gl.deleteFramebuffer( renderTarget.__webglFramebuffer[ i ] );\r\n\t\t\t\t_gl.deleteRenderbuffer( renderTarget.__webglRenderbuffer[ i ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\t_gl.deleteFramebuffer( renderTarget.__webglFramebuffer );\r\n\t\t\t_gl.deleteRenderbuffer( renderTarget.__webglRenderbuffer );\r\n\r\n\t\t}\r\n\r\n\t\tdelete renderTarget.__webglFramebuffer;\r\n\t\tdelete renderTarget.__webglRenderbuffer;\r\n\r\n\t};\r\n\r\n\tvar deallocateMaterial = function ( material ) {\r\n\r\n\t\tvar program = material.program.program;\r\n\r\n\t\tif ( program === undefined ) return;\r\n\r\n\t\tmaterial.program = undefined;\r\n\r\n\t\t// only deallocate GL program if this was the last use of shared program\r\n\t\t// assumed there is only single copy of any program in the _programs list\r\n\t\t// (that's how it's constructed)\r\n\r\n\t\tvar i, il, programInfo;\r\n\t\tvar deleteProgram = false;\r\n\r\n\t\tfor ( i = 0, il = _programs.length; i < il; i ++ ) {\r\n\r\n\t\t\tprogramInfo = _programs[ i ];\r\n\r\n\t\t\tif ( programInfo.program === program ) {\r\n\r\n\t\t\t\tprogramInfo.usedTimes --;\r\n\r\n\t\t\t\tif ( programInfo.usedTimes === 0 ) {\r\n\r\n\t\t\t\t\tdeleteProgram = true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( deleteProgram === true ) {\r\n\r\n\t\t\t// avoid using array.splice, this is costlier than creating new array from scratch\r\n\r\n\t\t\tvar newPrograms = [];\r\n\r\n\t\t\tfor ( i = 0, il = _programs.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tprogramInfo = _programs[ i ];\r\n\r\n\t\t\t\tif ( programInfo.program !== program ) {\r\n\r\n\t\t\t\t\tnewPrograms.push( programInfo );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_programs = newPrograms;\r\n\r\n\t\t\t_gl.deleteProgram( program );\r\n\r\n\t\t\t_this.info.memory.programs --;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t// Buffer initialization\r\n\r\n\tfunction initCustomAttributes ( object ) {\r\n\r\n\t\tvar geometry = object.geometry;\r\n\t\tvar material = object.material;\r\n\r\n\t\tvar nvertices = geometry.vertices.length;\r\n\r\n\t\tif ( material.attributes ) {\r\n\r\n\t\t\tif ( geometry.__webglCustomAttributesList === undefined ) {\r\n\r\n\t\t\t\tgeometry.__webglCustomAttributesList = [];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var name in material.attributes ) {\r\n\r\n\t\t\t\tvar attribute = material.attributes[ name ];\r\n\r\n\t\t\t\tif ( ! attribute.__webglInitialized || attribute.createUniqueBuffers ) {\r\n\r\n\t\t\t\t\tattribute.__webglInitialized = true;\r\n\r\n\t\t\t\t\tvar size = 1;   // \"f\" and \"i\"\r\n\r\n\t\t\t\t\tif ( attribute.type === 'v2' ) size = 2;\r\n\t\t\t\t\telse if ( attribute.type === 'v3' ) size = 3;\r\n\t\t\t\t\telse if ( attribute.type === 'v4' ) size = 4;\r\n\t\t\t\t\telse if ( attribute.type === 'c'  ) size = 3;\r\n\r\n\t\t\t\t\tattribute.size = size;\r\n\r\n\t\t\t\t\tattribute.array = new Float32Array( nvertices * size );\r\n\r\n\t\t\t\t\tattribute.buffer = _gl.createBuffer();\r\n\t\t\t\t\tattribute.buffer.belongsToAttribute = name;\r\n\r\n\t\t\t\t\tattribute.needsUpdate = true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tgeometry.__webglCustomAttributesList.push( attribute );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction initParticleBuffers ( geometry, object ) {\r\n\r\n\t\tvar nvertices = geometry.vertices.length;\r\n\r\n\t\tgeometry.__vertexArray = new Float32Array( nvertices * 3 );\r\n\t\tgeometry.__colorArray = new Float32Array( nvertices * 3 );\r\n\r\n\t\tgeometry.__webglParticleCount = nvertices;\r\n\r\n\t\tinitCustomAttributes( object );\r\n\r\n\t};\r\n\r\n\tfunction initLineBuffers ( geometry, object ) {\r\n\r\n\t\tvar nvertices = geometry.vertices.length;\r\n\r\n\t\tgeometry.__vertexArray = new Float32Array( nvertices * 3 );\r\n\t\tgeometry.__colorArray = new Float32Array( nvertices * 3 );\r\n\t\tgeometry.__lineDistanceArray = new Float32Array( nvertices * 1 );\r\n\r\n\t\tgeometry.__webglLineCount = nvertices;\r\n\r\n\t\tinitCustomAttributes( object );\r\n\r\n\t};\r\n\r\n\tfunction initMeshBuffers ( geometryGroup, object ) {\r\n\r\n\t\tvar geometry = object.geometry,\r\n\t\t\tfaces3 = geometryGroup.faces3,\r\n\r\n\t\t\tnvertices = faces3.length * 3,\r\n\t\t\tntris     = faces3.length * 1,\r\n\t\t\tnlines    = faces3.length * 3,\r\n\r\n\t\t\tmaterial = getBufferMaterial( object, geometryGroup );\r\n\r\n\t\tgeometryGroup.__vertexArray = new Float32Array( nvertices * 3 );\r\n\t\tgeometryGroup.__normalArray = new Float32Array( nvertices * 3 );\r\n\t\tgeometryGroup.__colorArray = new Float32Array( nvertices * 3 );\r\n\t\tgeometryGroup.__uvArray = new Float32Array( nvertices * 2 );\r\n\r\n\t\tif ( geometry.faceVertexUvs.length > 1 ) {\r\n\r\n\t\t\tgeometryGroup.__uv2Array = new Float32Array( nvertices * 2 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry.hasTangents ) {\r\n\r\n\t\t\tgeometryGroup.__tangentArray = new Float32Array( nvertices * 4 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( object.geometry.skinWeights.length && object.geometry.skinIndices.length ) {\r\n\r\n\t\t\tgeometryGroup.__skinIndexArray = new Float32Array( nvertices * 4 );\r\n\t\t\tgeometryGroup.__skinWeightArray = new Float32Array( nvertices * 4 );\r\n\r\n\t\t}\r\n\r\n\t\tvar UintArray = extensions.get( 'OES_element_index_uint' ) !== null && ntris > 21845 ? Uint32Array : Uint16Array; // 65535 / 3\r\n\r\n\t\tgeometryGroup.__typeArray = UintArray;\r\n\t\tgeometryGroup.__faceArray = new UintArray( ntris * 3 );\r\n\t\tgeometryGroup.__lineArray = new UintArray( nlines * 2 );\r\n\r\n\t\tvar numMorphTargets = geometryGroup.numMorphTargets;\r\n\r\n\t\tif ( numMorphTargets ) {\r\n\r\n\t\t\tgeometryGroup.__morphTargetsArrays = [];\r\n\r\n\t\t\tfor ( var m = 0, ml = numMorphTargets; m < ml; m ++ ) {\r\n\r\n\t\t\t\tgeometryGroup.__morphTargetsArrays.push( new Float32Array( nvertices * 3 ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvar numMorphNormals = geometryGroup.numMorphNormals;\r\n\r\n\t\tif ( numMorphNormals ) {\r\n\r\n\t\t\tgeometryGroup.__morphNormalsArrays = [];\r\n\r\n\t\t\tfor ( var m = 0, ml = numMorphNormals; m < ml; m ++ ) {\r\n\r\n\t\t\t\tgeometryGroup.__morphNormalsArrays.push( new Float32Array( nvertices * 3 ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tgeometryGroup.__webglFaceCount = ntris * 3;\r\n\t\tgeometryGroup.__webglLineCount = nlines * 2;\r\n\r\n\r\n\t\t// custom attributes\r\n\r\n\t\tif ( material.attributes ) {\r\n\r\n\t\t\tif ( geometryGroup.__webglCustomAttributesList === undefined ) {\r\n\r\n\t\t\t\tgeometryGroup.__webglCustomAttributesList = [];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var name in material.attributes ) {\r\n\r\n\t\t\t\t// Do a shallow copy of the attribute object so different geometryGroup chunks use different\r\n\t\t\t\t// attribute buffers which are correctly indexed in the setMeshBuffers function\r\n\r\n\t\t\t\tvar originalAttribute = material.attributes[ name ];\r\n\r\n\t\t\t\tvar attribute = {};\r\n\r\n\t\t\t\tfor ( var property in originalAttribute ) {\r\n\r\n\t\t\t\t\tattribute[ property ] = originalAttribute[ property ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( ! attribute.__webglInitialized || attribute.createUniqueBuffers ) {\r\n\r\n\t\t\t\t\tattribute.__webglInitialized = true;\r\n\r\n\t\t\t\t\tvar size = 1;   // \"f\" and \"i\"\r\n\r\n\t\t\t\t\tif ( attribute.type === 'v2' ) size = 2;\r\n\t\t\t\t\telse if ( attribute.type === 'v3' ) size = 3;\r\n\t\t\t\t\telse if ( attribute.type === 'v4' ) size = 4;\r\n\t\t\t\t\telse if ( attribute.type === 'c'  ) size = 3;\r\n\r\n\t\t\t\t\tattribute.size = size;\r\n\r\n\t\t\t\t\tattribute.array = new Float32Array( nvertices * size );\r\n\r\n\t\t\t\t\tattribute.buffer = _gl.createBuffer();\r\n\t\t\t\t\tattribute.buffer.belongsToAttribute = name;\r\n\r\n\t\t\t\t\toriginalAttribute.needsUpdate = true;\r\n\t\t\t\t\tattribute.__original = originalAttribute;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tgeometryGroup.__webglCustomAttributesList.push( attribute );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tgeometryGroup.__inittedArrays = true;\r\n\r\n\t};\r\n\r\n\tfunction getBufferMaterial( object, geometryGroup ) {\r\n\r\n\t\treturn object.material instanceof THREE.MeshFaceMaterial\r\n\t\t\t ? object.material.materials[ geometryGroup.materialIndex ]\r\n\t\t\t : object.material;\r\n\r\n\t}\r\n\r\n\tfunction materialNeedsFaceNormals ( material ) {\r\n\r\n\t\treturn material instanceof THREE.MeshPhongMaterial === false && material.shading === THREE.FlatShading;\r\n\r\n\t}\r\n\r\n\t// Buffer setting\r\n\r\n\tfunction setParticleBuffers ( geometry, hint, object ) {\r\n\r\n\t\tvar v, c, vertex, offset, color,\r\n\r\n\t\tvertices = geometry.vertices,\r\n\t\tvl = vertices.length,\r\n\r\n\t\tcolors = geometry.colors,\r\n\t\tcl = colors.length,\r\n\r\n\t\tvertexArray = geometry.__vertexArray,\r\n\t\tcolorArray = geometry.__colorArray,\r\n\r\n\t\tdirtyVertices = geometry.verticesNeedUpdate,\r\n\t\tdirtyColors = geometry.colorsNeedUpdate,\r\n\r\n\t\tcustomAttributes = geometry.__webglCustomAttributesList,\r\n\t\ti, il,\r\n\t\tca, cal, value,\r\n\t\tcustomAttribute;\r\n\r\n\t\tif ( dirtyVertices ) {\r\n\r\n\t\t\tfor ( v = 0; v < vl; v ++ ) {\r\n\r\n\t\t\t\tvertex = vertices[ v ];\r\n\r\n\t\t\t\toffset = v * 3;\r\n\r\n\t\t\t\tvertexArray[ offset ]     = vertex.x;\r\n\t\t\t\tvertexArray[ offset + 1 ] = vertex.y;\r\n\t\t\t\tvertexArray[ offset + 2 ] = vertex.z;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglVertexBuffer );\r\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );\r\n\r\n\t\t}\r\n\r\n\t\tif ( dirtyColors ) {\r\n\r\n\t\t\tfor ( c = 0; c < cl; c ++ ) {\r\n\r\n\t\t\t\tcolor = colors[ c ];\r\n\r\n\t\t\t\toffset = c * 3;\r\n\r\n\t\t\t\tcolorArray[ offset ]     = color.r;\r\n\t\t\t\tcolorArray[ offset + 1 ] = color.g;\r\n\t\t\t\tcolorArray[ offset + 2 ] = color.b;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglColorBuffer );\r\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );\r\n\r\n\t\t}\r\n\r\n\t\tif ( customAttributes ) {\r\n\r\n\t\t\tfor ( i = 0, il = customAttributes.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tcustomAttribute = customAttributes[ i ];\r\n\r\n\t\t\t\tif ( customAttribute.needsUpdate && ( customAttribute.boundTo === undefined ||  customAttribute.boundTo === 'vertices' ) ) {\r\n\r\n\t\t\t\t\tcal = customAttribute.value.length;\r\n\r\n\t\t\t\t\toffset = 0;\r\n\r\n\t\t\t\t\tif ( customAttribute.size === 1 ) {\r\n\r\n\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ ca ] = customAttribute.value[ ca ];\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( customAttribute.size === 2 ) {\r\n\r\n\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\r\n\r\n\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset ]   = value.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.y;\r\n\r\n\t\t\t\t\t\t\toffset += 2;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( customAttribute.size === 3 ) {\r\n\r\n\t\t\t\t\t\tif ( customAttribute.type === 'c' ) {\r\n\r\n\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\r\n\r\n\t\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\r\n\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset ]   = value.r;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.g;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2 ] = value.b;\r\n\r\n\t\t\t\t\t\t\t\toffset += 3;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\r\n\r\n\t\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\r\n\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset ]   = value.x;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.y;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2 ] = value.z;\r\n\r\n\t\t\t\t\t\t\t\toffset += 3;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( customAttribute.size === 4 ) {\r\n\r\n\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\r\n\r\n\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset ]      = value.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1  ] = value.y;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2  ] = value.z;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset + 3  ] = value.w;\r\n\r\n\t\t\t\t\t\t\toffset += 4;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );\r\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );\r\n\r\n\t\t\t\tcustomAttribute.needsUpdate = false;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction setLineBuffers ( geometry, hint ) {\r\n\r\n\t\tvar v, c, d, vertex, offset, color,\r\n\r\n\t\tvertices = geometry.vertices,\r\n\t\tcolors = geometry.colors,\r\n\t\tlineDistances = geometry.lineDistances,\r\n\r\n\t\tvl = vertices.length,\r\n\t\tcl = colors.length,\r\n\t\tdl = lineDistances.length,\r\n\r\n\t\tvertexArray = geometry.__vertexArray,\r\n\t\tcolorArray = geometry.__colorArray,\r\n\t\tlineDistanceArray = geometry.__lineDistanceArray,\r\n\r\n\t\tdirtyVertices = geometry.verticesNeedUpdate,\r\n\t\tdirtyColors = geometry.colorsNeedUpdate,\r\n\t\tdirtyLineDistances = geometry.lineDistancesNeedUpdate,\r\n\r\n\t\tcustomAttributes = geometry.__webglCustomAttributesList,\r\n\r\n\t\ti, il,\r\n\t\tca, cal, value,\r\n\t\tcustomAttribute;\r\n\r\n\t\tif ( dirtyVertices ) {\r\n\r\n\t\t\tfor ( v = 0; v < vl; v ++ ) {\r\n\r\n\t\t\t\tvertex = vertices[ v ];\r\n\r\n\t\t\t\toffset = v * 3;\r\n\r\n\t\t\t\tvertexArray[ offset ]     = vertex.x;\r\n\t\t\t\tvertexArray[ offset + 1 ] = vertex.y;\r\n\t\t\t\tvertexArray[ offset + 2 ] = vertex.z;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglVertexBuffer );\r\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );\r\n\r\n\t\t}\r\n\r\n\t\tif ( dirtyColors ) {\r\n\r\n\t\t\tfor ( c = 0; c < cl; c ++ ) {\r\n\r\n\t\t\t\tcolor = colors[ c ];\r\n\r\n\t\t\t\toffset = c * 3;\r\n\r\n\t\t\t\tcolorArray[ offset ]     = color.r;\r\n\t\t\t\tcolorArray[ offset + 1 ] = color.g;\r\n\t\t\t\tcolorArray[ offset + 2 ] = color.b;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglColorBuffer );\r\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );\r\n\r\n\t\t}\r\n\r\n\t\tif ( dirtyLineDistances ) {\r\n\r\n\t\t\tfor ( d = 0; d < dl; d ++ ) {\r\n\r\n\t\t\t\tlineDistanceArray[ d ] = lineDistances[ d ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglLineDistanceBuffer );\r\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, lineDistanceArray, hint );\r\n\r\n\t\t}\r\n\r\n\t\tif ( customAttributes ) {\r\n\r\n\t\t\tfor ( i = 0, il = customAttributes.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tcustomAttribute = customAttributes[ i ];\r\n\r\n\t\t\t\tif ( customAttribute.needsUpdate && ( customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices' ) ) {\r\n\r\n\t\t\t\t\toffset = 0;\r\n\r\n\t\t\t\t\tcal = customAttribute.value.length;\r\n\r\n\t\t\t\t\tif ( customAttribute.size === 1 ) {\r\n\r\n\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ ca ] = customAttribute.value[ ca ];\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( customAttribute.size === 2 ) {\r\n\r\n\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\r\n\r\n\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset ]   = value.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.y;\r\n\r\n\t\t\t\t\t\t\toffset += 2;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( customAttribute.size === 3 ) {\r\n\r\n\t\t\t\t\t\tif ( customAttribute.type === 'c' ) {\r\n\r\n\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\r\n\r\n\t\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\r\n\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset ]   = value.r;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.g;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2 ] = value.b;\r\n\r\n\t\t\t\t\t\t\t\toffset += 3;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\r\n\r\n\t\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\r\n\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset ]   = value.x;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.y;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2 ] = value.z;\r\n\r\n\t\t\t\t\t\t\t\toffset += 3;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( customAttribute.size === 4 ) {\r\n\r\n\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\r\n\r\n\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset ]    = value.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1  ] = value.y;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2  ] = value.z;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset + 3  ] = value.w;\r\n\r\n\t\t\t\t\t\t\toffset += 4;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );\r\n\t\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );\r\n\r\n\t\t\t\t\tcustomAttribute.needsUpdate = false;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction setMeshBuffers( geometryGroup, object, hint, dispose, material ) {\r\n\r\n\t\tif ( ! geometryGroup.__inittedArrays ) {\r\n\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tvar needsFaceNormals = materialNeedsFaceNormals( material );\r\n\r\n\t\tvar f, fl, fi, face,\r\n\t\tvertexNormals, faceNormal,\r\n\t\tvertexColors, faceColor,\r\n\t\tvertexTangents,\r\n\t\tuv, uv2, v1, v2, v3, t1, t2, t3, n1, n2, n3,\r\n\t\tc1, c2, c3,\r\n\t\tsw1, sw2, sw3,\r\n\t\tsi1, si2, si3,\r\n\t\ti, il,\r\n\t\tvn, uvi, uv2i,\r\n\t\tvk, vkl, vka,\r\n\t\tnka, chf, faceVertexNormals,\r\n\r\n\t\tvertexIndex = 0,\r\n\r\n\t\toffset = 0,\r\n\t\toffset_uv = 0,\r\n\t\toffset_uv2 = 0,\r\n\t\toffset_face = 0,\r\n\t\toffset_normal = 0,\r\n\t\toffset_tangent = 0,\r\n\t\toffset_line = 0,\r\n\t\toffset_color = 0,\r\n\t\toffset_skin = 0,\r\n\t\toffset_morphTarget = 0,\r\n\t\toffset_custom = 0,\r\n\r\n\t\tvalue,\r\n\r\n\t\tvertexArray = geometryGroup.__vertexArray,\r\n\t\tuvArray = geometryGroup.__uvArray,\r\n\t\tuv2Array = geometryGroup.__uv2Array,\r\n\t\tnormalArray = geometryGroup.__normalArray,\r\n\t\ttangentArray = geometryGroup.__tangentArray,\r\n\t\tcolorArray = geometryGroup.__colorArray,\r\n\r\n\t\tskinIndexArray = geometryGroup.__skinIndexArray,\r\n\t\tskinWeightArray = geometryGroup.__skinWeightArray,\r\n\r\n\t\tmorphTargetsArrays = geometryGroup.__morphTargetsArrays,\r\n\t\tmorphNormalsArrays = geometryGroup.__morphNormalsArrays,\r\n\r\n\t\tcustomAttributes = geometryGroup.__webglCustomAttributesList,\r\n\t\tcustomAttribute,\r\n\r\n\t\tfaceArray = geometryGroup.__faceArray,\r\n\t\tlineArray = geometryGroup.__lineArray,\r\n\r\n\t\tgeometry = object.geometry, // this is shared for all chunks\r\n\r\n\t\tdirtyVertices = geometry.verticesNeedUpdate,\r\n\t\tdirtyElements = geometry.elementsNeedUpdate,\r\n\t\tdirtyUvs = geometry.uvsNeedUpdate,\r\n\t\tdirtyNormals = geometry.normalsNeedUpdate,\r\n\t\tdirtyTangents = geometry.tangentsNeedUpdate,\r\n\t\tdirtyColors = geometry.colorsNeedUpdate,\r\n\t\tdirtyMorphTargets = geometry.morphTargetsNeedUpdate,\r\n\r\n\t\tvertices = geometry.vertices,\r\n\t\tchunk_faces3 = geometryGroup.faces3,\r\n\t\tobj_faces = geometry.faces,\r\n\r\n\t\tobj_uvs  = geometry.faceVertexUvs[ 0 ],\r\n\t\tobj_uvs2 = geometry.faceVertexUvs[ 1 ],\r\n\r\n\t\tobj_skinIndices = geometry.skinIndices,\r\n\t\tobj_skinWeights = geometry.skinWeights,\r\n\r\n\t\tmorphTargets = geometry.morphTargets,\r\n\t\tmorphNormals = geometry.morphNormals;\r\n\r\n\t\tif ( dirtyVertices ) {\r\n\r\n\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tface = obj_faces[ chunk_faces3[ f ] ];\r\n\r\n\t\t\t\tv1 = vertices[ face.a ];\r\n\t\t\t\tv2 = vertices[ face.b ];\r\n\t\t\t\tv3 = vertices[ face.c ];\r\n\r\n\t\t\t\tvertexArray[ offset ]     = v1.x;\r\n\t\t\t\tvertexArray[ offset + 1 ] = v1.y;\r\n\t\t\t\tvertexArray[ offset + 2 ] = v1.z;\r\n\r\n\t\t\t\tvertexArray[ offset + 3 ] = v2.x;\r\n\t\t\t\tvertexArray[ offset + 4 ] = v2.y;\r\n\t\t\t\tvertexArray[ offset + 5 ] = v2.z;\r\n\r\n\t\t\t\tvertexArray[ offset + 6 ] = v3.x;\r\n\t\t\t\tvertexArray[ offset + 7 ] = v3.y;\r\n\t\t\t\tvertexArray[ offset + 8 ] = v3.z;\r\n\r\n\t\t\t\toffset += 9;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );\r\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );\r\n\r\n\t\t}\r\n\r\n\t\tif ( dirtyMorphTargets ) {\r\n\r\n\t\t\tfor ( vk = 0, vkl = morphTargets.length; vk < vkl; vk ++ ) {\r\n\r\n\t\t\t\toffset_morphTarget = 0;\r\n\r\n\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\t\tchf = chunk_faces3[ f ];\r\n\t\t\t\t\tface = obj_faces[ chf ];\r\n\r\n\t\t\t\t\t// morph positions\r\n\r\n\t\t\t\t\tv1 = morphTargets[ vk ].vertices[ face.a ];\r\n\t\t\t\t\tv2 = morphTargets[ vk ].vertices[ face.b ];\r\n\t\t\t\t\tv3 = morphTargets[ vk ].vertices[ face.c ];\r\n\r\n\t\t\t\t\tvka = morphTargetsArrays[ vk ];\r\n\r\n\t\t\t\t\tvka[ offset_morphTarget ]     = v1.x;\r\n\t\t\t\t\tvka[ offset_morphTarget + 1 ] = v1.y;\r\n\t\t\t\t\tvka[ offset_morphTarget + 2 ] = v1.z;\r\n\r\n\t\t\t\t\tvka[ offset_morphTarget + 3 ] = v2.x;\r\n\t\t\t\t\tvka[ offset_morphTarget + 4 ] = v2.y;\r\n\t\t\t\t\tvka[ offset_morphTarget + 5 ] = v2.z;\r\n\r\n\t\t\t\t\tvka[ offset_morphTarget + 6 ] = v3.x;\r\n\t\t\t\t\tvka[ offset_morphTarget + 7 ] = v3.y;\r\n\t\t\t\t\tvka[ offset_morphTarget + 8 ] = v3.z;\r\n\r\n\t\t\t\t\t// morph normals\r\n\r\n\t\t\t\t\tif ( material.morphNormals ) {\r\n\r\n\t\t\t\t\t\tif ( needsFaceNormals ) {\r\n\r\n\t\t\t\t\t\t\tn1 = morphNormals[ vk ].faceNormals[ chf ];\r\n\t\t\t\t\t\t\tn2 = n1;\r\n\t\t\t\t\t\t\tn3 = n1;\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tfaceVertexNormals = morphNormals[ vk ].vertexNormals[ chf ];\r\n\r\n\t\t\t\t\t\t\tn1 = faceVertexNormals.a;\r\n\t\t\t\t\t\t\tn2 = faceVertexNormals.b;\r\n\t\t\t\t\t\t\tn3 = faceVertexNormals.c;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tnka = morphNormalsArrays[ vk ];\r\n\r\n\t\t\t\t\t\tnka[ offset_morphTarget ]     = n1.x;\r\n\t\t\t\t\t\tnka[ offset_morphTarget + 1 ] = n1.y;\r\n\t\t\t\t\t\tnka[ offset_morphTarget + 2 ] = n1.z;\r\n\r\n\t\t\t\t\t\tnka[ offset_morphTarget + 3 ] = n2.x;\r\n\t\t\t\t\t\tnka[ offset_morphTarget + 4 ] = n2.y;\r\n\t\t\t\t\t\tnka[ offset_morphTarget + 5 ] = n2.z;\r\n\r\n\t\t\t\t\t\tnka[ offset_morphTarget + 6 ] = n3.x;\r\n\t\t\t\t\t\tnka[ offset_morphTarget + 7 ] = n3.y;\r\n\t\t\t\t\t\tnka[ offset_morphTarget + 8 ] = n3.z;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t//\r\n\r\n\t\t\t\t\toffset_morphTarget += 9;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ vk ] );\r\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, morphTargetsArrays[ vk ], hint );\r\n\r\n\t\t\t\tif ( material.morphNormals ) {\r\n\r\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[ vk ] );\r\n\t\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, morphNormalsArrays[ vk ], hint );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( obj_skinWeights.length ) {\r\n\r\n\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tface = obj_faces[ chunk_faces3[ f ] ];\r\n\r\n\t\t\t\t// weights\r\n\r\n\t\t\t\tsw1 = obj_skinWeights[ face.a ];\r\n\t\t\t\tsw2 = obj_skinWeights[ face.b ];\r\n\t\t\t\tsw3 = obj_skinWeights[ face.c ];\r\n\r\n\t\t\t\tskinWeightArray[ offset_skin ]     = sw1.x;\r\n\t\t\t\tskinWeightArray[ offset_skin + 1 ] = sw1.y;\r\n\t\t\t\tskinWeightArray[ offset_skin + 2 ] = sw1.z;\r\n\t\t\t\tskinWeightArray[ offset_skin + 3 ] = sw1.w;\r\n\r\n\t\t\t\tskinWeightArray[ offset_skin + 4 ] = sw2.x;\r\n\t\t\t\tskinWeightArray[ offset_skin + 5 ] = sw2.y;\r\n\t\t\t\tskinWeightArray[ offset_skin + 6 ] = sw2.z;\r\n\t\t\t\tskinWeightArray[ offset_skin + 7 ] = sw2.w;\r\n\r\n\t\t\t\tskinWeightArray[ offset_skin + 8 ]  = sw3.x;\r\n\t\t\t\tskinWeightArray[ offset_skin + 9 ]  = sw3.y;\r\n\t\t\t\tskinWeightArray[ offset_skin + 10 ] = sw3.z;\r\n\t\t\t\tskinWeightArray[ offset_skin + 11 ] = sw3.w;\r\n\r\n\t\t\t\t// indices\r\n\r\n\t\t\t\tsi1 = obj_skinIndices[ face.a ];\r\n\t\t\t\tsi2 = obj_skinIndices[ face.b ];\r\n\t\t\t\tsi3 = obj_skinIndices[ face.c ];\r\n\r\n\t\t\t\tskinIndexArray[ offset_skin ]     = si1.x;\r\n\t\t\t\tskinIndexArray[ offset_skin + 1 ] = si1.y;\r\n\t\t\t\tskinIndexArray[ offset_skin + 2 ] = si1.z;\r\n\t\t\t\tskinIndexArray[ offset_skin + 3 ] = si1.w;\r\n\r\n\t\t\t\tskinIndexArray[ offset_skin + 4 ] = si2.x;\r\n\t\t\t\tskinIndexArray[ offset_skin + 5 ] = si2.y;\r\n\t\t\t\tskinIndexArray[ offset_skin + 6 ] = si2.z;\r\n\t\t\t\tskinIndexArray[ offset_skin + 7 ] = si2.w;\r\n\r\n\t\t\t\tskinIndexArray[ offset_skin + 8 ]  = si3.x;\r\n\t\t\t\tskinIndexArray[ offset_skin + 9 ]  = si3.y;\r\n\t\t\t\tskinIndexArray[ offset_skin + 10 ] = si3.z;\r\n\t\t\t\tskinIndexArray[ offset_skin + 11 ] = si3.w;\r\n\r\n\t\t\t\toffset_skin += 12;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( offset_skin > 0 ) {\r\n\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinIndicesBuffer );\r\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, skinIndexArray, hint );\r\n\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinWeightsBuffer );\r\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, skinWeightArray, hint );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( dirtyColors ) {\r\n\r\n\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tface = obj_faces[ chunk_faces3[ f ] ];\r\n\r\n\t\t\t\tvertexColors = face.vertexColors;\r\n\t\t\t\tfaceColor = face.color;\r\n\r\n\t\t\t\tif ( vertexColors.length === 3 && material.vertexColors === THREE.VertexColors ) {\r\n\r\n\t\t\t\t\tc1 = vertexColors[ 0 ];\r\n\t\t\t\t\tc2 = vertexColors[ 1 ];\r\n\t\t\t\t\tc3 = vertexColors[ 2 ];\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tc1 = faceColor;\r\n\t\t\t\t\tc2 = faceColor;\r\n\t\t\t\t\tc3 = faceColor;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tcolorArray[ offset_color ]     = c1.r;\r\n\t\t\t\tcolorArray[ offset_color + 1 ] = c1.g;\r\n\t\t\t\tcolorArray[ offset_color + 2 ] = c1.b;\r\n\r\n\t\t\t\tcolorArray[ offset_color + 3 ] = c2.r;\r\n\t\t\t\tcolorArray[ offset_color + 4 ] = c2.g;\r\n\t\t\t\tcolorArray[ offset_color + 5 ] = c2.b;\r\n\r\n\t\t\t\tcolorArray[ offset_color + 6 ] = c3.r;\r\n\t\t\t\tcolorArray[ offset_color + 7 ] = c3.g;\r\n\t\t\t\tcolorArray[ offset_color + 8 ] = c3.b;\r\n\r\n\t\t\t\toffset_color += 9;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( offset_color > 0 ) {\r\n\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglColorBuffer );\r\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( dirtyTangents && geometry.hasTangents ) {\r\n\r\n\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tface = obj_faces[ chunk_faces3[ f ] ];\r\n\r\n\t\t\t\tvertexTangents = face.vertexTangents;\r\n\r\n\t\t\t\tt1 = vertexTangents[ 0 ];\r\n\t\t\t\tt2 = vertexTangents[ 1 ];\r\n\t\t\t\tt3 = vertexTangents[ 2 ];\r\n\r\n\t\t\t\ttangentArray[ offset_tangent ]     = t1.x;\r\n\t\t\t\ttangentArray[ offset_tangent + 1 ] = t1.y;\r\n\t\t\t\ttangentArray[ offset_tangent + 2 ] = t1.z;\r\n\t\t\t\ttangentArray[ offset_tangent + 3 ] = t1.w;\r\n\r\n\t\t\t\ttangentArray[ offset_tangent + 4 ] = t2.x;\r\n\t\t\t\ttangentArray[ offset_tangent + 5 ] = t2.y;\r\n\t\t\t\ttangentArray[ offset_tangent + 6 ] = t2.z;\r\n\t\t\t\ttangentArray[ offset_tangent + 7 ] = t2.w;\r\n\r\n\t\t\t\ttangentArray[ offset_tangent + 8 ]  = t3.x;\r\n\t\t\t\ttangentArray[ offset_tangent + 9 ]  = t3.y;\r\n\t\t\t\ttangentArray[ offset_tangent + 10 ] = t3.z;\r\n\t\t\t\ttangentArray[ offset_tangent + 11 ] = t3.w;\r\n\r\n\t\t\t\toffset_tangent += 12;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglTangentBuffer );\r\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, tangentArray, hint );\r\n\r\n\t\t}\r\n\r\n\t\tif ( dirtyNormals ) {\r\n\r\n\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tface = obj_faces[ chunk_faces3[ f ] ];\r\n\r\n\t\t\t\tvertexNormals = face.vertexNormals;\r\n\t\t\t\tfaceNormal = face.normal;\r\n\r\n\t\t\t\tif ( vertexNormals.length === 3 && needsFaceNormals === false ) {\r\n\r\n\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\t\t\t\tvn = vertexNormals[ i ];\r\n\r\n\t\t\t\t\t\tnormalArray[ offset_normal ]     = vn.x;\r\n\t\t\t\t\t\tnormalArray[ offset_normal + 1 ] = vn.y;\r\n\t\t\t\t\t\tnormalArray[ offset_normal + 2 ] = vn.z;\r\n\r\n\t\t\t\t\t\toffset_normal += 3;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\t\t\t\tnormalArray[ offset_normal ]     = faceNormal.x;\r\n\t\t\t\t\t\tnormalArray[ offset_normal + 1 ] = faceNormal.y;\r\n\t\t\t\t\t\tnormalArray[ offset_normal + 2 ] = faceNormal.z;\r\n\r\n\t\t\t\t\t\toffset_normal += 3;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglNormalBuffer );\r\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, normalArray, hint );\r\n\r\n\t\t}\r\n\r\n\t\tif ( dirtyUvs && obj_uvs ) {\r\n\r\n\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tfi = chunk_faces3[ f ];\r\n\r\n\t\t\t\tuv = obj_uvs[ fi ];\r\n\r\n\t\t\t\tif ( uv === undefined ) continue;\r\n\r\n\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\t\t\tuvi = uv[ i ];\r\n\r\n\t\t\t\t\tuvArray[ offset_uv ]     = uvi.x;\r\n\t\t\t\t\tuvArray[ offset_uv + 1 ] = uvi.y;\r\n\r\n\t\t\t\t\toffset_uv += 2;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( offset_uv > 0 ) {\r\n\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUVBuffer );\r\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, uvArray, hint );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( dirtyUvs && obj_uvs2 ) {\r\n\r\n\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tfi = chunk_faces3[ f ];\r\n\r\n\t\t\t\tuv2 = obj_uvs2[ fi ];\r\n\r\n\t\t\t\tif ( uv2 === undefined ) continue;\r\n\r\n\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\t\t\tuv2i = uv2[ i ];\r\n\r\n\t\t\t\t\tuv2Array[ offset_uv2 ]     = uv2i.x;\r\n\t\t\t\t\tuv2Array[ offset_uv2 + 1 ] = uv2i.y;\r\n\r\n\t\t\t\t\toffset_uv2 += 2;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( offset_uv2 > 0 ) {\r\n\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUV2Buffer );\r\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, uv2Array, hint );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( dirtyElements ) {\r\n\r\n\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tfaceArray[ offset_face ]   = vertexIndex;\r\n\t\t\t\tfaceArray[ offset_face + 1 ] = vertexIndex + 1;\r\n\t\t\t\tfaceArray[ offset_face + 2 ] = vertexIndex + 2;\r\n\r\n\t\t\t\toffset_face += 3;\r\n\r\n\t\t\t\tlineArray[ offset_line ]     = vertexIndex;\r\n\t\t\t\tlineArray[ offset_line + 1 ] = vertexIndex + 1;\r\n\r\n\t\t\t\tlineArray[ offset_line + 2 ] = vertexIndex;\r\n\t\t\t\tlineArray[ offset_line + 3 ] = vertexIndex + 2;\r\n\r\n\t\t\t\tlineArray[ offset_line + 4 ] = vertexIndex + 1;\r\n\t\t\t\tlineArray[ offset_line + 5 ] = vertexIndex + 2;\r\n\r\n\t\t\t\toffset_line += 6;\r\n\r\n\t\t\t\tvertexIndex += 3;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglFaceBuffer );\r\n\t\t\t_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, faceArray, hint );\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglLineBuffer );\r\n\t\t\t_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, lineArray, hint );\r\n\r\n\t\t}\r\n\r\n\t\tif ( customAttributes ) {\r\n\r\n\t\t\tfor ( i = 0, il = customAttributes.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tcustomAttribute = customAttributes[ i ];\r\n\r\n\t\t\t\tif ( ! customAttribute.__original.needsUpdate ) continue;\r\n\r\n\t\t\t\toffset_custom = 0;\r\n\r\n\t\t\t\tif ( customAttribute.size === 1 ) {\r\n\r\n\t\t\t\t\tif ( customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices' ) {\r\n\r\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\t\t\t\tface = obj_faces[ chunk_faces3[ f ] ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ]     = customAttribute.value[ face.a ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = customAttribute.value[ face.b ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = customAttribute.value[ face.c ];\r\n\r\n\t\t\t\t\t\t\toffset_custom += 3;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( customAttribute.boundTo === 'faces' ) {\r\n\r\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\t\t\t\tvalue = customAttribute.value[ chunk_faces3[ f ] ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ]     = value;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = value;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = value;\r\n\r\n\t\t\t\t\t\t\toffset_custom += 3;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else if ( customAttribute.size === 2 ) {\r\n\r\n\t\t\t\t\tif ( customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices' ) {\r\n\r\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\t\t\t\tface = obj_faces[ chunk_faces3[ f ] ];\r\n\r\n\t\t\t\t\t\t\tv1 = customAttribute.value[ face.a ];\r\n\t\t\t\t\t\t\tv2 = customAttribute.value[ face.b ];\r\n\t\t\t\t\t\t\tv3 = customAttribute.value[ face.c ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ]     = v1.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = v1.y;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = v2.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3 ] = v2.y;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4 ] = v3.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5 ] = v3.y;\r\n\r\n\t\t\t\t\t\t\toffset_custom += 6;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( customAttribute.boundTo === 'faces' ) {\r\n\r\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\t\t\t\tvalue = customAttribute.value[ chunk_faces3[ f ] ];\r\n\r\n\t\t\t\t\t\t\tv1 = value;\r\n\t\t\t\t\t\t\tv2 = value;\r\n\t\t\t\t\t\t\tv3 = value;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ]     = v1.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = v1.y;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = v2.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3 ] = v2.y;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4 ] = v3.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5 ] = v3.y;\r\n\r\n\t\t\t\t\t\t\toffset_custom += 6;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else if ( customAttribute.size === 3 ) {\r\n\r\n\t\t\t\t\tvar pp;\r\n\r\n\t\t\t\t\tif ( customAttribute.type === 'c' ) {\r\n\r\n\t\t\t\t\t\tpp = [ 'r', 'g', 'b' ];\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tpp = [ 'x', 'y', 'z' ];\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices' ) {\r\n\r\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\t\t\t\tface = obj_faces[ chunk_faces3[ f ] ];\r\n\r\n\t\t\t\t\t\t\tv1 = customAttribute.value[ face.a ];\r\n\t\t\t\t\t\t\tv2 = customAttribute.value[ face.b ];\r\n\t\t\t\t\t\t\tv3 = customAttribute.value[ face.c ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ]     = v1[ pp[ 0 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];\r\n\r\n\t\t\t\t\t\t\toffset_custom += 9;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( customAttribute.boundTo === 'faces' ) {\r\n\r\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\t\t\t\tvalue = customAttribute.value[ chunk_faces3[ f ] ];\r\n\r\n\t\t\t\t\t\t\tv1 = value;\r\n\t\t\t\t\t\t\tv2 = value;\r\n\t\t\t\t\t\t\tv3 = value;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ]     = v1[ pp[ 0 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];\r\n\r\n\t\t\t\t\t\t\toffset_custom += 9;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( customAttribute.boundTo === 'faceVertices' ) {\r\n\r\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\t\t\t\tvalue = customAttribute.value[ chunk_faces3[ f ] ];\r\n\r\n\t\t\t\t\t\t\tv1 = value[ 0 ];\r\n\t\t\t\t\t\t\tv2 = value[ 1 ];\r\n\t\t\t\t\t\t\tv3 = value[ 2 ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ]     = v1[ pp[ 0 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];\r\n\r\n\t\t\t\t\t\t\toffset_custom += 9;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else if ( customAttribute.size === 4 ) {\r\n\r\n\t\t\t\t\tif ( customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices' ) {\r\n\r\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\t\t\t\tface = obj_faces[ chunk_faces3[ f ] ];\r\n\r\n\t\t\t\t\t\t\tv1 = customAttribute.value[ face.a ];\r\n\t\t\t\t\t\t\tv2 = customAttribute.value[ face.b ];\r\n\t\t\t\t\t\t\tv3 = customAttribute.value[ face.c ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom  ]   = v1.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1  ] = v1.y;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2  ] = v1.z;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3  ] = v1.w;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4  ] = v2.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5  ] = v2.y;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6  ] = v2.z;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7  ] = v2.w;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 8  ] = v3.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 9  ] = v3.y;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 10 ] = v3.z;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 11 ] = v3.w;\r\n\r\n\t\t\t\t\t\t\toffset_custom += 12;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( customAttribute.boundTo === 'faces' ) {\r\n\r\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\t\t\t\tvalue = customAttribute.value[ chunk_faces3[ f ] ];\r\n\r\n\t\t\t\t\t\t\tv1 = value;\r\n\t\t\t\t\t\t\tv2 = value;\r\n\t\t\t\t\t\t\tv3 = value;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom  ]   = v1.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1  ] = v1.y;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2  ] = v1.z;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3  ] = v1.w;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4  ] = v2.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5  ] = v2.y;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6  ] = v2.z;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7  ] = v2.w;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 8  ] = v3.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 9  ] = v3.y;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 10 ] = v3.z;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 11 ] = v3.w;\r\n\r\n\t\t\t\t\t\t\toffset_custom += 12;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( customAttribute.boundTo === 'faceVertices' ) {\r\n\r\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\t\t\t\tvalue = customAttribute.value[ chunk_faces3[ f ] ];\r\n\r\n\t\t\t\t\t\t\tv1 = value[ 0 ];\r\n\t\t\t\t\t\t\tv2 = value[ 1 ];\r\n\t\t\t\t\t\t\tv3 = value[ 2 ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom  ]   = v1.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1  ] = v1.y;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2  ] = v1.z;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3  ] = v1.w;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4  ] = v2.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5  ] = v2.y;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6  ] = v2.z;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7  ] = v2.w;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 8  ] = v3.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 9  ] = v3.y;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 10 ] = v3.z;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 11 ] = v3.w;\r\n\r\n\t\t\t\t\t\t\toffset_custom += 12;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );\r\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( dispose ) {\r\n\r\n\t\t\tdelete geometryGroup.__inittedArrays;\r\n\t\t\tdelete geometryGroup.__colorArray;\r\n\t\t\tdelete geometryGroup.__normalArray;\r\n\t\t\tdelete geometryGroup.__tangentArray;\r\n\t\t\tdelete geometryGroup.__uvArray;\r\n\t\t\tdelete geometryGroup.__uv2Array;\r\n\t\t\tdelete geometryGroup.__faceArray;\r\n\t\t\tdelete geometryGroup.__vertexArray;\r\n\t\t\tdelete geometryGroup.__lineArray;\r\n\t\t\tdelete geometryGroup.__skinIndexArray;\r\n\t\t\tdelete geometryGroup.__skinWeightArray;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t// Buffer rendering\r\n\r\n\tthis.renderBufferImmediate = function ( object, program, material ) {\r\n\r\n\t\tstate.initAttributes();\r\n\r\n\t\tif ( object.hasPositions && ! object.__webglVertexBuffer ) object.__webglVertexBuffer = _gl.createBuffer();\r\n\t\tif ( object.hasNormals && ! object.__webglNormalBuffer ) object.__webglNormalBuffer = _gl.createBuffer();\r\n\t\tif ( object.hasUvs && ! object.__webglUvBuffer ) object.__webglUvBuffer = _gl.createBuffer();\r\n\t\tif ( object.hasColors && ! object.__webglColorBuffer ) object.__webglColorBuffer = _gl.createBuffer();\r\n\r\n\t\tif ( object.hasPositions ) {\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglVertexBuffer );\r\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );\r\n\r\n\t\t\tstate.enableAttribute( program.attributes.position );\r\n\r\n\t\t\t_gl.vertexAttribPointer( program.attributes.position, 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( object.hasNormals ) {\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglNormalBuffer );\r\n\r\n\t\t\tif ( material instanceof THREE.MeshPhongMaterial === false &&\r\n\t\t\t\t   material.shading === THREE.FlatShading ) {\r\n\r\n\t\t\t\tvar nx, ny, nz,\r\n\t\t\t\t\tnax, nbx, ncx, nay, nby, ncy, naz, nbz, ncz,\r\n\t\t\t\t\tnormalArray,\r\n\t\t\t\t\ti, il = object.count * 3;\r\n\r\n\t\t\t\tfor ( i = 0; i < il; i += 9 ) {\r\n\r\n\t\t\t\t\tnormalArray = object.normalArray;\r\n\r\n\t\t\t\t\tnax  = normalArray[ i ];\r\n\t\t\t\t\tnay  = normalArray[ i + 1 ];\r\n\t\t\t\t\tnaz  = normalArray[ i + 2 ];\r\n\r\n\t\t\t\t\tnbx  = normalArray[ i + 3 ];\r\n\t\t\t\t\tnby  = normalArray[ i + 4 ];\r\n\t\t\t\t\tnbz  = normalArray[ i + 5 ];\r\n\r\n\t\t\t\t\tncx  = normalArray[ i + 6 ];\r\n\t\t\t\t\tncy  = normalArray[ i + 7 ];\r\n\t\t\t\t\tncz  = normalArray[ i + 8 ];\r\n\r\n\t\t\t\t\tnx = ( nax + nbx + ncx ) / 3;\r\n\t\t\t\t\tny = ( nay + nby + ncy ) / 3;\r\n\t\t\t\t\tnz = ( naz + nbz + ncz ) / 3;\r\n\r\n\t\t\t\t\tnormalArray[ i ]   = nx;\r\n\t\t\t\t\tnormalArray[ i + 1 ] = ny;\r\n\t\t\t\t\tnormalArray[ i + 2 ] = nz;\r\n\r\n\t\t\t\t\tnormalArray[ i + 3 ] = nx;\r\n\t\t\t\t\tnormalArray[ i + 4 ] = ny;\r\n\t\t\t\t\tnormalArray[ i + 5 ] = nz;\r\n\r\n\t\t\t\t\tnormalArray[ i + 6 ] = nx;\r\n\t\t\t\t\tnormalArray[ i + 7 ] = ny;\r\n\t\t\t\t\tnormalArray[ i + 8 ] = nz;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );\r\n\r\n\t\t\tstate.enableAttribute( program.attributes.normal );\r\n\r\n\t\t\t_gl.vertexAttribPointer( program.attributes.normal, 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( object.hasUvs && material.map ) {\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglUvBuffer );\r\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );\r\n\r\n\t\t\tstate.enableAttribute( program.attributes.uv );\r\n\r\n\t\t\t_gl.vertexAttribPointer( program.attributes.uv, 2, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( object.hasColors && material.vertexColors !== THREE.NoColors ) {\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglColorBuffer );\r\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );\r\n\r\n\t\t\tstate.enableAttribute( program.attributes.color );\r\n\r\n\t\t\t_gl.vertexAttribPointer( program.attributes.color, 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t}\r\n\r\n\t\tstate.disableUnusedAttributes();\r\n\r\n\t\t_gl.drawArrays( _gl.TRIANGLES, 0, object.count );\r\n\r\n\t\tobject.count = 0;\r\n\r\n\t};\r\n\r\n\tfunction setupVertexAttributes( material, program, geometry, startIndex ) {\r\n\r\n\t\tvar geometryAttributes = geometry.attributes;\r\n\r\n\t\tvar programAttributes = program.attributes;\r\n\t\tvar programAttributesKeys = program.attributesKeys;\r\n\r\n\t\tfor ( var i = 0, l = programAttributesKeys.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar key = programAttributesKeys[ i ];\r\n\t\t\tvar programAttribute = programAttributes[ key ];\r\n\r\n\t\t\tif ( programAttribute >= 0 ) {\r\n\r\n\t\t\t\tvar geometryAttribute = geometryAttributes[ key ];\r\n\r\n\t\t\t\tif ( geometryAttribute !== undefined ) {\r\n\r\n\t\t\t\t\tvar size = geometryAttribute.itemSize;\r\n\r\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryAttribute.buffer );\r\n\r\n\t\t\t\t\tstate.enableAttribute( programAttribute );\r\n\r\n\t\t\t\t\t_gl.vertexAttribPointer( programAttribute, size, _gl.FLOAT, false, 0, startIndex * size * 4 ); // 4 bytes per Float32\r\n\r\n\t\t\t\t} else if ( material.defaultAttributeValues !== undefined ) {\r\n\r\n\t\t\t\t\tif ( material.defaultAttributeValues[ key ].length === 2 ) {\r\n\r\n\t\t\t\t\t\t_gl.vertexAttrib2fv( programAttribute, material.defaultAttributeValues[ key ] );\r\n\r\n\t\t\t\t\t} else if ( material.defaultAttributeValues[ key ].length === 3 ) {\r\n\r\n\t\t\t\t\t\t_gl.vertexAttrib3fv( programAttribute, material.defaultAttributeValues[ key ] );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tstate.disableUnusedAttributes();\r\n\r\n\t}\r\n\r\n\tthis.renderBufferDirect = function ( camera, lights, fog, material, geometry, object ) {\r\n\r\n\t\tif ( material.visible === false ) return;\r\n\r\n\t\tupdateObject( object );\r\n\r\n\t\tvar program = setProgram( camera, lights, fog, material, object );\r\n\r\n\t\tvar updateBuffers = false,\r\n\t\t\twireframeBit = material.wireframe ? 1 : 0,\r\n\t\t\tgeometryProgram = 'direct_' + geometry.id + '_' + program.id + '_' + wireframeBit;\r\n\r\n\t\tif ( geometryProgram !== _currentGeometryProgram ) {\r\n\r\n\t\t\t_currentGeometryProgram = geometryProgram;\r\n\t\t\tupdateBuffers = true;\r\n\r\n\t\t}\r\n\r\n\t\tif ( updateBuffers ) {\r\n\r\n\t\t\tstate.initAttributes();\r\n\r\n\t\t}\r\n\r\n\t\t// render mesh\r\n\r\n\t\tif ( object instanceof THREE.Mesh ) {\r\n\r\n\t\t\tvar mode = material.wireframe === true ? _gl.LINES : _gl.TRIANGLES;\r\n\r\n\t\t\tvar index = geometry.attributes.index;\r\n\r\n\t\t\tif ( index ) {\r\n\r\n\t\t\t\t// indexed triangles\r\n\r\n\t\t\t\tvar type, size;\r\n\r\n\t\t\t\tif ( index.array instanceof Uint32Array && extensions.get( 'OES_element_index_uint' ) ) {\r\n\r\n\t\t\t\t\ttype = _gl.UNSIGNED_INT;\r\n\t\t\t\t\tsize = 4;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\ttype = _gl.UNSIGNED_SHORT;\r\n\t\t\t\t\tsize = 2;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar offsets = geometry.offsets;\r\n\r\n\t\t\t\tif ( offsets.length === 0 ) {\r\n\r\n\t\t\t\t\tif ( updateBuffers ) {\r\n\r\n\t\t\t\t\t\tsetupVertexAttributes( material, program, geometry, 0 );\r\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t_gl.drawElements( mode, index.array.length, type, 0 );\r\n\r\n\t\t\t\t\t_this.info.render.calls ++;\r\n\t\t\t\t\t_this.info.render.vertices += index.array.length; // not really true, here vertices can be shared\r\n\t\t\t\t\t_this.info.render.faces += index.array.length / 3;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// if there is more than 1 chunk\r\n\t\t\t\t\t// must set attribute pointers to use new offsets for each chunk\r\n\t\t\t\t\t// even if geometry and materials didn't change\r\n\r\n\t\t\t\t\tupdateBuffers = true;\r\n\r\n\t\t\t\t\tfor ( var i = 0, il = offsets.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\t\tvar startIndex = offsets[ i ].index;\r\n\r\n\t\t\t\t\t\tif ( updateBuffers ) {\r\n\r\n\t\t\t\t\t\t\tsetupVertexAttributes( material, program, geometry, startIndex );\r\n\t\t\t\t\t\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// render indexed triangles\r\n\r\n\t\t\t\t\t\t_gl.drawElements( mode, offsets[ i ].count, type, offsets[ i ].start * size );\r\n\r\n\t\t\t\t\t\t_this.info.render.calls ++;\r\n\t\t\t\t\t\t_this.info.render.vertices += offsets[ i ].count; // not really true, here vertices can be shared\r\n\t\t\t\t\t\t_this.info.render.faces += offsets[ i ].count / 3;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// non-indexed triangles\r\n\r\n\t\t\t\tif ( updateBuffers ) {\r\n\r\n\t\t\t\t\tsetupVertexAttributes( material, program, geometry, 0 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar position = geometry.attributes[ 'position' ];\r\n\r\n\t\t\t\t// render non-indexed triangles\r\n\r\n\t\t\t\t_gl.drawArrays( mode, 0, position.array.length / position.itemSize );\r\n\r\n\t\t\t\t_this.info.render.calls ++;\r\n\t\t\t\t_this.info.render.vertices += position.array.length / position.itemSize;\r\n\t\t\t\t_this.info.render.faces += position.array.length / ( 3 * position.itemSize );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( object instanceof THREE.PointCloud ) {\r\n\r\n\t\t\t// render particles\r\n\r\n\t\t\tvar mode = _gl.POINTS;\r\n\r\n\t\t\tvar index = geometry.attributes.index;\r\n\r\n\t\t\tif ( index ) {\r\n\r\n\t\t\t\t// indexed points\r\n\r\n\t\t\t\tvar type, size;\r\n\r\n\t\t\t\tif ( index.array instanceof Uint32Array && extensions.get( 'OES_element_index_uint' ) ) {\r\n\r\n\t\t\t\t\ttype = _gl.UNSIGNED_INT;\r\n\t\t\t\t\tsize = 4;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\ttype = _gl.UNSIGNED_SHORT;\r\n\t\t\t\t\tsize = 2;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar offsets = geometry.offsets;\r\n\r\n\t\t\t\tif ( offsets.length === 0 ) {\r\n\r\n\t\t\t\t\tif ( updateBuffers ) {\r\n\r\n\t\t\t\t\t\tsetupVertexAttributes( material, program, geometry, 0 );\r\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t_gl.drawElements( mode, index.array.length, type, 0);\r\n\r\n\t\t\t\t\t_this.info.render.calls ++;\r\n\t\t\t\t\t_this.info.render.points += index.array.length;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// if there is more than 1 chunk\r\n\t\t\t\t\t// must set attribute pointers to use new offsets for each chunk\r\n\t\t\t\t\t// even if geometry and materials didn't change\r\n\r\n\t\t\t\t\tif ( offsets.length > 1 ) updateBuffers = true;\r\n\r\n\t\t\t\t\tfor ( var i = 0, il = offsets.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\t\tvar startIndex = offsets[ i ].index;\r\n\r\n\t\t\t\t\t\tif ( updateBuffers ) {\r\n\r\n\t\t\t\t\t\t\tsetupVertexAttributes( material, program, geometry, startIndex );\r\n\t\t\t\t\t\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// render indexed points\r\n\r\n\t\t\t\t\t\t_gl.drawElements( mode, offsets[ i ].count, type, offsets[ i ].start * size );\r\n\r\n\t\t\t\t\t\t_this.info.render.calls ++;\r\n\t\t\t\t\t\t_this.info.render.points += offsets[ i ].count;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// non-indexed points\r\n\r\n\t\t\t\tif ( updateBuffers ) {\r\n\r\n\t\t\t\t\tsetupVertexAttributes( material, program, geometry, 0 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar position = geometry.attributes.position;\r\n\t\t\t\tvar offsets = geometry.offsets;\r\n\r\n\t\t\t\tif ( offsets.length === 0 ) {\r\n\r\n\t\t\t\t\t_gl.drawArrays( mode, 0, position.array.length / 3 );\r\n\r\n\t\t\t\t\t_this.info.render.calls ++;\r\n\t\t\t\t\t_this.info.render.points += position.array.length / 3;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tfor ( var i = 0, il = offsets.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\t\t_gl.drawArrays( mode, offsets[ i ].index, offsets[ i ].count );\r\n\r\n\t\t\t\t\t\t_this.info.render.calls ++;\r\n\t\t\t\t\t\t_this.info.render.points += offsets[ i ].count;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( object instanceof THREE.Line ) {\r\n\r\n\t\t\tvar mode = ( object.mode === THREE.LineStrip ) ? _gl.LINE_STRIP : _gl.LINES;\r\n\r\n\t\t\tstate.setLineWidth( material.linewidth * pixelRatio );\r\n\r\n\t\t\tvar index = geometry.attributes.index;\r\n\r\n\t\t\tif ( index ) {\r\n\r\n\t\t\t\t// indexed lines\r\n\r\n\t\t\t\tvar type, size;\r\n\r\n\t\t\t\tif ( index.array instanceof Uint32Array ) {\r\n\r\n\t\t\t\t\ttype = _gl.UNSIGNED_INT;\r\n\t\t\t\t\tsize = 4;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\ttype = _gl.UNSIGNED_SHORT;\r\n\t\t\t\t\tsize = 2;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar offsets = geometry.offsets;\r\n\r\n\t\t\t\tif ( offsets.length === 0 ) {\r\n\r\n\t\t\t\t\tif ( updateBuffers ) {\r\n\r\n\t\t\t\t\t\tsetupVertexAttributes( material, program, geometry, 0 );\r\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t_gl.drawElements( mode, index.array.length, type, 0 ); // 2 bytes per Uint16Array\r\n\r\n\t\t\t\t\t_this.info.render.calls ++;\r\n\t\t\t\t\t_this.info.render.vertices += index.array.length; // not really true, here vertices can be shared\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// if there is more than 1 chunk\r\n\t\t\t\t\t// must set attribute pointers to use new offsets for each chunk\r\n\t\t\t\t\t// even if geometry and materials didn't change\r\n\r\n\t\t\t\t\tif ( offsets.length > 1 ) updateBuffers = true;\r\n\r\n\t\t\t\t\tfor ( var i = 0, il = offsets.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\t\tvar startIndex = offsets[ i ].index;\r\n\r\n\t\t\t\t\t\tif ( updateBuffers ) {\r\n\r\n\t\t\t\t\t\t\tsetupVertexAttributes( material, program, geometry, startIndex );\r\n\t\t\t\t\t\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// render indexed lines\r\n\r\n\t\t\t\t\t\t_gl.drawElements( mode, offsets[ i ].count, type, offsets[ i ].start * size ); // 2 bytes per Uint16Array\r\n\r\n\t\t\t\t\t\t_this.info.render.calls ++;\r\n\t\t\t\t\t\t_this.info.render.vertices += offsets[ i ].count; // not really true, here vertices can be shared\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// non-indexed lines\r\n\r\n\t\t\t\tif ( updateBuffers ) {\r\n\r\n\t\t\t\t\tsetupVertexAttributes( material, program, geometry, 0 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar position = geometry.attributes.position;\r\n\t\t\t\tvar offsets = geometry.offsets;\r\n\r\n\t\t\t\tif ( offsets.length === 0 ) {\r\n\r\n\t\t\t\t\t_gl.drawArrays( mode, 0, position.array.length / 3 );\r\n\r\n\t\t\t\t\t_this.info.render.calls ++;\r\n\t\t\t\t\t_this.info.render.vertices += position.array.length / 3;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tfor ( var i = 0, il = offsets.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\t\t_gl.drawArrays( mode, offsets[ i ].index, offsets[ i ].count );\r\n\r\n\t\t\t\t\t\t_this.info.render.calls ++;\r\n\t\t\t\t\t\t_this.info.render.vertices += offsets[ i ].count;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.renderBuffer = function ( camera, lights, fog, material, geometryGroup, object ) {\r\n\r\n\t\tif ( material.visible === false ) return;\r\n\r\n\t\tupdateObject( object );\r\n\r\n\t\tvar program = setProgram( camera, lights, fog, material, object );\r\n\r\n\t\tvar attributes = program.attributes;\r\n\r\n\t\tvar updateBuffers = false,\r\n\t\t\twireframeBit = material.wireframe ? 1 : 0,\r\n\t\t\tgeometryProgram = geometryGroup.id + '_' + program.id + '_' + wireframeBit;\r\n\r\n\t\tif ( geometryProgram !== _currentGeometryProgram ) {\r\n\r\n\t\t\t_currentGeometryProgram = geometryProgram;\r\n\t\t\tupdateBuffers = true;\r\n\r\n\t\t}\r\n\r\n\t\tif ( updateBuffers ) {\r\n\r\n\t\t\tstate.initAttributes();\r\n\r\n\t\t}\r\n\r\n\t\t// vertices\r\n\r\n\t\tif ( ! material.morphTargets && attributes.position >= 0 ) {\r\n\r\n\t\t\tif ( updateBuffers ) {\r\n\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );\r\n\r\n\t\t\t\tstate.enableAttribute( attributes.position );\r\n\r\n\t\t\t\t_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tif ( object.morphTargetBase ) {\r\n\r\n\t\t\t\tsetupMorphTargets( material, geometryGroup, object );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\r\n\t\tif ( updateBuffers ) {\r\n\r\n\t\t\t// custom attributes\r\n\r\n\t\t\t// Use the per-geometryGroup custom attribute arrays which are setup in initMeshBuffers\r\n\r\n\t\t\tif ( geometryGroup.__webglCustomAttributesList ) {\r\n\r\n\t\t\t\tfor ( var i = 0, il = geometryGroup.__webglCustomAttributesList.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tvar attribute = geometryGroup.__webglCustomAttributesList[ i ];\r\n\r\n\t\t\t\t\tif ( attributes[ attribute.buffer.belongsToAttribute ] >= 0 ) {\r\n\r\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, attribute.buffer );\r\n\r\n\t\t\t\t\t\tstate.enableAttribute( attributes[ attribute.buffer.belongsToAttribute ] );\r\n\r\n\t\t\t\t\t\t_gl.vertexAttribPointer( attributes[ attribute.buffer.belongsToAttribute ], attribute.size, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\r\n\t\t\t// colors\r\n\r\n\t\t\tif ( attributes.color >= 0 ) {\r\n\r\n\t\t\t\tif ( object.geometry.colors.length > 0 || object.geometry.faces.length > 0 ) {\r\n\r\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglColorBuffer );\r\n\r\n\t\t\t\t\tstate.enableAttribute( attributes.color );\r\n\r\n\t\t\t\t\t_gl.vertexAttribPointer( attributes.color, 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t\t} else if ( material.defaultAttributeValues !== undefined ) {\r\n\r\n\r\n\t\t\t\t\t_gl.vertexAttrib3fv( attributes.color, material.defaultAttributeValues.color );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// normals\r\n\r\n\t\t\tif ( attributes.normal >= 0 ) {\r\n\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglNormalBuffer );\r\n\r\n\t\t\t\tstate.enableAttribute( attributes.normal );\r\n\r\n\t\t\t\t_gl.vertexAttribPointer( attributes.normal, 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// tangents\r\n\r\n\t\t\tif ( attributes.tangent >= 0 ) {\r\n\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglTangentBuffer );\r\n\r\n\t\t\t\tstate.enableAttribute( attributes.tangent );\r\n\r\n\t\t\t\t_gl.vertexAttribPointer( attributes.tangent, 4, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// uvs\r\n\r\n\t\t\tif ( attributes.uv >= 0 ) {\r\n\r\n\t\t\t\tif ( object.geometry.faceVertexUvs[ 0 ] ) {\r\n\r\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUVBuffer );\r\n\r\n\t\t\t\t\tstate.enableAttribute( attributes.uv );\r\n\r\n\t\t\t\t\t_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t\t} else if ( material.defaultAttributeValues !== undefined ) {\r\n\r\n\r\n\t\t\t\t\t_gl.vertexAttrib2fv( attributes.uv, material.defaultAttributeValues.uv );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( attributes.uv2 >= 0 ) {\r\n\r\n\t\t\t\tif ( object.geometry.faceVertexUvs[ 1 ] ) {\r\n\r\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUV2Buffer );\r\n\r\n\t\t\t\t\tstate.enableAttribute( attributes.uv2 );\r\n\r\n\t\t\t\t\t_gl.vertexAttribPointer( attributes.uv2, 2, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t\t} else if ( material.defaultAttributeValues !== undefined ) {\r\n\r\n\r\n\t\t\t\t\t_gl.vertexAttrib2fv( attributes.uv2, material.defaultAttributeValues.uv2 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( material.skinning &&\r\n\t\t\t\t attributes.skinIndex >= 0 && attributes.skinWeight >= 0 ) {\r\n\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinIndicesBuffer );\r\n\r\n\t\t\t\tstate.enableAttribute( attributes.skinIndex );\r\n\r\n\t\t\t\t_gl.vertexAttribPointer( attributes.skinIndex, 4, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinWeightsBuffer );\r\n\r\n\t\t\t\tstate.enableAttribute( attributes.skinWeight );\r\n\r\n\t\t\t\t_gl.vertexAttribPointer( attributes.skinWeight, 4, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// line distances\r\n\r\n\t\t\tif ( attributes.lineDistance >= 0 ) {\r\n\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglLineDistanceBuffer );\r\n\r\n\t\t\t\tstate.enableAttribute( attributes.lineDistance );\r\n\r\n\t\t\t\t_gl.vertexAttribPointer( attributes.lineDistance, 1, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tstate.disableUnusedAttributes();\r\n\r\n\t\t// render mesh\r\n\r\n\t\tif ( object instanceof THREE.Mesh ) {\r\n\r\n\t\t\tvar type = geometryGroup.__typeArray === Uint32Array ? _gl.UNSIGNED_INT : _gl.UNSIGNED_SHORT;\r\n\r\n\t\t\t// wireframe\r\n\r\n\t\t\tif ( material.wireframe ) {\r\n\r\n\t\t\t\tstate.setLineWidth( material.wireframeLinewidth * pixelRatio );\r\n\r\n\t\t\t\tif ( updateBuffers ) _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglLineBuffer );\r\n\t\t\t\t_gl.drawElements( _gl.LINES, geometryGroup.__webglLineCount, type, 0 );\r\n\r\n\t\t\t// triangles\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tif ( updateBuffers ) _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglFaceBuffer );\r\n\t\t\t\t_gl.drawElements( _gl.TRIANGLES, geometryGroup.__webglFaceCount, type, 0 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_this.info.render.calls ++;\r\n\t\t\t_this.info.render.vertices += geometryGroup.__webglFaceCount;\r\n\t\t\t_this.info.render.faces += geometryGroup.__webglFaceCount / 3;\r\n\r\n\t\t// render lines\r\n\r\n\t\t} else if ( object instanceof THREE.Line ) {\r\n\r\n\t\t\tvar mode = ( object.mode === THREE.LineStrip ) ? _gl.LINE_STRIP : _gl.LINES;\r\n\r\n\t\t\tstate.setLineWidth( material.linewidth * pixelRatio );\r\n\r\n\t\t\t_gl.drawArrays( mode, 0, geometryGroup.__webglLineCount );\r\n\r\n\t\t\t_this.info.render.calls ++;\r\n\r\n\t\t// render particles\r\n\r\n\t\t} else if ( object instanceof THREE.PointCloud ) {\r\n\r\n\t\t\t_gl.drawArrays( _gl.POINTS, 0, geometryGroup.__webglParticleCount );\r\n\r\n\t\t\t_this.info.render.calls ++;\r\n\t\t\t_this.info.render.points += geometryGroup.__webglParticleCount;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction setupMorphTargets ( material, geometryGroup, object ) {\r\n\r\n\t\t// set base\r\n\r\n\t\tvar attributes = material.program.attributes;\r\n\r\n\t\tif ( object.morphTargetBase !== - 1 && attributes.position >= 0 ) {\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ object.morphTargetBase ] );\r\n\r\n\t\t\tstate.enableAttribute( attributes.position );\r\n\r\n\t\t\t_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t} else if ( attributes.position >= 0 ) {\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );\r\n\r\n\t\t\tstate.enableAttribute( attributes.position );\r\n\r\n\t\t\t_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( object.morphTargetForcedOrder.length ) {\r\n\r\n\t\t\t// set forced order\r\n\r\n\t\t\tvar m = 0;\r\n\t\t\tvar order = object.morphTargetForcedOrder;\r\n\t\t\tvar influences = object.morphTargetInfluences;\r\n\r\n\t\t\tvar attribute;\r\n\r\n\t\t\twhile ( m < material.numSupportedMorphTargets && m < order.length ) {\r\n\r\n\t\t\t\tattribute = attributes[ 'morphTarget' + m ];\r\n\r\n\t\t\t\tif ( attribute >= 0 ) {\r\n\r\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ order[ m ] ] );\r\n\r\n\t\t\t\t\tstate.enableAttribute( attribute );\r\n\r\n\t\t\t\t\t_gl.vertexAttribPointer( attribute, 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tattribute = attributes[ 'morphNormal' + m ];\r\n\r\n\t\t\t\tif ( attribute >= 0 && material.morphNormals ) {\r\n\r\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[ order[ m ] ] );\r\n\r\n\t\t\t\t\tstate.enableAttribute( attribute );\r\n\r\n\t\t\t\t\t_gl.vertexAttribPointer( attribute, 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tobject.__webglMorphTargetInfluences[ m ] = influences[ order[ m ] ];\r\n\r\n\t\t\t\tm ++;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// find the most influencing\r\n\r\n\t\t\tvar activeInfluenceIndices = [];\r\n\t\t\tvar influences = object.morphTargetInfluences;\r\n\t\t\tvar morphTargets = object.geometry.morphTargets;\r\n\r\n\t\t\tif ( influences.length > morphTargets.length ) {\r\n\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Influences array is bigger than morphTargets array.' );\r\n\t\t\t\tinfluences.length = morphTargets.length;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var i = 0, il = influences.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tvar influence = influences[ i ];\r\n\r\n\t\t\t\tactiveInfluenceIndices.push( [ influence, i ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( activeInfluenceIndices.length > material.numSupportedMorphTargets ) {\r\n\r\n\t\t\t\tactiveInfluenceIndices.sort( numericalSort );\r\n\t\t\t\tactiveInfluenceIndices.length = material.numSupportedMorphTargets;\r\n\r\n\t\t\t} else if ( activeInfluenceIndices.length > material.numSupportedMorphNormals ) {\r\n\r\n\t\t\t\tactiveInfluenceIndices.sort( numericalSort );\r\n\r\n\t\t\t} else if ( activeInfluenceIndices.length === 0 ) {\r\n\r\n\t\t\t\tactiveInfluenceIndices.push( [ 0, 0 ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar attribute;\r\n\r\n\t\t\tfor ( var m = 0, ml = material.numSupportedMorphTargets; m < ml; m ++ ) {\r\n\r\n\t\t\t\tif ( activeInfluenceIndices[ m ] ) {\r\n\r\n\t\t\t\t\tvar influenceIndex = activeInfluenceIndices[ m ][ 1 ];\r\n\r\n\t\t\t\t\tattribute = attributes[ 'morphTarget' + m ];\r\n\r\n\t\t\t\t\tif ( attribute >= 0 ) {\r\n\r\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ influenceIndex ] );\r\n\r\n\t\t\t\t\t\tstate.enableAttribute( attribute );\r\n\r\n\t\t\t\t\t\t_gl.vertexAttribPointer( attribute, 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tattribute = attributes[ 'morphNormal' + m ];\r\n\r\n\t\t\t\t\tif ( attribute >= 0 && material.morphNormals ) {\r\n\r\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[ influenceIndex ] );\r\n\r\n\t\t\t\t\t\tstate.enableAttribute( attribute );\r\n\r\n\t\t\t\t\t\t_gl.vertexAttribPointer( attribute, 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tobject.__webglMorphTargetInfluences[ m ] = influences[ influenceIndex ];\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t/*\r\n\t\t\t\t\t_gl.vertexAttribPointer( attributes[ \"morphTarget\" + m ], 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t\t\tif ( material.morphNormals ) {\r\n\r\n\t\t\t\t\t\t_gl.vertexAttribPointer( attributes[ \"morphNormal\" + m ], 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t\t*/\r\n\r\n\t\t\t\t\tobject.__webglMorphTargetInfluences[ m ] = 0;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// load updated influences uniform\r\n\r\n\t\tif ( material.program.uniforms.morphTargetInfluences !== null ) {\r\n\r\n\t\t\t_gl.uniform1fv( material.program.uniforms.morphTargetInfluences, object.__webglMorphTargetInfluences );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// Sorting\r\n\r\n\tfunction painterSortStable ( a, b ) {\r\n\r\n\t\tif ( a.object.renderOrder !== b.object.renderOrder ) {\r\n\r\n\t\t\treturn a.object.renderOrder - b.object.renderOrder;\r\n\r\n\t\t} else if ( a.material.id !== b.material.id ) {\r\n\r\n\t\t\treturn a.material.id - b.material.id;\r\n\r\n\t\t} else if ( a.z !== b.z ) {\r\n\r\n\t\t\treturn a.z - b.z;\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn a.id - b.id;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction reversePainterSortStable ( a, b ) {\r\n\r\n\t\tif ( a.object.renderOrder !== b.object.renderOrder ) {\r\n\r\n\t\t\treturn a.object.renderOrder - b.object.renderOrder;\r\n\r\n\t\t} if ( a.z !== b.z ) {\r\n\r\n\t\t\treturn b.z - a.z;\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn a.id - b.id;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction numericalSort ( a, b ) {\r\n\r\n\t\treturn b[ 0 ] - a[ 0 ];\r\n\r\n\t}\r\n\r\n\t// Rendering\r\n\r\n\tthis.render = function ( scene, camera, renderTarget, forceClear ) {\r\n\r\n\t\tif ( camera instanceof THREE.Camera === false ) {\r\n\r\n\t\t\tTHREE.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tvar fog = scene.fog;\r\n\r\n\t\t// reset caching for this frame\r\n\r\n\t\t_currentGeometryProgram = '';\r\n\t\t_currentMaterialId = - 1;\r\n\t\t_currentCamera = null;\r\n\t\t_lightsNeedUpdate = true;\r\n\r\n\t\t// update scene graph\r\n\r\n\t\tif ( scene.autoUpdate === true ) scene.updateMatrixWorld();\r\n\r\n\t\t// update camera matrices and frustum\r\n\r\n\t\tif ( camera.parent === undefined ) camera.updateMatrixWorld();\r\n\r\n\t\t// update Skeleton objects\r\n\r\n\t\tscene.traverse( function ( object ) {\r\n\r\n\t\t\tif ( object instanceof THREE.SkinnedMesh ) {\r\n\r\n\t\t\t\tobject.skeleton.update();\r\n\r\n\t\t\t}\r\n\r\n\t\t} );\r\n\r\n\t\tcamera.matrixWorldInverse.getInverse( camera.matrixWorld );\r\n\r\n\t\t_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );\r\n\t\t_frustum.setFromMatrix( _projScreenMatrix );\r\n\r\n\t\tlights.length = 0;\r\n\t\topaqueObjects.length = 0;\r\n\t\ttransparentObjects.length = 0;\r\n\r\n\t\tsprites.length = 0;\r\n\t\tlensFlares.length = 0;\r\n\r\n\t\tprojectObject( scene );\r\n\r\n\t\tif ( _this.sortObjects === true ) {\r\n\r\n\t\t\topaqueObjects.sort( painterSortStable );\r\n\t\t\ttransparentObjects.sort( reversePainterSortStable );\r\n\r\n\t\t}\r\n\r\n\t\t// custom render plugins (pre pass)\r\n\r\n\t\tshadowMapPlugin.render( scene, camera );\r\n\r\n\t\t//\r\n\r\n\t\t_this.info.render.calls = 0;\r\n\t\t_this.info.render.vertices = 0;\r\n\t\t_this.info.render.faces = 0;\r\n\t\t_this.info.render.points = 0;\r\n\r\n\t\tthis.setRenderTarget( renderTarget );\r\n\r\n\t\tif ( this.autoClear || forceClear ) {\r\n\r\n\t\t\tthis.clear( this.autoClearColor, this.autoClearDepth, this.autoClearStencil );\r\n\r\n\t\t}\r\n\r\n\t\t// set matrices for immediate objects\r\n\r\n\t\tfor ( var i = 0, il = _webglObjectsImmediate.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar webglObject = _webglObjectsImmediate[ i ];\r\n\t\t\tvar object = webglObject.object;\r\n\r\n\t\t\tif ( object.visible ) {\r\n\r\n\t\t\t\tsetupMatrices( object, camera );\r\n\r\n\t\t\t\tunrollImmediateBufferMaterial( webglObject );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( scene.overrideMaterial ) {\r\n\r\n\t\t\tvar overrideMaterial = scene.overrideMaterial;\r\n\r\n\t\t\tsetMaterial( overrideMaterial );\r\n\r\n\t\t\trenderObjects( opaqueObjects, camera, lights, fog, overrideMaterial );\r\n\t\t\trenderObjects( transparentObjects, camera, lights, fog, overrideMaterial );\r\n\t\t\trenderObjectsImmediate( _webglObjectsImmediate, '', camera, lights, fog, overrideMaterial );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// opaque pass (front-to-back order)\r\n\r\n\t\t\tstate.setBlending( THREE.NoBlending );\r\n\r\n\t\t\trenderObjects( opaqueObjects, camera, lights, fog, null );\r\n\t\t\trenderObjectsImmediate( _webglObjectsImmediate, 'opaque', camera, lights, fog, null );\r\n\r\n\t\t\t// transparent pass (back-to-front order)\r\n\r\n\t\t\trenderObjects( transparentObjects, camera, lights, fog, null );\r\n\t\t\trenderObjectsImmediate( _webglObjectsImmediate, 'transparent', camera, lights, fog, null );\r\n\r\n\t\t}\r\n\r\n\t\t// custom render plugins (post pass)\r\n\r\n\t\tspritePlugin.render( scene, camera );\r\n\t\tlensFlarePlugin.render( scene, camera, _currentWidth, _currentHeight );\r\n\r\n\t\t// Generate mipmap if we're using any kind of mipmap filtering\r\n\r\n\t\tif ( renderTarget && renderTarget.generateMipmaps && renderTarget.minFilter !== THREE.NearestFilter && renderTarget.minFilter !== THREE.LinearFilter ) {\r\n\r\n\t\t\tupdateRenderTargetMipmap( renderTarget );\r\n\r\n\t\t}\r\n\r\n\t\t// Ensure depth buffer writing is enabled so it can be cleared on next render\r\n\r\n\t\tstate.setDepthTest( true );\r\n\t\tstate.setDepthWrite( true );\r\n\t\tstate.setColorWrite( true );\r\n\r\n\t\t// _gl.finish();\r\n\r\n\t};\r\n\r\n\tfunction projectObject( object ) {\r\n\r\n\t\tif ( object.visible === false ) return;\r\n\r\n\t\tif ( object instanceof THREE.Scene || object instanceof THREE.Group ) {\r\n\r\n\t\t\t// skip\r\n\r\n\t\t} else {\r\n\r\n\t\t\tinitObject( object );\r\n\r\n\t\t\tif ( object instanceof THREE.Light ) {\r\n\r\n\t\t\t\tlights.push( object );\r\n\r\n\t\t\t} else if ( object instanceof THREE.Sprite ) {\r\n\r\n\t\t\t\tsprites.push( object );\r\n\r\n\t\t\t} else if ( object instanceof THREE.LensFlare ) {\r\n\r\n\t\t\t\tlensFlares.push( object );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tvar webglObjects = _webglObjects[ object.id ];\r\n\r\n\t\t\t\tif ( webglObjects && ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) ) {\r\n\r\n\t\t\t\t\tfor ( var i = 0, l = webglObjects.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\t\tvar webglObject = webglObjects[ i ];\r\n\r\n\t\t\t\t\t\tunrollBufferMaterial( webglObject );\r\n\r\n\t\t\t\t\t\twebglObject.render = true;\r\n\r\n\t\t\t\t\t\tif ( _this.sortObjects === true ) {\r\n\r\n\t\t\t\t\t\t\t_vector3.setFromMatrixPosition( object.matrixWorld );\r\n\t\t\t\t\t\t\t_vector3.applyProjection( _projScreenMatrix );\r\n\r\n\t\t\t\t\t\t\twebglObject.z = _vector3.z;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var i = 0, l = object.children.length; i < l; i ++ ) {\r\n\r\n\t\t\tprojectObject( object.children[ i ] );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction renderObjects( renderList, camera, lights, fog, overrideMaterial ) {\r\n\r\n\t\tvar material;\r\n\r\n\t\tfor ( var i = 0, l = renderList.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar webglObject = renderList[ i ];\r\n\r\n\t\t\tvar object = webglObject.object;\r\n\t\t\tvar buffer = webglObject.buffer;\r\n\r\n\t\t\tsetupMatrices( object, camera );\r\n\r\n\t\t\tif ( overrideMaterial ) {\r\n\r\n\t\t\t\tmaterial = overrideMaterial;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tmaterial = webglObject.material;\r\n\r\n\t\t\t\tif ( ! material ) continue;\r\n\r\n\t\t\t\tsetMaterial( material );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_this.setMaterialFaces( material );\r\n\r\n\t\t\tif ( buffer instanceof THREE.BufferGeometry ) {\r\n\r\n\t\t\t\t_this.renderBufferDirect( camera, lights, fog, material, buffer, object );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t_this.renderBuffer( camera, lights, fog, material, buffer, object );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction renderObjectsImmediate ( renderList, materialType, camera, lights, fog, overrideMaterial ) {\r\n\r\n\t\tvar material;\r\n\r\n\t\tfor ( var i = 0, l = renderList.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar webglObject = renderList[ i ];\r\n\t\t\tvar object = webglObject.object;\r\n\r\n\t\t\tif ( object.visible ) {\r\n\r\n\t\t\t\tif ( overrideMaterial ) {\r\n\r\n\t\t\t\t\tmaterial = overrideMaterial;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tmaterial = webglObject[ materialType ];\r\n\r\n\t\t\t\t\tif ( ! material ) continue;\r\n\r\n\t\t\t\t\tsetMaterial( material );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t_this.renderImmediateObject( camera, lights, fog, material, object );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tthis.renderImmediateObject = function ( camera, lights, fog, material, object ) {\r\n\r\n\t\tvar program = setProgram( camera, lights, fog, material, object );\r\n\r\n\t\t_currentGeometryProgram = '';\r\n\r\n\t\t_this.setMaterialFaces( material );\r\n\r\n\t\tif ( object.immediateRenderCallback ) {\r\n\r\n\t\t\tobject.immediateRenderCallback( program, _gl, _frustum );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tobject.render( function ( object ) { _this.renderBufferImmediate( object, program, material ); } );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction unrollImmediateBufferMaterial ( globject ) {\r\n\r\n\t\tvar object = globject.object,\r\n\t\t\tmaterial = object.material;\r\n\r\n\t\tif ( material.transparent ) {\r\n\r\n\t\t\tglobject.transparent = material;\r\n\t\t\tglobject.opaque = null;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tglobject.opaque = material;\r\n\t\t\tglobject.transparent = null;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction unrollBufferMaterial ( globject ) {\r\n\r\n\t\tvar object = globject.object;\r\n\t\tvar buffer = globject.buffer;\r\n\r\n\t\tvar geometry = object.geometry;\r\n\t\tvar material = object.material;\r\n\r\n\t\tif ( material instanceof THREE.MeshFaceMaterial ) {\r\n\r\n\t\t\tvar materialIndex = geometry instanceof THREE.BufferGeometry ? 0 : buffer.materialIndex;\r\n\r\n\t\t\tmaterial = material.materials[ materialIndex ];\r\n\r\n\t\t\tglobject.material = material;\r\n\r\n\t\t\tif ( material.transparent ) {\r\n\r\n\t\t\t\ttransparentObjects.push( globject );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\topaqueObjects.push( globject );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( material ) {\r\n\r\n\t\t\tglobject.material = material;\r\n\r\n\t\t\tif ( material.transparent ) {\r\n\r\n\t\t\t\ttransparentObjects.push( globject );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\topaqueObjects.push( globject );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction initObject( object ) {\r\n\r\n\t\tif ( object.__webglInit === undefined ) {\r\n\r\n\t\t\tobject.__webglInit = true;\r\n\t\t\tobject._modelViewMatrix = new THREE.Matrix4();\r\n\t\t\tobject._normalMatrix = new THREE.Matrix3();\r\n\r\n\t\t\tobject.addEventListener( 'removed', onObjectRemoved );\r\n\r\n\t\t}\r\n\r\n\t\tvar geometry = object.geometry;\r\n\r\n\t\tif ( geometry === undefined ) {\r\n\r\n\t\t\t// ImmediateRenderObject\r\n\r\n\t\t} else if ( geometry.__webglInit === undefined ) {\r\n\r\n\t\t\tgeometry.__webglInit = true;\r\n\t\t\tgeometry.addEventListener( 'dispose', onGeometryDispose );\r\n\r\n\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\r\n\r\n\t\t\t\t_this.info.memory.geometries ++;\r\n\r\n\t\t\t} else if ( object instanceof THREE.Mesh ) {\r\n\r\n\t\t\t\tinitGeometryGroups( object, geometry );\r\n\r\n\t\t\t} else if ( object instanceof THREE.Line ) {\r\n\r\n\t\t\t\tif ( geometry.__webglVertexBuffer === undefined ) {\r\n\r\n\t\t\t\t\tcreateLineBuffers( geometry );\r\n\t\t\t\t\tinitLineBuffers( geometry, object );\r\n\r\n\t\t\t\t\tgeometry.verticesNeedUpdate = true;\r\n\t\t\t\t\tgeometry.colorsNeedUpdate = true;\r\n\t\t\t\t\tgeometry.lineDistancesNeedUpdate = true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( object instanceof THREE.PointCloud ) {\r\n\r\n\t\t\t\tif ( geometry.__webglVertexBuffer === undefined ) {\r\n\r\n\t\t\t\t\tcreateParticleBuffers( geometry );\r\n\t\t\t\t\tinitParticleBuffers( geometry, object );\r\n\r\n\t\t\t\t\tgeometry.verticesNeedUpdate = true;\r\n\t\t\t\t\tgeometry.colorsNeedUpdate = true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( object.__webglActive === undefined) {\r\n\r\n\t\t\tobject.__webglActive = true;\r\n\r\n\t\t\tif ( object instanceof THREE.Mesh ) {\r\n\r\n\t\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\r\n\r\n\t\t\t\t\taddBuffer( _webglObjects, geometry, object );\r\n\r\n\t\t\t\t} else if ( geometry instanceof THREE.Geometry ) {\r\n\r\n\t\t\t\t\tvar geometryGroupsList = geometryGroups[ geometry.id ];\r\n\r\n\t\t\t\t\tfor ( var i = 0,l = geometryGroupsList.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\t\taddBuffer( _webglObjects, geometryGroupsList[ i ], object );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( object instanceof THREE.Line || object instanceof THREE.PointCloud ) {\r\n\r\n\t\t\t\taddBuffer( _webglObjects, geometry, object );\r\n\r\n\t\t\t} else if ( object instanceof THREE.ImmediateRenderObject || object.immediateRenderCallback ) {\r\n\r\n\t\t\t\taddBufferImmediate( _webglObjectsImmediate, object );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// Geometry splitting\r\n\r\n\tvar geometryGroups = {};\r\n\tvar geometryGroupCounter = 0;\r\n\r\n\tfunction makeGroups( geometry, usesFaceMaterial ) {\r\n\r\n\t\tvar maxVerticesInGroup = extensions.get( 'OES_element_index_uint' ) ? 4294967296 : 65535;\r\n\r\n\t\tvar groupHash, hash_map = {};\r\n\r\n\t\tvar numMorphTargets = geometry.morphTargets.length;\r\n\t\tvar numMorphNormals = geometry.morphNormals.length;\r\n\r\n\t\tvar group;\r\n\t\tvar groups = {};\r\n\t\tvar groupsList = [];\r\n\r\n\t\tfor ( var f = 0, fl = geometry.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\tvar face = geometry.faces[ f ];\r\n\t\t\tvar materialIndex = usesFaceMaterial ? face.materialIndex : 0;\r\n\r\n\t\t\tif ( ! ( materialIndex in hash_map ) ) {\r\n\r\n\t\t\t\thash_map[ materialIndex ] = { hash: materialIndex, counter: 0 };\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgroupHash = hash_map[ materialIndex ].hash + '_' + hash_map[ materialIndex ].counter;\r\n\r\n\t\t\tif ( ! ( groupHash in groups ) ) {\r\n\r\n\t\t\t\tgroup = {\r\n\t\t\t\t\tid: geometryGroupCounter ++,\r\n\t\t\t\t\tfaces3: [],\r\n\t\t\t\t\tmaterialIndex: materialIndex,\r\n\t\t\t\t\tvertices: 0,\r\n\t\t\t\t\tnumMorphTargets: numMorphTargets,\r\n\t\t\t\t\tnumMorphNormals: numMorphNormals\r\n\t\t\t\t};\r\n\r\n\t\t\t\tgroups[ groupHash ] = group;\r\n\t\t\t\tgroupsList.push( group );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( groups[ groupHash ].vertices + 3 > maxVerticesInGroup ) {\r\n\r\n\t\t\t\thash_map[ materialIndex ].counter += 1;\r\n\t\t\t\tgroupHash = hash_map[ materialIndex ].hash + '_' + hash_map[ materialIndex ].counter;\r\n\r\n\t\t\t\tif ( ! ( groupHash in groups ) ) {\r\n\r\n\t\t\t\t\tgroup = {\r\n\t\t\t\t\t\tid: geometryGroupCounter ++,\r\n\t\t\t\t\t\tfaces3: [],\r\n\t\t\t\t\t\tmaterialIndex: materialIndex,\r\n\t\t\t\t\t\tvertices: 0,\r\n\t\t\t\t\t\tnumMorphTargets: numMorphTargets,\r\n\t\t\t\t\t\tnumMorphNormals: numMorphNormals\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\tgroups[ groupHash ] = group;\r\n\t\t\t\t\tgroupsList.push( group );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgroups[ groupHash ].faces3.push( f );\r\n\t\t\tgroups[ groupHash ].vertices += 3;\r\n\r\n\t\t}\r\n\r\n\t\treturn groupsList;\r\n\r\n\t}\r\n\r\n\tfunction initGeometryGroups( object, geometry ) {\r\n\r\n\t\tvar material = object.material, addBuffers = false;\r\n\r\n\t\tif ( geometryGroups[ geometry.id ] === undefined || geometry.groupsNeedUpdate === true ) {\r\n\r\n\t\t\tdelete _webglObjects[ object.id ];\r\n\r\n\t\t\tgeometryGroups[ geometry.id ] = makeGroups( geometry, material instanceof THREE.MeshFaceMaterial );\r\n\r\n\t\t\tgeometry.groupsNeedUpdate = false;\r\n\r\n\t\t}\r\n\r\n\t\tvar geometryGroupsList = geometryGroups[ geometry.id ];\r\n\r\n\t\t// create separate VBOs per geometry chunk\r\n\r\n\t\tfor ( var i = 0, il = geometryGroupsList.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar geometryGroup = geometryGroupsList[ i ];\r\n\r\n\t\t\t// initialise VBO on the first access\r\n\r\n\t\t\tif ( geometryGroup.__webglVertexBuffer === undefined ) {\r\n\r\n\t\t\t\tcreateMeshBuffers( geometryGroup );\r\n\t\t\t\tinitMeshBuffers( geometryGroup, object );\r\n\r\n\t\t\t\tgeometry.verticesNeedUpdate = true;\r\n\t\t\t\tgeometry.morphTargetsNeedUpdate = true;\r\n\t\t\t\tgeometry.elementsNeedUpdate = true;\r\n\t\t\t\tgeometry.uvsNeedUpdate = true;\r\n\t\t\t\tgeometry.normalsNeedUpdate = true;\r\n\t\t\t\tgeometry.tangentsNeedUpdate = true;\r\n\t\t\t\tgeometry.colorsNeedUpdate = true;\r\n\r\n\t\t\t\taddBuffers = true;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\taddBuffers = false;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( addBuffers || object.__webglActive === undefined ) {\r\n\r\n\t\t\t\taddBuffer( _webglObjects, geometryGroup, object );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tobject.__webglActive = true;\r\n\r\n\t}\r\n\r\n\tfunction addBuffer( objlist, buffer, object ) {\r\n\r\n\t\tvar id = object.id;\r\n\t\tobjlist[id] = objlist[id] || [];\r\n\t\tobjlist[id].push(\r\n\t\t\t{\r\n\t\t\t\tid: id,\r\n\t\t\t\tbuffer: buffer,\r\n\t\t\t\tobject: object,\r\n\t\t\t\tmaterial: null,\r\n\t\t\t\tz: 0\r\n\t\t\t}\r\n\t\t);\r\n\r\n\t};\r\n\r\n\tfunction addBufferImmediate( objlist, object ) {\r\n\r\n\t\tobjlist.push(\r\n\t\t\t{\r\n\t\t\t\tid: null,\r\n\t\t\t\tobject: object,\r\n\t\t\t\topaque: null,\r\n\t\t\t\ttransparent: null,\r\n\t\t\t\tz: 0\r\n\t\t\t}\r\n\t\t);\r\n\r\n\t};\r\n\r\n\t// Objects updates\r\n\r\n\tfunction updateObject( object ) {\r\n\r\n\t\tvar geometry = object.geometry;\r\n\r\n\t\tif ( geometry instanceof THREE.BufferGeometry ) {\r\n\r\n\t\t\tvar attributes = geometry.attributes;\r\n\t\t\tvar attributesKeys = geometry.attributesKeys;\r\n\r\n\t\t\tfor ( var i = 0, l = attributesKeys.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar key = attributesKeys[ i ];\r\n\t\t\t\tvar attribute = attributes[ key ];\r\n\t\t\t\tvar bufferType = ( key === 'index' ) ? _gl.ELEMENT_ARRAY_BUFFER : _gl.ARRAY_BUFFER;\r\n\r\n\t\t\t\tif ( attribute.buffer === undefined ) {\r\n\r\n\t\t\t\t\tattribute.buffer = _gl.createBuffer();\r\n\t\t\t\t\t_gl.bindBuffer( bufferType, attribute.buffer );\r\n\t\t\t\t\t_gl.bufferData( bufferType, attribute.array, ( attribute instanceof THREE.DynamicBufferAttribute ) ? _gl.DYNAMIC_DRAW : _gl.STATIC_DRAW );\r\n\r\n\t\t\t\t\tattribute.needsUpdate = false;\r\n\r\n\t\t\t\t} else if ( attribute.needsUpdate === true ) {\r\n\r\n\t\t\t\t\t_gl.bindBuffer( bufferType, attribute.buffer );\r\n\r\n\t\t\t\t\tif ( attribute.updateRange === undefined || attribute.updateRange.count === -1 ) { // Not using update ranges\r\n\r\n\t\t\t\t\t\t_gl.bufferSubData( bufferType, 0, attribute.array );\r\n\r\n\t\t\t\t\t} else if ( attribute.updateRange.count === 0 ) {\r\n\r\n\t\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.updateObject: using updateRange for THREE.DynamicBufferAttribute and marked as needsUpdate but count is 0, ensure you are using set methods or updating manually.' );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t_gl.bufferSubData( bufferType, attribute.updateRange.offset * attribute.array.BYTES_PER_ELEMENT,\r\n\t\t\t\t\t\t\t\t\t\t   attribute.array.subarray( attribute.updateRange.offset, attribute.updateRange.offset + attribute.updateRange.count ) );\r\n\r\n\t\t\t\t\t\tattribute.updateRange.count = 0; // reset range\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tattribute.needsUpdate = false;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( object instanceof THREE.Mesh ) {\r\n\r\n\t\t\t// check all geometry groups\r\n\r\n\t\t\tif ( geometry.groupsNeedUpdate === true ) {\r\n\r\n\t\t\t\tinitGeometryGroups( object, geometry );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar geometryGroupsList = geometryGroups[ geometry.id ];\r\n\r\n\t\t\tfor ( var i = 0, il = geometryGroupsList.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tvar geometryGroup = geometryGroupsList[ i ];\r\n\t\t\t\tvar material = getBufferMaterial( object, geometryGroup );\r\n\r\n\t\t\t\tvar customAttributesDirty = material.attributes && areCustomAttributesDirty( material );\r\n\r\n\t\t\t\tif ( geometry.verticesNeedUpdate || geometry.morphTargetsNeedUpdate || geometry.elementsNeedUpdate ||\r\n\t\t\t\t\t geometry.uvsNeedUpdate || geometry.normalsNeedUpdate ||\r\n\t\t\t\t\t geometry.colorsNeedUpdate || geometry.tangentsNeedUpdate || customAttributesDirty ) {\r\n\r\n\t\t\t\t\tsetMeshBuffers( geometryGroup, object, _gl.DYNAMIC_DRAW, ! geometry.dynamic, material );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeometry.verticesNeedUpdate = false;\r\n\t\t\tgeometry.morphTargetsNeedUpdate = false;\r\n\t\t\tgeometry.elementsNeedUpdate = false;\r\n\t\t\tgeometry.uvsNeedUpdate = false;\r\n\t\t\tgeometry.normalsNeedUpdate = false;\r\n\t\t\tgeometry.colorsNeedUpdate = false;\r\n\t\t\tgeometry.tangentsNeedUpdate = false;\r\n\r\n\t\t\tmaterial.attributes && clearCustomAttributes( material );\r\n\r\n\t\t} else if ( object instanceof THREE.Line ) {\r\n\r\n\t\t\tvar material = getBufferMaterial( object, geometry );\r\n\t\t\tvar customAttributesDirty = material.attributes && areCustomAttributesDirty( material );\r\n\r\n\t\t\tif ( geometry.verticesNeedUpdate || geometry.colorsNeedUpdate || geometry.lineDistancesNeedUpdate || customAttributesDirty ) {\r\n\r\n\t\t\t\tsetLineBuffers( geometry, _gl.DYNAMIC_DRAW );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeometry.verticesNeedUpdate = false;\r\n\t\t\tgeometry.colorsNeedUpdate = false;\r\n\t\t\tgeometry.lineDistancesNeedUpdate = false;\r\n\r\n\t\t\tmaterial.attributes && clearCustomAttributes( material );\r\n\r\n\t\t} else if ( object instanceof THREE.PointCloud ) {\r\n\r\n\t\t\tvar material = getBufferMaterial( object, geometry );\r\n\t\t\tvar customAttributesDirty = material.attributes && areCustomAttributesDirty( material );\r\n\r\n\t\t\tif ( geometry.verticesNeedUpdate || geometry.colorsNeedUpdate || customAttributesDirty ) {\r\n\r\n\t\t\t\tsetParticleBuffers( geometry, _gl.DYNAMIC_DRAW, object );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeometry.verticesNeedUpdate = false;\r\n\t\t\tgeometry.colorsNeedUpdate = false;\r\n\r\n\t\t\tmaterial.attributes && clearCustomAttributes( material );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// Objects updates - custom attributes check\r\n\r\n\tfunction areCustomAttributesDirty( material ) {\r\n\r\n\t\tfor ( var name in material.attributes ) {\r\n\r\n\t\t\tif ( material.attributes[ name ].needsUpdate ) return true;\r\n\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\r\n\t}\r\n\r\n\tfunction clearCustomAttributes( material ) {\r\n\r\n\t\tfor ( var name in material.attributes ) {\r\n\r\n\t\t\tmaterial.attributes[ name ].needsUpdate = false;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// Objects removal\r\n\r\n\tfunction removeObject( object ) {\r\n\r\n\t\tif ( object instanceof THREE.Mesh  ||\r\n\t\t\t object instanceof THREE.PointCloud ||\r\n\t\t\t object instanceof THREE.Line ) {\r\n\r\n\t\t\tdelete _webglObjects[ object.id ];\r\n\r\n\t\t} else if ( object instanceof THREE.ImmediateRenderObject || object.immediateRenderCallback ) {\r\n\r\n\t\t\tremoveInstances( _webglObjectsImmediate, object );\r\n\r\n\t\t}\r\n\r\n\t\tdelete object.__webglInit;\r\n\t\tdelete object._modelViewMatrix;\r\n\t\tdelete object._normalMatrix;\r\n\r\n\t\tdelete object.__webglActive;\r\n\r\n\t}\r\n\r\n\tfunction removeInstances( objlist, object ) {\r\n\r\n\t\tfor ( var o = objlist.length - 1; o >= 0; o -- ) {\r\n\r\n\t\t\tif ( objlist[ o ].object === object ) {\r\n\r\n\t\t\t\tobjlist.splice( o, 1 );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// Materials\r\n\r\n\tvar shaderIDs = {\r\n\t\tMeshDepthMaterial: 'depth',\r\n\t\tMeshNormalMaterial: 'normal',\r\n\t\tMeshBasicMaterial: 'basic',\r\n\t\tMeshLambertMaterial: 'lambert',\r\n\t\tMeshPhongMaterial: 'phong',\r\n\t\tLineBasicMaterial: 'basic',\r\n\t\tLineDashedMaterial: 'dashed',\r\n\t\tPointCloudMaterial: 'particle_basic'\r\n\t};\r\n\r\n\tfunction initMaterial( material, lights, fog, object ) {\r\n\r\n\t\tmaterial.addEventListener( 'dispose', onMaterialDispose );\r\n\r\n\t\tvar shaderID = shaderIDs[ material.type ];\r\n\r\n\t\tif ( shaderID ) {\r\n\r\n\t\t\tvar shader = THREE.ShaderLib[ shaderID ];\r\n\r\n\t\t\tmaterial.__webglShader = {\r\n\t\t\t\tuniforms: THREE.UniformsUtils.clone( shader.uniforms ),\r\n\t\t\t\tvertexShader: shader.vertexShader,\r\n\t\t\t\tfragmentShader: shader.fragmentShader\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tmaterial.__webglShader = {\r\n\t\t\t\tuniforms: material.uniforms,\r\n\t\t\t\tvertexShader: material.vertexShader,\r\n\t\t\t\tfragmentShader: material.fragmentShader\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// heuristics to create shader parameters according to lights in the scene\r\n\t\t// (not to blow over maxLights budget)\r\n\r\n\t\tvar maxLightCount = allocateLights( lights );\r\n\t\tvar maxShadows = allocateShadows( lights );\r\n\t\tvar maxBones = allocateBones( object );\r\n\r\n\t\tvar parameters = {\r\n\r\n\t\t\tprecision: _precision,\r\n\t\t\tsupportsVertexTextures: _supportsVertexTextures,\r\n\r\n\t\t\tmap: !! material.map,\r\n\t\t\tenvMap: !! material.envMap,\r\n\t\t\tenvMapMode: material.envMap && material.envMap.mapping,\r\n\t\t\tlightMap: !! material.lightMap,\r\n\t\t\tbumpMap: !! material.bumpMap,\r\n\t\t\tnormalMap: !! material.normalMap,\r\n\t\t\tspecularMap: !! material.specularMap,\r\n\t\t\talphaMap: !! material.alphaMap,\r\n\r\n\t\t\tcombine: material.combine,\r\n\r\n\t\t\tvertexColors: material.vertexColors,\r\n\r\n\t\t\tfog: fog,\r\n\t\t\tuseFog: material.fog,\r\n\t\t\tfogExp: fog instanceof THREE.FogExp2,\r\n\r\n\t\t\tflatShading: material.shading === THREE.FlatShading,\r\n\r\n\t\t\tsizeAttenuation: material.sizeAttenuation,\r\n\t\t\tlogarithmicDepthBuffer: _logarithmicDepthBuffer,\r\n\r\n\t\t\tskinning: material.skinning,\r\n\t\t\tmaxBones: maxBones,\r\n\t\t\tuseVertexTexture: _supportsBoneTextures && object && object.skeleton && object.skeleton.useVertexTexture,\r\n\r\n\t\t\tmorphTargets: material.morphTargets,\r\n\t\t\tmorphNormals: material.morphNormals,\r\n\t\t\tmaxMorphTargets: _this.maxMorphTargets,\r\n\t\t\tmaxMorphNormals: _this.maxMorphNormals,\r\n\r\n\t\t\tmaxDirLights: maxLightCount.directional,\r\n\t\t\tmaxPointLights: maxLightCount.point,\r\n\t\t\tmaxSpotLights: maxLightCount.spot,\r\n\t\t\tmaxHemiLights: maxLightCount.hemi,\r\n\r\n\t\t\tmaxShadows: maxShadows,\r\n\t\t\tshadowMapEnabled: _this.shadowMapEnabled && object.receiveShadow && maxShadows > 0,\r\n\t\t\tshadowMapType: _this.shadowMapType,\r\n\t\t\tshadowMapDebug: _this.shadowMapDebug,\r\n\t\t\tshadowMapCascade: _this.shadowMapCascade,\r\n\r\n\t\t\talphaTest: material.alphaTest,\r\n\t\t\tmetal: material.metal,\r\n\t\t\twrapAround: material.wrapAround,\r\n\t\t\tdoubleSided: material.side === THREE.DoubleSide,\r\n\t\t\tflipSided: material.side === THREE.BackSide\r\n\r\n\t\t};\r\n\r\n\t\t// Generate code\r\n\r\n\t\tvar chunks = [];\r\n\r\n\t\tif ( shaderID ) {\r\n\r\n\t\t\tchunks.push( shaderID );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tchunks.push( material.fragmentShader );\r\n\t\t\tchunks.push( material.vertexShader );\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.defines !== undefined ) {\r\n\r\n\t\t\tfor ( var name in material.defines ) {\r\n\r\n\t\t\t\tchunks.push( name );\r\n\t\t\t\tchunks.push( material.defines[ name ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var name in parameters ) {\r\n\r\n\t\t\tchunks.push( name );\r\n\t\t\tchunks.push( parameters[ name ] );\r\n\r\n\t\t}\r\n\r\n\t\tvar code = chunks.join();\r\n\r\n\t\tvar program;\r\n\r\n\t\t// Check if code has been already compiled\r\n\r\n\t\tfor ( var p = 0, pl = _programs.length; p < pl; p ++ ) {\r\n\r\n\t\t\tvar programInfo = _programs[ p ];\r\n\r\n\t\t\tif ( programInfo.code === code ) {\r\n\r\n\t\t\t\tprogram = programInfo;\r\n\t\t\t\tprogram.usedTimes ++;\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( program === undefined ) {\r\n\r\n\t\t\tprogram = new THREE.WebGLProgram( _this, code, material, parameters );\r\n\t\t\t_programs.push( program );\r\n\r\n\t\t\t_this.info.memory.programs = _programs.length;\r\n\r\n\t\t}\r\n\r\n\t\tmaterial.program = program;\r\n\r\n\t\tvar attributes = program.attributes;\r\n\r\n\t\tif ( material.morphTargets ) {\r\n\r\n\t\t\tmaterial.numSupportedMorphTargets = 0;\r\n\r\n\t\t\tvar id, base = 'morphTarget';\r\n\r\n\t\t\tfor ( var i = 0; i < _this.maxMorphTargets; i ++ ) {\r\n\r\n\t\t\t\tid = base + i;\r\n\r\n\t\t\t\tif ( attributes[ id ] >= 0 ) {\r\n\r\n\t\t\t\t\tmaterial.numSupportedMorphTargets ++;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.morphNormals ) {\r\n\r\n\t\t\tmaterial.numSupportedMorphNormals = 0;\r\n\r\n\t\t\tvar id, base = 'morphNormal';\r\n\r\n\t\t\tfor ( i = 0; i < _this.maxMorphNormals; i ++ ) {\r\n\r\n\t\t\t\tid = base + i;\r\n\r\n\t\t\t\tif ( attributes[ id ] >= 0 ) {\r\n\r\n\t\t\t\t\tmaterial.numSupportedMorphNormals ++;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tmaterial.uniformsList = [];\r\n\r\n\t\tfor ( var u in material.__webglShader.uniforms ) {\r\n\r\n\t\t\tvar location = material.program.uniforms[ u ];\r\n\r\n\t\t\tif ( location ) {\r\n\t\t\t\tmaterial.uniformsList.push( [ material.__webglShader.uniforms[ u ], location ] );\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction setMaterial( material ) {\r\n\r\n\t\tif ( material.transparent === true ) {\r\n\r\n\t\t\tstate.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tstate.setBlending( THREE.NoBlending );\r\n\r\n\t\t}\r\n\r\n\t\tstate.setDepthTest( material.depthTest );\r\n\t\tstate.setDepthWrite( material.depthWrite );\r\n\t\tstate.setColorWrite( material.colorWrite );\r\n\t\tstate.setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );\r\n\r\n\t}\r\n\r\n\tfunction setProgram( camera, lights, fog, material, object ) {\r\n\r\n\t\t_usedTextureUnits = 0;\r\n\r\n\t\tif ( material.needsUpdate ) {\r\n\r\n\t\t\tif ( material.program ) deallocateMaterial( material );\r\n\r\n\t\t\tinitMaterial( material, lights, fog, object );\r\n\t\t\tmaterial.needsUpdate = false;\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.morphTargets ) {\r\n\r\n\t\t\tif ( ! object.__webglMorphTargetInfluences ) {\r\n\r\n\t\t\t\tobject.__webglMorphTargetInfluences = new Float32Array( _this.maxMorphTargets );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvar refreshProgram = false;\r\n\t\tvar refreshMaterial = false;\r\n\t\tvar refreshLights = false;\r\n\r\n\t\tvar program = material.program,\r\n\t\t\tp_uniforms = program.uniforms,\r\n\t\t\tm_uniforms = material.__webglShader.uniforms;\r\n\r\n\t\tif ( program.id !== _currentProgram ) {\r\n\r\n\t\t\t_gl.useProgram( program.program );\r\n\t\t\t_currentProgram = program.id;\r\n\r\n\t\t\trefreshProgram = true;\r\n\t\t\trefreshMaterial = true;\r\n\t\t\trefreshLights = true;\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.id !== _currentMaterialId ) {\r\n\r\n\t\t\tif ( _currentMaterialId === -1 ) refreshLights = true;\r\n\t\t\t_currentMaterialId = material.id;\r\n\r\n\t\t\trefreshMaterial = true;\r\n\r\n\t\t}\r\n\r\n\t\tif ( refreshProgram || camera !== _currentCamera ) {\r\n\r\n\t\t\t_gl.uniformMatrix4fv( p_uniforms.projectionMatrix, false, camera.projectionMatrix.elements );\r\n\r\n\t\t\tif ( _logarithmicDepthBuffer ) {\r\n\r\n\t\t\t\t_gl.uniform1f( p_uniforms.logDepthBufFC, 2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );\r\n\r\n\t\t\t}\r\n\r\n\r\n\t\t\tif ( camera !== _currentCamera ) _currentCamera = camera;\r\n\r\n\t\t\t// load material specific uniforms\r\n\t\t\t// (shader material also gets them for the sake of genericity)\r\n\r\n\t\t\tif ( material instanceof THREE.ShaderMaterial ||\r\n\t\t\t\t material instanceof THREE.MeshPhongMaterial ||\r\n\t\t\t\t material.envMap ) {\r\n\r\n\t\t\t\tif ( p_uniforms.cameraPosition !== null ) {\r\n\r\n\t\t\t\t\t_vector3.setFromMatrixPosition( camera.matrixWorld );\r\n\t\t\t\t\t_gl.uniform3f( p_uniforms.cameraPosition, _vector3.x, _vector3.y, _vector3.z );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( material instanceof THREE.MeshPhongMaterial ||\r\n\t\t\t\t material instanceof THREE.MeshLambertMaterial ||\r\n\t\t\t\t material instanceof THREE.MeshBasicMaterial ||\r\n\t\t\t\t material instanceof THREE.ShaderMaterial ||\r\n\t\t\t\t material.skinning ) {\r\n\r\n\t\t\t\tif ( p_uniforms.viewMatrix !== null ) {\r\n\r\n\t\t\t\t\t_gl.uniformMatrix4fv( p_uniforms.viewMatrix, false, camera.matrixWorldInverse.elements );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// skinning uniforms must be set even if material didn't change\r\n\t\t// auto-setting of texture unit for bone texture must go before other textures\r\n\t\t// not sure why, but otherwise weird things happen\r\n\r\n\t\tif ( material.skinning ) {\r\n\r\n\t\t\tif ( object.bindMatrix && p_uniforms.bindMatrix !== null ) {\r\n\r\n\t\t\t\t_gl.uniformMatrix4fv( p_uniforms.bindMatrix, false, object.bindMatrix.elements );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( object.bindMatrixInverse && p_uniforms.bindMatrixInverse !== null ) {\r\n\r\n\t\t\t\t_gl.uniformMatrix4fv( p_uniforms.bindMatrixInverse, false, object.bindMatrixInverse.elements );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( _supportsBoneTextures && object.skeleton && object.skeleton.useVertexTexture ) {\r\n\r\n\t\t\t\tif ( p_uniforms.boneTexture !== null ) {\r\n\r\n\t\t\t\t\tvar textureUnit = getTextureUnit();\r\n\r\n\t\t\t\t\t_gl.uniform1i( p_uniforms.boneTexture, textureUnit );\r\n\t\t\t\t\t_this.setTexture( object.skeleton.boneTexture, textureUnit );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( p_uniforms.boneTextureWidth !== null ) {\r\n\r\n\t\t\t\t\t_gl.uniform1i( p_uniforms.boneTextureWidth, object.skeleton.boneTextureWidth );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( p_uniforms.boneTextureHeight !== null ) {\r\n\r\n\t\t\t\t\t_gl.uniform1i( p_uniforms.boneTextureHeight, object.skeleton.boneTextureHeight );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( object.skeleton && object.skeleton.boneMatrices ) {\r\n\r\n\t\t\t\tif ( p_uniforms.boneGlobalMatrices !== null ) {\r\n\r\n\t\t\t\t\t_gl.uniformMatrix4fv( p_uniforms.boneGlobalMatrices, false, object.skeleton.boneMatrices );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( refreshMaterial ) {\r\n\r\n\t\t\t// refresh uniforms common to several materials\r\n\r\n\t\t\tif ( fog && material.fog ) {\r\n\r\n\t\t\t\trefreshUniformsFog( m_uniforms, fog );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( material instanceof THREE.MeshPhongMaterial ||\r\n\t\t\t\t material instanceof THREE.MeshLambertMaterial ||\r\n\t\t\t\t material.lights ) {\r\n\r\n\t\t\t\tif ( _lightsNeedUpdate ) {\r\n\r\n\t\t\t\t\trefreshLights = true;\r\n\t\t\t\t\tsetupLights( lights );\r\n\t\t\t\t\t_lightsNeedUpdate = false;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( refreshLights ) {\r\n\t\t\t\t\trefreshUniformsLights( m_uniforms, _lights );\r\n\t\t\t\t\tmarkUniformsLightsNeedsUpdate( m_uniforms, true );\r\n\t\t\t\t} else {\r\n\t\t\t\t\tmarkUniformsLightsNeedsUpdate( m_uniforms, false );\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( material instanceof THREE.MeshBasicMaterial ||\r\n\t\t\t\t material instanceof THREE.MeshLambertMaterial ||\r\n\t\t\t\t material instanceof THREE.MeshPhongMaterial ) {\r\n\r\n\t\t\t\trefreshUniformsCommon( m_uniforms, material );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// refresh single material specific uniforms\r\n\r\n\t\t\tif ( material instanceof THREE.LineBasicMaterial ) {\r\n\r\n\t\t\t\trefreshUniformsLine( m_uniforms, material );\r\n\r\n\t\t\t} else if ( material instanceof THREE.LineDashedMaterial ) {\r\n\r\n\t\t\t\trefreshUniformsLine( m_uniforms, material );\r\n\t\t\t\trefreshUniformsDash( m_uniforms, material );\r\n\r\n\t\t\t} else if ( material instanceof THREE.PointCloudMaterial ) {\r\n\r\n\t\t\t\trefreshUniformsParticle( m_uniforms, material );\r\n\r\n\t\t\t} else if ( material instanceof THREE.MeshPhongMaterial ) {\r\n\r\n\t\t\t\trefreshUniformsPhong( m_uniforms, material );\r\n\r\n\t\t\t} else if ( material instanceof THREE.MeshLambertMaterial ) {\r\n\r\n\t\t\t\trefreshUniformsLambert( m_uniforms, material );\r\n\r\n\t\t\t} else if ( material instanceof THREE.MeshDepthMaterial ) {\r\n\r\n\t\t\t\tm_uniforms.mNear.value = camera.near;\r\n\t\t\t\tm_uniforms.mFar.value = camera.far;\r\n\t\t\t\tm_uniforms.opacity.value = material.opacity;\r\n\r\n\t\t\t} else if ( material instanceof THREE.MeshNormalMaterial ) {\r\n\r\n\t\t\t\tm_uniforms.opacity.value = material.opacity;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( object.receiveShadow && ! material._shadowPass ) {\r\n\r\n\t\t\t\trefreshUniformsShadow( m_uniforms, lights );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// load common uniforms\r\n\r\n\t\t\tloadUniformsGeneric( material.uniformsList );\r\n\r\n\t\t}\r\n\r\n\t\tloadUniformsMatrices( p_uniforms, object );\r\n\r\n\t\tif ( p_uniforms.modelMatrix !== null ) {\r\n\r\n\t\t\t_gl.uniformMatrix4fv( p_uniforms.modelMatrix, false, object.matrixWorld.elements );\r\n\r\n\t\t}\r\n\r\n\t\treturn program;\r\n\r\n\t}\r\n\r\n\t// Uniforms (refresh uniforms objects)\r\n\r\n\tfunction refreshUniformsCommon ( uniforms, material ) {\r\n\r\n\t\tuniforms.opacity.value = material.opacity;\r\n\r\n\t\tuniforms.diffuse.value = material.color;\r\n\r\n\t\tuniforms.map.value = material.map;\r\n\t\tuniforms.lightMap.value = material.lightMap;\r\n\t\tuniforms.specularMap.value = material.specularMap;\r\n\t\tuniforms.alphaMap.value = material.alphaMap;\r\n\r\n\t\tif ( material.bumpMap ) {\r\n\r\n\t\t\tuniforms.bumpMap.value = material.bumpMap;\r\n\t\t\tuniforms.bumpScale.value = material.bumpScale;\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.normalMap ) {\r\n\r\n\t\t\tuniforms.normalMap.value = material.normalMap;\r\n\t\t\tuniforms.normalScale.value.copy( material.normalScale );\r\n\r\n\t\t}\r\n\r\n\t\t// uv repeat and offset setting priorities\r\n\t\t//  1. color map\r\n\t\t//  2. specular map\r\n\t\t//  3. normal map\r\n\t\t//  4. bump map\r\n\t\t//  5. alpha map\r\n\r\n\t\tvar uvScaleMap;\r\n\r\n\t\tif ( material.map ) {\r\n\r\n\t\t\tuvScaleMap = material.map;\r\n\r\n\t\t} else if ( material.specularMap ) {\r\n\r\n\t\t\tuvScaleMap = material.specularMap;\r\n\r\n\t\t} else if ( material.normalMap ) {\r\n\r\n\t\t\tuvScaleMap = material.normalMap;\r\n\r\n\t\t} else if ( material.bumpMap ) {\r\n\r\n\t\t\tuvScaleMap = material.bumpMap;\r\n\r\n\t\t} else if ( material.alphaMap ) {\r\n\r\n\t\t\tuvScaleMap = material.alphaMap;\r\n\r\n\t\t}\r\n\r\n\t\tif ( uvScaleMap !== undefined ) {\r\n\r\n\t\t\tvar offset = uvScaleMap.offset;\r\n\t\t\tvar repeat = uvScaleMap.repeat;\r\n\r\n\t\t\tuniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );\r\n\r\n\t\t}\r\n\r\n\t\tuniforms.envMap.value = material.envMap;\r\n\t\tuniforms.flipEnvMap.value = ( material.envMap instanceof THREE.WebGLRenderTargetCube ) ? 1 : - 1;\r\n\r\n\t\tuniforms.reflectivity.value = material.reflectivity;\r\n\t\tuniforms.refractionRatio.value = material.refractionRatio;\r\n\r\n\t}\r\n\r\n\tfunction refreshUniformsLine ( uniforms, material ) {\r\n\r\n\t\tuniforms.diffuse.value = material.color;\r\n\t\tuniforms.opacity.value = material.opacity;\r\n\r\n\t}\r\n\r\n\tfunction refreshUniformsDash ( uniforms, material ) {\r\n\r\n\t\tuniforms.dashSize.value = material.dashSize;\r\n\t\tuniforms.totalSize.value = material.dashSize + material.gapSize;\r\n\t\tuniforms.scale.value = material.scale;\r\n\r\n\t}\r\n\r\n\tfunction refreshUniformsParticle ( uniforms, material ) {\r\n\r\n\t\tuniforms.psColor.value = material.color;\r\n\t\tuniforms.opacity.value = material.opacity;\r\n\t\tuniforms.size.value = material.size;\r\n\t\tuniforms.scale.value = _canvas.height / 2.0; // TODO: Cache this.\r\n\r\n\t\tuniforms.map.value = material.map;\r\n\r\n\t\tif ( material.map !== null ) {\r\n\r\n\t\t\tvar offset = material.map.offset;\r\n\t\t\tvar repeat = material.map.repeat;\r\n\r\n\t\t\tuniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction refreshUniformsFog ( uniforms, fog ) {\r\n\r\n\t\tuniforms.fogColor.value = fog.color;\r\n\r\n\t\tif ( fog instanceof THREE.Fog ) {\r\n\r\n\t\t\tuniforms.fogNear.value = fog.near;\r\n\t\t\tuniforms.fogFar.value = fog.far;\r\n\r\n\t\t} else if ( fog instanceof THREE.FogExp2 ) {\r\n\r\n\t\t\tuniforms.fogDensity.value = fog.density;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction refreshUniformsPhong ( uniforms, material ) {\r\n\r\n\t\tuniforms.shininess.value = material.shininess;\r\n\r\n\t\tuniforms.emissive.value = material.emissive;\r\n\t\tuniforms.specular.value = material.specular;\r\n\r\n\t\tif ( material.wrapAround ) {\r\n\r\n\t\t\tuniforms.wrapRGB.value.copy( material.wrapRGB );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction refreshUniformsLambert ( uniforms, material ) {\r\n\r\n\t\tuniforms.emissive.value = material.emissive;\r\n\r\n\t\tif ( material.wrapAround ) {\r\n\r\n\t\t\tuniforms.wrapRGB.value.copy( material.wrapRGB );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction refreshUniformsLights ( uniforms, lights ) {\r\n\r\n\t\tuniforms.ambientLightColor.value = lights.ambient;\r\n\r\n\t\tuniforms.directionalLightColor.value = lights.directional.colors;\r\n\t\tuniforms.directionalLightDirection.value = lights.directional.positions;\r\n\r\n\t\tuniforms.pointLightColor.value = lights.point.colors;\r\n\t\tuniforms.pointLightPosition.value = lights.point.positions;\r\n\t\tuniforms.pointLightDistance.value = lights.point.distances;\r\n\t\tuniforms.pointLightDecay.value = lights.point.decays;\r\n\r\n\t\tuniforms.spotLightColor.value = lights.spot.colors;\r\n\t\tuniforms.spotLightPosition.value = lights.spot.positions;\r\n\t\tuniforms.spotLightDistance.value = lights.spot.distances;\r\n\t\tuniforms.spotLightDirection.value = lights.spot.directions;\r\n\t\tuniforms.spotLightAngleCos.value = lights.spot.anglesCos;\r\n\t\tuniforms.spotLightExponent.value = lights.spot.exponents;\r\n\t\tuniforms.spotLightDecay.value = lights.spot.decays;\r\n\r\n\t\tuniforms.hemisphereLightSkyColor.value = lights.hemi.skyColors;\r\n\t\tuniforms.hemisphereLightGroundColor.value = lights.hemi.groundColors;\r\n\t\tuniforms.hemisphereLightDirection.value = lights.hemi.positions;\r\n\r\n\t}\r\n\r\n\t// If uniforms are marked as clean, they don't need to be loaded to the GPU.\r\n\r\n\tfunction markUniformsLightsNeedsUpdate ( uniforms, value ) {\r\n\r\n\t\tuniforms.ambientLightColor.needsUpdate = value;\r\n\r\n\t\tuniforms.directionalLightColor.needsUpdate = value;\r\n\t\tuniforms.directionalLightDirection.needsUpdate = value;\r\n\r\n\t\tuniforms.pointLightColor.needsUpdate = value;\r\n\t\tuniforms.pointLightPosition.needsUpdate = value;\r\n\t\tuniforms.pointLightDistance.needsUpdate = value;\r\n\t\tuniforms.pointLightDecay.needsUpdate = value;\r\n\r\n\t\tuniforms.spotLightColor.needsUpdate = value;\r\n\t\tuniforms.spotLightPosition.needsUpdate = value;\r\n\t\tuniforms.spotLightDistance.needsUpdate = value;\r\n\t\tuniforms.spotLightDirection.needsUpdate = value;\r\n\t\tuniforms.spotLightAngleCos.needsUpdate = value;\r\n\t\tuniforms.spotLightExponent.needsUpdate = value;\r\n\t\tuniforms.spotLightDecay.needsUpdate = value;\r\n\r\n\t\tuniforms.hemisphereLightSkyColor.needsUpdate = value;\r\n\t\tuniforms.hemisphereLightGroundColor.needsUpdate = value;\r\n\t\tuniforms.hemisphereLightDirection.needsUpdate = value;\r\n\r\n\t}\r\n\r\n\tfunction refreshUniformsShadow ( uniforms, lights ) {\r\n\r\n\t\tif ( uniforms.shadowMatrix ) {\r\n\r\n\t\t\tvar j = 0;\r\n\r\n\t\t\tfor ( var i = 0, il = lights.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tvar light = lights[ i ];\r\n\r\n\t\t\t\tif ( ! light.castShadow ) continue;\r\n\r\n\t\t\t\tif ( light instanceof THREE.SpotLight || ( light instanceof THREE.DirectionalLight && ! light.shadowCascade ) ) {\r\n\r\n\t\t\t\t\tuniforms.shadowMap.value[ j ] = light.shadowMap;\r\n\t\t\t\t\tuniforms.shadowMapSize.value[ j ] = light.shadowMapSize;\r\n\r\n\t\t\t\t\tuniforms.shadowMatrix.value[ j ] = light.shadowMatrix;\r\n\r\n\t\t\t\t\tuniforms.shadowDarkness.value[ j ] = light.shadowDarkness;\r\n\t\t\t\t\tuniforms.shadowBias.value[ j ] = light.shadowBias;\r\n\r\n\t\t\t\t\tj ++;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// Uniforms (load to GPU)\r\n\r\n\tfunction loadUniformsMatrices ( uniforms, object ) {\r\n\r\n\t\t_gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, object._modelViewMatrix.elements );\r\n\r\n\t\tif ( uniforms.normalMatrix ) {\r\n\r\n\t\t\t_gl.uniformMatrix3fv( uniforms.normalMatrix, false, object._normalMatrix.elements );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction getTextureUnit() {\r\n\r\n\t\tvar textureUnit = _usedTextureUnits;\r\n\r\n\t\tif ( textureUnit >= _maxTextures ) {\r\n\r\n\t\t\tTHREE.warn( 'WebGLRenderer: trying to use ' + textureUnit + ' texture units while this GPU supports only ' + _maxTextures );\r\n\r\n\t\t}\r\n\r\n\t\t_usedTextureUnits += 1;\r\n\r\n\t\treturn textureUnit;\r\n\r\n\t}\r\n\r\n\tfunction loadUniformsGeneric ( uniforms ) {\r\n\r\n\t\tvar texture, textureUnit, offset;\r\n\r\n\t\tfor ( var j = 0, jl = uniforms.length; j < jl; j ++ ) {\r\n\r\n\t\t\tvar uniform = uniforms[ j ][ 0 ];\r\n\r\n\t\t\t// needsUpdate property is not added to all uniforms.\r\n\t\t\tif ( uniform.needsUpdate === false ) continue;\r\n\r\n\t\t\tvar type = uniform.type;\r\n\t\t\tvar value = uniform.value;\r\n\t\t\tvar location = uniforms[ j ][ 1 ];\r\n\r\n\t\t\tswitch ( type ) {\r\n\r\n\t\t\t\tcase '1i':\r\n\t\t\t\t\t_gl.uniform1i( location, value );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase '1f':\r\n\t\t\t\t\t_gl.uniform1f( location, value );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase '2f':\r\n\t\t\t\t\t_gl.uniform2f( location, value[ 0 ], value[ 1 ] );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase '3f':\r\n\t\t\t\t\t_gl.uniform3f( location, value[ 0 ], value[ 1 ], value[ 2 ] );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase '4f':\r\n\t\t\t\t\t_gl.uniform4f( location, value[ 0 ], value[ 1 ], value[ 2 ], value[ 3 ] );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase '1iv':\r\n\t\t\t\t\t_gl.uniform1iv( location, value );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase '3iv':\r\n\t\t\t\t\t_gl.uniform3iv( location, value );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase '1fv':\r\n\t\t\t\t\t_gl.uniform1fv( location, value );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase '2fv':\r\n\t\t\t\t\t_gl.uniform2fv( location, value );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase '3fv':\r\n\t\t\t\t\t_gl.uniform3fv( location, value );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase '4fv':\r\n\t\t\t\t\t_gl.uniform4fv( location, value );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'Matrix3fv':\r\n\t\t\t\t\t_gl.uniformMatrix3fv( location, false, value );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'Matrix4fv':\r\n\t\t\t\t\t_gl.uniformMatrix4fv( location, false, value );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t//\r\n\r\n\t\t\t\tcase 'i':\r\n\r\n\t\t\t\t\t// single integer\r\n\t\t\t\t\t_gl.uniform1i( location, value );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'f':\r\n\r\n\t\t\t\t\t// single float\r\n\t\t\t\t\t_gl.uniform1f( location, value );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'v2':\r\n\r\n\t\t\t\t\t// single THREE.Vector2\r\n\t\t\t\t\t_gl.uniform2f( location, value.x, value.y );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'v3':\r\n\r\n\t\t\t\t\t// single THREE.Vector3\r\n\t\t\t\t\t_gl.uniform3f( location, value.x, value.y, value.z );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'v4':\r\n\r\n\t\t\t\t\t// single THREE.Vector4\r\n\t\t\t\t\t_gl.uniform4f( location, value.x, value.y, value.z, value.w );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'c':\r\n\r\n\t\t\t\t\t// single THREE.Color\r\n\t\t\t\t\t_gl.uniform3f( location, value.r, value.g, value.b );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'iv1':\r\n\r\n\t\t\t\t\t// flat array of integers (JS or typed array)\r\n\t\t\t\t\t_gl.uniform1iv( location, value );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'iv':\r\n\r\n\t\t\t\t\t// flat array of integers with 3 x N size (JS or typed array)\r\n\t\t\t\t\t_gl.uniform3iv( location, value );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'fv1':\r\n\r\n\t\t\t\t\t// flat array of floats (JS or typed array)\r\n\t\t\t\t\t_gl.uniform1fv( location, value );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'fv':\r\n\r\n\t\t\t\t\t// flat array of floats with 3 x N size (JS or typed array)\r\n\t\t\t\t\t_gl.uniform3fv( location, value );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'v2v':\r\n\r\n\t\t\t\t\t// array of THREE.Vector2\r\n\r\n\t\t\t\t\tif ( uniform._array === undefined ) {\r\n\r\n\t\t\t\t\t\tuniform._array = new Float32Array( 2 * value.length );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tfor ( var i = 0, il = value.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\t\toffset = i * 2;\r\n\r\n\t\t\t\t\t\tuniform._array[ offset ]   = value[ i ].x;\r\n\t\t\t\t\t\tuniform._array[ offset + 1 ] = value[ i ].y;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t_gl.uniform2fv( location, uniform._array );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'v3v':\r\n\r\n\t\t\t\t\t// array of THREE.Vector3\r\n\r\n\t\t\t\t\tif ( uniform._array === undefined ) {\r\n\r\n\t\t\t\t\t\tuniform._array = new Float32Array( 3 * value.length );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tfor ( var i = 0, il = value.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\t\toffset = i * 3;\r\n\r\n\t\t\t\t\t\tuniform._array[ offset ]   = value[ i ].x;\r\n\t\t\t\t\t\tuniform._array[ offset + 1 ] = value[ i ].y;\r\n\t\t\t\t\t\tuniform._array[ offset + 2 ] = value[ i ].z;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t_gl.uniform3fv( location, uniform._array );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'v4v':\r\n\r\n\t\t\t\t\t// array of THREE.Vector4\r\n\r\n\t\t\t\t\tif ( uniform._array === undefined ) {\r\n\r\n\t\t\t\t\t\tuniform._array = new Float32Array( 4 * value.length );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tfor ( var i = 0, il = value.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\t\toffset = i * 4;\r\n\r\n\t\t\t\t\t\tuniform._array[ offset ]   = value[ i ].x;\r\n\t\t\t\t\t\tuniform._array[ offset + 1 ] = value[ i ].y;\r\n\t\t\t\t\t\tuniform._array[ offset + 2 ] = value[ i ].z;\r\n\t\t\t\t\t\tuniform._array[ offset + 3 ] = value[ i ].w;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t_gl.uniform4fv( location, uniform._array );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'm3':\r\n\r\n\t\t\t\t\t// single THREE.Matrix3\r\n\t\t\t\t\t_gl.uniformMatrix3fv( location, false, value.elements );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'm3v':\r\n\r\n\t\t\t\t\t// array of THREE.Matrix3\r\n\r\n\t\t\t\t\tif ( uniform._array === undefined ) {\r\n\r\n\t\t\t\t\t\tuniform._array = new Float32Array( 9 * value.length );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tfor ( var i = 0, il = value.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\t\tvalue[ i ].flattenToArrayOffset( uniform._array, i * 9 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t_gl.uniformMatrix3fv( location, false, uniform._array );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'm4':\r\n\r\n\t\t\t\t\t// single THREE.Matrix4\r\n\t\t\t\t\t_gl.uniformMatrix4fv( location, false, value.elements );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'm4v':\r\n\r\n\t\t\t\t\t// array of THREE.Matrix4\r\n\r\n\t\t\t\t\tif ( uniform._array === undefined ) {\r\n\r\n\t\t\t\t\t\tuniform._array = new Float32Array( 16 * value.length );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tfor ( var i = 0, il = value.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\t\tvalue[ i ].flattenToArrayOffset( uniform._array, i * 16 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t_gl.uniformMatrix4fv( location, false, uniform._array );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 't':\r\n\r\n\t\t\t\t\t// single THREE.Texture (2d or cube)\r\n\r\n\t\t\t\t\ttexture = value;\r\n\t\t\t\t\ttextureUnit = getTextureUnit();\r\n\r\n\t\t\t\t\t_gl.uniform1i( location, textureUnit );\r\n\r\n\t\t\t\t\tif ( ! texture ) continue;\r\n\r\n\t\t\t\t\tif ( texture instanceof THREE.CubeTexture ||\r\n\t\t\t\t\t   ( texture.image instanceof Array && texture.image.length === 6 ) ) { // CompressedTexture can have Array in image :/\r\n\r\n\t\t\t\t\t\tsetCubeTexture( texture, textureUnit );\r\n\r\n\t\t\t\t\t} else if ( texture instanceof THREE.WebGLRenderTargetCube ) {\r\n\r\n\t\t\t\t\t\tsetCubeTextureDynamic( texture, textureUnit );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t_this.setTexture( texture, textureUnit );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'tv':\r\n\r\n\t\t\t\t\t// array of THREE.Texture (2d)\r\n\r\n\t\t\t\t\tif ( uniform._array === undefined ) {\r\n\r\n\t\t\t\t\t\tuniform._array = [];\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tfor ( var i = 0, il = uniform.value.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\t\tuniform._array[ i ] = getTextureUnit();\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t_gl.uniform1iv( location, uniform._array );\r\n\r\n\t\t\t\t\tfor ( var i = 0, il = uniform.value.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\t\ttexture = uniform.value[ i ];\r\n\t\t\t\t\t\ttextureUnit = uniform._array[ i ];\r\n\r\n\t\t\t\t\t\tif ( ! texture ) continue;\r\n\r\n\t\t\t\t\t\t_this.setTexture( texture, textureUnit );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tdefault:\r\n\r\n\t\t\t\t\tTHREE.warn( 'THREE.WebGLRenderer: Unknown uniform type: ' + type );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction setupMatrices ( object, camera ) {\r\n\r\n\t\tobject._modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );\r\n\t\tobject._normalMatrix.getNormalMatrix( object._modelViewMatrix );\r\n\r\n\t}\r\n\r\n\tfunction setColorLinear( array, offset, color, intensity ) {\r\n\r\n\t\tarray[ offset ]     = color.r * intensity;\r\n\t\tarray[ offset + 1 ] = color.g * intensity;\r\n\t\tarray[ offset + 2 ] = color.b * intensity;\r\n\r\n\t}\r\n\r\n\tfunction setupLights ( lights ) {\r\n\r\n\t\tvar l, ll, light,\r\n\t\tr = 0, g = 0, b = 0,\r\n\t\tcolor, skyColor, groundColor,\r\n\t\tintensity,\r\n\t\tdistance,\r\n\r\n\t\tzlights = _lights,\r\n\r\n\t\tdirColors = zlights.directional.colors,\r\n\t\tdirPositions = zlights.directional.positions,\r\n\r\n\t\tpointColors = zlights.point.colors,\r\n\t\tpointPositions = zlights.point.positions,\r\n\t\tpointDistances = zlights.point.distances,\r\n\t\tpointDecays = zlights.point.decays,\r\n\r\n\t\tspotColors = zlights.spot.colors,\r\n\t\tspotPositions = zlights.spot.positions,\r\n\t\tspotDistances = zlights.spot.distances,\r\n\t\tspotDirections = zlights.spot.directions,\r\n\t\tspotAnglesCos = zlights.spot.anglesCos,\r\n\t\tspotExponents = zlights.spot.exponents,\r\n\t\tspotDecays = zlights.spot.decays,\r\n\r\n\t\themiSkyColors = zlights.hemi.skyColors,\r\n\t\themiGroundColors = zlights.hemi.groundColors,\r\n\t\themiPositions = zlights.hemi.positions,\r\n\r\n\t\tdirLength = 0,\r\n\t\tpointLength = 0,\r\n\t\tspotLength = 0,\r\n\t\themiLength = 0,\r\n\r\n\t\tdirCount = 0,\r\n\t\tpointCount = 0,\r\n\t\tspotCount = 0,\r\n\t\themiCount = 0,\r\n\r\n\t\tdirOffset = 0,\r\n\t\tpointOffset = 0,\r\n\t\tspotOffset = 0,\r\n\t\themiOffset = 0;\r\n\r\n\t\tfor ( l = 0, ll = lights.length; l < ll; l ++ ) {\r\n\r\n\t\t\tlight = lights[ l ];\r\n\r\n\t\t\tif ( light.onlyShadow ) continue;\r\n\r\n\t\t\tcolor = light.color;\r\n\t\t\tintensity = light.intensity;\r\n\t\t\tdistance = light.distance;\r\n\r\n\t\t\tif ( light instanceof THREE.AmbientLight ) {\r\n\r\n\t\t\t\tif ( ! light.visible ) continue;\r\n\r\n\t\t\t\tr += color.r;\r\n\t\t\t\tg += color.g;\r\n\t\t\t\tb += color.b;\r\n\r\n\t\t\t} else if ( light instanceof THREE.DirectionalLight ) {\r\n\r\n\t\t\t\tdirCount += 1;\r\n\r\n\t\t\t\tif ( ! light.visible ) continue;\r\n\r\n\t\t\t\t_direction.setFromMatrixPosition( light.matrixWorld );\r\n\t\t\t\t_vector3.setFromMatrixPosition( light.target.matrixWorld );\r\n\t\t\t\t_direction.sub( _vector3 );\r\n\t\t\t\t_direction.normalize();\r\n\r\n\t\t\t\tdirOffset = dirLength * 3;\r\n\r\n\t\t\t\tdirPositions[ dirOffset ]     = _direction.x;\r\n\t\t\t\tdirPositions[ dirOffset + 1 ] = _direction.y;\r\n\t\t\t\tdirPositions[ dirOffset + 2 ] = _direction.z;\r\n\r\n\t\t\t\tsetColorLinear( dirColors, dirOffset, color, intensity );\r\n\r\n\t\t\t\tdirLength += 1;\r\n\r\n\t\t\t} else if ( light instanceof THREE.PointLight ) {\r\n\r\n\t\t\t\tpointCount += 1;\r\n\r\n\t\t\t\tif ( ! light.visible ) continue;\r\n\r\n\t\t\t\tpointOffset = pointLength * 3;\r\n\r\n\t\t\t\tsetColorLinear( pointColors, pointOffset, color, intensity );\r\n\r\n\t\t\t\t_vector3.setFromMatrixPosition( light.matrixWorld );\r\n\r\n\t\t\t\tpointPositions[ pointOffset ]     = _vector3.x;\r\n\t\t\t\tpointPositions[ pointOffset + 1 ] = _vector3.y;\r\n\t\t\t\tpointPositions[ pointOffset + 2 ] = _vector3.z;\r\n\r\n\t\t\t\t// distance is 0 if decay is 0, because there is no attenuation at all.\r\n\t\t\t\tpointDistances[ pointLength ] = distance;\r\n\t\t\t\tpointDecays[ pointLength ] = ( light.distance === 0 ) ? 0.0 : light.decay;\r\n\r\n\t\t\t\tpointLength += 1;\r\n\r\n\t\t\t} else if ( light instanceof THREE.SpotLight ) {\r\n\r\n\t\t\t\tspotCount += 1;\r\n\r\n\t\t\t\tif ( ! light.visible ) continue;\r\n\r\n\t\t\t\tspotOffset = spotLength * 3;\r\n\r\n\t\t\t\tsetColorLinear( spotColors, spotOffset, color, intensity );\r\n\r\n\t\t\t\t_direction.setFromMatrixPosition( light.matrixWorld );\r\n\r\n\t\t\t\tspotPositions[ spotOffset ]     = _direction.x;\r\n\t\t\t\tspotPositions[ spotOffset + 1 ] = _direction.y;\r\n\t\t\t\tspotPositions[ spotOffset + 2 ] = _direction.z;\r\n\r\n\t\t\t\tspotDistances[ spotLength ] = distance;\r\n\r\n\t\t\t\t_vector3.setFromMatrixPosition( light.target.matrixWorld );\r\n\t\t\t\t_direction.sub( _vector3 );\r\n\t\t\t\t_direction.normalize();\r\n\r\n\t\t\t\tspotDirections[ spotOffset ]     = _direction.x;\r\n\t\t\t\tspotDirections[ spotOffset + 1 ] = _direction.y;\r\n\t\t\t\tspotDirections[ spotOffset + 2 ] = _direction.z;\r\n\r\n\t\t\t\tspotAnglesCos[ spotLength ] = Math.cos( light.angle );\r\n\t\t\t\tspotExponents[ spotLength ] = light.exponent;\r\n\t\t\t\tspotDecays[ spotLength ] = ( light.distance === 0 ) ? 0.0 : light.decay;\r\n\r\n\t\t\t\tspotLength += 1;\r\n\r\n\t\t\t} else if ( light instanceof THREE.HemisphereLight ) {\r\n\r\n\t\t\t\themiCount += 1;\r\n\r\n\t\t\t\tif ( ! light.visible ) continue;\r\n\r\n\t\t\t\t_direction.setFromMatrixPosition( light.matrixWorld );\r\n\t\t\t\t_direction.normalize();\r\n\r\n\t\t\t\themiOffset = hemiLength * 3;\r\n\r\n\t\t\t\themiPositions[ hemiOffset ]     = _direction.x;\r\n\t\t\t\themiPositions[ hemiOffset + 1 ] = _direction.y;\r\n\t\t\t\themiPositions[ hemiOffset + 2 ] = _direction.z;\r\n\r\n\t\t\t\tskyColor = light.color;\r\n\t\t\t\tgroundColor = light.groundColor;\r\n\r\n\t\t\t\tsetColorLinear( hemiSkyColors, hemiOffset, skyColor, intensity );\r\n\t\t\t\tsetColorLinear( hemiGroundColors, hemiOffset, groundColor, intensity );\r\n\r\n\t\t\t\themiLength += 1;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// null eventual remains from removed lights\r\n\t\t// (this is to avoid if in shader)\r\n\r\n\t\tfor ( l = dirLength * 3, ll = Math.max( dirColors.length, dirCount * 3 ); l < ll; l ++ ) dirColors[ l ] = 0.0;\r\n\t\tfor ( l = pointLength * 3, ll = Math.max( pointColors.length, pointCount * 3 ); l < ll; l ++ ) pointColors[ l ] = 0.0;\r\n\t\tfor ( l = spotLength * 3, ll = Math.max( spotColors.length, spotCount * 3 ); l < ll; l ++ ) spotColors[ l ] = 0.0;\r\n\t\tfor ( l = hemiLength * 3, ll = Math.max( hemiSkyColors.length, hemiCount * 3 ); l < ll; l ++ ) hemiSkyColors[ l ] = 0.0;\r\n\t\tfor ( l = hemiLength * 3, ll = Math.max( hemiGroundColors.length, hemiCount * 3 ); l < ll; l ++ ) hemiGroundColors[ l ] = 0.0;\r\n\r\n\t\tzlights.directional.length = dirLength;\r\n\t\tzlights.point.length = pointLength;\r\n\t\tzlights.spot.length = spotLength;\r\n\t\tzlights.hemi.length = hemiLength;\r\n\r\n\t\tzlights.ambient[ 0 ] = r;\r\n\t\tzlights.ambient[ 1 ] = g;\r\n\t\tzlights.ambient[ 2 ] = b;\r\n\r\n\t}\r\n\r\n\t// GL state setting\r\n\r\n\tthis.setFaceCulling = function ( cullFace, frontFaceDirection ) {\r\n\r\n\t\tif ( cullFace === THREE.CullFaceNone ) {\r\n\r\n\t\t\t_gl.disable( _gl.CULL_FACE );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tif ( frontFaceDirection === THREE.FrontFaceDirectionCW ) {\r\n\r\n\t\t\t\t_gl.frontFace( _gl.CW );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t_gl.frontFace( _gl.CCW );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( cullFace === THREE.CullFaceBack ) {\r\n\r\n\t\t\t\t_gl.cullFace( _gl.BACK );\r\n\r\n\t\t\t} else if ( cullFace === THREE.CullFaceFront ) {\r\n\r\n\t\t\t\t_gl.cullFace( _gl.FRONT );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t_gl.cullFace( _gl.FRONT_AND_BACK );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_gl.enable( _gl.CULL_FACE );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.setMaterialFaces = function ( material ) {\r\n\r\n\t\tstate.setDoubleSided( material.side === THREE.DoubleSide );\r\n\t\tstate.setFlipSided( material.side === THREE.BackSide );\r\n\r\n\t};\r\n\r\n\t// Textures\r\n\r\n\tfunction setTextureParameters ( textureType, texture, isImagePowerOfTwo ) {\r\n\r\n\t\tvar extension;\r\n\r\n\t\tif ( isImagePowerOfTwo ) {\r\n\r\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL( texture.wrapS ) );\r\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL( texture.wrapT ) );\r\n\r\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL( texture.magFilter ) );\r\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL( texture.minFilter ) );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );\r\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );\r\n\r\n\t\t\tif ( texture.wrapS !== THREE.ClampToEdgeWrapping || texture.wrapT !== THREE.ClampToEdgeWrapping ) {\r\n\r\n\t\t\t\tTHREE.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping. ( ' + texture.sourceFile + ' )' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );\r\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );\r\n\r\n\t\t\tif ( texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter ) {\r\n\r\n\t\t\t\tTHREE.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter. ( ' + texture.sourceFile + ' )' );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\textension = extensions.get( 'EXT_texture_filter_anisotropic' );\r\n\r\n\t\tif ( extension && texture.type !== THREE.FloatType && texture.type !== THREE.HalfFloatType ) {\r\n\r\n\t\t\tif ( texture.anisotropy > 1 || texture.__currentAnisotropy ) {\r\n\r\n\t\t\t\t_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, _this.getMaxAnisotropy() ) );\r\n\t\t\t\ttexture.__currentAnisotropy = texture.anisotropy;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tthis.uploadTexture = function ( texture ) {\r\n\r\n\t\tif ( texture.__webglInit === undefined ) {\r\n\r\n\t\t\ttexture.__webglInit = true;\r\n\r\n\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\r\n\r\n\t\t\ttexture.__webglTexture = _gl.createTexture();\r\n\r\n\t\t\t_this.info.memory.textures ++;\r\n\r\n\t\t}\r\n\r\n\t\t_gl.bindTexture( _gl.TEXTURE_2D, texture.__webglTexture );\r\n\r\n\t\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\r\n\t\t_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );\r\n\t\t_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );\r\n\r\n\t\ttexture.image = clampToMaxSize( texture.image, _maxTextureSize );\r\n\r\n\t\tvar image = texture.image,\r\n\t\tisImagePowerOfTwo = THREE.Math.isPowerOfTwo( image.width ) && THREE.Math.isPowerOfTwo( image.height ),\r\n\t\tglFormat = paramThreeToGL( texture.format ),\r\n\t\tglType = paramThreeToGL( texture.type );\r\n\r\n\t\tsetTextureParameters( _gl.TEXTURE_2D, texture, isImagePowerOfTwo );\r\n\r\n\t\tvar mipmap, mipmaps = texture.mipmaps;\r\n\r\n\t\tif ( texture instanceof THREE.DataTexture ) {\r\n\r\n\t\t\t// use manually created mipmaps if available\r\n\t\t\t// if there are no manual mipmaps\r\n\t\t\t// set 0 level mipmap and then use GL to generate other mipmap levels\r\n\r\n\t\t\tif ( mipmaps.length > 0 && isImagePowerOfTwo ) {\r\n\r\n\t\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tmipmap = mipmaps[ i ];\r\n\t\t\t\t\t_gl.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttexture.generateMipmaps = false;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t_gl.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( texture instanceof THREE.CompressedTexture ) {\r\n\r\n\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tmipmap = mipmaps[ i ];\r\n\r\n\t\t\t\tif ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {\r\n\r\n\t\t\t\t\tif ( getCompressedTextureFormats().indexOf( glFormat ) > -1 ) {\r\n\r\n\t\t\t\t\t\t_gl.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tTHREE.warn( \"THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()\" );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t_gl.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else { // regular Texture (image, video, canvas)\r\n\r\n\t\t\t// use manually created mipmaps if available\r\n\t\t\t// if there are no manual mipmaps\r\n\t\t\t// set 0 level mipmap and then use GL to generate other mipmap levels\r\n\r\n\t\t\tif ( mipmaps.length > 0 && isImagePowerOfTwo ) {\r\n\r\n\t\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tmipmap = mipmaps[ i ];\r\n\t\t\t\t\t_gl.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttexture.generateMipmaps = false;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t_gl.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, texture.image );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( texture.generateMipmaps && isImagePowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );\r\n\r\n\t\ttexture.needsUpdate = false;\r\n\r\n\t\tif ( texture.onUpdate ) texture.onUpdate();\r\n\r\n\t};\r\n\r\n\tthis.setTexture = function ( texture, slot ) {\r\n\r\n\t\t_gl.activeTexture( _gl.TEXTURE0 + slot );\r\n\r\n\t\tif ( texture.needsUpdate ) {\r\n\r\n\t\t\t_this.uploadTexture( texture );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t_gl.bindTexture( _gl.TEXTURE_2D, texture.__webglTexture );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction clampToMaxSize ( image, maxSize ) {\r\n\r\n\t\tif ( image.width > maxSize || image.height > maxSize ) {\r\n\r\n\t\t\t// Warning: Scaling through the canvas will only work with images that use\r\n\t\t\t// premultiplied alpha.\r\n\r\n\t\t\tvar scale = maxSize / Math.max( image.width, image.height );\r\n\r\n\t\t\tvar canvas = document.createElement( 'canvas' );\r\n\t\t\tcanvas.width = Math.floor( image.width * scale );\r\n\t\t\tcanvas.height = Math.floor( image.height * scale );\r\n\r\n\t\t\tvar context = canvas.getContext( '2d' );\r\n\t\t\tcontext.drawImage( image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height );\r\n\r\n\t\t\tTHREE.warn( 'THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );\r\n\r\n\t\t\treturn canvas;\r\n\r\n\t\t}\r\n\r\n\t\treturn image;\r\n\r\n\t}\r\n\r\n\tfunction setCubeTexture ( texture, slot ) {\r\n\r\n\t\tif ( texture.image.length === 6 ) {\r\n\r\n\t\t\tif ( texture.needsUpdate ) {\r\n\r\n\t\t\t\tif ( ! texture.image.__webglTextureCube ) {\r\n\r\n\t\t\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\r\n\r\n\t\t\t\t\ttexture.image.__webglTextureCube = _gl.createTexture();\r\n\r\n\t\t\t\t\t_this.info.memory.textures ++;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t_gl.activeTexture( _gl.TEXTURE0 + slot );\r\n\t\t\t\t_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.image.__webglTextureCube );\r\n\r\n\t\t\t\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\r\n\r\n\t\t\t\tvar isCompressed = texture instanceof THREE.CompressedTexture;\r\n\t\t\t\tvar isDataTexture = texture.image[ 0 ] instanceof THREE.DataTexture;\r\n\r\n\t\t\t\tvar cubeImage = [];\r\n\r\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\t\t\tif ( _this.autoScaleCubemaps && ! isCompressed && ! isDataTexture ) {\r\n\r\n\t\t\t\t\t\tcubeImage[ i ] = clampToMaxSize( texture.image[ i ], _maxCubemapSize );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tcubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar image = cubeImage[ 0 ],\r\n\t\t\t\tisImagePowerOfTwo = THREE.Math.isPowerOfTwo( image.width ) && THREE.Math.isPowerOfTwo( image.height ),\r\n\t\t\t\tglFormat = paramThreeToGL( texture.format ),\r\n\t\t\t\tglType = paramThreeToGL( texture.type );\r\n\r\n\t\t\t\tsetTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isImagePowerOfTwo );\r\n\r\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\t\t\tif ( ! isCompressed ) {\r\n\r\n\t\t\t\t\t\tif ( isDataTexture ) {\r\n\r\n\t\t\t\t\t\t\t_gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t_gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tvar mipmap, mipmaps = cubeImage[ i ].mipmaps;\r\n\r\n\t\t\t\t\t\tfor ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\t\t\tmipmap = mipmaps[ j ];\r\n\r\n\t\t\t\t\t\t\tif ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {\r\n\r\n\t\t\t\t\t\t\t\tif ( getCompressedTextureFormats().indexOf( glFormat ) > -1 ) {\r\n\r\n\t\t\t\t\t\t\t\t\t_gl.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );\r\n\r\n\t\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\t\tTHREE.warn( \"THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setCubeTexture()\" );\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\t_gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( texture.generateMipmaps && isImagePowerOfTwo ) {\r\n\r\n\t\t\t\t\t_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttexture.needsUpdate = false;\r\n\r\n\t\t\t\tif ( texture.onUpdate ) texture.onUpdate();\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t_gl.activeTexture( _gl.TEXTURE0 + slot );\r\n\t\t\t\t_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.image.__webglTextureCube );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction setCubeTextureDynamic ( texture, slot ) {\r\n\r\n\t\t_gl.activeTexture( _gl.TEXTURE0 + slot );\r\n\t\t_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.__webglTexture );\r\n\r\n\t}\r\n\r\n\t// Render targets\r\n\r\n\tfunction setupFrameBuffer ( framebuffer, renderTarget, textureTarget ) {\r\n\r\n\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\r\n\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureTarget, renderTarget.__webglTexture, 0 );\r\n\r\n\t}\r\n\r\n\tfunction setupRenderBuffer ( renderbuffer, renderTarget  ) {\r\n\r\n\t\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );\r\n\r\n\t\tif ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {\r\n\r\n\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );\r\n\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\r\n\r\n\t\t/* For some reason this is not working. Defaulting to RGBA4.\r\n\t\t} else if ( ! renderTarget.depthBuffer && renderTarget.stencilBuffer ) {\r\n\r\n\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.STENCIL_INDEX8, renderTarget.width, renderTarget.height );\r\n\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\r\n\t\t*/\r\n\t\t} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {\r\n\r\n\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );\r\n\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tthis.setRenderTarget = function ( renderTarget ) {\r\n\r\n\t\tvar isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );\r\n\r\n\t\tif ( renderTarget && renderTarget.__webglFramebuffer === undefined ) {\r\n\r\n\t\t\tif ( renderTarget.depthBuffer === undefined ) renderTarget.depthBuffer = true;\r\n\t\t\tif ( renderTarget.stencilBuffer === undefined ) renderTarget.stencilBuffer = true;\r\n\r\n\t\t\trenderTarget.addEventListener( 'dispose', onRenderTargetDispose );\r\n\r\n\t\t\trenderTarget.__webglTexture = _gl.createTexture();\r\n\r\n\t\t\t_this.info.memory.textures ++;\r\n\r\n\t\t\t// Setup texture, create render and frame buffers\r\n\r\n\t\t\tvar isTargetPowerOfTwo = THREE.Math.isPowerOfTwo( renderTarget.width ) && THREE.Math.isPowerOfTwo( renderTarget.height ),\r\n\t\t\t\tglFormat = paramThreeToGL( renderTarget.format ),\r\n\t\t\t\tglType = paramThreeToGL( renderTarget.type );\r\n\r\n\t\t\tif ( isCube ) {\r\n\r\n\t\t\t\trenderTarget.__webglFramebuffer = [];\r\n\t\t\t\trenderTarget.__webglRenderbuffer = [];\r\n\r\n\t\t\t\t_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, renderTarget.__webglTexture );\r\n\t\t\t\tsetTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget, isTargetPowerOfTwo );\r\n\r\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\t\t\trenderTarget.__webglFramebuffer[ i ] = _gl.createFramebuffer();\r\n\t\t\t\t\trenderTarget.__webglRenderbuffer[ i ] = _gl.createRenderbuffer();\r\n\r\n\t\t\t\t\t_gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );\r\n\r\n\t\t\t\t\tsetupFrameBuffer( renderTarget.__webglFramebuffer[ i ], renderTarget, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );\r\n\t\t\t\t\tsetupRenderBuffer( renderTarget.__webglRenderbuffer[ i ], renderTarget );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\trenderTarget.__webglFramebuffer = _gl.createFramebuffer();\r\n\r\n\t\t\t\tif ( renderTarget.shareDepthFrom ) {\r\n\r\n\t\t\t\t\trenderTarget.__webglRenderbuffer = renderTarget.shareDepthFrom.__webglRenderbuffer;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\trenderTarget.__webglRenderbuffer = _gl.createRenderbuffer();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t_gl.bindTexture( _gl.TEXTURE_2D, renderTarget.__webglTexture );\r\n\t\t\t\tsetTextureParameters( _gl.TEXTURE_2D, renderTarget, isTargetPowerOfTwo );\r\n\r\n\t\t\t\t_gl.texImage2D( _gl.TEXTURE_2D, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );\r\n\r\n\t\t\t\tsetupFrameBuffer( renderTarget.__webglFramebuffer, renderTarget, _gl.TEXTURE_2D );\r\n\r\n\t\t\t\tif ( renderTarget.shareDepthFrom ) {\r\n\r\n\t\t\t\t\tif ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {\r\n\r\n\t\t\t\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderTarget.__webglRenderbuffer );\r\n\r\n\t\t\t\t\t} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {\r\n\r\n\t\t\t\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderTarget.__webglRenderbuffer );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tsetupRenderBuffer( renderTarget.__webglRenderbuffer, renderTarget );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Release everything\r\n\r\n\t\t\tif ( isCube ) {\r\n\r\n\t\t\t\t_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, null );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t_gl.bindTexture( _gl.TEXTURE_2D, null );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );\r\n\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );\r\n\r\n\t\t}\r\n\r\n\t\tvar framebuffer, width, height, vx, vy;\r\n\r\n\t\tif ( renderTarget ) {\r\n\r\n\t\t\tif ( isCube ) {\r\n\r\n\t\t\t\tframebuffer = renderTarget.__webglFramebuffer[ renderTarget.activeCubeFace ];\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tframebuffer = renderTarget.__webglFramebuffer;\r\n\r\n\t\t\t}\r\n\r\n\t\t\twidth = renderTarget.width;\r\n\t\t\theight = renderTarget.height;\r\n\r\n\t\t\tvx = 0;\r\n\t\t\tvy = 0;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tframebuffer = null;\r\n\r\n\t\t\twidth = _viewportWidth;\r\n\t\t\theight = _viewportHeight;\r\n\r\n\t\t\tvx = _viewportX;\r\n\t\t\tvy = _viewportY;\r\n\r\n\t\t}\r\n\r\n\t\tif ( framebuffer !== _currentFramebuffer ) {\r\n\r\n\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\r\n\t\t\t_gl.viewport( vx, vy, width, height );\r\n\r\n\t\t\t_currentFramebuffer = framebuffer;\r\n\r\n\t\t}\r\n\r\n\t\t_currentWidth = width;\r\n\t\t_currentHeight = height;\r\n\r\n\t};\r\n\r\n\tthis.readRenderTargetPixels = function( renderTarget, x, y, width, height, buffer ) {\r\n\r\n\t\tif ( ! ( renderTarget instanceof THREE.WebGLRenderTarget ) ) {\r\n\r\n\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tif ( renderTarget.__webglFramebuffer ) {\r\n\r\n\t\t\tif ( renderTarget.format !== THREE.RGBAFormat ) {\r\n\r\n\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA format. readPixels can read only RGBA format.' );\r\n\t\t\t\treturn;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar restore = false;\r\n\r\n\t\t\tif ( renderTarget.__webglFramebuffer !== _currentFramebuffer ) {\r\n\r\n\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTarget.__webglFramebuffer );\r\n\r\n\t\t\t\trestore = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( _gl.checkFramebufferStatus( _gl.FRAMEBUFFER ) === _gl.FRAMEBUFFER_COMPLETE ) {\r\n\r\n\t\t\t\t_gl.readPixels( x, y, width, height, _gl.RGBA, _gl.UNSIGNED_BYTE, buffer );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( restore ) {\r\n\r\n\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, _currentFramebuffer );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction updateRenderTargetMipmap ( renderTarget ) {\r\n\r\n\t\tif ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {\r\n\r\n\t\t\t_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, renderTarget.__webglTexture );\r\n\t\t\t_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\r\n\t\t\t_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, null );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t_gl.bindTexture( _gl.TEXTURE_2D, renderTarget.__webglTexture );\r\n\t\t\t_gl.generateMipmap( _gl.TEXTURE_2D );\r\n\t\t\t_gl.bindTexture( _gl.TEXTURE_2D, null );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// Fallback filters for non-power-of-2 textures\r\n\r\n\tfunction filterFallback ( f ) {\r\n\r\n\t\tif ( f === THREE.NearestFilter || f === THREE.NearestMipMapNearestFilter || f === THREE.NearestMipMapLinearFilter ) {\r\n\r\n\t\t\treturn _gl.NEAREST;\r\n\r\n\t\t}\r\n\r\n\t\treturn _gl.LINEAR;\r\n\r\n\t}\r\n\r\n\t// Map three.js constants to WebGL constants\r\n\r\n\tfunction paramThreeToGL ( p ) {\r\n\r\n\t\tvar extension;\r\n\r\n\t\tif ( p === THREE.RepeatWrapping ) return _gl.REPEAT;\r\n\t\tif ( p === THREE.ClampToEdgeWrapping ) return _gl.CLAMP_TO_EDGE;\r\n\t\tif ( p === THREE.MirroredRepeatWrapping ) return _gl.MIRRORED_REPEAT;\r\n\r\n\t\tif ( p === THREE.NearestFilter ) return _gl.NEAREST;\r\n\t\tif ( p === THREE.NearestMipMapNearestFilter ) return _gl.NEAREST_MIPMAP_NEAREST;\r\n\t\tif ( p === THREE.NearestMipMapLinearFilter ) return _gl.NEAREST_MIPMAP_LINEAR;\r\n\r\n\t\tif ( p === THREE.LinearFilter ) return _gl.LINEAR;\r\n\t\tif ( p === THREE.LinearMipMapNearestFilter ) return _gl.LINEAR_MIPMAP_NEAREST;\r\n\t\tif ( p === THREE.LinearMipMapLinearFilter ) return _gl.LINEAR_MIPMAP_LINEAR;\r\n\r\n\t\tif ( p === THREE.UnsignedByteType ) return _gl.UNSIGNED_BYTE;\r\n\t\tif ( p === THREE.UnsignedShort4444Type ) return _gl.UNSIGNED_SHORT_4_4_4_4;\r\n\t\tif ( p === THREE.UnsignedShort5551Type ) return _gl.UNSIGNED_SHORT_5_5_5_1;\r\n\t\tif ( p === THREE.UnsignedShort565Type ) return _gl.UNSIGNED_SHORT_5_6_5;\r\n\r\n\t\tif ( p === THREE.ByteType ) return _gl.BYTE;\r\n\t\tif ( p === THREE.ShortType ) return _gl.SHORT;\r\n\t\tif ( p === THREE.UnsignedShortType ) return _gl.UNSIGNED_SHORT;\r\n\t\tif ( p === THREE.IntType ) return _gl.INT;\r\n\t\tif ( p === THREE.UnsignedIntType ) return _gl.UNSIGNED_INT;\r\n\t\tif ( p === THREE.FloatType ) return _gl.FLOAT;\r\n\r\n\t\textension = extensions.get( 'OES_texture_half_float' );\r\n\r\n\t\tif ( extension !== null ) {\r\n\r\n\t\t\tif ( p === THREE.HalfFloatType ) return extension.HALF_FLOAT_OES;\r\n\r\n\t\t}\r\n\r\n\t\tif ( p === THREE.AlphaFormat ) return _gl.ALPHA;\r\n\t\tif ( p === THREE.RGBFormat ) return _gl.RGB;\r\n\t\tif ( p === THREE.RGBAFormat ) return _gl.RGBA;\r\n\t\tif ( p === THREE.LuminanceFormat ) return _gl.LUMINANCE;\r\n\t\tif ( p === THREE.LuminanceAlphaFormat ) return _gl.LUMINANCE_ALPHA;\r\n\r\n\t\tif ( p === THREE.AddEquation ) return _gl.FUNC_ADD;\r\n\t\tif ( p === THREE.SubtractEquation ) return _gl.FUNC_SUBTRACT;\r\n\t\tif ( p === THREE.ReverseSubtractEquation ) return _gl.FUNC_REVERSE_SUBTRACT;\r\n\r\n\t\tif ( p === THREE.ZeroFactor ) return _gl.ZERO;\r\n\t\tif ( p === THREE.OneFactor ) return _gl.ONE;\r\n\t\tif ( p === THREE.SrcColorFactor ) return _gl.SRC_COLOR;\r\n\t\tif ( p === THREE.OneMinusSrcColorFactor ) return _gl.ONE_MINUS_SRC_COLOR;\r\n\t\tif ( p === THREE.SrcAlphaFactor ) return _gl.SRC_ALPHA;\r\n\t\tif ( p === THREE.OneMinusSrcAlphaFactor ) return _gl.ONE_MINUS_SRC_ALPHA;\r\n\t\tif ( p === THREE.DstAlphaFactor ) return _gl.DST_ALPHA;\r\n\t\tif ( p === THREE.OneMinusDstAlphaFactor ) return _gl.ONE_MINUS_DST_ALPHA;\r\n\r\n\t\tif ( p === THREE.DstColorFactor ) return _gl.DST_COLOR;\r\n\t\tif ( p === THREE.OneMinusDstColorFactor ) return _gl.ONE_MINUS_DST_COLOR;\r\n\t\tif ( p === THREE.SrcAlphaSaturateFactor ) return _gl.SRC_ALPHA_SATURATE;\r\n\r\n\t\textension = extensions.get( 'WEBGL_compressed_texture_s3tc' );\r\n\r\n\t\tif ( extension !== null ) {\r\n\r\n\t\t\tif ( p === THREE.RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;\r\n\t\t\tif ( p === THREE.RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;\r\n\t\t\tif ( p === THREE.RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;\r\n\t\t\tif ( p === THREE.RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;\r\n\r\n\t\t}\r\n\r\n\t\textension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );\r\n\r\n\t\tif ( extension !== null ) {\r\n\r\n\t\t\tif ( p === THREE.RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;\r\n\t\t\tif ( p === THREE.RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;\r\n\t\t\tif ( p === THREE.RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;\r\n\t\t\tif ( p === THREE.RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;\r\n\r\n\t\t}\r\n\r\n\t\textension = extensions.get( 'EXT_blend_minmax' );\r\n\r\n\t\tif ( extension !== null ) {\r\n\r\n\t\t\tif ( p === THREE.MinEquation ) return extension.MIN_EXT;\r\n\t\t\tif ( p === THREE.MaxEquation ) return extension.MAX_EXT;\r\n\r\n\t\t}\r\n\r\n\t\treturn 0;\r\n\r\n\t}\r\n\r\n\t// Allocations\r\n\r\n\tfunction allocateBones ( object ) {\r\n\r\n\t\tif ( _supportsBoneTextures && object && object.skeleton && object.skeleton.useVertexTexture ) {\r\n\r\n\t\t\treturn 1024;\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// default for when object is not specified\r\n\t\t\t// ( for example when prebuilding shader\r\n\t\t\t//   to be used with multiple objects )\r\n\t\t\t//\r\n\t\t\t//  - leave some extra space for other uniforms\r\n\t\t\t//  - limit here is ANGLE's 254 max uniform vectors\r\n\t\t\t//    (up to 54 should be safe)\r\n\r\n\t\t\tvar nVertexUniforms = _gl.getParameter( _gl.MAX_VERTEX_UNIFORM_VECTORS );\r\n\t\t\tvar nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );\r\n\r\n\t\t\tvar maxBones = nVertexMatrices;\r\n\r\n\t\t\tif ( object !== undefined && object instanceof THREE.SkinnedMesh ) {\r\n\r\n\t\t\t\tmaxBones = Math.min( object.skeleton.bones.length, maxBones );\r\n\r\n\t\t\t\tif ( maxBones < object.skeleton.bones.length ) {\r\n\r\n\t\t\t\t\tTHREE.warn( 'WebGLRenderer: too many bones - ' + object.skeleton.bones.length + ', this GPU supports just ' + maxBones + ' (try OpenGL instead of ANGLE)' );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn maxBones;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction allocateLights( lights ) {\r\n\r\n\t\tvar dirLights = 0;\r\n\t\tvar pointLights = 0;\r\n\t\tvar spotLights = 0;\r\n\t\tvar hemiLights = 0;\r\n\r\n\t\tfor ( var l = 0, ll = lights.length; l < ll; l ++ ) {\r\n\r\n\t\t\tvar light = lights[ l ];\r\n\r\n\t\t\tif ( light.onlyShadow || light.visible === false ) continue;\r\n\r\n\t\t\tif ( light instanceof THREE.DirectionalLight ) dirLights ++;\r\n\t\t\tif ( light instanceof THREE.PointLight ) pointLights ++;\r\n\t\t\tif ( light instanceof THREE.SpotLight ) spotLights ++;\r\n\t\t\tif ( light instanceof THREE.HemisphereLight ) hemiLights ++;\r\n\r\n\t\t}\r\n\r\n\t\treturn { 'directional': dirLights, 'point': pointLights, 'spot': spotLights, 'hemi': hemiLights };\r\n\r\n\t}\r\n\r\n\tfunction allocateShadows( lights ) {\r\n\r\n\t\tvar maxShadows = 0;\r\n\r\n\t\tfor ( var l = 0, ll = lights.length; l < ll; l ++ ) {\r\n\r\n\t\t\tvar light = lights[ l ];\r\n\r\n\t\t\tif ( ! light.castShadow ) continue;\r\n\r\n\t\t\tif ( light instanceof THREE.SpotLight ) maxShadows ++;\r\n\t\t\tif ( light instanceof THREE.DirectionalLight && ! light.shadowCascade ) maxShadows ++;\r\n\r\n\t\t}\r\n\r\n\t\treturn maxShadows;\r\n\r\n\t}\r\n\r\n\t// DEPRECATED\r\n\r\n\tthis.initMaterial = function () {\r\n\r\n\t\tTHREE.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );\r\n\r\n\t};\r\n\r\n\tthis.addPrePlugin = function () {\r\n\r\n\t\tTHREE.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );\r\n\r\n\t};\r\n\r\n\tthis.addPostPlugin = function () {\r\n\r\n\t\tTHREE.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );\r\n\r\n\t};\r\n\r\n\tthis.updateShadowMap = function () {\r\n\r\n\t\tTHREE.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );\r\n\r\n\t};\r\n\r\n};\r\n\r\n// File:src/renderers/WebGLRenderTarget.js\r\n\r\n/**\r\n * @author szimek / https://github.com/szimek/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.WebGLRenderTarget = function ( width, height, options ) {\r\n\r\n\tthis.width = width;\r\n\tthis.height = height;\r\n\r\n\toptions = options || {};\r\n\r\n\tthis.wrapS = options.wrapS !== undefined ? options.wrapS : THREE.ClampToEdgeWrapping;\r\n\tthis.wrapT = options.wrapT !== undefined ? options.wrapT : THREE.ClampToEdgeWrapping;\r\n\r\n\tthis.magFilter = options.magFilter !== undefined ? options.magFilter : THREE.LinearFilter;\r\n\tthis.minFilter = options.minFilter !== undefined ? options.minFilter : THREE.LinearMipMapLinearFilter;\r\n\r\n\tthis.anisotropy = options.anisotropy !== undefined ? options.anisotropy : 1;\r\n\r\n\tthis.offset = new THREE.Vector2( 0, 0 );\r\n\tthis.repeat = new THREE.Vector2( 1, 1 );\r\n\r\n\tthis.format = options.format !== undefined ? options.format : THREE.RGBAFormat;\r\n\tthis.type = options.type !== undefined ? options.type : THREE.UnsignedByteType;\r\n\r\n\tthis.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;\r\n\tthis.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;\r\n\r\n\tthis.generateMipmaps = true;\r\n\r\n\tthis.shareDepthFrom = options.shareDepthFrom !== undefined ? options.shareDepthFrom : null;\r\n\r\n};\r\n\r\nTHREE.WebGLRenderTarget.prototype = {\r\n\r\n\tconstructor: THREE.WebGLRenderTarget,\r\n\r\n\tsetSize: function ( width, height ) {\r\n\r\n\t\tthis.width = width;\r\n\t\tthis.height = height;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\tvar tmp = new THREE.WebGLRenderTarget( this.width, this.height );\r\n\r\n\t\ttmp.wrapS = this.wrapS;\r\n\t\ttmp.wrapT = this.wrapT;\r\n\r\n\t\ttmp.magFilter = this.magFilter;\r\n\t\ttmp.minFilter = this.minFilter;\r\n\r\n\t\ttmp.anisotropy = this.anisotropy;\r\n\r\n\t\ttmp.offset.copy( this.offset );\r\n\t\ttmp.repeat.copy( this.repeat );\r\n\r\n\t\ttmp.format = this.format;\r\n\t\ttmp.type = this.type;\r\n\r\n\t\ttmp.depthBuffer = this.depthBuffer;\r\n\t\ttmp.stencilBuffer = this.stencilBuffer;\r\n\r\n\t\ttmp.generateMipmaps = this.generateMipmaps;\r\n\r\n\t\ttmp.shareDepthFrom = this.shareDepthFrom;\r\n\r\n\t\treturn tmp;\r\n\r\n\t},\r\n\r\n\tdispose: function () {\r\n\r\n\t\tthis.dispatchEvent( { type: 'dispose' } );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.EventDispatcher.prototype.apply( THREE.WebGLRenderTarget.prototype );\r\n\r\n// File:src/renderers/WebGLRenderTargetCube.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com\r\n */\r\n\r\nTHREE.WebGLRenderTargetCube = function ( width, height, options ) {\r\n\r\n\tTHREE.WebGLRenderTarget.call( this, width, height, options );\r\n\r\n\tthis.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5\r\n\r\n};\r\n\r\nTHREE.WebGLRenderTargetCube.prototype = Object.create( THREE.WebGLRenderTarget.prototype );\r\nTHREE.WebGLRenderTargetCube.prototype.constructor = THREE.WebGLRenderTargetCube;\r\n\r\n// File:src/renderers/webgl/WebGLExtensions.js\r\n\r\n/**\r\n* @author mrdoob / http://mrdoob.com/\r\n*/\r\n\r\nTHREE.WebGLExtensions = function ( gl ) {\r\n\r\n\tvar extensions = {};\r\n\r\n\tthis.get = function ( name ) {\r\n\r\n\t\tif ( extensions[ name ] !== undefined ) {\r\n\r\n\t\t\treturn extensions[ name ];\r\n\r\n\t\t}\r\n\r\n\t\tvar extension;\r\n\r\n\t\tswitch ( name ) {\r\n\r\n\t\t\tcase 'EXT_texture_filter_anisotropic':\r\n\t\t\t\textension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'WEBGL_compressed_texture_s3tc':\r\n\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'WEBGL_compressed_texture_pvrtc':\r\n\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tdefault:\r\n\t\t\t\textension = gl.getExtension( name );\r\n\r\n\t\t}\r\n\r\n\t\tif ( extension === null ) {\r\n\r\n\t\t\tTHREE.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );\r\n\r\n\t\t}\r\n\r\n\t\textensions[ name ] = extension;\r\n\r\n\t\treturn extension;\r\n\r\n\t};\r\n\r\n};\r\n\r\n// File:src/renderers/webgl/WebGLProgram.js\r\n\r\nTHREE.WebGLProgram = ( function () {\r\n\r\n\tvar programIdCount = 0;\r\n\r\n\tvar generateDefines = function ( defines ) {\r\n\r\n\t\tvar value, chunk, chunks = [];\r\n\r\n\t\tfor ( var d in defines ) {\r\n\r\n\t\t\tvalue = defines[ d ];\r\n\t\t\tif ( value === false ) continue;\r\n\r\n\t\t\tchunk = '#define ' + d + ' ' + value;\r\n\t\t\tchunks.push( chunk );\r\n\r\n\t\t}\r\n\r\n\t\treturn chunks.join( '\\n' );\r\n\r\n\t};\r\n\r\n\tvar cacheUniformLocations = function ( gl, program, identifiers ) {\r\n\r\n\t\tvar uniforms = {};\r\n\r\n\t\tfor ( var i = 0, l = identifiers.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar id = identifiers[ i ];\r\n\t\t\tuniforms[ id ] = gl.getUniformLocation( program, id );\r\n\r\n\t\t}\r\n\r\n\t\treturn uniforms;\r\n\r\n\t};\r\n\r\n\tvar cacheAttributeLocations = function ( gl, program, identifiers ) {\r\n\r\n\t\tvar attributes = {};\r\n\r\n\t\tfor ( var i = 0, l = identifiers.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar id = identifiers[ i ];\r\n\t\t\tattributes[ id ] = gl.getAttribLocation( program, id );\r\n\r\n\t\t}\r\n\r\n\t\treturn attributes;\r\n\r\n\t};\r\n\r\n\treturn function ( renderer, code, material, parameters ) {\r\n\r\n\t\tvar _this = renderer;\r\n\t\tvar _gl = _this.context;\r\n\r\n\t\tvar defines = material.defines;\r\n\t\tvar uniforms = material.__webglShader.uniforms;\r\n\t\tvar attributes = material.attributes;\r\n\r\n\t\tvar vertexShader = material.__webglShader.vertexShader;\r\n\t\tvar fragmentShader = material.__webglShader.fragmentShader;\r\n\r\n\t\tvar index0AttributeName = material.index0AttributeName;\r\n\r\n\t\tif ( index0AttributeName === undefined && parameters.morphTargets === true ) {\r\n\r\n\t\t\t// programs with morphTargets displace position out of attribute 0\r\n\r\n\t\t\tindex0AttributeName = 'position';\r\n\r\n\t\t}\r\n\r\n\t\tvar shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';\r\n\r\n\t\tif ( parameters.shadowMapType === THREE.PCFShadowMap ) {\r\n\r\n\t\t\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';\r\n\r\n\t\t} else if ( parameters.shadowMapType === THREE.PCFSoftShadowMap ) {\r\n\r\n\t\t\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';\r\n\r\n\t\t}\r\n\r\n\t\tvar envMapTypeDefine = 'ENVMAP_TYPE_CUBE';\r\n\t\tvar envMapModeDefine = 'ENVMAP_MODE_REFLECTION';\r\n\t\tvar envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';\r\n\r\n\t\tif ( parameters.envMap ) {\r\n\r\n\t\t\tswitch ( material.envMap.mapping ) {\r\n\r\n\t\t\t\tcase THREE.CubeReflectionMapping:\r\n\t\t\t\tcase THREE.CubeRefractionMapping:\r\n\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_CUBE';\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase THREE.EquirectangularReflectionMapping:\r\n\t\t\t\tcase THREE.EquirectangularRefractionMapping:\r\n\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase THREE.SphericalReflectionMapping:\r\n\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_SPHERE';\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tswitch ( material.envMap.mapping ) {\r\n\r\n\t\t\t\tcase THREE.CubeRefractionMapping:\r\n\t\t\t\tcase THREE.EquirectangularRefractionMapping:\r\n\t\t\t\t\tenvMapModeDefine = 'ENVMAP_MODE_REFRACTION';\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tswitch ( material.combine ) {\r\n\r\n\t\t\t\tcase THREE.MultiplyOperation:\r\n\t\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase THREE.MixOperation:\r\n\t\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_MIX';\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase THREE.AddOperation:\r\n\t\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_ADD';\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvar gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;\r\n\r\n\t\t// console.log( 'building new program ' );\r\n\r\n\t\t//\r\n\r\n\t\tvar customDefines = generateDefines( defines );\r\n\r\n\t\t//\r\n\r\n\t\tvar program = _gl.createProgram();\r\n\r\n\t\tvar prefix_vertex, prefix_fragment;\r\n\r\n\t\tif ( material instanceof THREE.RawShaderMaterial ) {\r\n\r\n\t\t\tprefix_vertex = '';\r\n\t\t\tprefix_fragment = '';\r\n\r\n\t\t} else {\r\n\r\n\t\t\tprefix_vertex = [\r\n\r\n\t\t\t\t'precision ' + parameters.precision + ' float;',\r\n\t\t\t\t'precision ' + parameters.precision + ' int;',\r\n\r\n\t\t\t\tcustomDefines,\r\n\r\n\t\t\t\tparameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',\r\n\r\n\t\t\t\t_this.gammaInput ? '#define GAMMA_INPUT' : '',\r\n\t\t\t\t_this.gammaOutput ? '#define GAMMA_OUTPUT' : '',\r\n\t\t\t\t'#define GAMMA_FACTOR ' + gammaFactorDefine,\r\n\r\n\t\t\t\t'#define MAX_DIR_LIGHTS ' + parameters.maxDirLights,\r\n\t\t\t\t'#define MAX_POINT_LIGHTS ' + parameters.maxPointLights,\r\n\t\t\t\t'#define MAX_SPOT_LIGHTS ' + parameters.maxSpotLights,\r\n\t\t\t\t'#define MAX_HEMI_LIGHTS ' + parameters.maxHemiLights,\r\n\r\n\t\t\t\t'#define MAX_SHADOWS ' + parameters.maxShadows,\r\n\r\n\t\t\t\t'#define MAX_BONES ' + parameters.maxBones,\r\n\r\n\t\t\t\tparameters.map ? '#define USE_MAP' : '',\r\n\t\t\t\tparameters.envMap ? '#define USE_ENVMAP' : '',\r\n\t\t\t\tparameters.envMap ? '#define ' + envMapModeDefine : '',\r\n\t\t\t\tparameters.lightMap ? '#define USE_LIGHTMAP' : '',\r\n\t\t\t\tparameters.bumpMap ? '#define USE_BUMPMAP' : '',\r\n\t\t\t\tparameters.normalMap ? '#define USE_NORMALMAP' : '',\r\n\t\t\t\tparameters.specularMap ? '#define USE_SPECULARMAP' : '',\r\n\t\t\t\tparameters.alphaMap ? '#define USE_ALPHAMAP' : '',\r\n\t\t\t\tparameters.vertexColors ? '#define USE_COLOR' : '',\r\n\r\n\t\t\t\tparameters.flatShading ? '#define FLAT_SHADED': '',\r\n\r\n\t\t\t\tparameters.skinning ? '#define USE_SKINNING' : '',\r\n\t\t\t\tparameters.useVertexTexture ? '#define BONE_TEXTURE' : '',\r\n\r\n\t\t\t\tparameters.morphTargets ? '#define USE_MORPHTARGETS' : '',\r\n\t\t\t\tparameters.morphNormals ? '#define USE_MORPHNORMALS' : '',\r\n\t\t\t\tparameters.wrapAround ? '#define WRAP_AROUND' : '',\r\n\t\t\t\tparameters.doubleSided ? '#define DOUBLE_SIDED' : '',\r\n\t\t\t\tparameters.flipSided ? '#define FLIP_SIDED' : '',\r\n\r\n\t\t\t\tparameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',\r\n\t\t\t\tparameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',\r\n\t\t\t\tparameters.shadowMapDebug ? '#define SHADOWMAP_DEBUG' : '',\r\n\t\t\t\tparameters.shadowMapCascade ? '#define SHADOWMAP_CASCADE' : '',\r\n\r\n\t\t\t\tparameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',\r\n\r\n\t\t\t\tparameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',\r\n\t\t\t\t//_this._glExtensionFragDepth ? '#define USE_LOGDEPTHBUF_EXT' : '',\r\n\r\n\r\n\t\t\t\t'uniform mat4 modelMatrix;',\r\n\t\t\t\t'uniform mat4 modelViewMatrix;',\r\n\t\t\t\t'uniform mat4 projectionMatrix;',\r\n\t\t\t\t'uniform mat4 viewMatrix;',\r\n\t\t\t\t'uniform mat3 normalMatrix;',\r\n\t\t\t\t'uniform vec3 cameraPosition;',\r\n\r\n\t\t\t\t'attribute vec3 position;',\r\n\t\t\t\t'attribute vec3 normal;',\r\n\t\t\t\t'attribute vec2 uv;',\r\n\t\t\t\t'attribute vec2 uv2;',\r\n\r\n\t\t\t\t'#ifdef USE_COLOR',\r\n\r\n\t\t\t\t'\tattribute vec3 color;',\r\n\r\n\t\t\t\t'#endif',\r\n\r\n\t\t\t\t'#ifdef USE_MORPHTARGETS',\r\n\r\n\t\t\t\t'\tattribute vec3 morphTarget0;',\r\n\t\t\t\t'\tattribute vec3 morphTarget1;',\r\n\t\t\t\t'\tattribute vec3 morphTarget2;',\r\n\t\t\t\t'\tattribute vec3 morphTarget3;',\r\n\r\n\t\t\t\t'\t#ifdef USE_MORPHNORMALS',\r\n\r\n\t\t\t\t'\t\tattribute vec3 morphNormal0;',\r\n\t\t\t\t'\t\tattribute vec3 morphNormal1;',\r\n\t\t\t\t'\t\tattribute vec3 morphNormal2;',\r\n\t\t\t\t'\t\tattribute vec3 morphNormal3;',\r\n\r\n\t\t\t\t'\t#else',\r\n\r\n\t\t\t\t'\t\tattribute vec3 morphTarget4;',\r\n\t\t\t\t'\t\tattribute vec3 morphTarget5;',\r\n\t\t\t\t'\t\tattribute vec3 morphTarget6;',\r\n\t\t\t\t'\t\tattribute vec3 morphTarget7;',\r\n\r\n\t\t\t\t'\t#endif',\r\n\r\n\t\t\t\t'#endif',\r\n\r\n\t\t\t\t'#ifdef USE_SKINNING',\r\n\r\n\t\t\t\t'\tattribute vec4 skinIndex;',\r\n\t\t\t\t'\tattribute vec4 skinWeight;',\r\n\r\n\t\t\t\t'#endif',\r\n\r\n\t\t\t\t''\r\n\r\n\t\t\t].join( '\\n' );\r\n\r\n\t\t\tprefix_fragment = [\r\n\r\n\t\t\t\t'precision ' + parameters.precision + ' float;',\r\n\t\t\t\t'precision ' + parameters.precision + ' int;',\r\n\r\n\t\t\t\t( parameters.bumpMap || parameters.normalMap || parameters.flatShading ) ? '#extension GL_OES_standard_derivatives : enable' : '',\r\n\r\n\t\t\t\tcustomDefines,\r\n\r\n\t\t\t\t'#define MAX_DIR_LIGHTS ' + parameters.maxDirLights,\r\n\t\t\t\t'#define MAX_POINT_LIGHTS ' + parameters.maxPointLights,\r\n\t\t\t\t'#define MAX_SPOT_LIGHTS ' + parameters.maxSpotLights,\r\n\t\t\t\t'#define MAX_HEMI_LIGHTS ' + parameters.maxHemiLights,\r\n\r\n\t\t\t\t'#define MAX_SHADOWS ' + parameters.maxShadows,\r\n\r\n\t\t\t\tparameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '',\r\n\r\n\t\t\t\t_this.gammaInput ? '#define GAMMA_INPUT' : '',\r\n\t\t\t\t_this.gammaOutput ? '#define GAMMA_OUTPUT' : '',\r\n\t\t\t\t'#define GAMMA_FACTOR ' + gammaFactorDefine,\r\n\r\n\t\t\t\t( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',\r\n\t\t\t\t( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',\r\n\r\n\t\t\t\tparameters.map ? '#define USE_MAP' : '',\r\n\t\t\t\tparameters.envMap ? '#define USE_ENVMAP' : '',\r\n\t\t\t\tparameters.envMap ? '#define ' + envMapTypeDefine : '',\r\n\t\t\t\tparameters.envMap ? '#define ' + envMapModeDefine : '',\r\n\t\t\t\tparameters.envMap ? '#define ' + envMapBlendingDefine : '',\r\n\t\t\t\tparameters.lightMap ? '#define USE_LIGHTMAP' : '',\r\n\t\t\t\tparameters.bumpMap ? '#define USE_BUMPMAP' : '',\r\n\t\t\t\tparameters.normalMap ? '#define USE_NORMALMAP' : '',\r\n\t\t\t\tparameters.specularMap ? '#define USE_SPECULARMAP' : '',\r\n\t\t\t\tparameters.alphaMap ? '#define USE_ALPHAMAP' : '',\r\n\t\t\t\tparameters.vertexColors ? '#define USE_COLOR' : '',\r\n\r\n\t\t\t\tparameters.flatShading ? '#define FLAT_SHADED': '',\r\n\r\n\t\t\t\tparameters.metal ? '#define METAL' : '',\r\n\t\t\t\tparameters.wrapAround ? '#define WRAP_AROUND' : '',\r\n\t\t\t\tparameters.doubleSided ? '#define DOUBLE_SIDED' : '',\r\n\t\t\t\tparameters.flipSided ? '#define FLIP_SIDED' : '',\r\n\r\n\t\t\t\tparameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',\r\n\t\t\t\tparameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',\r\n\t\t\t\tparameters.shadowMapDebug ? '#define SHADOWMAP_DEBUG' : '',\r\n\t\t\t\tparameters.shadowMapCascade ? '#define SHADOWMAP_CASCADE' : '',\r\n\r\n\t\t\t\tparameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',\r\n\t\t\t\t//_this._glExtensionFragDepth ? '#define USE_LOGDEPTHBUF_EXT' : '',\r\n\r\n\t\t\t\t'uniform mat4 viewMatrix;',\r\n\t\t\t\t'uniform vec3 cameraPosition;',\r\n\t\t\t\t''\r\n\r\n\t\t\t].join( '\\n' );\r\n\r\n\t\t}\r\n\r\n\t\tvar glVertexShader = new THREE.WebGLShader( _gl, _gl.VERTEX_SHADER, prefix_vertex + vertexShader );\r\n\t\tvar glFragmentShader = new THREE.WebGLShader( _gl, _gl.FRAGMENT_SHADER, prefix_fragment + fragmentShader );\r\n\r\n\t\t_gl.attachShader( program, glVertexShader );\r\n\t\t_gl.attachShader( program, glFragmentShader );\r\n\r\n\t\tif ( index0AttributeName !== undefined ) {\r\n\r\n\t\t\t// Force a particular attribute to index 0.\r\n\t\t\t// because potentially expensive emulation is done by browser if attribute 0 is disabled.\r\n\t\t\t// And, color, for example is often automatically bound to index 0 so disabling it\r\n\r\n\t\t\t_gl.bindAttribLocation( program, 0, index0AttributeName );\r\n\r\n\t\t}\r\n\r\n\t\t_gl.linkProgram( program );\r\n\r\n\t\tvar programLogInfo = _gl.getProgramInfoLog( program );\r\n\r\n\t\tif ( _gl.getProgramParameter( program, _gl.LINK_STATUS ) === false ) {\r\n\r\n\t\t\tTHREE.error( 'THREE.WebGLProgram: shader error: ' + _gl.getError(), 'gl.VALIDATE_STATUS', _gl.getProgramParameter( program, _gl.VALIDATE_STATUS ), 'gl.getPRogramInfoLog', programLogInfo );\r\n\r\n\t\t}\r\n\r\n\t\tif ( programLogInfo !== '' ) {\r\n\r\n\t\t\tTHREE.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()' + programLogInfo );\r\n\t\t\t// THREE.warn( _gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glVertexShader ) );\r\n\t\t\t// THREE.warn( _gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glFragmentShader ) );\r\n\r\n\t\t}\r\n\r\n\t\t// clean up\r\n\r\n\t\t_gl.deleteShader( glVertexShader );\r\n\t\t_gl.deleteShader( glFragmentShader );\r\n\r\n\t\t// cache uniform locations\r\n\r\n\t\tvar identifiers = [\r\n\r\n\t\t\t'viewMatrix',\r\n\t\t\t'modelViewMatrix',\r\n\t\t\t'projectionMatrix',\r\n\t\t\t'normalMatrix',\r\n\t\t\t'modelMatrix',\r\n\t\t\t'cameraPosition',\r\n\t\t\t'morphTargetInfluences',\r\n\t\t\t'bindMatrix',\r\n\t\t\t'bindMatrixInverse'\r\n\r\n\t\t];\r\n\r\n\t\tif ( parameters.useVertexTexture ) {\r\n\r\n\t\t\tidentifiers.push( 'boneTexture' );\r\n\t\t\tidentifiers.push( 'boneTextureWidth' );\r\n\t\t\tidentifiers.push( 'boneTextureHeight' );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tidentifiers.push( 'boneGlobalMatrices' );\r\n\r\n\t\t}\r\n\r\n\t\tif ( parameters.logarithmicDepthBuffer ) {\r\n\r\n\t\t\tidentifiers.push('logDepthBufFC');\r\n\r\n\t\t}\r\n\r\n\r\n\t\tfor ( var u in uniforms ) {\r\n\r\n\t\t\tidentifiers.push( u );\r\n\r\n\t\t}\r\n\r\n\t\tthis.uniforms = cacheUniformLocations( _gl, program, identifiers );\r\n\r\n\t\t// cache attributes locations\r\n\r\n\t\tidentifiers = [\r\n\r\n\t\t\t'position',\r\n\t\t\t'normal',\r\n\t\t\t'uv',\r\n\t\t\t'uv2',\r\n\t\t\t'tangent',\r\n\t\t\t'color',\r\n\t\t\t'skinIndex',\r\n\t\t\t'skinWeight',\r\n\t\t\t'lineDistance'\r\n\r\n\t\t];\r\n\r\n\t\tfor ( var i = 0; i < parameters.maxMorphTargets; i ++ ) {\r\n\r\n\t\t\tidentifiers.push( 'morphTarget' + i );\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var i = 0; i < parameters.maxMorphNormals; i ++ ) {\r\n\r\n\t\t\tidentifiers.push( 'morphNormal' + i );\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var a in attributes ) {\r\n\r\n\t\t\tidentifiers.push( a );\r\n\r\n\t\t}\r\n\r\n\t\tthis.attributes = cacheAttributeLocations( _gl, program, identifiers );\r\n\t\tthis.attributesKeys = Object.keys( this.attributes );\r\n\r\n\t\t//\r\n\r\n\t\tthis.id = programIdCount ++;\r\n\t\tthis.code = code;\r\n\t\tthis.usedTimes = 1;\r\n\t\tthis.program = program;\r\n\t\tthis.vertexShader = glVertexShader;\r\n\t\tthis.fragmentShader = glFragmentShader;\r\n\r\n\t\treturn this;\r\n\r\n\t};\r\n\r\n} )();\r\n\r\n// File:src/renderers/webgl/WebGLShader.js\r\n\r\nTHREE.WebGLShader = ( function () {\r\n\r\n\tvar addLineNumbers = function ( string ) {\r\n\r\n\t\tvar lines = string.split( '\\n' );\r\n\r\n\t\tfor ( var i = 0; i < lines.length; i ++ ) {\r\n\r\n\t\t\tlines[ i ] = ( i + 1 ) + ': ' + lines[ i ];\r\n\r\n\t\t}\r\n\r\n\t\treturn lines.join( '\\n' );\r\n\r\n\t};\r\n\r\n\treturn function ( gl, type, string ) {\r\n\r\n\t\tvar shader = gl.createShader( type ); \r\n\r\n\t\tgl.shaderSource( shader, string );\r\n\t\tgl.compileShader( shader );\r\n\r\n\t\tif ( gl.getShaderParameter( shader, gl.COMPILE_STATUS ) === false ) {\r\n\r\n\t\t\tTHREE.error( 'THREE.WebGLShader: Shader couldn\\'t compile.' );\r\n\r\n\t\t}\r\n\r\n\t\tif ( gl.getShaderInfoLog( shader ) !== '' ) {\r\n\r\n\t\t\tTHREE.warn( 'THREE.WebGLShader: gl.getShaderInfoLog()', gl.getShaderInfoLog( shader ), addLineNumbers( string ) );\r\n\r\n\t\t}\r\n\r\n\t\t// --enable-privileged-webgl-extension\r\n\t\t// console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );\r\n\r\n\t\treturn shader;\r\n\r\n\t};\r\n\r\n} )();\r\n\r\n// File:src/renderers/webgl/WebGLState.js\r\n\r\n/**\r\n* @author mrdoob / http://mrdoob.com/\r\n*/\r\n\r\nTHREE.WebGLState = function ( gl, paramThreeToGL ) {\r\n\r\n\tvar newAttributes = new Uint8Array( 16 );\r\n\tvar enabledAttributes = new Uint8Array( 16 );\r\n\r\n\tvar currentBlending = null;\r\n\tvar currentBlendEquation = null;\r\n\tvar currentBlendSrc = null;\r\n\tvar currentBlendDst = null;\r\n\tvar currentBlendEquationAlpha = null;\r\n\tvar currentBlendSrcAlpha = null;\r\n\tvar currentBlendDstAlpha = null;\r\n\r\n\tvar currentDepthTest = null;\r\n\tvar currentDepthWrite = null;\r\n\r\n\tvar currentColorWrite = null;\r\n\r\n\tvar currentDoubleSided = null;\r\n\tvar currentFlipSided = null;\r\n\r\n\tvar currentLineWidth = null;\r\n\r\n\tvar currentPolygonOffset = null;\r\n\tvar currentPolygonOffsetFactor = null;\r\n\tvar currentPolygonOffsetUnits = null;\r\n\r\n\tthis.initAttributes = function () {\r\n\r\n\t\tfor ( var i = 0, l = newAttributes.length; i < l; i ++ ) {\r\n\r\n\t\t\tnewAttributes[ i ] = 0;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.enableAttribute = function ( attribute ) {\r\n\r\n\t\tnewAttributes[ attribute ] = 1;\r\n\r\n\t\tif ( enabledAttributes[ attribute ] === 0 ) {\r\n\r\n\t\t\tgl.enableVertexAttribArray( attribute );\r\n\t\t\tenabledAttributes[ attribute ] = 1;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.disableUnusedAttributes = function () {\r\n\r\n\t\tfor ( var i = 0, l = enabledAttributes.length; i < l; i ++ ) {\r\n\r\n\t\t\tif ( enabledAttributes[ i ] !== newAttributes[ i ] ) {\r\n\r\n\t\t\t\tgl.disableVertexAttribArray( i );\r\n\t\t\t\tenabledAttributes[ i ] = 0;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.setBlending = function ( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha ) {\r\n\r\n\t\tif ( blending !== currentBlending ) {\r\n\r\n\t\t\tif ( blending === THREE.NoBlending ) {\r\n\r\n\t\t\t\tgl.disable( gl.BLEND );\r\n\r\n\t\t\t} else if ( blending === THREE.AdditiveBlending ) {\r\n\r\n\t\t\t\tgl.enable( gl.BLEND );\r\n\t\t\t\tgl.blendEquation( gl.FUNC_ADD );\r\n\t\t\t\tgl.blendFunc( gl.SRC_ALPHA, gl.ONE );\r\n\r\n\t\t\t} else if ( blending === THREE.SubtractiveBlending ) {\r\n\r\n\t\t\t\t// TODO: Find blendFuncSeparate() combination\r\n\t\t\t\tgl.enable( gl.BLEND );\r\n\t\t\t\tgl.blendEquation( gl.FUNC_ADD );\r\n\t\t\t\tgl.blendFunc( gl.ZERO, gl.ONE_MINUS_SRC_COLOR );\r\n\r\n\t\t\t} else if ( blending === THREE.MultiplyBlending ) {\r\n\r\n\t\t\t\t// TODO: Find blendFuncSeparate() combination\r\n\t\t\t\tgl.enable( gl.BLEND );\r\n\t\t\t\tgl.blendEquation( gl.FUNC_ADD );\r\n\t\t\t\tgl.blendFunc( gl.ZERO, gl.SRC_COLOR );\r\n\r\n\t\t\t} else if ( blending === THREE.CustomBlending ) {\r\n\r\n\t\t\t\tgl.enable( gl.BLEND );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tgl.enable( gl.BLEND );\r\n\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\r\n\t\t\t\tgl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tcurrentBlending = blending;\r\n\r\n\t\t}\r\n\r\n\t\tif ( blending === THREE.CustomBlending ) {\r\n\r\n\t\t\tblendEquationAlpha = blendEquationAlpha || blendEquation;\r\n\t\t\tblendSrcAlpha = blendSrcAlpha || blendSrc;\r\n\t\t\tblendDstAlpha = blendDstAlpha || blendDst;\r\n\r\n\t\t\tif ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {\r\n\r\n\t\t\t\tgl.blendEquationSeparate( paramThreeToGL( blendEquation ), paramThreeToGL( blendEquationAlpha ) );\r\n\r\n\t\t\t\tcurrentBlendEquation = blendEquation;\r\n\t\t\t\tcurrentBlendEquationAlpha = blendEquationAlpha;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {\r\n\r\n\t\t\t\tgl.blendFuncSeparate( paramThreeToGL( blendSrc ), paramThreeToGL( blendDst ), paramThreeToGL( blendSrcAlpha ), paramThreeToGL( blendDstAlpha ) );\r\n\r\n\t\t\t\tcurrentBlendSrc = blendSrc;\r\n\t\t\t\tcurrentBlendDst = blendDst;\r\n\t\t\t\tcurrentBlendSrcAlpha = blendSrcAlpha;\r\n\t\t\t\tcurrentBlendDstAlpha = blendDstAlpha;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tcurrentBlendEquation = null;\r\n\t\t\tcurrentBlendSrc = null;\r\n\t\t\tcurrentBlendDst = null;\r\n\t\t\tcurrentBlendEquationAlpha = null;\r\n\t\t\tcurrentBlendSrcAlpha = null;\r\n\t\t\tcurrentBlendDstAlpha = null;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.setDepthTest = function ( depthTest ) {\r\n\r\n\t\tif ( currentDepthTest !== depthTest ) {\r\n\r\n\t\t\tif ( depthTest ) {\r\n\r\n\t\t\t\tgl.enable( gl.DEPTH_TEST );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tgl.disable( gl.DEPTH_TEST );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tcurrentDepthTest = depthTest;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.setDepthWrite = function ( depthWrite ) {\r\n\r\n\t\tif ( currentDepthWrite !== depthWrite ) {\r\n\r\n\t\t\tgl.depthMask( depthWrite );\r\n\t\t\tcurrentDepthWrite = depthWrite;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.setColorWrite = function ( colorWrite ) {\r\n\r\n\t\tif ( currentColorWrite !== colorWrite ) {\r\n\r\n\t\t\tgl.colorMask( colorWrite, colorWrite, colorWrite, colorWrite );\r\n\t\t\tcurrentColorWrite = colorWrite;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.setDoubleSided = function ( doubleSided ) {\r\n\r\n\t\tif ( currentDoubleSided !== doubleSided ) {\r\n\r\n\t\t\tif ( doubleSided ) {\r\n\r\n\t\t\t\tgl.disable( gl.CULL_FACE );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tgl.enable( gl.CULL_FACE );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tcurrentDoubleSided = doubleSided;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.setFlipSided = function ( flipSided ) {\r\n\r\n\t\tif ( currentFlipSided !== flipSided ) {\r\n\r\n\t\t\tif ( flipSided ) {\r\n\r\n\t\t\t\tgl.frontFace( gl.CW );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tgl.frontFace( gl.CCW );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tcurrentFlipSided = flipSided;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.setLineWidth = function ( width ) {\r\n\r\n\t\tif ( width !== currentLineWidth ) {\r\n\r\n\t\t\tgl.lineWidth( width );\r\n\r\n\t\t\tcurrentLineWidth = width;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.setPolygonOffset = function ( polygonoffset, factor, units ) {\r\n\r\n\t\tif ( currentPolygonOffset !== polygonoffset ) {\r\n\r\n\t\t\tif ( polygonoffset ) {\r\n\r\n\t\t\t\tgl.enable( gl.POLYGON_OFFSET_FILL );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tgl.disable( gl.POLYGON_OFFSET_FILL );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tcurrentPolygonOffset = polygonoffset;\r\n\r\n\t\t}\r\n\r\n\t\tif ( polygonoffset && ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) ) {\r\n\r\n\t\t\tgl.polygonOffset( factor, units );\r\n\r\n\t\t\tcurrentPolygonOffsetFactor = factor;\r\n\t\t\tcurrentPolygonOffsetUnits = units;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.reset = function () {\r\n\r\n\t\tfor ( var i = 0; i < enabledAttributes.length; i ++ ) {\r\n\r\n\t\t\tenabledAttributes[ i ] = 0;\r\n\r\n\t\t}\r\n\r\n\t\tcurrentBlending = null;\r\n\t\tcurrentDepthTest = null;\r\n\t\tcurrentDepthWrite = null;\r\n\t\tcurrentColorWrite = null;\r\n\t\tcurrentDoubleSided = null;\r\n\t\tcurrentFlipSided = null;\r\n\r\n\t};\r\n\r\n};\r\n\r\n// File:src/renderers/webgl/plugins/LensFlarePlugin.js\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.LensFlarePlugin = function ( renderer, flares ) {\r\n\r\n\tvar gl = renderer.context;\r\n\r\n\tvar vertexBuffer, elementBuffer;\r\n\tvar program, attributes, uniforms;\r\n\tvar hasVertexTexture;\r\n\r\n\tvar tempTexture, occlusionTexture;\r\n\r\n\tvar init = function () {\r\n\r\n\t\tvar vertices = new Float32Array( [\r\n\t\t\t-1, -1,  0, 0,\r\n\t\t\t 1, -1,  1, 0,\r\n\t\t\t 1,  1,  1, 1,\r\n\t\t\t-1,  1,  0, 1\r\n\t\t] );\r\n\r\n\t\tvar faces = new Uint16Array( [\r\n\t\t\t0, 1, 2,\r\n\t\t\t0, 2, 3\r\n\t\t] );\r\n\r\n\t\t// buffers\r\n\r\n\t\tvertexBuffer     = gl.createBuffer();\r\n\t\telementBuffer    = gl.createBuffer();\r\n\r\n\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\r\n\t\tgl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );\r\n\r\n\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\r\n\t\tgl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );\r\n\r\n\t\t// textures\r\n\r\n\t\ttempTexture      = gl.createTexture();\r\n\t\tocclusionTexture = gl.createTexture();\r\n\r\n\t\tgl.bindTexture( gl.TEXTURE_2D, tempTexture );\r\n\t\tgl.texImage2D( gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null );\r\n\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );\r\n\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );\r\n\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\r\n\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\r\n\r\n\t\tgl.bindTexture( gl.TEXTURE_2D, occlusionTexture );\r\n\t\tgl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null );\r\n\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );\r\n\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );\r\n\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\r\n\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\r\n\r\n\t\thasVertexTexture = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS ) > 0;\r\n\r\n\t\tvar shader;\r\n\r\n\t\tif ( hasVertexTexture ) {\r\n\r\n\t\t\tshader = {\r\n\r\n\t\t\t\tvertexShader: [\r\n\r\n\t\t\t\t\t\"uniform lowp int renderType;\",\r\n\r\n\t\t\t\t\t\"uniform vec3 screenPosition;\",\r\n\t\t\t\t\t\"uniform vec2 scale;\",\r\n\t\t\t\t\t\"uniform float rotation;\",\r\n\r\n\t\t\t\t\t\"uniform sampler2D occlusionMap;\",\r\n\r\n\t\t\t\t\t\"attribute vec2 position;\",\r\n\t\t\t\t\t\"attribute vec2 uv;\",\r\n\r\n\t\t\t\t\t\"varying vec2 vUV;\",\r\n\t\t\t\t\t\"varying float vVisibility;\",\r\n\r\n\t\t\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\t\t\"vUV = uv;\",\r\n\r\n\t\t\t\t\t\t\"vec2 pos = position;\",\r\n\r\n\t\t\t\t\t\t\"if( renderType == 2 ) {\",\r\n\r\n\t\t\t\t\t\t\t\"vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\",\r\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\",\r\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\",\r\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\",\r\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\",\r\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\",\r\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\",\r\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\",\r\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\",\r\n\r\n\t\t\t\t\t\t\t\"vVisibility =        visibility.r / 9.0;\",\r\n\t\t\t\t\t\t\t\"vVisibility *= 1.0 - visibility.g / 9.0;\",\r\n\t\t\t\t\t\t\t\"vVisibility *=       visibility.b / 9.0;\",\r\n\t\t\t\t\t\t\t\"vVisibility *= 1.0 - visibility.a / 9.0;\",\r\n\r\n\t\t\t\t\t\t\t\"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\",\r\n\t\t\t\t\t\t\t\"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\",\r\n\r\n\t\t\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\t\t\"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\",\r\n\r\n\t\t\t\t\t\"}\"\r\n\r\n\t\t\t\t].join( \"\\n\" ),\r\n\r\n\t\t\t\tfragmentShader: [\r\n\r\n\t\t\t\t\t\"uniform lowp int renderType;\",\r\n\r\n\t\t\t\t\t\"uniform sampler2D map;\",\r\n\t\t\t\t\t\"uniform float opacity;\",\r\n\t\t\t\t\t\"uniform vec3 color;\",\r\n\r\n\t\t\t\t\t\"varying vec2 vUV;\",\r\n\t\t\t\t\t\"varying float vVisibility;\",\r\n\r\n\t\t\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\t\t// pink square\r\n\r\n\t\t\t\t\t\t\"if( renderType == 0 ) {\",\r\n\r\n\t\t\t\t\t\t\t\"gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );\",\r\n\r\n\t\t\t\t\t\t// restore\r\n\r\n\t\t\t\t\t\t\"} else if( renderType == 1 ) {\",\r\n\r\n\t\t\t\t\t\t\t\"gl_FragColor = texture2D( map, vUV );\",\r\n\r\n\t\t\t\t\t\t// flare\r\n\r\n\t\t\t\t\t\t\"} else {\",\r\n\r\n\t\t\t\t\t\t\t\"vec4 texture = texture2D( map, vUV );\",\r\n\t\t\t\t\t\t\t\"texture.a *= opacity * vVisibility;\",\r\n\t\t\t\t\t\t\t\"gl_FragColor = texture;\",\r\n\t\t\t\t\t\t\t\"gl_FragColor.rgb *= color;\",\r\n\r\n\t\t\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\t\"}\"\r\n\r\n\t\t\t\t].join( \"\\n\" )\r\n\r\n\t\t\t};\r\n\r\n\t\t} else {\r\n\r\n\t\t\tshader = {\r\n\r\n\t\t\t\tvertexShader: [\r\n\r\n\t\t\t\t\t\"uniform lowp int renderType;\",\r\n\r\n\t\t\t\t\t\"uniform vec3 screenPosition;\",\r\n\t\t\t\t\t\"uniform vec2 scale;\",\r\n\t\t\t\t\t\"uniform float rotation;\",\r\n\r\n\t\t\t\t\t\"attribute vec2 position;\",\r\n\t\t\t\t\t\"attribute vec2 uv;\",\r\n\r\n\t\t\t\t\t\"varying vec2 vUV;\",\r\n\r\n\t\t\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\t\t\"vUV = uv;\",\r\n\r\n\t\t\t\t\t\t\"vec2 pos = position;\",\r\n\r\n\t\t\t\t\t\t\"if( renderType == 2 ) {\",\r\n\r\n\t\t\t\t\t\t\t\"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\",\r\n\t\t\t\t\t\t\t\"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\",\r\n\r\n\t\t\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\t\t\"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\",\r\n\r\n\t\t\t\t\t\"}\"\r\n\r\n\t\t\t\t].join( \"\\n\" ),\r\n\r\n\t\t\t\tfragmentShader: [\r\n\r\n\t\t\t\t\t\"precision mediump float;\",\r\n\r\n\t\t\t\t\t\"uniform lowp int renderType;\",\r\n\r\n\t\t\t\t\t\"uniform sampler2D map;\",\r\n\t\t\t\t\t\"uniform sampler2D occlusionMap;\",\r\n\t\t\t\t\t\"uniform float opacity;\",\r\n\t\t\t\t\t\"uniform vec3 color;\",\r\n\r\n\t\t\t\t\t\"varying vec2 vUV;\",\r\n\r\n\t\t\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\t\t// pink square\r\n\r\n\t\t\t\t\t\t\"if( renderType == 0 ) {\",\r\n\r\n\t\t\t\t\t\t\t\"gl_FragColor = vec4( texture2D( map, vUV ).rgb, 0.0 );\",\r\n\r\n\t\t\t\t\t\t// restore\r\n\r\n\t\t\t\t\t\t\"} else if( renderType == 1 ) {\",\r\n\r\n\t\t\t\t\t\t\t\"gl_FragColor = texture2D( map, vUV );\",\r\n\r\n\t\t\t\t\t\t// flare\r\n\r\n\t\t\t\t\t\t\"} else {\",\r\n\r\n\t\t\t\t\t\t\t\"float visibility = texture2D( occlusionMap, vec2( 0.5, 0.1 ) ).a;\",\r\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) ).a;\",\r\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) ).a;\",\r\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) ).a;\",\r\n\t\t\t\t\t\t\t\"visibility = ( 1.0 - visibility / 4.0 );\",\r\n\r\n\t\t\t\t\t\t\t\"vec4 texture = texture2D( map, vUV );\",\r\n\t\t\t\t\t\t\t\"texture.a *= opacity * visibility;\",\r\n\t\t\t\t\t\t\t\"gl_FragColor = texture;\",\r\n\t\t\t\t\t\t\t\"gl_FragColor.rgb *= color;\",\r\n\r\n\t\t\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\t\"}\"\r\n\r\n\t\t\t\t].join( \"\\n\" )\r\n\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t\tprogram = createProgram( shader );\r\n\r\n\t\tattributes = {\r\n\t\t\tvertex: gl.getAttribLocation ( program, \"position\" ),\r\n\t\t\tuv:     gl.getAttribLocation ( program, \"uv\" )\r\n\t\t}\r\n\r\n\t\tuniforms = {\r\n\t\t\trenderType:     gl.getUniformLocation( program, \"renderType\" ),\r\n\t\t\tmap:            gl.getUniformLocation( program, \"map\" ),\r\n\t\t\tocclusionMap:   gl.getUniformLocation( program, \"occlusionMap\" ),\r\n\t\t\topacity:        gl.getUniformLocation( program, \"opacity\" ),\r\n\t\t\tcolor:          gl.getUniformLocation( program, \"color\" ),\r\n\t\t\tscale:          gl.getUniformLocation( program, \"scale\" ),\r\n\t\t\trotation:       gl.getUniformLocation( program, \"rotation\" ),\r\n\t\t\tscreenPosition: gl.getUniformLocation( program, \"screenPosition\" )\r\n\t\t};\r\n\r\n\t};\r\n\r\n\t/*\r\n\t * Render lens flares\r\n\t * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,\r\n\t *         reads these back and calculates occlusion.\r\n\t */\r\n\r\n\tthis.render = function ( scene, camera, viewportWidth, viewportHeight ) {\r\n\r\n\t\tif ( flares.length === 0 ) return;\r\n\r\n\t\tvar tempPosition = new THREE.Vector3();\r\n\r\n\t\tvar invAspect = viewportHeight / viewportWidth,\r\n\t\t\thalfViewportWidth = viewportWidth * 0.5,\r\n\t\t\thalfViewportHeight = viewportHeight * 0.5;\r\n\r\n\t\tvar size = 16 / viewportHeight,\r\n\t\t\tscale = new THREE.Vector2( size * invAspect, size );\r\n\r\n\t\tvar screenPosition = new THREE.Vector3( 1, 1, 0 ),\r\n\t\t\tscreenPositionPixels = new THREE.Vector2( 1, 1 );\r\n\r\n\t\tif ( program === undefined ) {\r\n\r\n\t\t\tinit();\r\n\r\n\t\t}\r\n\r\n\t\tgl.useProgram( program );\r\n\r\n\t\tgl.enableVertexAttribArray( attributes.vertex );\r\n\t\tgl.enableVertexAttribArray( attributes.uv );\r\n\r\n\t\t// loop through all lens flares to update their occlusion and positions\r\n\t\t// setup gl and common used attribs/unforms\r\n\r\n\t\tgl.uniform1i( uniforms.occlusionMap, 0 );\r\n\t\tgl.uniform1i( uniforms.map, 1 );\r\n\r\n\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\r\n\t\tgl.vertexAttribPointer( attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0 );\r\n\t\tgl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );\r\n\r\n\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\r\n\r\n\t\tgl.disable( gl.CULL_FACE );\r\n\t\tgl.depthMask( false );\r\n\r\n\t\tfor ( var i = 0, l = flares.length; i < l; i ++ ) {\r\n\r\n\t\t\tsize = 16 / viewportHeight;\r\n\t\t\tscale.set( size * invAspect, size );\r\n\r\n\t\t\t// calc object screen position\r\n\r\n\t\t\tvar flare = flares[ i ];\r\n\r\n\t\t\ttempPosition.set( flare.matrixWorld.elements[12], flare.matrixWorld.elements[13], flare.matrixWorld.elements[14] );\r\n\r\n\t\t\ttempPosition.applyMatrix4( camera.matrixWorldInverse );\r\n\t\t\ttempPosition.applyProjection( camera.projectionMatrix );\r\n\r\n\t\t\t// setup arrays for gl programs\r\n\r\n\t\t\tscreenPosition.copy( tempPosition )\r\n\r\n\t\t\tscreenPositionPixels.x = screenPosition.x * halfViewportWidth + halfViewportWidth;\r\n\t\t\tscreenPositionPixels.y = screenPosition.y * halfViewportHeight + halfViewportHeight;\r\n\r\n\t\t\t// screen cull\r\n\r\n\t\t\tif ( hasVertexTexture || (\r\n\t\t\t\tscreenPositionPixels.x > 0 &&\r\n\t\t\t\tscreenPositionPixels.x < viewportWidth &&\r\n\t\t\t\tscreenPositionPixels.y > 0 &&\r\n\t\t\t\tscreenPositionPixels.y < viewportHeight ) ) {\r\n\r\n\t\t\t\t// save current RGB to temp texture\r\n\r\n\t\t\t\tgl.activeTexture( gl.TEXTURE1 );\r\n\t\t\t\tgl.bindTexture( gl.TEXTURE_2D, tempTexture );\r\n\t\t\t\tgl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0 );\r\n\r\n\r\n\t\t\t\t// render pink quad\r\n\r\n\t\t\t\tgl.uniform1i( uniforms.renderType, 0 );\r\n\t\t\t\tgl.uniform2f( uniforms.scale, scale.x, scale.y );\r\n\t\t\t\tgl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );\r\n\r\n\t\t\t\tgl.disable( gl.BLEND );\r\n\t\t\t\tgl.enable( gl.DEPTH_TEST );\r\n\r\n\t\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\r\n\r\n\r\n\t\t\t\t// copy result to occlusionMap\r\n\r\n\t\t\t\tgl.activeTexture( gl.TEXTURE0 );\r\n\t\t\t\tgl.bindTexture( gl.TEXTURE_2D, occlusionTexture );\r\n\t\t\t\tgl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0 );\r\n\r\n\r\n\t\t\t\t// restore graphics\r\n\r\n\t\t\t\tgl.uniform1i( uniforms.renderType, 1 );\r\n\t\t\t\tgl.disable( gl.DEPTH_TEST );\r\n\r\n\t\t\t\tgl.activeTexture( gl.TEXTURE1 );\r\n\t\t\t\tgl.bindTexture( gl.TEXTURE_2D, tempTexture );\r\n\t\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\r\n\r\n\r\n\t\t\t\t// update object positions\r\n\r\n\t\t\t\tflare.positionScreen.copy( screenPosition )\r\n\r\n\t\t\t\tif ( flare.customUpdateCallback ) {\r\n\r\n\t\t\t\t\tflare.customUpdateCallback( flare );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tflare.updateLensFlares();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// render flares\r\n\r\n\t\t\t\tgl.uniform1i( uniforms.renderType, 2 );\r\n\t\t\t\tgl.enable( gl.BLEND );\r\n\r\n\t\t\t\tfor ( var j = 0, jl = flare.lensFlares.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\tvar sprite = flare.lensFlares[ j ];\r\n\r\n\t\t\t\t\tif ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {\r\n\r\n\t\t\t\t\t\tscreenPosition.x = sprite.x;\r\n\t\t\t\t\t\tscreenPosition.y = sprite.y;\r\n\t\t\t\t\t\tscreenPosition.z = sprite.z;\r\n\r\n\t\t\t\t\t\tsize = sprite.size * sprite.scale / viewportHeight;\r\n\r\n\t\t\t\t\t\tscale.x = size * invAspect;\r\n\t\t\t\t\t\tscale.y = size;\r\n\r\n\t\t\t\t\t\tgl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );\r\n\t\t\t\t\t\tgl.uniform2f( uniforms.scale, scale.x, scale.y );\r\n\t\t\t\t\t\tgl.uniform1f( uniforms.rotation, sprite.rotation );\r\n\r\n\t\t\t\t\t\tgl.uniform1f( uniforms.opacity, sprite.opacity );\r\n\t\t\t\t\t\tgl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );\r\n\r\n\t\t\t\t\t\trenderer.state.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );\r\n\t\t\t\t\t\trenderer.setTexture( sprite.texture, 1 );\r\n\r\n\t\t\t\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// restore gl\r\n\r\n\t\tgl.enable( gl.CULL_FACE );\r\n\t\tgl.enable( gl.DEPTH_TEST );\r\n\t\tgl.depthMask( true );\r\n\r\n\t\trenderer.resetGLState();\r\n\r\n\t};\r\n\r\n\tfunction createProgram ( shader ) {\r\n\r\n\t\tvar program = gl.createProgram();\r\n\r\n\t\tvar fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );\r\n\t\tvar vertexShader = gl.createShader( gl.VERTEX_SHADER );\r\n\r\n\t\tvar prefix = \"precision \" + renderer.getPrecision() + \" float;\\n\";\r\n\r\n\t\tgl.shaderSource( fragmentShader, prefix + shader.fragmentShader );\r\n\t\tgl.shaderSource( vertexShader, prefix + shader.vertexShader );\r\n\r\n\t\tgl.compileShader( fragmentShader );\r\n\t\tgl.compileShader( vertexShader );\r\n\r\n\t\tgl.attachShader( program, fragmentShader );\r\n\t\tgl.attachShader( program, vertexShader );\r\n\r\n\t\tgl.linkProgram( program );\r\n\r\n\t\treturn program;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/renderers/webgl/plugins/ShadowMapPlugin.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.ShadowMapPlugin = function ( _renderer, _lights, _webglObjects, _webglObjectsImmediate ) {\r\n\r\n\tvar _gl = _renderer.context;\r\n\r\n\tvar _depthMaterial, _depthMaterialMorph, _depthMaterialSkin, _depthMaterialMorphSkin,\r\n\r\n\t_frustum = new THREE.Frustum(),\r\n\t_projScreenMatrix = new THREE.Matrix4(),\r\n\r\n\t_min = new THREE.Vector3(),\r\n\t_max = new THREE.Vector3(),\r\n\r\n\t_matrixPosition = new THREE.Vector3(),\r\n\r\n\t_renderList = [];\r\n\r\n\t// init\r\n\r\n\tvar depthShader = THREE.ShaderLib[ \"depthRGBA\" ];\r\n\tvar depthUniforms = THREE.UniformsUtils.clone( depthShader.uniforms );\r\n\r\n\t_depthMaterial = new THREE.ShaderMaterial( {\r\n\t\tuniforms: depthUniforms,\r\n\t\tvertexShader: depthShader.vertexShader,\r\n\t\tfragmentShader: depthShader.fragmentShader\r\n\t } );\r\n\r\n\t_depthMaterialMorph = new THREE.ShaderMaterial( {\r\n\t\tuniforms: depthUniforms,\r\n\t\tvertexShader: depthShader.vertexShader,\r\n\t\tfragmentShader: depthShader.fragmentShader,\r\n\t\tmorphTargets: true\r\n\t} );\r\n\r\n\t_depthMaterialSkin = new THREE.ShaderMaterial( {\r\n\t\tuniforms: depthUniforms,\r\n\t\tvertexShader: depthShader.vertexShader,\r\n\t\tfragmentShader: depthShader.fragmentShader,\r\n\t\tskinning: true\r\n\t} );\r\n\r\n\t_depthMaterialMorphSkin = new THREE.ShaderMaterial( {\r\n\t\tuniforms: depthUniforms,\r\n\t\tvertexShader: depthShader.vertexShader,\r\n\t\tfragmentShader: depthShader.fragmentShader,\r\n\t\tmorphTargets: true,\r\n\t\tskinning: true\r\n\t} );\r\n\r\n\t_depthMaterial._shadowPass = true;\r\n\t_depthMaterialMorph._shadowPass = true;\r\n\t_depthMaterialSkin._shadowPass = true;\r\n\t_depthMaterialMorphSkin._shadowPass = true;\r\n\r\n\tthis.render = function ( scene, camera ) {\r\n\r\n\t\tif ( _renderer.shadowMapEnabled === false ) return;\r\n\r\n\t\tvar i, il, j, jl, n,\r\n\r\n\t\tshadowMap, shadowMatrix, shadowCamera,\r\n\t\tbuffer, material,\r\n\t\twebglObject, object, light,\r\n\r\n\t\tlights = [],\r\n\t\tk = 0,\r\n\r\n\t\tfog = null;\r\n\r\n\t\t// set GL state for depth map\r\n\r\n\t\t_gl.clearColor( 1, 1, 1, 1 );\r\n\t\t_gl.disable( _gl.BLEND );\r\n\r\n\t\t_gl.enable( _gl.CULL_FACE );\r\n\t\t_gl.frontFace( _gl.CCW );\r\n\r\n\t\tif ( _renderer.shadowMapCullFace === THREE.CullFaceFront ) {\r\n\r\n\t\t\t_gl.cullFace( _gl.FRONT );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t_gl.cullFace( _gl.BACK );\r\n\r\n\t\t}\r\n\r\n\t\t_renderer.state.setDepthTest( true );\r\n\r\n\t\t// preprocess lights\r\n\t\t// \t- skip lights that are not casting shadows\r\n\t\t//\t- create virtual lights for cascaded shadow maps\r\n\r\n\t\tfor ( i = 0, il = _lights.length; i < il; i ++ ) {\r\n\r\n\t\t\tlight = _lights[ i ];\r\n\r\n\t\t\tif ( ! light.castShadow ) continue;\r\n\r\n\t\t\tif ( ( light instanceof THREE.DirectionalLight ) && light.shadowCascade ) {\r\n\r\n\t\t\t\tfor ( n = 0; n < light.shadowCascadeCount; n ++ ) {\r\n\r\n\t\t\t\t\tvar virtualLight;\r\n\r\n\t\t\t\t\tif ( ! light.shadowCascadeArray[ n ] ) {\r\n\r\n\t\t\t\t\t\tvirtualLight = createVirtualLight( light, n );\r\n\t\t\t\t\t\tvirtualLight.originalCamera = camera;\r\n\r\n\t\t\t\t\t\tvar gyro = new THREE.Gyroscope();\r\n\t\t\t\t\t\tgyro.position.copy( light.shadowCascadeOffset );\r\n\r\n\t\t\t\t\t\tgyro.add( virtualLight );\r\n\t\t\t\t\t\tgyro.add( virtualLight.target );\r\n\r\n\t\t\t\t\t\tcamera.add( gyro );\r\n\r\n\t\t\t\t\t\tlight.shadowCascadeArray[ n ] = virtualLight;\r\n\r\n\t\t\t\t\t\t//console.log( \"Created virtualLight\", virtualLight );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tvirtualLight = light.shadowCascadeArray[ n ];\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tupdateVirtualLight( light, n );\r\n\r\n\t\t\t\t\tlights[ k ] = virtualLight;\r\n\t\t\t\t\tk ++;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tlights[ k ] = light;\r\n\t\t\t\tk ++;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// render depth map\r\n\r\n\t\tfor ( i = 0, il = lights.length; i < il; i ++ ) {\r\n\r\n\t\t\tlight = lights[ i ];\r\n\r\n\t\t\tif ( ! light.shadowMap ) {\r\n\r\n\t\t\t\tvar shadowFilter = THREE.LinearFilter;\r\n\r\n\t\t\t\tif ( _renderer.shadowMapType === THREE.PCFSoftShadowMap ) {\r\n\r\n\t\t\t\t\tshadowFilter = THREE.NearestFilter;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar pars = { minFilter: shadowFilter, magFilter: shadowFilter, format: THREE.RGBAFormat };\r\n\r\n\t\t\t\tlight.shadowMap = new THREE.WebGLRenderTarget( light.shadowMapWidth, light.shadowMapHeight, pars );\r\n\t\t\t\tlight.shadowMapSize = new THREE.Vector2( light.shadowMapWidth, light.shadowMapHeight );\r\n\r\n\t\t\t\tlight.shadowMatrix = new THREE.Matrix4();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( ! light.shadowCamera ) {\r\n\r\n\t\t\t\tif ( light instanceof THREE.SpotLight ) {\r\n\r\n\t\t\t\t\tlight.shadowCamera = new THREE.PerspectiveCamera( light.shadowCameraFov, light.shadowMapWidth / light.shadowMapHeight, light.shadowCameraNear, light.shadowCameraFar );\r\n\r\n\t\t\t\t} else if ( light instanceof THREE.DirectionalLight ) {\r\n\r\n\t\t\t\t\tlight.shadowCamera = new THREE.OrthographicCamera( light.shadowCameraLeft, light.shadowCameraRight, light.shadowCameraTop, light.shadowCameraBottom, light.shadowCameraNear, light.shadowCameraFar );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tTHREE.error( \"THREE.ShadowMapPlugin: Unsupported light type for shadow\", light );\r\n\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tscene.add( light.shadowCamera );\r\n\r\n\t\t\t\tif ( scene.autoUpdate === true ) scene.updateMatrixWorld();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( light.shadowCameraVisible && ! light.cameraHelper ) {\r\n\r\n\t\t\t\tlight.cameraHelper = new THREE.CameraHelper( light.shadowCamera );\r\n\t\t\t\tscene.add( light.cameraHelper );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( light.isVirtual && virtualLight.originalCamera == camera ) {\r\n\r\n\t\t\t\tupdateShadowCamera( camera, light );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tshadowMap = light.shadowMap;\r\n\t\t\tshadowMatrix = light.shadowMatrix;\r\n\t\t\tshadowCamera = light.shadowCamera;\r\n\r\n\t\t\t//\r\n\r\n\t\t\tshadowCamera.position.setFromMatrixPosition( light.matrixWorld );\r\n\t\t\t_matrixPosition.setFromMatrixPosition( light.target.matrixWorld );\r\n\t\t\tshadowCamera.lookAt( _matrixPosition );\r\n\t\t\tshadowCamera.updateMatrixWorld();\r\n\r\n\t\t\tshadowCamera.matrixWorldInverse.getInverse( shadowCamera.matrixWorld );\r\n\r\n\t\t\t//\r\n\r\n\t\t\tif ( light.cameraHelper ) light.cameraHelper.visible = light.shadowCameraVisible;\r\n\t\t\tif ( light.shadowCameraVisible ) light.cameraHelper.update();\r\n\r\n\t\t\t// compute shadow matrix\r\n\r\n\t\t\tshadowMatrix.set(\r\n\t\t\t\t0.5, 0.0, 0.0, 0.5,\r\n\t\t\t\t0.0, 0.5, 0.0, 0.5,\r\n\t\t\t\t0.0, 0.0, 0.5, 0.5,\r\n\t\t\t\t0.0, 0.0, 0.0, 1.0\r\n\t\t\t);\r\n\r\n\t\t\tshadowMatrix.multiply( shadowCamera.projectionMatrix );\r\n\t\t\tshadowMatrix.multiply( shadowCamera.matrixWorldInverse );\r\n\r\n\t\t\t// update camera matrices and frustum\r\n\r\n\t\t\t_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );\r\n\t\t\t_frustum.setFromMatrix( _projScreenMatrix );\r\n\r\n\t\t\t// render shadow map\r\n\r\n\t\t\t_renderer.setRenderTarget( shadowMap );\r\n\t\t\t_renderer.clear();\r\n\r\n\t\t\t// set object matrices & frustum culling\r\n\r\n\t\t\t_renderList.length = 0;\r\n\r\n\t\t\tprojectObject( scene, scene, shadowCamera );\r\n\r\n\r\n\t\t\t// render regular objects\r\n\r\n\t\t\tvar objectMaterial, useMorphing, useSkinning;\r\n\r\n\t\t\tfor ( j = 0, jl = _renderList.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\twebglObject = _renderList[ j ];\r\n\r\n\t\t\t\tobject = webglObject.object;\r\n\t\t\t\tbuffer = webglObject.buffer;\r\n\r\n\t\t\t\t// culling is overriden globally for all objects\r\n\t\t\t\t// while rendering depth map\r\n\r\n\t\t\t\t// need to deal with MeshFaceMaterial somehow\r\n\t\t\t\t// in that case just use the first of material.materials for now\r\n\t\t\t\t// (proper solution would require to break objects by materials\r\n\t\t\t\t//  similarly to regular rendering and then set corresponding\r\n\t\t\t\t//  depth materials per each chunk instead of just once per object)\r\n\r\n\t\t\t\tobjectMaterial = getObjectMaterial( object );\r\n\r\n\t\t\t\tuseMorphing = object.geometry.morphTargets !== undefined && object.geometry.morphTargets.length > 0 && objectMaterial.morphTargets;\r\n\t\t\t\tuseSkinning = object instanceof THREE.SkinnedMesh && objectMaterial.skinning;\r\n\r\n\t\t\t\tif ( object.customDepthMaterial ) {\r\n\r\n\t\t\t\t\tmaterial = object.customDepthMaterial;\r\n\r\n\t\t\t\t} else if ( useSkinning ) {\r\n\r\n\t\t\t\t\tmaterial = useMorphing ? _depthMaterialMorphSkin : _depthMaterialSkin;\r\n\r\n\t\t\t\t} else if ( useMorphing ) {\r\n\r\n\t\t\t\t\tmaterial = _depthMaterialMorph;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tmaterial = _depthMaterial;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t_renderer.setMaterialFaces( objectMaterial );\r\n\r\n\t\t\t\tif ( buffer instanceof THREE.BufferGeometry ) {\r\n\r\n\t\t\t\t\t_renderer.renderBufferDirect( shadowCamera, _lights, fog, material, buffer, object );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t_renderer.renderBuffer( shadowCamera, _lights, fog, material, buffer, object );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// set matrices and render immediate objects\r\n\r\n\t\t\tfor ( j = 0, jl = _webglObjectsImmediate.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\twebglObject = _webglObjectsImmediate[ j ];\r\n\t\t\t\tobject = webglObject.object;\r\n\r\n\t\t\t\tif ( object.visible && object.castShadow ) {\r\n\r\n\t\t\t\t\tobject._modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );\r\n\r\n\t\t\t\t\t_renderer.renderImmediateObject( shadowCamera, _lights, fog, _depthMaterial, object );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// restore GL state\r\n\r\n\t\tvar clearColor = _renderer.getClearColor(),\r\n\t\tclearAlpha = _renderer.getClearAlpha();\r\n\r\n\t\t_gl.clearColor( clearColor.r, clearColor.g, clearColor.b, clearAlpha );\r\n\t\t_gl.enable( _gl.BLEND );\r\n\r\n\t\tif ( _renderer.shadowMapCullFace === THREE.CullFaceFront ) {\r\n\r\n\t\t\t_gl.cullFace( _gl.BACK );\r\n\r\n\t\t}\r\n\r\n\t\t_renderer.resetGLState();\r\n\r\n\t};\r\n\r\n\tfunction projectObject( scene, object, shadowCamera ) {\r\n\r\n\t\tif ( object.visible ) {\r\n\r\n\t\t\tvar webglObjects = _webglObjects[ object.id ];\r\n\r\n\t\t\tif ( webglObjects && object.castShadow && (object.frustumCulled === false || _frustum.intersectsObject( object ) === true) ) {\r\n\r\n\t\t\t\tfor ( var i = 0, l = webglObjects.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\tvar webglObject = webglObjects[ i ];\r\n\r\n\t\t\t\t\tobject._modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );\r\n\t\t\t\t\t_renderList.push( webglObject );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var i = 0, l = object.children.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tprojectObject( scene, object.children[ i ], shadowCamera );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction createVirtualLight( light, cascade ) {\r\n\r\n\t\tvar virtualLight = new THREE.DirectionalLight();\r\n\r\n\t\tvirtualLight.isVirtual = true;\r\n\r\n\t\tvirtualLight.onlyShadow = true;\r\n\t\tvirtualLight.castShadow = true;\r\n\r\n\t\tvirtualLight.shadowCameraNear = light.shadowCameraNear;\r\n\t\tvirtualLight.shadowCameraFar = light.shadowCameraFar;\r\n\r\n\t\tvirtualLight.shadowCameraLeft = light.shadowCameraLeft;\r\n\t\tvirtualLight.shadowCameraRight = light.shadowCameraRight;\r\n\t\tvirtualLight.shadowCameraBottom = light.shadowCameraBottom;\r\n\t\tvirtualLight.shadowCameraTop = light.shadowCameraTop;\r\n\r\n\t\tvirtualLight.shadowCameraVisible = light.shadowCameraVisible;\r\n\r\n\t\tvirtualLight.shadowDarkness = light.shadowDarkness;\r\n\r\n\t\tvirtualLight.shadowBias = light.shadowCascadeBias[ cascade ];\r\n\t\tvirtualLight.shadowMapWidth = light.shadowCascadeWidth[ cascade ];\r\n\t\tvirtualLight.shadowMapHeight = light.shadowCascadeHeight[ cascade ];\r\n\r\n\t\tvirtualLight.pointsWorld = [];\r\n\t\tvirtualLight.pointsFrustum = [];\r\n\r\n\t\tvar pointsWorld = virtualLight.pointsWorld,\r\n\t\t\tpointsFrustum = virtualLight.pointsFrustum;\r\n\r\n\t\tfor ( var i = 0; i < 8; i ++ ) {\r\n\r\n\t\t\tpointsWorld[ i ] = new THREE.Vector3();\r\n\t\t\tpointsFrustum[ i ] = new THREE.Vector3();\r\n\r\n\t\t}\r\n\r\n\t\tvar nearZ = light.shadowCascadeNearZ[ cascade ];\r\n\t\tvar farZ = light.shadowCascadeFarZ[ cascade ];\r\n\r\n\t\tpointsFrustum[ 0 ].set( - 1, - 1, nearZ );\r\n\t\tpointsFrustum[ 1 ].set(  1, - 1, nearZ );\r\n\t\tpointsFrustum[ 2 ].set( - 1,  1, nearZ );\r\n\t\tpointsFrustum[ 3 ].set(  1,  1, nearZ );\r\n\r\n\t\tpointsFrustum[ 4 ].set( - 1, - 1, farZ );\r\n\t\tpointsFrustum[ 5 ].set(  1, - 1, farZ );\r\n\t\tpointsFrustum[ 6 ].set( - 1,  1, farZ );\r\n\t\tpointsFrustum[ 7 ].set(  1,  1, farZ );\r\n\r\n\t\treturn virtualLight;\r\n\r\n\t}\r\n\r\n\t// Synchronize virtual light with the original light\r\n\r\n\tfunction updateVirtualLight( light, cascade ) {\r\n\r\n\t\tvar virtualLight = light.shadowCascadeArray[ cascade ];\r\n\r\n\t\tvirtualLight.position.copy( light.position );\r\n\t\tvirtualLight.target.position.copy( light.target.position );\r\n\t\tvirtualLight.lookAt( virtualLight.target );\r\n\r\n\t\tvirtualLight.shadowCameraVisible = light.shadowCameraVisible;\r\n\t\tvirtualLight.shadowDarkness = light.shadowDarkness;\r\n\r\n\t\tvirtualLight.shadowBias = light.shadowCascadeBias[ cascade ];\r\n\r\n\t\tvar nearZ = light.shadowCascadeNearZ[ cascade ];\r\n\t\tvar farZ = light.shadowCascadeFarZ[ cascade ];\r\n\r\n\t\tvar pointsFrustum = virtualLight.pointsFrustum;\r\n\r\n\t\tpointsFrustum[ 0 ].z = nearZ;\r\n\t\tpointsFrustum[ 1 ].z = nearZ;\r\n\t\tpointsFrustum[ 2 ].z = nearZ;\r\n\t\tpointsFrustum[ 3 ].z = nearZ;\r\n\r\n\t\tpointsFrustum[ 4 ].z = farZ;\r\n\t\tpointsFrustum[ 5 ].z = farZ;\r\n\t\tpointsFrustum[ 6 ].z = farZ;\r\n\t\tpointsFrustum[ 7 ].z = farZ;\r\n\r\n\t}\r\n\r\n\t// Fit shadow camera's ortho frustum to camera frustum\r\n\r\n\tfunction updateShadowCamera( camera, light ) {\r\n\r\n\t\tvar shadowCamera = light.shadowCamera,\r\n\t\t\tpointsFrustum = light.pointsFrustum,\r\n\t\t\tpointsWorld = light.pointsWorld;\r\n\r\n\t\t_min.set( Infinity, Infinity, Infinity );\r\n\t\t_max.set( - Infinity, - Infinity, - Infinity );\r\n\r\n\t\tfor ( var i = 0; i < 8; i ++ ) {\r\n\r\n\t\t\tvar p = pointsWorld[ i ];\r\n\r\n\t\t\tp.copy( pointsFrustum[ i ] );\r\n\t\t\tp.unproject( camera );\r\n\r\n\t\t\tp.applyMatrix4( shadowCamera.matrixWorldInverse );\r\n\r\n\t\t\tif ( p.x < _min.x ) _min.x = p.x;\r\n\t\t\tif ( p.x > _max.x ) _max.x = p.x;\r\n\r\n\t\t\tif ( p.y < _min.y ) _min.y = p.y;\r\n\t\t\tif ( p.y > _max.y ) _max.y = p.y;\r\n\r\n\t\t\tif ( p.z < _min.z ) _min.z = p.z;\r\n\t\t\tif ( p.z > _max.z ) _max.z = p.z;\r\n\r\n\t\t}\r\n\r\n\t\tshadowCamera.left = _min.x;\r\n\t\tshadowCamera.right = _max.x;\r\n\t\tshadowCamera.top = _max.y;\r\n\t\tshadowCamera.bottom = _min.y;\r\n\r\n\t\t// can't really fit near/far\r\n\t\t//shadowCamera.near = _min.z;\r\n\t\t//shadowCamera.far = _max.z;\r\n\r\n\t\tshadowCamera.updateProjectionMatrix();\r\n\r\n\t}\r\n\r\n\t// For the moment just ignore objects that have multiple materials with different animation methods\r\n\t// Only the first material will be taken into account for deciding which depth material to use for shadow maps\r\n\r\n\tfunction getObjectMaterial( object ) {\r\n\r\n\t\treturn object.material instanceof THREE.MeshFaceMaterial\r\n\t\t\t? object.material.materials[ 0 ]\r\n\t\t\t: object.material;\r\n\r\n\t};\r\n\r\n};\r\n\r\n// File:src/renderers/webgl/plugins/SpritePlugin.js\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.SpritePlugin = function ( renderer, sprites ) {\r\n\r\n\tvar gl = renderer.context;\r\n\r\n\tvar vertexBuffer, elementBuffer;\r\n\tvar program, attributes, uniforms;\r\n\r\n\tvar texture;\r\n\r\n\t// decompose matrixWorld\r\n\r\n\tvar spritePosition = new THREE.Vector3();\r\n\tvar spriteRotation = new THREE.Quaternion();\r\n\tvar spriteScale = new THREE.Vector3();\r\n\r\n\tvar init = function () {\r\n\r\n\t\tvar vertices = new Float32Array( [\r\n\t\t\t- 0.5, - 0.5,  0, 0,\r\n\t\t\t  0.5, - 0.5,  1, 0,\r\n\t\t\t  0.5,   0.5,  1, 1,\r\n\t\t\t- 0.5,   0.5,  0, 1\r\n\t\t] );\r\n\r\n\t\tvar faces = new Uint16Array( [\r\n\t\t\t0, 1, 2,\r\n\t\t\t0, 2, 3\r\n\t\t] );\r\n\r\n\t\tvertexBuffer  = gl.createBuffer();\r\n\t\telementBuffer = gl.createBuffer();\r\n\r\n\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\r\n\t\tgl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );\r\n\r\n\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\r\n\t\tgl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );\r\n\r\n\t\tprogram = createProgram();\r\n\r\n\t\tattributes = {\r\n\t\t\tposition:\t\t\tgl.getAttribLocation ( program, 'position' ),\r\n\t\t\tuv:\t\t\t\t\tgl.getAttribLocation ( program, 'uv' )\r\n\t\t};\r\n\r\n\t\tuniforms = {\r\n\t\t\tuvOffset:\t\t\tgl.getUniformLocation( program, 'uvOffset' ),\r\n\t\t\tuvScale:\t\t\tgl.getUniformLocation( program, 'uvScale' ),\r\n\r\n\t\t\trotation:\t\t\tgl.getUniformLocation( program, 'rotation' ),\r\n\t\t\tscale:\t\t\t\tgl.getUniformLocation( program, 'scale' ),\r\n\r\n\t\t\tcolor:\t\t\t\tgl.getUniformLocation( program, 'color' ),\r\n\t\t\tmap:\t\t\t\tgl.getUniformLocation( program, 'map' ),\r\n\t\t\topacity:\t\t\tgl.getUniformLocation( program, 'opacity' ),\r\n\r\n\t\t\tmodelViewMatrix: \tgl.getUniformLocation( program, 'modelViewMatrix' ),\r\n\t\t\tprojectionMatrix:\tgl.getUniformLocation( program, 'projectionMatrix' ),\r\n\r\n\t\t\tfogType:\t\t\tgl.getUniformLocation( program, 'fogType' ),\r\n\t\t\tfogDensity:\t\t\tgl.getUniformLocation( program, 'fogDensity' ),\r\n\t\t\tfogNear:\t\t\tgl.getUniformLocation( program, 'fogNear' ),\r\n\t\t\tfogFar:\t\t\t\tgl.getUniformLocation( program, 'fogFar' ),\r\n\t\t\tfogColor:\t\t\tgl.getUniformLocation( program, 'fogColor' ),\r\n\r\n\t\t\talphaTest:\t\t\tgl.getUniformLocation( program, 'alphaTest' )\r\n\t\t};\r\n\r\n\t\tvar canvas = document.createElement( 'canvas' );\r\n\t\tcanvas.width = 8;\r\n\t\tcanvas.height = 8;\r\n\r\n\t\tvar context = canvas.getContext( '2d' );\r\n\t\tcontext.fillStyle = 'white';\r\n\t\tcontext.fillRect( 0, 0, 8, 8 );\r\n\r\n\t\ttexture = new THREE.Texture( canvas );\r\n\t\ttexture.needsUpdate = true;\r\n\r\n\t};\r\n\r\n\tthis.render = function ( scene, camera ) {\r\n\r\n\t\tif ( sprites.length === 0 ) return;\r\n\r\n\t\t// setup gl\r\n\r\n\t\tif ( program === undefined ) {\r\n\r\n\t\t\tinit();\r\n\r\n\t\t}\r\n\r\n\t\tgl.useProgram( program );\r\n\r\n\t\tgl.enableVertexAttribArray( attributes.position );\r\n\t\tgl.enableVertexAttribArray( attributes.uv );\r\n\r\n\t\tgl.disable( gl.CULL_FACE );\r\n\t\tgl.enable( gl.BLEND );\r\n\r\n\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\r\n\t\tgl.vertexAttribPointer( attributes.position, 2, gl.FLOAT, false, 2 * 8, 0 );\r\n\t\tgl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );\r\n\r\n\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\r\n\r\n\t\tgl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );\r\n\r\n\t\tgl.activeTexture( gl.TEXTURE0 );\r\n\t\tgl.uniform1i( uniforms.map, 0 );\r\n\r\n\t\tvar oldFogType = 0;\r\n\t\tvar sceneFogType = 0;\r\n\t\tvar fog = scene.fog;\r\n\r\n\t\tif ( fog ) {\r\n\r\n\t\t\tgl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );\r\n\r\n\t\t\tif ( fog instanceof THREE.Fog ) {\r\n\r\n\t\t\t\tgl.uniform1f( uniforms.fogNear, fog.near );\r\n\t\t\t\tgl.uniform1f( uniforms.fogFar, fog.far );\r\n\r\n\t\t\t\tgl.uniform1i( uniforms.fogType, 1 );\r\n\t\t\t\toldFogType = 1;\r\n\t\t\t\tsceneFogType = 1;\r\n\r\n\t\t\t} else if ( fog instanceof THREE.FogExp2 ) {\r\n\r\n\t\t\t\tgl.uniform1f( uniforms.fogDensity, fog.density );\r\n\r\n\t\t\t\tgl.uniform1i( uniforms.fogType, 2 );\r\n\t\t\t\toldFogType = 2;\r\n\t\t\t\tsceneFogType = 2;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tgl.uniform1i( uniforms.fogType, 0 );\r\n\t\t\toldFogType = 0;\r\n\t\t\tsceneFogType = 0;\r\n\r\n\t\t}\r\n\r\n\r\n\t\t// update positions and sort\r\n\r\n\t\tfor ( var i = 0, l = sprites.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar sprite = sprites[ i ];\r\n\r\n\t\t\tsprite._modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );\r\n\t\t\tsprite.z = - sprite._modelViewMatrix.elements[ 14 ];\r\n\r\n\t\t}\r\n\r\n\t\tsprites.sort( painterSortStable );\r\n\r\n\t\t// render all sprites\r\n\r\n\t\tvar scale = [];\r\n\r\n\t\tfor ( var i = 0, l = sprites.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar sprite = sprites[ i ];\r\n\t\t\tvar material = sprite.material;\r\n\r\n\t\t\tgl.uniform1f( uniforms.alphaTest, material.alphaTest );\r\n\t\t\tgl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite._modelViewMatrix.elements );\r\n\r\n\t\t\tsprite.matrixWorld.decompose( spritePosition, spriteRotation, spriteScale );\r\n\r\n\t\t\tscale[ 0 ] = spriteScale.x;\r\n\t\t\tscale[ 1 ] = spriteScale.y;\r\n\r\n\t\t\tvar fogType = 0;\r\n\r\n\t\t\tif ( scene.fog && material.fog ) {\r\n\r\n\t\t\t\tfogType = sceneFogType;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( oldFogType !== fogType ) {\r\n\r\n\t\t\t\tgl.uniform1i( uniforms.fogType, fogType );\r\n\t\t\t\toldFogType = fogType;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( material.map !== null ) {\r\n\r\n\t\t\t\tgl.uniform2f( uniforms.uvOffset, material.map.offset.x, material.map.offset.y );\r\n\t\t\t\tgl.uniform2f( uniforms.uvScale, material.map.repeat.x, material.map.repeat.y );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tgl.uniform2f( uniforms.uvOffset, 0, 0 );\r\n\t\t\t\tgl.uniform2f( uniforms.uvScale, 1, 1 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgl.uniform1f( uniforms.opacity, material.opacity );\r\n\t\t\tgl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );\r\n\r\n\t\t\tgl.uniform1f( uniforms.rotation, material.rotation );\r\n\t\t\tgl.uniform2fv( uniforms.scale, scale );\r\n\r\n\t\t\trenderer.state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );\r\n\t\t\trenderer.state.setDepthTest( material.depthTest );\r\n\t\t\trenderer.state.setDepthWrite( material.depthWrite );\r\n\r\n\t\t\tif ( material.map && material.map.image && material.map.image.width ) {\r\n\r\n\t\t\t\trenderer.setTexture( material.map, 0 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\trenderer.setTexture( texture, 0 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\r\n\r\n\t\t}\r\n\r\n\t\t// restore gl\r\n\r\n\t\tgl.enable( gl.CULL_FACE );\r\n\r\n\t\trenderer.resetGLState();\r\n\r\n\t};\r\n\r\n\tfunction createProgram () {\r\n\r\n\t\tvar program = gl.createProgram();\r\n\r\n\t\tvar vertexShader = gl.createShader( gl.VERTEX_SHADER );\r\n\t\tvar fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );\r\n\r\n\t\tgl.shaderSource( vertexShader, [\r\n\r\n\t\t\t'precision ' + renderer.getPrecision() + ' float;',\r\n\r\n\t\t\t'uniform mat4 modelViewMatrix;',\r\n\t\t\t'uniform mat4 projectionMatrix;',\r\n\t\t\t'uniform float rotation;',\r\n\t\t\t'uniform vec2 scale;',\r\n\t\t\t'uniform vec2 uvOffset;',\r\n\t\t\t'uniform vec2 uvScale;',\r\n\r\n\t\t\t'attribute vec2 position;',\r\n\t\t\t'attribute vec2 uv;',\r\n\r\n\t\t\t'varying vec2 vUV;',\r\n\r\n\t\t\t'void main() {',\r\n\r\n\t\t\t\t'vUV = uvOffset + uv * uvScale;',\r\n\r\n\t\t\t\t'vec2 alignedPosition = position * scale;',\r\n\r\n\t\t\t\t'vec2 rotatedPosition;',\r\n\t\t\t\t'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',\r\n\t\t\t\t'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',\r\n\r\n\t\t\t\t'vec4 finalPosition;',\r\n\r\n\t\t\t\t'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',\r\n\t\t\t\t'finalPosition.xy += rotatedPosition;',\r\n\t\t\t\t'finalPosition = projectionMatrix * finalPosition;',\r\n\r\n\t\t\t\t'gl_Position = finalPosition;',\r\n\r\n\t\t\t'}'\r\n\r\n\t\t].join( '\\n' ) );\r\n\r\n\t\tgl.shaderSource( fragmentShader, [\r\n\r\n\t\t\t'precision ' + renderer.getPrecision() + ' float;',\r\n\r\n\t\t\t'uniform vec3 color;',\r\n\t\t\t'uniform sampler2D map;',\r\n\t\t\t'uniform float opacity;',\r\n\r\n\t\t\t'uniform int fogType;',\r\n\t\t\t'uniform vec3 fogColor;',\r\n\t\t\t'uniform float fogDensity;',\r\n\t\t\t'uniform float fogNear;',\r\n\t\t\t'uniform float fogFar;',\r\n\t\t\t'uniform float alphaTest;',\r\n\r\n\t\t\t'varying vec2 vUV;',\r\n\r\n\t\t\t'void main() {',\r\n\r\n\t\t\t\t'vec4 texture = texture2D( map, vUV );',\r\n\r\n\t\t\t\t'if ( texture.a < alphaTest ) discard;',\r\n\r\n\t\t\t\t'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',\r\n\r\n\t\t\t\t'if ( fogType > 0 ) {',\r\n\r\n\t\t\t\t\t'float depth = gl_FragCoord.z / gl_FragCoord.w;',\r\n\t\t\t\t\t'float fogFactor = 0.0;',\r\n\r\n\t\t\t\t\t'if ( fogType == 1 ) {',\r\n\r\n\t\t\t\t\t\t'fogFactor = smoothstep( fogNear, fogFar, depth );',\r\n\r\n\t\t\t\t\t'} else {',\r\n\r\n\t\t\t\t\t\t'const float LOG2 = 1.442695;',\r\n\t\t\t\t\t\t'float fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',\r\n\t\t\t\t\t\t'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',\r\n\r\n\t\t\t\t\t'}',\r\n\r\n\t\t\t\t\t'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',\r\n\r\n\t\t\t\t'}',\r\n\r\n\t\t\t'}'\r\n\r\n\t\t].join( '\\n' ) );\r\n\r\n\t\tgl.compileShader( vertexShader );\r\n\t\tgl.compileShader( fragmentShader );\r\n\r\n\t\tgl.attachShader( program, vertexShader );\r\n\t\tgl.attachShader( program, fragmentShader );\r\n\r\n\t\tgl.linkProgram( program );\r\n\r\n\t\treturn program;\r\n\r\n\t};\r\n\r\n\tfunction painterSortStable ( a, b ) {\r\n\r\n\t\tif ( a.z !== b.z ) {\r\n\r\n\t\t\treturn b.z - a.z;\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn b.id - a.id;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n};\r\n\r\n// File:src/extras/GeometryUtils.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.GeometryUtils = {\r\n\r\n\tmerge: function ( geometry1, geometry2, materialIndexOffset ) {\r\n\r\n\t\tTHREE.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );\r\n\r\n\t\tvar matrix;\r\n\r\n\t\tif ( geometry2 instanceof THREE.Mesh ) {\r\n\r\n\t\t\tgeometry2.matrixAutoUpdate && geometry2.updateMatrix();\r\n\r\n\t\t\tmatrix = geometry2.matrix;\r\n\t\t\tgeometry2 = geometry2.geometry;\r\n\r\n\t\t}\r\n\r\n\t\tgeometry1.merge( geometry2, matrix, materialIndexOffset );\r\n\r\n\t},\r\n\r\n\tcenter: function ( geometry ) {\r\n\r\n\t\tTHREE.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );\r\n\t\treturn geometry.center();\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/extras/ImageUtils.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author Daosheng Mu / https://github.com/DaoshengMu/\r\n */\r\n\r\nTHREE.ImageUtils = {\r\n\r\n\tcrossOrigin: undefined,\r\n\r\n\tloadTexture: function ( url, mapping, onLoad, onError ) {\r\n\r\n\t\tvar loader = new THREE.ImageLoader();\r\n\t\tloader.crossOrigin = this.crossOrigin;\r\n\r\n\t\tvar texture = new THREE.Texture( undefined, mapping );\r\n\r\n\t\tloader.load( url, function ( image ) {\r\n\r\n\t\t\ttexture.image = image;\r\n\t\t\ttexture.needsUpdate = true;\r\n\r\n\t\t\tif ( onLoad ) onLoad( texture );\r\n\r\n\t\t}, undefined, function ( event ) {\r\n\r\n\t\t\tif ( onError ) onError( event );\r\n\r\n\t\t} );\r\n\r\n\t\ttexture.sourceFile = url;\r\n\r\n\t\treturn texture;\r\n\r\n\t},\r\n\r\n\tloadTextureCube: function ( array, mapping, onLoad, onError ) {\r\n\r\n\t\tvar images = [];\r\n\r\n\t\tvar loader = new THREE.ImageLoader();\r\n\t\tloader.crossOrigin = this.crossOrigin;\r\n\r\n\t\tvar texture = new THREE.CubeTexture( images, mapping );\r\n\r\n\t\t// no flipping needed for cube textures\r\n\r\n\t\ttexture.flipY = false;\r\n\r\n\t\tvar loaded = 0;\r\n\r\n\t\tvar loadTexture = function ( i ) {\r\n\r\n\t\t\tloader.load( array[ i ], function ( image ) {\r\n\r\n\t\t\t\ttexture.images[ i ] = image;\r\n\r\n\t\t\t\tloaded += 1;\r\n\r\n\t\t\t\tif ( loaded === 6 ) {\r\n\r\n\t\t\t\t\ttexture.needsUpdate = true;\r\n\r\n\t\t\t\t\tif ( onLoad ) onLoad( texture );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}, undefined, onError );\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var i = 0, il = array.length; i < il; ++ i ) {\r\n\r\n\t\t\tloadTexture( i );\r\n\r\n\t\t}\r\n\r\n\t\treturn texture;\r\n\r\n\t},\r\n\r\n\tloadCompressedTexture: function () {\r\n\r\n\t\tTHREE.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' )\r\n\r\n\t},\r\n\r\n\tloadCompressedTextureCube: function () {\r\n\r\n\t\tTHREE.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' )\r\n\r\n\t},\r\n\r\n\tgetNormalMap: function ( image, depth ) {\r\n\r\n\t\t// Adapted from http://www.paulbrunt.co.uk/lab/heightnormal/\r\n\r\n\t\tvar cross = function ( a, b ) {\r\n\r\n\t\t\treturn [ a[ 1 ] * b[ 2 ] - a[ 2 ] * b[ 1 ], a[ 2 ] * b[ 0 ] - a[ 0 ] * b[ 2 ], a[ 0 ] * b[ 1 ] - a[ 1 ] * b[ 0 ] ];\r\n\r\n\t\t}\r\n\r\n\t\tvar subtract = function ( a, b ) {\r\n\r\n\t\t\treturn [ a[ 0 ] - b[ 0 ], a[ 1 ] - b[ 1 ], a[ 2 ] - b[ 2 ] ];\r\n\r\n\t\t}\r\n\r\n\t\tvar normalize = function ( a ) {\r\n\r\n\t\t\tvar l = Math.sqrt( a[ 0 ] * a[ 0 ] + a[ 1 ] * a[ 1 ] + a[ 2 ] * a[ 2 ] );\r\n\t\t\treturn [ a[ 0 ] / l, a[ 1 ] / l, a[ 2 ] / l ];\r\n\r\n\t\t}\r\n\r\n\t\tdepth = depth | 1;\r\n\r\n\t\tvar width = image.width;\r\n\t\tvar height = image.height;\r\n\r\n\t\tvar canvas = document.createElement( 'canvas' );\r\n\t\tcanvas.width = width;\r\n\t\tcanvas.height = height;\r\n\r\n\t\tvar context = canvas.getContext( '2d' );\r\n\t\tcontext.drawImage( image, 0, 0 );\r\n\r\n\t\tvar data = context.getImageData( 0, 0, width, height ).data;\r\n\t\tvar imageData = context.createImageData( width, height );\r\n\t\tvar output = imageData.data;\r\n\r\n\t\tfor ( var x = 0; x < width; x ++ ) {\r\n\r\n\t\t\tfor ( var y = 0; y < height; y ++ ) {\r\n\r\n\t\t\t\tvar ly = y - 1 < 0 ? 0 : y - 1;\r\n\t\t\t\tvar uy = y + 1 > height - 1 ? height - 1 : y + 1;\r\n\t\t\t\tvar lx = x - 1 < 0 ? 0 : x - 1;\r\n\t\t\t\tvar ux = x + 1 > width - 1 ? width - 1 : x + 1;\r\n\r\n\t\t\t\tvar points = [];\r\n\t\t\t\tvar origin = [ 0, 0, data[ ( y * width + x ) * 4 ] / 255 * depth ];\r\n\t\t\t\tpoints.push( [ - 1, 0, data[ ( y * width + lx ) * 4 ] / 255 * depth ] );\r\n\t\t\t\tpoints.push( [ - 1, - 1, data[ ( ly * width + lx ) * 4 ] / 255 * depth ] );\r\n\t\t\t\tpoints.push( [ 0, - 1, data[ ( ly * width + x ) * 4 ] / 255 * depth ] );\r\n\t\t\t\tpoints.push( [ 1, - 1, data[ ( ly * width + ux ) * 4 ] / 255 * depth ] );\r\n\t\t\t\tpoints.push( [ 1, 0, data[ ( y * width + ux ) * 4 ] / 255 * depth ] );\r\n\t\t\t\tpoints.push( [ 1, 1, data[ ( uy * width + ux ) * 4 ] / 255 * depth ] );\r\n\t\t\t\tpoints.push( [ 0, 1, data[ ( uy * width + x ) * 4 ] / 255 * depth ] );\r\n\t\t\t\tpoints.push( [ - 1, 1, data[ ( uy * width + lx ) * 4 ] / 255 * depth ] );\r\n\r\n\t\t\t\tvar normals = [];\r\n\t\t\t\tvar num_points = points.length;\r\n\r\n\t\t\t\tfor ( var i = 0; i < num_points; i ++ ) {\r\n\r\n\t\t\t\t\tvar v1 = points[ i ];\r\n\t\t\t\t\tvar v2 = points[ ( i + 1 ) % num_points ];\r\n\t\t\t\t\tv1 = subtract( v1, origin );\r\n\t\t\t\t\tv2 = subtract( v2, origin );\r\n\t\t\t\t\tnormals.push( normalize( cross( v1, v2 ) ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar normal = [ 0, 0, 0 ];\r\n\r\n\t\t\t\tfor ( var i = 0; i < normals.length; i ++ ) {\r\n\r\n\t\t\t\t\tnormal[ 0 ] += normals[ i ][ 0 ];\r\n\t\t\t\t\tnormal[ 1 ] += normals[ i ][ 1 ];\r\n\t\t\t\t\tnormal[ 2 ] += normals[ i ][ 2 ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tnormal[ 0 ] /= normals.length;\r\n\t\t\t\tnormal[ 1 ] /= normals.length;\r\n\t\t\t\tnormal[ 2 ] /= normals.length;\r\n\r\n\t\t\t\tvar idx = ( y * width + x ) * 4;\r\n\r\n\t\t\t\toutput[ idx ] = ( ( normal[ 0 ] + 1.0 ) / 2.0 * 255 ) | 0;\r\n\t\t\t\toutput[ idx + 1 ] = ( ( normal[ 1 ] + 1.0 ) / 2.0 * 255 ) | 0;\r\n\t\t\t\toutput[ idx + 2 ] = ( normal[ 2 ] * 255 ) | 0;\r\n\t\t\t\toutput[ idx + 3 ] = 255;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tcontext.putImageData( imageData, 0, 0 );\r\n\r\n\t\treturn canvas;\r\n\r\n\t},\r\n\r\n\tgenerateDataTexture: function ( width, height, color ) {\r\n\r\n\t\tvar size = width * height;\r\n\t\tvar data = new Uint8Array( 3 * size );\r\n\r\n\t\tvar r = Math.floor( color.r * 255 );\r\n\t\tvar g = Math.floor( color.g * 255 );\r\n\t\tvar b = Math.floor( color.b * 255 );\r\n\r\n\t\tfor ( var i = 0; i < size; i ++ ) {\r\n\r\n\t\t\tdata[ i * 3 ] \t   = r;\r\n\t\t\tdata[ i * 3 + 1 ] = g;\r\n\t\t\tdata[ i * 3 + 2 ] = b;\r\n\r\n\t\t}\r\n\r\n\t\tvar texture = new THREE.DataTexture( data, width, height, THREE.RGBFormat );\r\n\t\ttexture.needsUpdate = true;\r\n\r\n\t\treturn texture;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/extras/SceneUtils.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.SceneUtils = {\r\n\r\n\tcreateMultiMaterialObject: function ( geometry, materials ) {\r\n\r\n\t\tvar group = new THREE.Object3D();\r\n\r\n\t\tfor ( var i = 0, l = materials.length; i < l; i ++ ) {\r\n\r\n\t\t\tgroup.add( new THREE.Mesh( geometry, materials[ i ] ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn group;\r\n\r\n\t},\r\n\r\n\tdetach: function ( child, parent, scene ) {\r\n\r\n\t\tchild.applyMatrix( parent.matrixWorld );\r\n\t\tparent.remove( child );\r\n\t\tscene.add( child );\r\n\r\n\t},\r\n\r\n\tattach: function ( child, scene, parent ) {\r\n\r\n\t\tvar matrixWorldInverse = new THREE.Matrix4();\r\n\t\tmatrixWorldInverse.getInverse( parent.matrixWorld );\r\n\t\tchild.applyMatrix( matrixWorldInverse );\r\n\r\n\t\tscene.remove( child );\r\n\t\tparent.add( child );\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/extras/FontUtils.js\r\n\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * For Text operations in three.js (See TextGeometry)\r\n *\r\n * It uses techniques used in:\r\n *\r\n * \ttypeface.js and canvastext\r\n * \t\tFor converting fonts and rendering with javascript\r\n *\t\thttp://typeface.neocracy.org\r\n *\r\n *\tTriangulation ported from AS3\r\n *\t\tSimple Polygon Triangulation\r\n *\t\thttp://actionsnippet.com/?p=1462\r\n *\r\n * \tA Method to triangulate shapes with holes\r\n *\t\thttp://www.sakri.net/blog/2009/06/12/an-approach-to-triangulating-polygons-with-holes/\r\n *\r\n */\r\n\r\nTHREE.FontUtils = {\r\n\r\n\tfaces: {},\r\n\r\n\t// Just for now. face[weight][style]\r\n\r\n\tface: 'helvetiker',\r\n\tweight: 'normal',\r\n\tstyle: 'normal',\r\n\tsize: 150,\r\n\tdivisions: 10,\r\n\r\n\tgetFace: function () {\r\n\r\n\t\ttry {\r\n\r\n\t\t\treturn this.faces[ this.face ][ this.weight ][ this.style ];\r\n\r\n\t\t} catch (e) {\r\n\r\n\t\t\tthrow \"The font \" + this.face + \" with \" + this.weight + \" weight and \" + this.style + \" style is missing.\"\r\n\r\n\t\t};\r\n\r\n\t},\r\n\r\n\tloadFace: function ( data ) {\r\n\r\n\t\tvar family = data.familyName.toLowerCase();\r\n\r\n\t\tvar ThreeFont = this;\r\n\r\n\t\tThreeFont.faces[ family ] = ThreeFont.faces[ family ] || {};\r\n\r\n\t\tThreeFont.faces[ family ][ data.cssFontWeight ] = ThreeFont.faces[ family ][ data.cssFontWeight ] || {};\r\n\t\tThreeFont.faces[ family ][ data.cssFontWeight ][ data.cssFontStyle ] = data;\r\n\r\n\t\tThreeFont.faces[ family ][ data.cssFontWeight ][ data.cssFontStyle ] = data;\r\n\r\n\t\treturn data;\r\n\r\n\t},\r\n\r\n\tdrawText: function ( text ) {\r\n\r\n\t\t// RenderText\r\n\r\n\t\tvar i,\r\n\t\t\tface = this.getFace(),\r\n\t\t\tscale = this.size / face.resolution,\r\n\t\t\toffset = 0,\r\n\t\t\tchars = String( text ).split( '' ),\r\n\t\t\tlength = chars.length;\r\n\r\n\t\tvar fontPaths = [];\r\n\r\n\t\tfor ( i = 0; i < length; i ++ ) {\r\n\r\n\t\t\tvar path = new THREE.Path();\r\n\r\n\t\t\tvar ret = this.extractGlyphPoints( chars[ i ], face, scale, offset, path );\r\n\t\t\toffset += ret.offset;\r\n\r\n\t\t\tfontPaths.push( ret.path );\r\n\r\n\t\t}\r\n\r\n\t\t// get the width\r\n\r\n\t\tvar width = offset / 2;\r\n\t\t//\r\n\t\t// for ( p = 0; p < allPts.length; p++ ) {\r\n\t\t//\r\n\t\t// \tallPts[ p ].x -= width;\r\n\t\t//\r\n\t\t// }\r\n\r\n\t\t//var extract = this.extractPoints( allPts, characterPts );\r\n\t\t//extract.contour = allPts;\r\n\r\n\t\t//extract.paths = fontPaths;\r\n\t\t//extract.offset = width;\r\n\r\n\t\treturn { paths: fontPaths, offset: width };\r\n\r\n\t},\r\n\r\n\r\n\r\n\r\n\textractGlyphPoints: function ( c, face, scale, offset, path ) {\r\n\r\n\t\tvar pts = [];\r\n\r\n\t\tvar i, i2, divisions,\r\n\t\t\toutline, action, length,\r\n\t\t\tscaleX, scaleY,\r\n\t\t\tx, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2,\r\n\t\t\tlaste,\r\n\t\t\tglyph = face.glyphs[ c ] || face.glyphs[ '?' ];\r\n\r\n\t\tif ( ! glyph ) return;\r\n\r\n\t\tif ( glyph.o ) {\r\n\r\n\t\t\toutline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );\r\n\t\t\tlength = outline.length;\r\n\r\n\t\t\tscaleX = scale;\r\n\t\t\tscaleY = scale;\r\n\r\n\t\t\tfor ( i = 0; i < length; ) {\r\n\r\n\t\t\t\taction = outline[ i ++ ];\r\n\r\n\t\t\t\t//console.log( action );\r\n\r\n\t\t\t\tswitch ( action ) {\r\n\r\n\t\t\t\tcase 'm':\r\n\r\n\t\t\t\t\t// Move To\r\n\r\n\t\t\t\t\tx = outline[ i ++ ] * scaleX + offset;\r\n\t\t\t\t\ty = outline[ i ++ ] * scaleY;\r\n\r\n\t\t\t\t\tpath.moveTo( x, y );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'l':\r\n\r\n\t\t\t\t\t// Line To\r\n\r\n\t\t\t\t\tx = outline[ i ++ ] * scaleX + offset;\r\n\t\t\t\t\ty = outline[ i ++ ] * scaleY;\r\n\t\t\t\t\tpath.lineTo( x, y );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'q':\r\n\r\n\t\t\t\t\t// QuadraticCurveTo\r\n\r\n\t\t\t\t\tcpx  = outline[ i ++ ] * scaleX + offset;\r\n\t\t\t\t\tcpy  = outline[ i ++ ] * scaleY;\r\n\t\t\t\t\tcpx1 = outline[ i ++ ] * scaleX + offset;\r\n\t\t\t\t\tcpy1 = outline[ i ++ ] * scaleY;\r\n\r\n\t\t\t\t\tpath.quadraticCurveTo( cpx1, cpy1, cpx, cpy );\r\n\r\n\t\t\t\t\tlaste = pts[ pts.length - 1 ];\r\n\r\n\t\t\t\t\tif ( laste ) {\r\n\r\n\t\t\t\t\t\tcpx0 = laste.x;\r\n\t\t\t\t\t\tcpy0 = laste.y;\r\n\r\n\t\t\t\t\t\tfor ( i2 = 1, divisions = this.divisions; i2 <= divisions; i2 ++ ) {\r\n\r\n\t\t\t\t\t\t\tvar t = i2 / divisions;\r\n\t\t\t\t\t\t\tTHREE.Shape.Utils.b2( t, cpx0, cpx1, cpx );\r\n\t\t\t\t\t\t\tTHREE.Shape.Utils.b2( t, cpy0, cpy1, cpy );\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'b':\r\n\r\n\t\t\t\t\t// Cubic Bezier Curve\r\n\r\n\t\t\t\t\tcpx  = outline[ i ++ ] *  scaleX + offset;\r\n\t\t\t\t\tcpy  = outline[ i ++ ] *  scaleY;\r\n\t\t\t\t\tcpx1 = outline[ i ++ ] *  scaleX + offset;\r\n\t\t\t\t\tcpy1 = outline[ i ++ ] *  scaleY;\r\n\t\t\t\t\tcpx2 = outline[ i ++ ] *  scaleX + offset;\r\n\t\t\t\t\tcpy2 = outline[ i ++ ] *  scaleY;\r\n\r\n\t\t\t\t\tpath.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );\r\n\r\n\t\t\t\t\tlaste = pts[ pts.length - 1 ];\r\n\r\n\t\t\t\t\tif ( laste ) {\r\n\r\n\t\t\t\t\t\tcpx0 = laste.x;\r\n\t\t\t\t\t\tcpy0 = laste.y;\r\n\r\n\t\t\t\t\t\tfor ( i2 = 1, divisions = this.divisions; i2 <= divisions; i2 ++ ) {\r\n\r\n\t\t\t\t\t\t\tvar t = i2 / divisions;\r\n\t\t\t\t\t\t\tTHREE.Shape.Utils.b3( t, cpx0, cpx1, cpx2, cpx );\r\n\t\t\t\t\t\t\tTHREE.Shape.Utils.b3( t, cpy0, cpy1, cpy2, cpy );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t}\r\n\r\n\r\n\r\n\t\treturn { offset: glyph.ha * scale, path:path };\r\n\t}\r\n\r\n};\r\n\r\n\r\nTHREE.FontUtils.generateShapes = function ( text, parameters ) {\r\n\r\n\t// Parameters \r\n\r\n\tparameters = parameters || {};\r\n\r\n\tvar size = parameters.size !== undefined ? parameters.size : 100;\r\n\tvar curveSegments = parameters.curveSegments !== undefined ? parameters.curveSegments : 4;\r\n\r\n\tvar font = parameters.font !== undefined ? parameters.font : 'helvetiker';\r\n\tvar weight = parameters.weight !== undefined ? parameters.weight : 'normal';\r\n\tvar style = parameters.style !== undefined ? parameters.style : 'normal';\r\n\r\n\tTHREE.FontUtils.size = size;\r\n\tTHREE.FontUtils.divisions = curveSegments;\r\n\r\n\tTHREE.FontUtils.face = font;\r\n\tTHREE.FontUtils.weight = weight;\r\n\tTHREE.FontUtils.style = style;\r\n\r\n\t// Get a Font data json object\r\n\r\n\tvar data = THREE.FontUtils.drawText( text );\r\n\r\n\tvar paths = data.paths;\r\n\tvar shapes = [];\r\n\r\n\tfor ( var p = 0, pl = paths.length; p < pl; p ++ ) {\r\n\r\n\t\tArray.prototype.push.apply( shapes, paths[ p ].toShapes() );\r\n\r\n\t}\r\n\r\n\treturn shapes;\r\n\r\n};\r\n\r\n\r\n/**\r\n * This code is a quick port of code written in C++ which was submitted to\r\n * flipcode.com by John W. Ratcliff  // July 22, 2000\r\n * See original code and more information here:\r\n * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml\r\n *\r\n * ported to actionscript by Zevan Rosser\r\n * www.actionsnippet.com\r\n *\r\n * ported to javascript by Joshua Koo\r\n * http://www.lab4games.net/zz85/blog\r\n *\r\n */\r\n\r\n\r\n( function ( namespace ) {\r\n\r\n\tvar EPSILON = 0.0000000001;\r\n\r\n\t// takes in an contour array and returns\r\n\r\n\tvar process = function ( contour, indices ) {\r\n\r\n\t\tvar n = contour.length;\r\n\r\n\t\tif ( n < 3 ) return null;\r\n\r\n\t\tvar result = [],\r\n\t\t\tverts = [],\r\n\t\t\tvertIndices = [];\r\n\r\n\t\t/* we want a counter-clockwise polygon in verts */\r\n\r\n\t\tvar u, v, w;\r\n\r\n\t\tif ( area( contour ) > 0.0 ) {\r\n\r\n\t\t\tfor ( v = 0; v < n; v ++ ) verts[ v ] = v;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tfor ( v = 0; v < n; v ++ ) verts[ v ] = ( n - 1 ) - v;\r\n\r\n\t\t}\r\n\r\n\t\tvar nv = n;\r\n\r\n\t\t/*  remove nv - 2 vertices, creating 1 triangle every time */\r\n\r\n\t\tvar count = 2 * nv;   /* error detection */\r\n\r\n\t\tfor ( v = nv - 1; nv > 2; ) {\r\n\r\n\t\t\t/* if we loop, it is probably a non-simple polygon */\r\n\r\n\t\t\tif ( ( count -- ) <= 0 ) {\r\n\r\n\t\t\t\t//** Triangulate: ERROR - probable bad polygon!\r\n\r\n\t\t\t\t//throw ( \"Warning, unable to triangulate polygon!\" );\r\n\t\t\t\t//return null;\r\n\t\t\t\t// Sometimes warning is fine, especially polygons are triangulated in reverse.\r\n\t\t\t\tTHREE.warn( 'THREE.FontUtils: Warning, unable to triangulate polygon! in Triangulate.process()' );\r\n\r\n\t\t\t\tif ( indices ) return vertIndices;\r\n\t\t\t\treturn result;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t/* three consecutive vertices in current polygon, <u,v,w> */\r\n\r\n\t\t\tu = v; \t \tif ( nv <= u ) u = 0;     /* previous */\r\n\t\t\tv = u + 1;  if ( nv <= v ) v = 0;     /* new v    */\r\n\t\t\tw = v + 1;  if ( nv <= w ) w = 0;     /* next     */\r\n\r\n\t\t\tif ( snip( contour, u, v, w, nv, verts ) ) {\r\n\r\n\t\t\t\tvar a, b, c, s, t;\r\n\r\n\t\t\t\t/* true names of the vertices */\r\n\r\n\t\t\t\ta = verts[ u ];\r\n\t\t\t\tb = verts[ v ];\r\n\t\t\t\tc = verts[ w ];\r\n\r\n\t\t\t\t/* output Triangle */\r\n\r\n\t\t\t\tresult.push( [ contour[ a ],\r\n\t\t\t\t\tcontour[ b ],\r\n\t\t\t\t\tcontour[ c ] ] );\r\n\r\n\r\n\t\t\t\tvertIndices.push( [ verts[ u ], verts[ v ], verts[ w ] ] );\r\n\r\n\t\t\t\t/* remove v from the remaining polygon */\r\n\r\n\t\t\t\tfor ( s = v, t = v + 1; t < nv; s ++, t ++ ) {\r\n\r\n\t\t\t\t\tverts[ s ] = verts[ t ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tnv --;\r\n\r\n\t\t\t\t/* reset error detection counter */\r\n\r\n\t\t\t\tcount = 2 * nv;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( indices ) return vertIndices;\r\n\t\treturn result;\r\n\r\n\t};\r\n\r\n\t// calculate area of the contour polygon\r\n\r\n\tvar area = function ( contour ) {\r\n\r\n\t\tvar n = contour.length;\r\n\t\tvar a = 0.0;\r\n\r\n\t\tfor ( var p = n - 1, q = 0; q < n; p = q ++ ) {\r\n\r\n\t\t\ta += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;\r\n\r\n\t\t}\r\n\r\n\t\treturn a * 0.5;\r\n\r\n\t};\r\n\r\n\tvar snip = function ( contour, u, v, w, n, verts ) {\r\n\r\n\t\tvar p;\r\n\t\tvar ax, ay, bx, by;\r\n\t\tvar cx, cy, px, py;\r\n\r\n\t\tax = contour[ verts[ u ] ].x;\r\n\t\tay = contour[ verts[ u ] ].y;\r\n\r\n\t\tbx = contour[ verts[ v ] ].x;\r\n\t\tby = contour[ verts[ v ] ].y;\r\n\r\n\t\tcx = contour[ verts[ w ] ].x;\r\n\t\tcy = contour[ verts[ w ] ].y;\r\n\r\n\t\tif ( EPSILON > ( ( ( bx - ax ) * ( cy - ay ) ) - ( ( by - ay ) * ( cx - ax ) ) ) ) return false;\r\n\r\n\t\tvar aX, aY, bX, bY, cX, cY;\r\n\t\tvar apx, apy, bpx, bpy, cpx, cpy;\r\n\t\tvar cCROSSap, bCROSScp, aCROSSbp;\r\n\r\n\t\taX = cx - bx;  aY = cy - by;\r\n\t\tbX = ax - cx;  bY = ay - cy;\r\n\t\tcX = bx - ax;  cY = by - ay;\r\n\r\n\t\tfor ( p = 0; p < n; p ++ ) {\r\n\r\n\t\t\tpx = contour[ verts[ p ] ].x\r\n\t\t\tpy = contour[ verts[ p ] ].y\r\n\r\n\t\t\tif ( ( ( px === ax ) && ( py === ay ) ) ||\r\n\t\t\t\t ( ( px === bx ) && ( py === by ) ) ||\r\n\t\t\t\t ( ( px === cx ) && ( py === cy ) ) )\tcontinue;\r\n\r\n\t\t\tapx = px - ax;  apy = py - ay;\r\n\t\t\tbpx = px - bx;  bpy = py - by;\r\n\t\t\tcpx = px - cx;  cpy = py - cy;\r\n\r\n\t\t\t// see if p is inside triangle abc\r\n\r\n\t\t\taCROSSbp = aX * bpy - aY * bpx;\r\n\t\t\tcCROSSap = cX * apy - cY * apx;\r\n\t\t\tbCROSScp = bX * cpy - bY * cpx;\r\n\r\n\t\t\tif ( ( aCROSSbp >= - EPSILON ) && ( bCROSScp >= - EPSILON ) && ( cCROSSap >= - EPSILON ) ) return false;\r\n\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\t};\r\n\r\n\r\n\tnamespace.Triangulate = process;\r\n\tnamespace.Triangulate.area = area;\r\n\r\n\treturn namespace;\r\n\r\n} )( THREE.FontUtils );\r\n\r\n// To use the typeface.js face files, hook up the API\r\nself._typeface_js = { faces: THREE.FontUtils.faces, loadFace: THREE.FontUtils.loadFace };\r\nTHREE.typeface_js = self._typeface_js;\r\n\r\n// File:src/extras/audio/Audio.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Audio = function ( listener ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.type = 'Audio';\r\n\r\n\tthis.context = listener.context;\r\n\tthis.source = this.context.createBufferSource();\r\n\tthis.source.onended = this.onEnded.bind(this);\r\n\r\n\tthis.gain = this.context.createGain();\r\n\tthis.gain.connect( this.context.destination );\r\n\r\n\tthis.panner = this.context.createPanner();\r\n\tthis.panner.connect( this.gain );\r\n\r\n\tthis.autoplay = false;\r\n\r\n\tthis.startTime = 0;\r\n\tthis.isPlaying = false;\r\n\r\n};\r\n\r\nTHREE.Audio.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.Audio.prototype.constructor = THREE.Audio;\r\n\r\nTHREE.Audio.prototype.load = function ( file ) {\r\n\r\n\tvar scope = this;\r\n\r\n\tvar request = new XMLHttpRequest();\r\n\trequest.open( 'GET', file, true );\r\n\trequest.responseType = 'arraybuffer';\r\n\trequest.onload = function ( e ) {\r\n\r\n\t\tscope.context.decodeAudioData( this.response, function ( buffer ) {\r\n\r\n\t\t\tscope.source.buffer = buffer;\r\n\r\n\t\t\tif( scope.autoplay ) scope.play();\r\n\r\n\t\t} );\r\n\r\n\t};\r\n\trequest.send();\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\nTHREE.Audio.prototype.play = function () {\r\n\r\n\tif ( this.isPlaying === true ) {\r\n\r\n\t\tTHREE.warn( 'THREE.Audio: Audio is already playing.' );\r\n\t\treturn;\r\n\r\n\t}\r\n\r\n\tvar source = this.context.createBufferSource();\r\n\r\n\tsource.buffer = this.source.buffer;\r\n\tsource.loop = this.source.loop;\r\n\tsource.onended = this.source.onended;\r\n\tsource.connect( this.panner );\r\n\tsource.start( 0, this.startTime );\r\n\r\n\tthis.isPlaying = true;\r\n\r\n\tthis.source = source;\r\n\r\n};\r\n\r\nTHREE.Audio.prototype.pause = function () {\r\n\r\n\tthis.source.stop();\r\n\tthis.startTime = this.context.currentTime;\r\n\r\n};\r\n\r\nTHREE.Audio.prototype.stop = function () {\r\n\r\n\tthis.source.stop();\r\n\tthis.startTime = 0;\r\n\r\n};\r\n\r\nTHREE.Audio.prototype.onEnded = function() {\r\n\r\n\tthis.isPlaying = false;\r\n\r\n};\r\n\r\nTHREE.Audio.prototype.setLoop = function ( value ) {\r\n\r\n\tthis.source.loop = value;\r\n\r\n};\r\n\r\nTHREE.Audio.prototype.setRefDistance = function ( value ) {\r\n\r\n\tthis.panner.refDistance = value;\r\n\r\n};\r\n\r\nTHREE.Audio.prototype.setRolloffFactor = function ( value ) {\r\n\r\n\tthis.panner.rolloffFactor = value;\r\n\r\n};\r\n\r\nTHREE.Audio.prototype.setVolume = function ( value ) {\r\n\r\n\tthis.gain.gain.value = value;\r\n\r\n};\r\n\r\nTHREE.Audio.prototype.updateMatrixWorld = ( function () {\r\n\r\n\tvar position = new THREE.Vector3();\r\n\r\n\treturn function ( force ) {\r\n\r\n\t\tTHREE.Object3D.prototype.updateMatrixWorld.call( this, force );\r\n\r\n\t\tposition.setFromMatrixPosition( this.matrixWorld );\r\n\r\n\t\tthis.panner.setPosition( position.x, position.y, position.z );\r\n\r\n\t};\r\n\r\n} )();\r\n\r\n// File:src/extras/audio/AudioListener.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.AudioListener = function () {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.type = 'AudioListener';\r\n\r\n\tthis.context = new ( window.AudioContext || window.webkitAudioContext )();\r\n\r\n};\r\n\r\nTHREE.AudioListener.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.AudioListener.prototype.constructor = THREE.AudioListener;\r\n\r\nTHREE.AudioListener.prototype.updateMatrixWorld = ( function () {\r\n\r\n\tvar position = new THREE.Vector3();\r\n\tvar quaternion = new THREE.Quaternion();\r\n\tvar scale = new THREE.Vector3();\r\n\r\n\tvar orientation = new THREE.Vector3();\r\n\tvar velocity = new THREE.Vector3();\r\n\r\n\tvar positionPrev = new THREE.Vector3();\r\n\r\n\treturn function ( force ) {\r\n\r\n\t\tTHREE.Object3D.prototype.updateMatrixWorld.call( this, force );\r\n\r\n\t\tvar listener = this.context.listener;\r\n\t\tvar up = this.up;\r\n\r\n\t\tthis.matrixWorld.decompose( position, quaternion, scale );\r\n\r\n\t\torientation.set( 0, 0, -1 ).applyQuaternion( quaternion );\r\n\t\tvelocity.subVectors( position, positionPrev );\r\n\r\n\t\tlistener.setPosition( position.x, position.y, position.z );\r\n\t\tlistener.setOrientation( orientation.x, orientation.y, orientation.z, up.x, up.y, up.z );\r\n\t\tlistener.setVelocity( velocity.x, velocity.y, velocity.z );\r\n\r\n\t\tpositionPrev.copy( position );\r\n\r\n\t};\r\n\r\n} )();\r\n\r\n// File:src/extras/core/Curve.js\r\n\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n * Extensible curve object\r\n *\r\n * Some common of Curve methods\r\n * .getPoint(t), getTangent(t)\r\n * .getPointAt(u), getTagentAt(u)\r\n * .getPoints(), .getSpacedPoints()\r\n * .getLength()\r\n * .updateArcLengths()\r\n *\r\n * This following classes subclasses THREE.Curve:\r\n *\r\n * -- 2d classes --\r\n * THREE.LineCurve\r\n * THREE.QuadraticBezierCurve\r\n * THREE.CubicBezierCurve\r\n * THREE.SplineCurve\r\n * THREE.ArcCurve\r\n * THREE.EllipseCurve\r\n *\r\n * -- 3d classes --\r\n * THREE.LineCurve3\r\n * THREE.QuadraticBezierCurve3\r\n * THREE.CubicBezierCurve3\r\n * THREE.SplineCurve3\r\n * THREE.ClosedSplineCurve3\r\n *\r\n * A series of curves can be represented as a THREE.CurvePath\r\n *\r\n **/\r\n\r\n/**************************************************************\r\n *\tAbstract Curve base class\r\n **************************************************************/\r\n\r\nTHREE.Curve = function () {\r\n\r\n};\r\n\r\n// Virtual base class method to overwrite and implement in subclasses\r\n//\t- t [0 .. 1]\r\n\r\nTHREE.Curve.prototype.getPoint = function ( t ) {\r\n\r\n\tTHREE.warn( \"THREE.Curve: Warning, getPoint() not implemented!\" );\r\n\treturn null;\r\n\r\n};\r\n\r\n// Get point at relative position in curve according to arc length\r\n// - u [0 .. 1]\r\n\r\nTHREE.Curve.prototype.getPointAt = function ( u ) {\r\n\r\n\tvar t = this.getUtoTmapping( u );\r\n\treturn this.getPoint( t );\r\n\r\n};\r\n\r\n// Get sequence of points using getPoint( t )\r\n\r\nTHREE.Curve.prototype.getPoints = function ( divisions ) {\r\n\r\n\tif ( ! divisions ) divisions = 5;\r\n\r\n\tvar d, pts = [];\r\n\r\n\tfor ( d = 0; d <= divisions; d ++ ) {\r\n\r\n\t\tpts.push( this.getPoint( d / divisions ) );\r\n\r\n\t}\r\n\r\n\treturn pts;\r\n\r\n};\r\n\r\n// Get sequence of points using getPointAt( u )\r\n\r\nTHREE.Curve.prototype.getSpacedPoints = function ( divisions ) {\r\n\r\n\tif ( ! divisions ) divisions = 5;\r\n\r\n\tvar d, pts = [];\r\n\r\n\tfor ( d = 0; d <= divisions; d ++ ) {\r\n\r\n\t\tpts.push( this.getPointAt( d / divisions ) );\r\n\r\n\t}\r\n\r\n\treturn pts;\r\n\r\n};\r\n\r\n// Get total curve arc length\r\n\r\nTHREE.Curve.prototype.getLength = function () {\r\n\r\n\tvar lengths = this.getLengths();\r\n\treturn lengths[ lengths.length - 1 ];\r\n\r\n};\r\n\r\n// Get list of cumulative segment lengths\r\n\r\nTHREE.Curve.prototype.getLengths = function ( divisions ) {\r\n\r\n\tif ( ! divisions ) divisions = (this.__arcLengthDivisions) ? (this.__arcLengthDivisions) : 200;\r\n\r\n\tif ( this.cacheArcLengths\r\n\t\t&& ( this.cacheArcLengths.length == divisions + 1 )\r\n\t\t&& ! this.needsUpdate) {\r\n\r\n\t\t//console.log( \"cached\", this.cacheArcLengths );\r\n\t\treturn this.cacheArcLengths;\r\n\r\n\t}\r\n\r\n\tthis.needsUpdate = false;\r\n\r\n\tvar cache = [];\r\n\tvar current, last = this.getPoint( 0 );\r\n\tvar p, sum = 0;\r\n\r\n\tcache.push( 0 );\r\n\r\n\tfor ( p = 1; p <= divisions; p ++ ) {\r\n\r\n\t\tcurrent = this.getPoint ( p / divisions );\r\n\t\tsum += current.distanceTo( last );\r\n\t\tcache.push( sum );\r\n\t\tlast = current;\r\n\r\n\t}\r\n\r\n\tthis.cacheArcLengths = cache;\r\n\r\n\treturn cache; // { sums: cache, sum:sum }; Sum is in the last element.\r\n\r\n};\r\n\r\n\r\nTHREE.Curve.prototype.updateArcLengths = function() {\r\n\tthis.needsUpdate = true;\r\n\tthis.getLengths();\r\n};\r\n\r\n// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equi distance\r\n\r\nTHREE.Curve.prototype.getUtoTmapping = function ( u, distance ) {\r\n\r\n\tvar arcLengths = this.getLengths();\r\n\r\n\tvar i = 0, il = arcLengths.length;\r\n\r\n\tvar targetArcLength; // The targeted u distance value to get\r\n\r\n\tif ( distance ) {\r\n\r\n\t\ttargetArcLength = distance;\r\n\r\n\t} else {\r\n\r\n\t\ttargetArcLength = u * arcLengths[ il - 1 ];\r\n\r\n\t}\r\n\r\n\t//var time = Date.now();\r\n\r\n\t// binary search for the index with largest value smaller than target u distance\r\n\r\n\tvar low = 0, high = il - 1, comparison;\r\n\r\n\twhile ( low <= high ) {\r\n\r\n\t\ti = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats\r\n\r\n\t\tcomparison = arcLengths[ i ] - targetArcLength;\r\n\r\n\t\tif ( comparison < 0 ) {\r\n\r\n\t\t\tlow = i + 1;\r\n\r\n\t\t} else if ( comparison > 0 ) {\r\n\r\n\t\t\thigh = i - 1;\r\n\r\n\t\t} else {\r\n\r\n\t\t\thigh = i;\r\n\t\t\tbreak;\r\n\r\n\t\t\t// DONE\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\ti = high;\r\n\r\n\t//console.log('b' , i, low, high, Date.now()- time);\r\n\r\n\tif ( arcLengths[ i ] == targetArcLength ) {\r\n\r\n\t\tvar t = i / ( il - 1 );\r\n\t\treturn t;\r\n\r\n\t}\r\n\r\n\t// we could get finer grain at lengths, or use simple interpolatation between two points\r\n\r\n\tvar lengthBefore = arcLengths[ i ];\r\n\tvar lengthAfter = arcLengths[ i + 1 ];\r\n\r\n\tvar segmentLength = lengthAfter - lengthBefore;\r\n\r\n    // determine where we are between the 'before' and 'after' points\r\n\r\n\tvar segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;\r\n\r\n    // add that fractional amount to t\r\n\r\n\tvar t = ( i + segmentFraction ) / ( il - 1 );\r\n\r\n\treturn t;\r\n\r\n};\r\n\r\n// Returns a unit vector tangent at t\r\n// In case any sub curve does not implement its tangent derivation,\r\n// 2 points a small delta apart will be used to find its gradient\r\n// which seems to give a reasonable approximation\r\n\r\nTHREE.Curve.prototype.getTangent = function( t ) {\r\n\r\n\tvar delta = 0.0001;\r\n\tvar t1 = t - delta;\r\n\tvar t2 = t + delta;\r\n\r\n\t// Capping in case of danger\r\n\r\n\tif ( t1 < 0 ) t1 = 0;\r\n\tif ( t2 > 1 ) t2 = 1;\r\n\r\n\tvar pt1 = this.getPoint( t1 );\r\n\tvar pt2 = this.getPoint( t2 );\r\n\r\n\tvar vec = pt2.clone().sub(pt1);\r\n\treturn vec.normalize();\r\n\r\n};\r\n\r\n\r\nTHREE.Curve.prototype.getTangentAt = function ( u ) {\r\n\r\n\tvar t = this.getUtoTmapping( u );\r\n\treturn this.getTangent( t );\r\n\r\n};\r\n\r\n\r\n\r\n\r\n\r\n/**************************************************************\r\n *\tUtils\r\n **************************************************************/\r\n\r\nTHREE.Curve.Utils = {\r\n\r\n\ttangentQuadraticBezier: function ( t, p0, p1, p2 ) {\r\n\r\n\t\treturn 2 * ( 1 - t ) * ( p1 - p0 ) + 2 * t * ( p2 - p1 );\r\n\r\n\t},\r\n\r\n\t// Puay Bing, thanks for helping with this derivative!\r\n\r\n\ttangentCubicBezier: function (t, p0, p1, p2, p3 ) {\r\n\r\n\t\treturn - 3 * p0 * (1 - t) * (1 - t)  +\r\n\t\t\t3 * p1 * (1 - t) * (1 - t) - 6 * t * p1 * (1 - t) +\r\n\t\t\t6 * t *  p2 * (1 - t) - 3 * t * t * p2 +\r\n\t\t\t3 * t * t * p3;\r\n\r\n\t},\r\n\r\n\ttangentSpline: function ( t, p0, p1, p2, p3 ) {\r\n\r\n\t\t// To check if my formulas are correct\r\n\r\n\t\tvar h00 = 6 * t * t - 6 * t; \t// derived from 2t^3 â 3t^2 + 1\r\n\t\tvar h10 = 3 * t * t - 4 * t + 1; // t^3 â 2t^2 + t\r\n\t\tvar h01 = - 6 * t * t + 6 * t; \t// â 2t3 + 3t2\r\n\t\tvar h11 = 3 * t * t - 2 * t;\t// t3 â t2\r\n\r\n\t\treturn h00 + h10 + h01 + h11;\r\n\r\n\t},\r\n\r\n\t// Catmull-Rom\r\n\r\n\tinterpolate: function( p0, p1, p2, p3, t ) {\r\n\r\n\t\tvar v0 = ( p2 - p0 ) * 0.5;\r\n\t\tvar v1 = ( p3 - p1 ) * 0.5;\r\n\t\tvar t2 = t * t;\r\n\t\tvar t3 = t * t2;\r\n\t\treturn ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;\r\n\r\n\t}\r\n\r\n};\r\n\r\n\r\n// TODO: Transformation for Curves?\r\n\r\n/**************************************************************\r\n *\t3D Curves\r\n **************************************************************/\r\n\r\n// A Factory method for creating new curve subclasses\r\n\r\nTHREE.Curve.create = function ( constructor, getPointFunc ) {\r\n\r\n\tconstructor.prototype = Object.create( THREE.Curve.prototype );\r\n\tconstructor.prototype.constructor = constructor;\r\n\tconstructor.prototype.getPoint = getPointFunc;\r\n\r\n\treturn constructor;\r\n\r\n};\r\n\r\n// File:src/extras/core/CurvePath.js\r\n\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n *\r\n **/\r\n\r\n/**************************************************************\r\n *\tCurved Path - a curve path is simply a array of connected\r\n *  curves, but retains the api of a curve\r\n **************************************************************/\r\n\r\nTHREE.CurvePath = function () {\r\n\r\n\tthis.curves = [];\r\n\tthis.bends = [];\r\n\t\r\n\tthis.autoClose = false; // Automatically closes the path\r\n};\r\n\r\nTHREE.CurvePath.prototype = Object.create( THREE.Curve.prototype );\r\nTHREE.CurvePath.prototype.constructor = THREE.CurvePath;\r\n\r\nTHREE.CurvePath.prototype.add = function ( curve ) {\r\n\r\n\tthis.curves.push( curve );\r\n\r\n};\r\n\r\nTHREE.CurvePath.prototype.checkConnection = function() {\r\n\t// TODO\r\n\t// If the ending of curve is not connected to the starting\r\n\t// or the next curve, then, this is not a real path\r\n};\r\n\r\nTHREE.CurvePath.prototype.closePath = function() {\r\n\t// TODO Test\r\n\t// and verify for vector3 (needs to implement equals)\r\n\t// Add a line curve if start and end of lines are not connected\r\n\tvar startPoint = this.curves[0].getPoint(0);\r\n\tvar endPoint = this.curves[this.curves.length - 1].getPoint(1);\r\n\t\r\n\tif (! startPoint.equals(endPoint)) {\r\n\t\tthis.curves.push( new THREE.LineCurve(endPoint, startPoint) );\r\n\t}\r\n\t\r\n};\r\n\r\n// To get accurate point with reference to\r\n// entire path distance at time t,\r\n// following has to be done:\r\n\r\n// 1. Length of each sub path have to be known\r\n// 2. Locate and identify type of curve\r\n// 3. Get t for the curve\r\n// 4. Return curve.getPointAt(t')\r\n\r\nTHREE.CurvePath.prototype.getPoint = function( t ) {\r\n\r\n\tvar d = t * this.getLength();\r\n\tvar curveLengths = this.getCurveLengths();\r\n\tvar i = 0, diff, curve;\r\n\r\n\t// To think about boundaries points.\r\n\r\n\twhile ( i < curveLengths.length ) {\r\n\r\n\t\tif ( curveLengths[ i ] >= d ) {\r\n\r\n\t\t\tdiff = curveLengths[ i ] - d;\r\n\t\t\tcurve = this.curves[ i ];\r\n\r\n\t\t\tvar u = 1 - diff / curve.getLength();\r\n\r\n\t\t\treturn curve.getPointAt( u );\r\n\r\n\t\t}\r\n\r\n\t\ti ++;\r\n\r\n\t}\r\n\r\n\treturn null;\r\n\r\n\t// loop where sum != 0, sum > d , sum+1 <d\r\n\r\n};\r\n\r\n/*\r\nTHREE.CurvePath.prototype.getTangent = function( t ) {\r\n};*/\r\n\r\n\r\n// We cannot use the default THREE.Curve getPoint() with getLength() because in\r\n// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath\r\n// getPoint() depends on getLength\r\n\r\nTHREE.CurvePath.prototype.getLength = function() {\r\n\r\n\tvar lens = this.getCurveLengths();\r\n\treturn lens[ lens.length - 1 ];\r\n\r\n};\r\n\r\n// Compute lengths and cache them\r\n// We cannot overwrite getLengths() because UtoT mapping uses it.\r\n\r\nTHREE.CurvePath.prototype.getCurveLengths = function() {\r\n\r\n\t// We use cache values if curves and cache array are same length\r\n\r\n\tif ( this.cacheLengths && this.cacheLengths.length == this.curves.length ) {\r\n\r\n\t\treturn this.cacheLengths;\r\n\r\n\t};\r\n\r\n\t// Get length of subsurve\r\n\t// Push sums into cached array\r\n\r\n\tvar lengths = [], sums = 0;\r\n\tvar i, il = this.curves.length;\r\n\r\n\tfor ( i = 0; i < il; i ++ ) {\r\n\r\n\t\tsums += this.curves[ i ].getLength();\r\n\t\tlengths.push( sums );\r\n\r\n\t}\r\n\r\n\tthis.cacheLengths = lengths;\r\n\r\n\treturn lengths;\r\n\r\n};\r\n\r\n\r\n\r\n// Returns min and max coordinates\r\n\r\nTHREE.CurvePath.prototype.getBoundingBox = function () {\r\n\r\n\tvar points = this.getPoints();\r\n\r\n\tvar maxX, maxY, maxZ;\r\n\tvar minX, minY, minZ;\r\n\r\n\tmaxX = maxY = Number.NEGATIVE_INFINITY;\r\n\tminX = minY = Number.POSITIVE_INFINITY;\r\n\r\n\tvar p, i, il, sum;\r\n\r\n\tvar v3 = points[0] instanceof THREE.Vector3;\r\n\r\n\tsum = v3 ? new THREE.Vector3() : new THREE.Vector2();\r\n\r\n\tfor ( i = 0, il = points.length; i < il; i ++ ) {\r\n\r\n\t\tp = points[ i ];\r\n\r\n\t\tif ( p.x > maxX ) maxX = p.x;\r\n\t\telse if ( p.x < minX ) minX = p.x;\r\n\r\n\t\tif ( p.y > maxY ) maxY = p.y;\r\n\t\telse if ( p.y < minY ) minY = p.y;\r\n\r\n\t\tif ( v3 ) {\r\n\r\n\t\t\tif ( p.z > maxZ ) maxZ = p.z;\r\n\t\t\telse if ( p.z < minZ ) minZ = p.z;\r\n\r\n\t\t}\r\n\r\n\t\tsum.add( p );\r\n\r\n\t}\r\n\r\n\tvar ret = {\r\n\r\n\t\tminX: minX,\r\n\t\tminY: minY,\r\n\t\tmaxX: maxX,\r\n\t\tmaxY: maxY\r\n\r\n\t};\r\n\r\n\tif ( v3 ) {\r\n\r\n\t\tret.maxZ = maxZ;\r\n\t\tret.minZ = minZ;\r\n\r\n\t}\r\n\r\n\treturn ret;\r\n\r\n};\r\n\r\n/**************************************************************\r\n *\tCreate Geometries Helpers\r\n **************************************************************/\r\n\r\n/// Generate geometry from path points (for Line or Points objects)\r\n\r\nTHREE.CurvePath.prototype.createPointsGeometry = function( divisions ) {\r\n\r\n\tvar pts = this.getPoints( divisions, true );\r\n\treturn this.createGeometry( pts );\r\n\r\n};\r\n\r\n// Generate geometry from equidistance sampling along the path\r\n\r\nTHREE.CurvePath.prototype.createSpacedPointsGeometry = function( divisions ) {\r\n\r\n\tvar pts = this.getSpacedPoints( divisions, true );\r\n\treturn this.createGeometry( pts );\r\n\r\n};\r\n\r\nTHREE.CurvePath.prototype.createGeometry = function( points ) {\r\n\r\n\tvar geometry = new THREE.Geometry();\r\n\r\n\tfor ( var i = 0; i < points.length; i ++ ) {\r\n\r\n\t\tgeometry.vertices.push( new THREE.Vector3( points[ i ].x, points[ i ].y, points[ i ].z || 0) );\r\n\r\n\t}\r\n\r\n\treturn geometry;\r\n\r\n};\r\n\r\n\r\n/**************************************************************\r\n *\tBend / Wrap Helper Methods\r\n **************************************************************/\r\n\r\n// Wrap path / Bend modifiers?\r\n\r\nTHREE.CurvePath.prototype.addWrapPath = function ( bendpath ) {\r\n\r\n\tthis.bends.push( bendpath );\r\n\r\n};\r\n\r\nTHREE.CurvePath.prototype.getTransformedPoints = function( segments, bends ) {\r\n\r\n\tvar oldPts = this.getPoints( segments ); // getPoints getSpacedPoints\r\n\tvar i, il;\r\n\r\n\tif ( ! bends ) {\r\n\r\n\t\tbends = this.bends;\r\n\r\n\t}\r\n\r\n\tfor ( i = 0, il = bends.length; i < il; i ++ ) {\r\n\r\n\t\toldPts = this.getWrapPoints( oldPts, bends[ i ] );\r\n\r\n\t}\r\n\r\n\treturn oldPts;\r\n\r\n};\r\n\r\nTHREE.CurvePath.prototype.getTransformedSpacedPoints = function( segments, bends ) {\r\n\r\n\tvar oldPts = this.getSpacedPoints( segments );\r\n\r\n\tvar i, il;\r\n\r\n\tif ( ! bends ) {\r\n\r\n\t\tbends = this.bends;\r\n\r\n\t}\r\n\r\n\tfor ( i = 0, il = bends.length; i < il; i ++ ) {\r\n\r\n\t\toldPts = this.getWrapPoints( oldPts, bends[ i ] );\r\n\r\n\t}\r\n\r\n\treturn oldPts;\r\n\r\n};\r\n\r\n// This returns getPoints() bend/wrapped around the contour of a path.\r\n// Read http://www.planetclegg.com/projects/WarpingTextToSplines.html\r\n\r\nTHREE.CurvePath.prototype.getWrapPoints = function ( oldPts, path ) {\r\n\r\n\tvar bounds = this.getBoundingBox();\r\n\r\n\tvar i, il, p, oldX, oldY, xNorm;\r\n\r\n\tfor ( i = 0, il = oldPts.length; i < il; i ++ ) {\r\n\r\n\t\tp = oldPts[ i ];\r\n\r\n\t\toldX = p.x;\r\n\t\toldY = p.y;\r\n\r\n\t\txNorm = oldX / bounds.maxX;\r\n\r\n\t\t// If using actual distance, for length > path, requires line extrusions\r\n\t\t//xNorm = path.getUtoTmapping(xNorm, oldX); // 3 styles. 1) wrap stretched. 2) wrap stretch by arc length 3) warp by actual distance\r\n\r\n\t\txNorm = path.getUtoTmapping( xNorm, oldX );\r\n\r\n\t\t// check for out of bounds?\r\n\r\n\t\tvar pathPt = path.getPoint( xNorm );\r\n\t\tvar normal = path.getTangent( xNorm );\r\n\t\tnormal.set( - normal.y, normal.x ).multiplyScalar( oldY );\r\n\r\n\t\tp.x = pathPt.x + normal.x;\r\n\t\tp.y = pathPt.y + normal.y;\r\n\r\n\t}\r\n\r\n\treturn oldPts;\r\n\r\n};\r\n\r\n\r\n// File:src/extras/core/Gyroscope.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Gyroscope = function () {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n};\r\n\r\nTHREE.Gyroscope.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.Gyroscope.prototype.constructor = THREE.Gyroscope;\r\n\r\nTHREE.Gyroscope.prototype.updateMatrixWorld = ( function () {\r\n\r\n\tvar translationObject = new THREE.Vector3();\r\n\tvar quaternionObject = new THREE.Quaternion();\r\n\tvar scaleObject = new THREE.Vector3();\r\n\r\n\tvar translationWorld = new THREE.Vector3();\r\n\tvar quaternionWorld = new THREE.Quaternion();\r\n\tvar scaleWorld = new THREE.Vector3();\r\n\r\n\treturn function ( force ) {\r\n\r\n\t\tthis.matrixAutoUpdate && this.updateMatrix();\r\n\r\n\t\t// update matrixWorld\r\n\r\n\t\tif ( this.matrixWorldNeedsUpdate || force ) {\r\n\r\n\t\t\tif ( this.parent ) {\r\n\r\n\t\t\t\tthis.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\r\n\r\n\t\t\t\tthis.matrixWorld.decompose( translationWorld, quaternionWorld, scaleWorld );\r\n\t\t\t\tthis.matrix.decompose( translationObject, quaternionObject, scaleObject );\r\n\r\n\t\t\t\tthis.matrixWorld.compose( translationWorld, quaternionObject, scaleWorld );\r\n\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis.matrixWorld.copy( this.matrix );\r\n\r\n\t\t\t}\r\n\r\n\r\n\t\t\tthis.matrixWorldNeedsUpdate = false;\r\n\r\n\t\t\tforce = true;\r\n\r\n\t\t}\r\n\r\n\t\t// update children\r\n\r\n\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\r\n\r\n\t\t\tthis.children[ i ].updateMatrixWorld( force );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\t\r\n}() );\r\n\r\n// File:src/extras/core/Path.js\r\n\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n * Creates free form 2d path using series of points, lines or curves.\r\n *\r\n **/\r\n\r\nTHREE.Path = function ( points ) {\r\n\r\n\tTHREE.CurvePath.call(this);\r\n\r\n\tthis.actions = [];\r\n\r\n\tif ( points ) {\r\n\r\n\t\tthis.fromPoints( points );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.Path.prototype = Object.create( THREE.CurvePath.prototype );\r\nTHREE.Path.prototype.constructor = THREE.Path;\r\n\r\nTHREE.PathActions = {\r\n\r\n\tMOVE_TO: 'moveTo',\r\n\tLINE_TO: 'lineTo',\r\n\tQUADRATIC_CURVE_TO: 'quadraticCurveTo', // Bezier quadratic curve\r\n\tBEZIER_CURVE_TO: 'bezierCurveTo', \t\t// Bezier cubic curve\r\n\tCSPLINE_THRU: 'splineThru',\t\t\t\t// Catmull-rom spline\r\n\tARC: 'arc',\t\t\t\t\t\t\t\t// Circle\r\n\tELLIPSE: 'ellipse'\r\n};\r\n\r\n// TODO Clean up PATH API\r\n\r\n// Create path using straight lines to connect all points\r\n// - vectors: array of Vector2\r\n\r\nTHREE.Path.prototype.fromPoints = function ( vectors ) {\r\n\r\n\tthis.moveTo( vectors[ 0 ].x, vectors[ 0 ].y );\r\n\r\n\tfor ( var v = 1, vlen = vectors.length; v < vlen; v ++ ) {\r\n\r\n\t\tthis.lineTo( vectors[ v ].x, vectors[ v ].y );\r\n\r\n\t};\r\n\r\n};\r\n\r\n// startPath() endPath()?\r\n\r\nTHREE.Path.prototype.moveTo = function ( x, y ) {\r\n\r\n\tvar args = Array.prototype.slice.call( arguments );\r\n\tthis.actions.push( { action: THREE.PathActions.MOVE_TO, args: args } );\r\n\r\n};\r\n\r\nTHREE.Path.prototype.lineTo = function ( x, y ) {\r\n\r\n\tvar args = Array.prototype.slice.call( arguments );\r\n\r\n\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\r\n\r\n\tvar x0 = lastargs[ lastargs.length - 2 ];\r\n\tvar y0 = lastargs[ lastargs.length - 1 ];\r\n\r\n\tvar curve = new THREE.LineCurve( new THREE.Vector2( x0, y0 ), new THREE.Vector2( x, y ) );\r\n\tthis.curves.push( curve );\r\n\r\n\tthis.actions.push( { action: THREE.PathActions.LINE_TO, args: args } );\r\n\r\n};\r\n\r\nTHREE.Path.prototype.quadraticCurveTo = function( aCPx, aCPy, aX, aY ) {\r\n\r\n\tvar args = Array.prototype.slice.call( arguments );\r\n\r\n\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\r\n\r\n\tvar x0 = lastargs[ lastargs.length - 2 ];\r\n\tvar y0 = lastargs[ lastargs.length - 1 ];\r\n\r\n\tvar curve = new THREE.QuadraticBezierCurve( new THREE.Vector2( x0, y0 ),\r\n\t\t\t\t\t\t\t\t\t\t\t\tnew THREE.Vector2( aCPx, aCPy ),\r\n\t\t\t\t\t\t\t\t\t\t\t\tnew THREE.Vector2( aX, aY ) );\r\n\tthis.curves.push( curve );\r\n\r\n\tthis.actions.push( { action: THREE.PathActions.QUADRATIC_CURVE_TO, args: args } );\r\n\r\n};\r\n\r\nTHREE.Path.prototype.bezierCurveTo = function( aCP1x, aCP1y,\r\n\t\t\t\t\t\t\t\t\t\t\t   aCP2x, aCP2y,\r\n\t\t\t\t\t\t\t\t\t\t\t   aX, aY ) {\r\n\r\n\tvar args = Array.prototype.slice.call( arguments );\r\n\r\n\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\r\n\r\n\tvar x0 = lastargs[ lastargs.length - 2 ];\r\n\tvar y0 = lastargs[ lastargs.length - 1 ];\r\n\r\n\tvar curve = new THREE.CubicBezierCurve( new THREE.Vector2( x0, y0 ),\r\n\t\t\t\t\t\t\t\t\t\t\tnew THREE.Vector2( aCP1x, aCP1y ),\r\n\t\t\t\t\t\t\t\t\t\t\tnew THREE.Vector2( aCP2x, aCP2y ),\r\n\t\t\t\t\t\t\t\t\t\t\tnew THREE.Vector2( aX, aY ) );\r\n\tthis.curves.push( curve );\r\n\r\n\tthis.actions.push( { action: THREE.PathActions.BEZIER_CURVE_TO, args: args } );\r\n\r\n};\r\n\r\nTHREE.Path.prototype.splineThru = function( pts /*Array of Vector*/ ) {\r\n\r\n\tvar args = Array.prototype.slice.call( arguments );\r\n\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\r\n\r\n\tvar x0 = lastargs[ lastargs.length - 2 ];\r\n\tvar y0 = lastargs[ lastargs.length - 1 ];\r\n//---\r\n\tvar npts = [ new THREE.Vector2( x0, y0 ) ];\r\n\tArray.prototype.push.apply( npts, pts );\r\n\r\n\tvar curve = new THREE.SplineCurve( npts );\r\n\tthis.curves.push( curve );\r\n\r\n\tthis.actions.push( { action: THREE.PathActions.CSPLINE_THRU, args: args } );\r\n\r\n};\r\n\r\n// FUTURE: Change the API or follow canvas API?\r\n\r\nTHREE.Path.prototype.arc = function ( aX, aY, aRadius,\r\n\t\t\t\t\t\t\t\t\t  aStartAngle, aEndAngle, aClockwise ) {\r\n\r\n\tvar lastargs = this.actions[ this.actions.length - 1].args;\r\n\tvar x0 = lastargs[ lastargs.length - 2 ];\r\n\tvar y0 = lastargs[ lastargs.length - 1 ];\r\n\r\n\tthis.absarc(aX + x0, aY + y0, aRadius,\r\n\t\taStartAngle, aEndAngle, aClockwise );\r\n\r\n };\r\n\r\n THREE.Path.prototype.absarc = function ( aX, aY, aRadius,\r\n\t\t\t\t\t\t\t\t\t  aStartAngle, aEndAngle, aClockwise ) {\r\n\tthis.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);\r\n };\r\n\r\nTHREE.Path.prototype.ellipse = function ( aX, aY, xRadius, yRadius,\r\n\t\t\t\t\t\t\t\t\t  aStartAngle, aEndAngle, aClockwise ) {\r\n\r\n\tvar lastargs = this.actions[ this.actions.length - 1].args;\r\n\tvar x0 = lastargs[ lastargs.length - 2 ];\r\n\tvar y0 = lastargs[ lastargs.length - 1 ];\r\n\r\n\tthis.absellipse(aX + x0, aY + y0, xRadius, yRadius,\r\n\t\taStartAngle, aEndAngle, aClockwise );\r\n\r\n };\r\n\r\n\r\nTHREE.Path.prototype.absellipse = function ( aX, aY, xRadius, yRadius,\r\n\t\t\t\t\t\t\t\t\t  aStartAngle, aEndAngle, aClockwise ) {\r\n\r\n\tvar args = Array.prototype.slice.call( arguments );\r\n\tvar curve = new THREE.EllipseCurve( aX, aY, xRadius, yRadius,\r\n\t\t\t\t\t\t\t\t\taStartAngle, aEndAngle, aClockwise );\r\n\tthis.curves.push( curve );\r\n\r\n\tvar lastPoint = curve.getPoint(1);\r\n\targs.push(lastPoint.x);\r\n\targs.push(lastPoint.y);\r\n\r\n\tthis.actions.push( { action: THREE.PathActions.ELLIPSE, args: args } );\r\n\r\n };\r\n\r\nTHREE.Path.prototype.getSpacedPoints = function ( divisions, closedPath ) {\r\n\r\n\tif ( ! divisions ) divisions = 40;\r\n\r\n\tvar points = [];\r\n\r\n\tfor ( var i = 0; i < divisions; i ++ ) {\r\n\r\n\t\tpoints.push( this.getPoint( i / divisions ) );\r\n\r\n\t\t//if( !this.getPoint( i / divisions ) ) throw \"DIE\";\r\n\r\n\t}\r\n\r\n\t// if ( closedPath ) {\r\n\t//\r\n\t// \tpoints.push( points[ 0 ] );\r\n\t//\r\n\t// }\r\n\r\n\treturn points;\r\n\r\n};\r\n\r\n/* Return an array of vectors based on contour of the path */\r\n\r\nTHREE.Path.prototype.getPoints = function( divisions, closedPath ) {\r\n\r\n\tif (this.useSpacedPoints) {\r\n\t\tconsole.log('tata');\r\n\t\treturn this.getSpacedPoints( divisions, closedPath );\r\n\t}\r\n\r\n\tdivisions = divisions || 12;\r\n\r\n\tvar points = [];\r\n\r\n\tvar i, il, item, action, args;\r\n\tvar cpx, cpy, cpx2, cpy2, cpx1, cpy1, cpx0, cpy0,\r\n\t\tlaste, j,\r\n\t\tt, tx, ty;\r\n\r\n\tfor ( i = 0, il = this.actions.length; i < il; i ++ ) {\r\n\r\n\t\titem = this.actions[ i ];\r\n\r\n\t\taction = item.action;\r\n\t\targs = item.args;\r\n\r\n\t\tswitch ( action ) {\r\n\r\n\t\tcase THREE.PathActions.MOVE_TO:\r\n\r\n\t\t\tpoints.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );\r\n\r\n\t\t\tbreak;\r\n\r\n\t\tcase THREE.PathActions.LINE_TO:\r\n\r\n\t\t\tpoints.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );\r\n\r\n\t\t\tbreak;\r\n\r\n\t\tcase THREE.PathActions.QUADRATIC_CURVE_TO:\r\n\r\n\t\t\tcpx  = args[ 2 ];\r\n\t\t\tcpy  = args[ 3 ];\r\n\r\n\t\t\tcpx1 = args[ 0 ];\r\n\t\t\tcpy1 = args[ 1 ];\r\n\r\n\t\t\tif ( points.length > 0 ) {\r\n\r\n\t\t\t\tlaste = points[ points.length - 1 ];\r\n\r\n\t\t\t\tcpx0 = laste.x;\r\n\t\t\t\tcpy0 = laste.y;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tlaste = this.actions[ i - 1 ].args;\r\n\r\n\t\t\t\tcpx0 = laste[ laste.length - 2 ];\r\n\t\t\t\tcpy0 = laste[ laste.length - 1 ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( j = 1; j <= divisions; j ++ ) {\r\n\r\n\t\t\t\tt = j / divisions;\r\n\r\n\t\t\t\ttx = THREE.Shape.Utils.b2( t, cpx0, cpx1, cpx );\r\n\t\t\t\tty = THREE.Shape.Utils.b2( t, cpy0, cpy1, cpy );\r\n\r\n\t\t\t\tpoints.push( new THREE.Vector2( tx, ty ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tbreak;\r\n\r\n\t\tcase THREE.PathActions.BEZIER_CURVE_TO:\r\n\r\n\t\t\tcpx  = args[ 4 ];\r\n\t\t\tcpy  = args[ 5 ];\r\n\r\n\t\t\tcpx1 = args[ 0 ];\r\n\t\t\tcpy1 = args[ 1 ];\r\n\r\n\t\t\tcpx2 = args[ 2 ];\r\n\t\t\tcpy2 = args[ 3 ];\r\n\r\n\t\t\tif ( points.length > 0 ) {\r\n\r\n\t\t\t\tlaste = points[ points.length - 1 ];\r\n\r\n\t\t\t\tcpx0 = laste.x;\r\n\t\t\t\tcpy0 = laste.y;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tlaste = this.actions[ i - 1 ].args;\r\n\r\n\t\t\t\tcpx0 = laste[ laste.length - 2 ];\r\n\t\t\t\tcpy0 = laste[ laste.length - 1 ];\r\n\r\n\t\t\t}\r\n\r\n\r\n\t\t\tfor ( j = 1; j <= divisions; j ++ ) {\r\n\r\n\t\t\t\tt = j / divisions;\r\n\r\n\t\t\t\ttx = THREE.Shape.Utils.b3( t, cpx0, cpx1, cpx2, cpx );\r\n\t\t\t\tty = THREE.Shape.Utils.b3( t, cpy0, cpy1, cpy2, cpy );\r\n\r\n\t\t\t\tpoints.push( new THREE.Vector2( tx, ty ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tbreak;\r\n\r\n\t\tcase THREE.PathActions.CSPLINE_THRU:\r\n\r\n\t\t\tlaste = this.actions[ i - 1 ].args;\r\n\r\n\t\t\tvar last = new THREE.Vector2( laste[ laste.length - 2 ], laste[ laste.length - 1 ] );\r\n\t\t\tvar spts = [ last ];\r\n\r\n\t\t\tvar n = divisions * args[ 0 ].length;\r\n\r\n\t\t\tspts = spts.concat( args[ 0 ] );\r\n\r\n\t\t\tvar spline = new THREE.SplineCurve( spts );\r\n\r\n\t\t\tfor ( j = 1; j <= n; j ++ ) {\r\n\r\n\t\t\t\tpoints.push( spline.getPointAt( j / n ) ) ;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tbreak;\r\n\r\n\t\tcase THREE.PathActions.ARC:\r\n\r\n\t\t\tvar aX = args[ 0 ], aY = args[ 1 ],\r\n\t\t\t\taRadius = args[ 2 ],\r\n\t\t\t\taStartAngle = args[ 3 ], aEndAngle = args[ 4 ],\r\n\t\t\t\taClockwise = !! args[ 5 ];\r\n\r\n\t\t\tvar deltaAngle = aEndAngle - aStartAngle;\r\n\t\t\tvar angle;\r\n\t\t\tvar tdivisions = divisions * 2;\r\n\r\n\t\t\tfor ( j = 1; j <= tdivisions; j ++ ) {\r\n\r\n\t\t\t\tt = j / tdivisions;\r\n\r\n\t\t\t\tif ( ! aClockwise ) {\r\n\r\n\t\t\t\t\tt = 1 - t;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tangle = aStartAngle + t * deltaAngle;\r\n\r\n\t\t\t\ttx = aX + aRadius * Math.cos( angle );\r\n\t\t\t\tty = aY + aRadius * Math.sin( angle );\r\n\r\n\t\t\t\t//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);\r\n\r\n\t\t\t\tpoints.push( new THREE.Vector2( tx, ty ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t//console.log(points);\r\n\r\n\t\t\tbreak;\r\n\t\t  \r\n\t\tcase THREE.PathActions.ELLIPSE:\r\n\r\n\t\t\tvar aX = args[ 0 ], aY = args[ 1 ],\r\n\t\t\t\txRadius = args[ 2 ],\r\n\t\t\t\tyRadius = args[ 3 ],\r\n\t\t\t\taStartAngle = args[ 4 ], aEndAngle = args[ 5 ],\r\n\t\t\t\taClockwise = !! args[ 6 ];\r\n\r\n\r\n\t\t\tvar deltaAngle = aEndAngle - aStartAngle;\r\n\t\t\tvar angle;\r\n\t\t\tvar tdivisions = divisions * 2;\r\n\r\n\t\t\tfor ( j = 1; j <= tdivisions; j ++ ) {\r\n\r\n\t\t\t\tt = j / tdivisions;\r\n\r\n\t\t\t\tif ( ! aClockwise ) {\r\n\r\n\t\t\t\t\tt = 1 - t;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tangle = aStartAngle + t * deltaAngle;\r\n\r\n\t\t\t\ttx = aX + xRadius * Math.cos( angle );\r\n\t\t\t\tty = aY + yRadius * Math.sin( angle );\r\n\r\n\t\t\t\t//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);\r\n\r\n\t\t\t\tpoints.push( new THREE.Vector2( tx, ty ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t//console.log(points);\r\n\r\n\t\t\tbreak;\r\n\r\n\t\t} // end switch\r\n\r\n\t}\r\n\r\n\r\n\r\n\t// Normalize to remove the closing point by default.\r\n\tvar lastPoint = points[ points.length - 1];\r\n\tvar EPSILON = 0.0000000001;\r\n\tif ( Math.abs(lastPoint.x - points[ 0 ].x) < EPSILON &&\r\n\t\t\t Math.abs(lastPoint.y - points[ 0 ].y) < EPSILON)\r\n\t\tpoints.splice( points.length - 1, 1);\r\n\tif ( closedPath ) {\r\n\r\n\t\tpoints.push( points[ 0 ] );\r\n\r\n\t}\r\n\r\n\treturn points;\r\n\r\n};\r\n\r\n//\r\n// Breaks path into shapes\r\n//\r\n//\tAssumptions (if parameter isCCW==true the opposite holds):\r\n//\t- solid shapes are defined clockwise (CW)\r\n//\t- holes are defined counterclockwise (CCW)\r\n//\r\n//\tIf parameter noHoles==true:\r\n//  - all subPaths are regarded as solid shapes\r\n//  - definition order CW/CCW has no relevance\r\n//\r\n\r\nTHREE.Path.prototype.toShapes = function( isCCW, noHoles ) {\r\n\r\n\tfunction extractSubpaths( inActions ) {\r\n\r\n\t\tvar i, il, item, action, args;\r\n\r\n\t\tvar subPaths = [], lastPath = new THREE.Path();\r\n\r\n\t\tfor ( i = 0, il = inActions.length; i < il; i ++ ) {\r\n\r\n\t\t\titem = inActions[ i ];\r\n\r\n\t\t\targs = item.args;\r\n\t\t\taction = item.action;\r\n\r\n\t\t\tif ( action == THREE.PathActions.MOVE_TO ) {\r\n\r\n\t\t\t\tif ( lastPath.actions.length != 0 ) {\r\n\r\n\t\t\t\t\tsubPaths.push( lastPath );\r\n\t\t\t\t\tlastPath = new THREE.Path();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tlastPath[ action ].apply( lastPath, args );\r\n\r\n\t\t}\r\n\r\n\t\tif ( lastPath.actions.length != 0 ) {\r\n\r\n\t\t\tsubPaths.push( lastPath );\r\n\r\n\t\t}\r\n\r\n\t\t// console.log(subPaths);\r\n\r\n\t\treturn\tsubPaths;\r\n\t}\r\n\r\n\tfunction toShapesNoHoles( inSubpaths ) {\r\n\r\n\t\tvar shapes = [];\r\n\r\n\t\tfor ( var i = 0, il = inSubpaths.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar tmpPath = inSubpaths[ i ];\r\n\r\n\t\t\tvar tmpShape = new THREE.Shape();\r\n\t\t\ttmpShape.actions = tmpPath.actions;\r\n\t\t\ttmpShape.curves = tmpPath.curves;\r\n\r\n\t\t\tshapes.push( tmpShape );\r\n\t\t}\r\n\r\n\t\t//console.log(\"shape\", shapes);\r\n\r\n\t\treturn shapes;\r\n\t};\r\n\r\n\tfunction isPointInsidePolygon( inPt, inPolygon ) {\r\n\t\tvar EPSILON = 0.0000000001;\r\n\r\n\t\tvar polyLen = inPolygon.length;\r\n\r\n\t\t// inPt on polygon contour => immediate success    or\r\n\t\t// toggling of inside/outside at every single! intersection point of an edge\r\n\t\t//  with the horizontal line through inPt, left of inPt\r\n\t\t//  not counting lowerY endpoints of edges and whole edges on that line\r\n\t\tvar inside = false;\r\n\t\tfor ( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {\r\n\t\t\tvar edgeLowPt  = inPolygon[ p ];\r\n\t\t\tvar edgeHighPt = inPolygon[ q ];\r\n\r\n\t\t\tvar edgeDx = edgeHighPt.x - edgeLowPt.x;\r\n\t\t\tvar edgeDy = edgeHighPt.y - edgeLowPt.y;\r\n\r\n\t\t\tif ( Math.abs(edgeDy) > EPSILON ) {\t\t\t// not parallel\r\n\t\t\t\tif ( edgeDy < 0 ) {\r\n\t\t\t\t\tedgeLowPt  = inPolygon[ q ]; edgeDx = - edgeDx;\r\n\t\t\t\t\tedgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;\r\n\t\t\t\t}\r\n\t\t\t\tif ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) \t\tcontinue;\r\n\r\n\t\t\t\tif ( inPt.y == edgeLowPt.y ) {\r\n\t\t\t\t\tif ( inPt.x == edgeLowPt.x )\t\treturn\ttrue;\t\t// inPt is on contour ?\r\n\t\t\t\t\t// continue;\t\t\t\t// no intersection or edgeLowPt => doesn't count !!!\r\n\t\t\t\t} else {\r\n\t\t\t\t\tvar perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);\r\n\t\t\t\t\tif ( perpEdge == 0 )\t\t\t\treturn\ttrue;\t\t// inPt is on contour ?\r\n\t\t\t\t\tif ( perpEdge < 0 ) \t\t\t\tcontinue;\r\n\t\t\t\t\tinside = ! inside;\t\t// true intersection left of inPt\r\n\t\t\t\t}\r\n\t\t\t} else {\t\t// parallel or colinear\r\n\t\t\t\tif ( inPt.y != edgeLowPt.y ) \t\tcontinue;\t\t\t// parallel\r\n\t\t\t\t// egde lies on the same horizontal line as inPt\r\n\t\t\t\tif ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||\r\n\t\t\t\t\t ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )\t\treturn\ttrue;\t// inPt: Point on contour !\r\n\t\t\t\t// continue;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn\tinside;\r\n\t}\r\n\r\n\r\n\tvar subPaths = extractSubpaths( this.actions );\r\n\tif ( subPaths.length == 0 ) return [];\r\n\r\n\tif ( noHoles === true )\treturn\ttoShapesNoHoles( subPaths );\r\n\r\n\r\n\tvar solid, tmpPath, tmpShape, shapes = [];\r\n\r\n\tif ( subPaths.length == 1) {\r\n\r\n\t\ttmpPath = subPaths[0];\r\n\t\ttmpShape = new THREE.Shape();\r\n\t\ttmpShape.actions = tmpPath.actions;\r\n\t\ttmpShape.curves = tmpPath.curves;\r\n\t\tshapes.push( tmpShape );\r\n\t\treturn shapes;\r\n\r\n\t}\r\n\r\n\tvar holesFirst = ! THREE.Shape.Utils.isClockWise( subPaths[ 0 ].getPoints() );\r\n\tholesFirst = isCCW ? ! holesFirst : holesFirst;\r\n\r\n\t// console.log(\"Holes first\", holesFirst);\r\n\t\r\n\tvar betterShapeHoles = [];\r\n\tvar newShapes = [];\r\n\tvar newShapeHoles = [];\r\n\tvar mainIdx = 0;\r\n\tvar tmpPoints;\r\n\r\n\tnewShapes[mainIdx] = undefined;\r\n\tnewShapeHoles[mainIdx] = [];\r\n\r\n\tvar i, il;\r\n\r\n\tfor ( i = 0, il = subPaths.length; i < il; i ++ ) {\r\n\r\n\t\ttmpPath = subPaths[ i ];\r\n\t\ttmpPoints = tmpPath.getPoints();\r\n\t\tsolid = THREE.Shape.Utils.isClockWise( tmpPoints );\r\n\t\tsolid = isCCW ? ! solid : solid;\r\n\r\n\t\tif ( solid ) {\r\n\r\n\t\t\tif ( (! holesFirst ) && ( newShapes[mainIdx] ) )\tmainIdx ++;\r\n\r\n\t\t\tnewShapes[mainIdx] = { s: new THREE.Shape(), p: tmpPoints };\r\n\t\t\tnewShapes[mainIdx].s.actions = tmpPath.actions;\r\n\t\t\tnewShapes[mainIdx].s.curves = tmpPath.curves;\r\n\t\t\t\r\n\t\t\tif ( holesFirst )\tmainIdx ++;\r\n\t\t\tnewShapeHoles[mainIdx] = [];\r\n\r\n\t\t\t//console.log('cw', i);\r\n\r\n\t\t} else {\r\n\r\n\t\t\tnewShapeHoles[mainIdx].push( { h: tmpPath, p: tmpPoints[0] } );\r\n\r\n\t\t\t//console.log('ccw', i);\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// only Holes? -> probably all Shapes with wrong orientation\r\n\tif ( ! newShapes[0] )\treturn\ttoShapesNoHoles( subPaths );\r\n\r\n\r\n\tif ( newShapes.length > 1 ) {\r\n\t\tvar ambigious = false;\r\n\t\tvar toChange = [];\r\n\r\n\t\tfor (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\r\n\t\t\tbetterShapeHoles[sIdx] = [];\r\n\t\t}\r\n\t\tfor (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\r\n\t\t\tvar sho = newShapeHoles[sIdx];\r\n\t\t\tfor (var hIdx = 0; hIdx < sho.length; hIdx ++ ) {\r\n\t\t\t\tvar ho = sho[hIdx];\r\n\t\t\t\tvar hole_unassigned = true;\r\n\t\t\t\tfor (var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {\r\n\t\t\t\t\tif ( isPointInsidePolygon( ho.p, newShapes[s2Idx].p ) ) {\r\n\t\t\t\t\t\tif ( sIdx != s2Idx )\t\ttoChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );\r\n\t\t\t\t\t\tif ( hole_unassigned ) {\r\n\t\t\t\t\t\t\thole_unassigned = false;\r\n\t\t\t\t\t\t\tbetterShapeHoles[s2Idx].push( ho );\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tambigious = true;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif ( hole_unassigned ) { betterShapeHoles[sIdx].push( ho ); }\r\n\t\t\t}\r\n\t\t}\r\n\t\t// console.log(\"ambigious: \", ambigious);\r\n\t\tif ( toChange.length > 0 ) {\r\n\t\t\t// console.log(\"to change: \", toChange);\r\n\t\t\tif (! ambigious)\tnewShapeHoles = betterShapeHoles;\r\n\t\t}\r\n\t}\r\n\r\n\tvar tmpHoles, j, jl;\r\n\tfor ( i = 0, il = newShapes.length; i < il; i ++ ) {\r\n\t\ttmpShape = newShapes[i].s;\r\n\t\tshapes.push( tmpShape );\r\n\t\ttmpHoles = newShapeHoles[i];\r\n\t\tfor ( j = 0, jl = tmpHoles.length; j < jl; j ++ ) {\r\n\t\t\ttmpShape.holes.push( tmpHoles[j].h );\r\n\t\t}\r\n\t}\r\n\r\n\t//console.log(\"shape\", shapes);\r\n\r\n\treturn shapes;\r\n\r\n};\r\n\r\n// File:src/extras/core/Shape.js\r\n\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n * Defines a 2d shape plane using paths.\r\n **/\r\n\r\n// STEP 1 Create a path.\r\n// STEP 2 Turn path into shape.\r\n// STEP 3 ExtrudeGeometry takes in Shape/Shapes\r\n// STEP 3a - Extract points from each shape, turn to vertices\r\n// STEP 3b - Triangulate each shape, add faces.\r\n\r\nTHREE.Shape = function () {\r\n\r\n\tTHREE.Path.apply( this, arguments );\r\n\tthis.holes = [];\r\n\r\n};\r\n\r\nTHREE.Shape.prototype = Object.create( THREE.Path.prototype );\r\nTHREE.Shape.prototype.constructor = THREE.Shape;\r\n\r\n// Convenience method to return ExtrudeGeometry\r\n\r\nTHREE.Shape.prototype.extrude = function ( options ) {\r\n\r\n\tvar extruded = new THREE.ExtrudeGeometry( this, options );\r\n\treturn extruded;\r\n\r\n};\r\n\r\n// Convenience method to return ShapeGeometry\r\n\r\nTHREE.Shape.prototype.makeGeometry = function ( options ) {\r\n\r\n\tvar geometry = new THREE.ShapeGeometry( this, options );\r\n\treturn geometry;\r\n\r\n};\r\n\r\n// Get points of holes\r\n\r\nTHREE.Shape.prototype.getPointsHoles = function ( divisions ) {\r\n\r\n\tvar i, il = this.holes.length, holesPts = [];\r\n\r\n\tfor ( i = 0; i < il; i ++ ) {\r\n\r\n\t\tholesPts[ i ] = this.holes[ i ].getTransformedPoints( divisions, this.bends );\r\n\r\n\t}\r\n\r\n\treturn holesPts;\r\n\r\n};\r\n\r\n// Get points of holes (spaced by regular distance)\r\n\r\nTHREE.Shape.prototype.getSpacedPointsHoles = function ( divisions ) {\r\n\r\n\tvar i, il = this.holes.length, holesPts = [];\r\n\r\n\tfor ( i = 0; i < il; i ++ ) {\r\n\r\n\t\tholesPts[ i ] = this.holes[ i ].getTransformedSpacedPoints( divisions, this.bends );\r\n\r\n\t}\r\n\r\n\treturn holesPts;\r\n\r\n};\r\n\r\n\r\n// Get points of shape and holes (keypoints based on segments parameter)\r\n\r\nTHREE.Shape.prototype.extractAllPoints = function ( divisions ) {\r\n\r\n\treturn {\r\n\r\n\t\tshape: this.getTransformedPoints( divisions ),\r\n\t\tholes: this.getPointsHoles( divisions )\r\n\r\n\t};\r\n\r\n};\r\n\r\nTHREE.Shape.prototype.extractPoints = function ( divisions ) {\r\n\r\n\tif (this.useSpacedPoints) {\r\n\t\treturn this.extractAllSpacedPoints(divisions);\r\n\t}\r\n\r\n\treturn this.extractAllPoints(divisions);\r\n\r\n};\r\n\r\n//\r\n// THREE.Shape.prototype.extractAllPointsWithBend = function ( divisions, bend ) {\r\n//\r\n// \treturn {\r\n//\r\n// \t\tshape: this.transform( bend, divisions ),\r\n// \t\tholes: this.getPointsHoles( divisions, bend )\r\n//\r\n// \t};\r\n//\r\n// };\r\n\r\n// Get points of shape and holes (spaced by regular distance)\r\n\r\nTHREE.Shape.prototype.extractAllSpacedPoints = function ( divisions ) {\r\n\r\n\treturn {\r\n\r\n\t\tshape: this.getTransformedSpacedPoints( divisions ),\r\n\t\tholes: this.getSpacedPointsHoles( divisions )\r\n\r\n\t};\r\n\r\n};\r\n\r\n/**************************************************************\r\n *\tUtils\r\n **************************************************************/\r\n\r\nTHREE.Shape.Utils = {\r\n\r\n\ttriangulateShape: function ( contour, holes ) {\r\n\r\n\t\tfunction point_in_segment_2D_colin( inSegPt1, inSegPt2, inOtherPt ) {\r\n\t\t\t// inOtherPt needs to be colinear to the inSegment\r\n\t\t\tif ( inSegPt1.x != inSegPt2.x ) {\r\n\t\t\t\tif ( inSegPt1.x < inSegPt2.x ) {\r\n\t\t\t\t\treturn\t( ( inSegPt1.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt2.x ) );\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn\t( ( inSegPt2.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt1.x ) );\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tif ( inSegPt1.y < inSegPt2.y ) {\r\n\t\t\t\t\treturn\t( ( inSegPt1.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt2.y ) );\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn\t( ( inSegPt2.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt1.y ) );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction intersect_segments_2D( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs ) {\r\n\t\t\tvar EPSILON = 0.0000000001;\r\n\r\n\t\t\tvar seg1dx = inSeg1Pt2.x - inSeg1Pt1.x,   seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;\r\n\t\t\tvar seg2dx = inSeg2Pt2.x - inSeg2Pt1.x,   seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;\r\n\r\n\t\t\tvar seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;\r\n\t\t\tvar seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;\r\n\r\n\t\t\tvar limit\t\t= seg1dy * seg2dx - seg1dx * seg2dy;\r\n\t\t\tvar perpSeg1\t= seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;\r\n\r\n\t\t\tif ( Math.abs(limit) > EPSILON ) {\t\t\t// not parallel\r\n\r\n\t\t\t\tvar perpSeg2;\r\n\t\t\t\tif ( limit > 0 ) {\r\n\t\t\t\t\tif ( ( perpSeg1 < 0 ) || ( perpSeg1 > limit ) ) \t\treturn [];\r\n\t\t\t\t\tperpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;\r\n\t\t\t\t\tif ( ( perpSeg2 < 0 ) || ( perpSeg2 > limit ) ) \t\treturn [];\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif ( ( perpSeg1 > 0 ) || ( perpSeg1 < limit ) ) \t\treturn [];\r\n\t\t\t\t\tperpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;\r\n\t\t\t\t\tif ( ( perpSeg2 > 0 ) || ( perpSeg2 < limit ) ) \t\treturn [];\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// i.e. to reduce rounding errors\r\n\t\t\t\t// intersection at endpoint of segment#1?\r\n\t\t\t\tif ( perpSeg2 == 0 ) {\r\n\t\t\t\t\tif ( ( inExcludeAdjacentSegs ) &&\r\n\t\t\t\t\t\t ( ( perpSeg1 == 0 ) || ( perpSeg1 == limit ) ) )\t\treturn [];\r\n\t\t\t\t\treturn [ inSeg1Pt1 ];\r\n\t\t\t\t}\r\n\t\t\t\tif ( perpSeg2 == limit ) {\r\n\t\t\t\t\tif ( ( inExcludeAdjacentSegs ) &&\r\n\t\t\t\t\t\t ( ( perpSeg1 == 0 ) || ( perpSeg1 == limit ) ) )\t\treturn [];\r\n\t\t\t\t\treturn [ inSeg1Pt2 ];\r\n\t\t\t\t}\r\n\t\t\t\t// intersection at endpoint of segment#2?\r\n\t\t\t\tif ( perpSeg1 == 0 )\t\treturn [ inSeg2Pt1 ];\r\n\t\t\t\tif ( perpSeg1 == limit )\treturn [ inSeg2Pt2 ];\r\n\r\n\t\t\t\t// return real intersection point\r\n\t\t\t\tvar factorSeg1 = perpSeg2 / limit;\r\n\t\t\t\treturn\t[ { x: inSeg1Pt1.x + factorSeg1 * seg1dx,\r\n\t\t\t\t\t\t\ty: inSeg1Pt1.y + factorSeg1 * seg1dy } ];\r\n\r\n\t\t\t} else {\t\t// parallel or colinear\r\n\t\t\t\tif ( ( perpSeg1 != 0 ) ||\r\n\t\t\t\t\t ( seg2dy * seg1seg2dx != seg2dx * seg1seg2dy ) ) \t\t\treturn [];\r\n\r\n\t\t\t\t// they are collinear or degenerate\r\n\t\t\t\tvar seg1Pt = ( (seg1dx == 0) && (seg1dy == 0) );\t// segment1 ist just a point?\r\n\t\t\t\tvar seg2Pt = ( (seg2dx == 0) && (seg2dy == 0) );\t// segment2 ist just a point?\r\n\t\t\t\t// both segments are points\r\n\t\t\t\tif ( seg1Pt && seg2Pt ) {\r\n\t\t\t\t\tif ( (inSeg1Pt1.x != inSeg2Pt1.x) ||\r\n\t\t\t\t\t\t (inSeg1Pt1.y != inSeg2Pt1.y) )\t\treturn [];   \t// they are distinct  points\r\n\t\t\t\t\treturn [ inSeg1Pt1 ];                 \t\t\t\t\t// they are the same point\r\n\t\t\t\t}\r\n\t\t\t\t// segment#1  is a single point\r\n\t\t\t\tif ( seg1Pt ) {\r\n\t\t\t\t\tif (! point_in_segment_2D_colin( inSeg2Pt1, inSeg2Pt2, inSeg1Pt1 ) )\t\treturn [];\t\t// but not in segment#2\r\n\t\t\t\t\treturn [ inSeg1Pt1 ];\r\n\t\t\t\t}\r\n\t\t\t\t// segment#2  is a single point\r\n\t\t\t\tif ( seg2Pt ) {\r\n\t\t\t\t\tif (! point_in_segment_2D_colin( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1 ) )\t\treturn [];\t\t// but not in segment#1\r\n\t\t\t\t\treturn [ inSeg2Pt1 ];\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// they are collinear segments, which might overlap\r\n\t\t\t\tvar seg1min, seg1max, seg1minVal, seg1maxVal;\r\n\t\t\t\tvar seg2min, seg2max, seg2minVal, seg2maxVal;\r\n\t\t\t\tif (seg1dx != 0) {\t\t// the segments are NOT on a vertical line\r\n\t\t\t\t\tif ( inSeg1Pt1.x < inSeg1Pt2.x ) {\r\n\t\t\t\t\t\tseg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.x;\r\n\t\t\t\t\t\tseg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.x;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tseg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.x;\r\n\t\t\t\t\t\tseg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.x;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ( inSeg2Pt1.x < inSeg2Pt2.x ) {\r\n\t\t\t\t\t\tseg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.x;\r\n\t\t\t\t\t\tseg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.x;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tseg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.x;\r\n\t\t\t\t\t\tseg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.x;\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\t\t\t\t// the segments are on a vertical line\r\n\t\t\t\t\tif ( inSeg1Pt1.y < inSeg1Pt2.y ) {\r\n\t\t\t\t\t\tseg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.y;\r\n\t\t\t\t\t\tseg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.y;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tseg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.y;\r\n\t\t\t\t\t\tseg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.y;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ( inSeg2Pt1.y < inSeg2Pt2.y ) {\r\n\t\t\t\t\t\tseg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.y;\r\n\t\t\t\t\t\tseg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.y;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tseg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.y;\r\n\t\t\t\t\t\tseg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.y;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif ( seg1minVal <= seg2minVal ) {\r\n\t\t\t\t\tif ( seg1maxVal <  seg2minVal )\treturn [];\r\n\t\t\t\t\tif ( seg1maxVal == seg2minVal )\t{\r\n\t\t\t\t\t\tif ( inExcludeAdjacentSegs )\t\treturn [];\r\n\t\t\t\t\t\treturn [ seg2min ];\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ( seg1maxVal <= seg2maxVal )\treturn [ seg2min, seg1max ];\r\n\t\t\t\t\treturn\t[ seg2min, seg2max ];\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif ( seg1minVal >  seg2maxVal )\treturn [];\r\n\t\t\t\t\tif ( seg1minVal == seg2maxVal )\t{\r\n\t\t\t\t\t\tif ( inExcludeAdjacentSegs )\t\treturn [];\r\n\t\t\t\t\t\treturn [ seg1min ];\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ( seg1maxVal <= seg2maxVal )\treturn [ seg1min, seg1max ];\r\n\t\t\t\t\treturn\t[ seg1min, seg2max ];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction isPointInsideAngle( inVertex, inLegFromPt, inLegToPt, inOtherPt ) {\r\n\t\t\t// The order of legs is important\r\n\r\n\t\t\tvar EPSILON = 0.0000000001;\r\n\r\n\t\t\t// translation of all points, so that Vertex is at (0,0)\r\n\t\t\tvar legFromPtX\t= inLegFromPt.x - inVertex.x,  legFromPtY\t= inLegFromPt.y - inVertex.y;\r\n\t\t\tvar legToPtX\t= inLegToPt.x\t- inVertex.x,  legToPtY\t\t= inLegToPt.y\t- inVertex.y;\r\n\t\t\tvar otherPtX\t= inOtherPt.x\t- inVertex.x,  otherPtY\t\t= inOtherPt.y\t- inVertex.y;\r\n\r\n\t\t\t// main angle >0: < 180 deg.; 0: 180 deg.; <0: > 180 deg.\r\n\t\t\tvar from2toAngle\t= legFromPtX * legToPtY - legFromPtY * legToPtX;\r\n\t\t\tvar from2otherAngle\t= legFromPtX * otherPtY - legFromPtY * otherPtX;\r\n\r\n\t\t\tif ( Math.abs(from2toAngle) > EPSILON ) {\t\t\t// angle != 180 deg.\r\n\r\n\t\t\t\tvar other2toAngle\t\t= otherPtX * legToPtY - otherPtY * legToPtX;\r\n\t\t\t\t// console.log( \"from2to: \" + from2toAngle + \", from2other: \" + from2otherAngle + \", other2to: \" + other2toAngle );\r\n\r\n\t\t\t\tif ( from2toAngle > 0 ) {\t\t\t\t// main angle < 180 deg.\r\n\t\t\t\t\treturn\t( ( from2otherAngle >= 0 ) && ( other2toAngle >= 0 ) );\r\n\t\t\t\t} else {\t\t\t\t\t\t\t\t// main angle > 180 deg.\r\n\t\t\t\t\treturn\t( ( from2otherAngle >= 0 ) || ( other2toAngle >= 0 ) );\r\n\t\t\t\t}\r\n\t\t\t} else {\t\t\t\t\t\t\t\t\t\t// angle == 180 deg.\r\n\t\t\t\t// console.log( \"from2to: 180 deg., from2other: \" + from2otherAngle  );\r\n\t\t\t\treturn\t( from2otherAngle > 0 );\r\n\t\t\t}\r\n\t\t}\r\n\r\n\r\n\t\tfunction removeHoles( contour, holes ) {\r\n\r\n\t\t\tvar shape = contour.concat(); // work on this shape\r\n\t\t\tvar hole;\r\n\r\n\t\t\tfunction isCutLineInsideAngles( inShapeIdx, inHoleIdx ) {\r\n\t\t\t\t// Check if hole point lies within angle around shape point\r\n\t\t\t\tvar lastShapeIdx = shape.length - 1;\r\n\r\n\t\t\t\tvar prevShapeIdx = inShapeIdx - 1;\r\n\t\t\t\tif ( prevShapeIdx < 0 )\t\t\tprevShapeIdx = lastShapeIdx;\r\n\r\n\t\t\t\tvar nextShapeIdx = inShapeIdx + 1;\r\n\t\t\t\tif ( nextShapeIdx > lastShapeIdx )\tnextShapeIdx = 0;\r\n\r\n\t\t\t\tvar insideAngle = isPointInsideAngle( shape[inShapeIdx], shape[ prevShapeIdx ], shape[ nextShapeIdx ], hole[inHoleIdx] );\r\n\t\t\t\tif (! insideAngle ) {\r\n\t\t\t\t\t// console.log( \"Vertex (Shape): \" + inShapeIdx + \", Point: \" + hole[inHoleIdx].x + \"/\" + hole[inHoleIdx].y );\r\n\t\t\t\t\treturn\tfalse;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Check if shape point lies within angle around hole point\r\n\t\t\t\tvar lastHoleIdx = hole.length - 1;\r\n\r\n\t\t\t\tvar prevHoleIdx = inHoleIdx - 1;\r\n\t\t\t\tif ( prevHoleIdx < 0 )\t\t\tprevHoleIdx = lastHoleIdx;\r\n\r\n\t\t\t\tvar nextHoleIdx = inHoleIdx + 1;\r\n\t\t\t\tif ( nextHoleIdx > lastHoleIdx )\tnextHoleIdx = 0;\r\n\r\n\t\t\t\tinsideAngle = isPointInsideAngle( hole[inHoleIdx], hole[ prevHoleIdx ], hole[ nextHoleIdx ], shape[inShapeIdx] );\r\n\t\t\t\tif (! insideAngle ) {\r\n\t\t\t\t\t// console.log( \"Vertex (Hole): \" + inHoleIdx + \", Point: \" + shape[inShapeIdx].x + \"/\" + shape[inShapeIdx].y );\r\n\t\t\t\t\treturn\tfalse;\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn\ttrue;\r\n\t\t\t}\r\n\r\n\t\t\tfunction intersectsShapeEdge( inShapePt, inHolePt ) {\r\n\t\t\t\t// checks for intersections with shape edges\r\n\t\t\t\tvar sIdx, nextIdx, intersection;\r\n\t\t\t\tfor ( sIdx = 0; sIdx < shape.length; sIdx ++ ) {\r\n\t\t\t\t\tnextIdx = sIdx + 1; nextIdx %= shape.length;\r\n\t\t\t\t\tintersection = intersect_segments_2D( inShapePt, inHolePt, shape[sIdx], shape[nextIdx], true );\r\n\t\t\t\t\tif ( intersection.length > 0 )\t\treturn\ttrue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn\tfalse;\r\n\t\t\t}\r\n\r\n\t\t\tvar indepHoles = [];\r\n\r\n\t\t\tfunction intersectsHoleEdge( inShapePt, inHolePt ) {\r\n\t\t\t\t// checks for intersections with hole edges\r\n\t\t\t\tvar ihIdx, chkHole,\r\n\t\t\t\t\thIdx, nextIdx, intersection;\r\n\t\t\t\tfor ( ihIdx = 0; ihIdx < indepHoles.length; ihIdx ++ ) {\r\n\t\t\t\t\tchkHole = holes[indepHoles[ihIdx]];\r\n\t\t\t\t\tfor ( hIdx = 0; hIdx < chkHole.length; hIdx ++ ) {\r\n\t\t\t\t\t\tnextIdx = hIdx + 1; nextIdx %= chkHole.length;\r\n\t\t\t\t\t\tintersection = intersect_segments_2D( inShapePt, inHolePt, chkHole[hIdx], chkHole[nextIdx], true );\r\n\t\t\t\t\t\tif ( intersection.length > 0 )\t\treturn\ttrue;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn\tfalse;\r\n\t\t\t}\r\n\r\n\t\t\tvar holeIndex, shapeIndex,\r\n\t\t\t\tshapePt, holePt,\r\n\t\t\t\tholeIdx, cutKey, failedCuts = [],\r\n\t\t\t\ttmpShape1, tmpShape2,\r\n\t\t\t\ttmpHole1, tmpHole2;\r\n\r\n\t\t\tfor ( var h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n\t\t\t\tindepHoles.push( h );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar minShapeIndex = 0;\r\n\t\t\tvar counter = indepHoles.length * 2;\r\n\t\t\twhile ( indepHoles.length > 0 ) {\r\n\t\t\t\tcounter --;\r\n\t\t\t\tif ( counter < 0 ) {\r\n\t\t\t\t\tconsole.log( \"Infinite Loop! Holes left:\" + indepHoles.length + \", Probably Hole outside Shape!\" );\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// search for shape-vertex and hole-vertex,\r\n\t\t\t\t// which can be connected without intersections\r\n\t\t\t\tfor ( shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex ++ ) {\r\n\r\n\t\t\t\t\tshapePt = shape[ shapeIndex ];\r\n\t\t\t\t\tholeIndex\t= - 1;\r\n\r\n\t\t\t\t\t// search for hole which can be reached without intersections\r\n\t\t\t\t\tfor ( var h = 0; h < indepHoles.length; h ++ ) {\r\n\t\t\t\t\t\tholeIdx = indepHoles[h];\r\n\r\n\t\t\t\t\t\t// prevent multiple checks\r\n\t\t\t\t\t\tcutKey = shapePt.x + \":\" + shapePt.y + \":\" + holeIdx;\r\n\t\t\t\t\t\tif ( failedCuts[cutKey] !== undefined )\t\t\tcontinue;\r\n\r\n\t\t\t\t\t\thole = holes[holeIdx];\r\n\t\t\t\t\t\tfor ( var h2 = 0; h2 < hole.length; h2 ++ ) {\r\n\t\t\t\t\t\t\tholePt = hole[ h2 ];\r\n\t\t\t\t\t\t\tif (! isCutLineInsideAngles( shapeIndex, h2 ) )\t\tcontinue;\r\n\t\t\t\t\t\t\tif ( intersectsShapeEdge( shapePt, holePt ) )\t\tcontinue;\r\n\t\t\t\t\t\t\tif ( intersectsHoleEdge( shapePt, holePt ) )\t\tcontinue;\r\n\r\n\t\t\t\t\t\t\tholeIndex = h2;\r\n\t\t\t\t\t\t\tindepHoles.splice(h, 1);\r\n\r\n\t\t\t\t\t\t\ttmpShape1 = shape.slice( 0, shapeIndex + 1 );\r\n\t\t\t\t\t\t\ttmpShape2 = shape.slice( shapeIndex );\r\n\t\t\t\t\t\t\ttmpHole1 = hole.slice( holeIndex );\r\n\t\t\t\t\t\t\ttmpHole2 = hole.slice( 0, holeIndex + 1 );\r\n\r\n\t\t\t\t\t\t\tshape = tmpShape1.concat( tmpHole1 ).concat( tmpHole2 ).concat( tmpShape2 );\r\n\r\n\t\t\t\t\t\t\tminShapeIndex = shapeIndex;\r\n\r\n\t\t\t\t\t\t\t// Debug only, to show the selected cuts\r\n\t\t\t\t\t\t\t// glob_CutLines.push( [ shapePt, holePt ] );\r\n\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif ( holeIndex >= 0 )\tbreak;\t\t// hole-vertex found\r\n\r\n\t\t\t\t\t\tfailedCuts[cutKey] = true;\t\t\t// remember failure\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ( holeIndex >= 0 )\tbreak;\t\t// hole-vertex found\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn shape; \t\t\t/* shape with no holes */\r\n\t\t}\r\n\r\n\r\n\t\tvar i, il, f, face,\r\n\t\t\tkey, index,\r\n\t\t\tallPointsMap = {};\r\n\r\n\t\t// To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.\r\n\r\n\t\tvar allpoints = contour.concat();\r\n\r\n\t\tfor ( var h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n\t\t\tArray.prototype.push.apply( allpoints, holes[h] );\r\n\r\n\t\t}\r\n\r\n\t\t//console.log( \"allpoints\",allpoints, allpoints.length );\r\n\r\n\t\t// prepare all points map\r\n\r\n\t\tfor ( i = 0, il = allpoints.length; i < il; i ++ ) {\r\n\r\n\t\t\tkey = allpoints[ i ].x + \":\" + allpoints[ i ].y;\r\n\r\n\t\t\tif ( allPointsMap[ key ] !== undefined ) {\r\n\r\n\t\t\t\tTHREE.warn( \"THREE.Shape: Duplicate point\", key );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tallPointsMap[ key ] = i;\r\n\r\n\t\t}\r\n\r\n\t\t// remove holes by cutting paths to holes and adding them to the shape\r\n\t\tvar shapeWithoutHoles = removeHoles( contour, holes );\r\n\r\n\t\tvar triangles = THREE.FontUtils.Triangulate( shapeWithoutHoles, false ); // True returns indices for points of spooled shape\r\n\t\t//console.log( \"triangles\",triangles, triangles.length );\r\n\r\n\t\t// check all face vertices against all points map\r\n\r\n\t\tfor ( i = 0, il = triangles.length; i < il; i ++ ) {\r\n\r\n\t\t\tface = triangles[ i ];\r\n\r\n\t\t\tfor ( f = 0; f < 3; f ++ ) {\r\n\r\n\t\t\t\tkey = face[ f ].x + \":\" + face[ f ].y;\r\n\r\n\t\t\t\tindex = allPointsMap[ key ];\r\n\r\n\t\t\t\tif ( index !== undefined ) {\r\n\r\n\t\t\t\t\tface[ f ] = index;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn triangles.concat();\r\n\r\n\t},\r\n\r\n\tisClockWise: function ( pts ) {\r\n\r\n\t\treturn THREE.FontUtils.Triangulate.area( pts ) < 0;\r\n\r\n\t},\r\n\r\n\t// Bezier Curves formulas obtained from\r\n\t// http://en.wikipedia.org/wiki/B%C3%A9zier_curve\r\n\r\n\t// Quad Bezier Functions\r\n\r\n\tb2p0: function ( t, p ) {\r\n\r\n\t\tvar k = 1 - t;\r\n\t\treturn k * k * p;\r\n\r\n\t},\r\n\r\n\tb2p1: function ( t, p ) {\r\n\r\n\t\treturn 2 * ( 1 - t ) * t * p;\r\n\r\n\t},\r\n\r\n\tb2p2: function ( t, p ) {\r\n\r\n\t\treturn t * t * p;\r\n\r\n\t},\r\n\r\n\tb2: function ( t, p0, p1, p2 ) {\r\n\r\n\t\treturn this.b2p0( t, p0 ) + this.b2p1( t, p1 ) + this.b2p2( t, p2 );\r\n\r\n\t},\r\n\r\n\t// Cubic Bezier Functions\r\n\r\n\tb3p0: function ( t, p ) {\r\n\r\n\t\tvar k = 1 - t;\r\n\t\treturn k * k * k * p;\r\n\r\n\t},\r\n\r\n\tb3p1: function ( t, p ) {\r\n\r\n\t\tvar k = 1 - t;\r\n\t\treturn 3 * k * k * t * p;\r\n\r\n\t},\r\n\r\n\tb3p2: function ( t, p ) {\r\n\r\n\t\tvar k = 1 - t;\r\n\t\treturn 3 * k * t * t * p;\r\n\r\n\t},\r\n\r\n\tb3p3: function ( t, p ) {\r\n\r\n\t\treturn t * t * t * p;\r\n\r\n\t},\r\n\r\n\tb3: function ( t, p0, p1, p2, p3 ) {\r\n\r\n\t\treturn this.b3p0( t, p0 ) + this.b3p1( t, p1 ) + this.b3p2( t, p2 ) +  this.b3p3( t, p3 );\r\n\r\n\t}\r\n\r\n};\r\n\r\n\r\n// File:src/extras/curves/LineCurve.js\r\n\r\n/**************************************************************\r\n *\tLine\r\n **************************************************************/\r\n\r\nTHREE.LineCurve = function ( v1, v2 ) {\r\n\r\n\tthis.v1 = v1;\r\n\tthis.v2 = v2;\r\n\r\n};\r\n\r\nTHREE.LineCurve.prototype = Object.create( THREE.Curve.prototype );\r\nTHREE.LineCurve.prototype.constructor = THREE.LineCurve;\r\n\r\nTHREE.LineCurve.prototype.getPoint = function ( t ) {\r\n\r\n\tvar point = this.v2.clone().sub(this.v1);\r\n\tpoint.multiplyScalar( t ).add( this.v1 );\r\n\r\n\treturn point;\r\n\r\n};\r\n\r\n// Line curve is linear, so we can overwrite default getPointAt\r\n\r\nTHREE.LineCurve.prototype.getPointAt = function ( u ) {\r\n\r\n\treturn this.getPoint( u );\r\n\r\n};\r\n\r\nTHREE.LineCurve.prototype.getTangent = function( t ) {\r\n\r\n\tvar tangent = this.v2.clone().sub(this.v1);\r\n\r\n\treturn tangent.normalize();\r\n\r\n};\r\n\r\n// File:src/extras/curves/QuadraticBezierCurve.js\r\n\r\n/**************************************************************\r\n *\tQuadratic Bezier curve\r\n **************************************************************/\r\n\r\n\r\nTHREE.QuadraticBezierCurve = function ( v0, v1, v2 ) {\r\n\r\n\tthis.v0 = v0;\r\n\tthis.v1 = v1;\r\n\tthis.v2 = v2;\r\n\r\n};\r\n\r\nTHREE.QuadraticBezierCurve.prototype = Object.create( THREE.Curve.prototype );\r\nTHREE.QuadraticBezierCurve.prototype.constructor = THREE.QuadraticBezierCurve;\r\n\r\n\r\nTHREE.QuadraticBezierCurve.prototype.getPoint = function ( t ) {\r\n\r\n\tvar vector = new THREE.Vector2();\r\n\r\n\tvector.x = THREE.Shape.Utils.b2( t, this.v0.x, this.v1.x, this.v2.x );\r\n\tvector.y = THREE.Shape.Utils.b2( t, this.v0.y, this.v1.y, this.v2.y );\r\n\r\n\treturn vector;\r\n\r\n};\r\n\r\n\r\nTHREE.QuadraticBezierCurve.prototype.getTangent = function( t ) {\r\n\r\n\tvar vector = new THREE.Vector2();\r\n\r\n\tvector.x = THREE.Curve.Utils.tangentQuadraticBezier( t, this.v0.x, this.v1.x, this.v2.x );\r\n\tvector.y = THREE.Curve.Utils.tangentQuadraticBezier( t, this.v0.y, this.v1.y, this.v2.y );\r\n\r\n\t// returns unit vector\r\n\r\n\treturn vector.normalize();\r\n\r\n};\r\n\r\n// File:src/extras/curves/CubicBezierCurve.js\r\n\r\n/**************************************************************\r\n *\tCubic Bezier curve\r\n **************************************************************/\r\n\r\nTHREE.CubicBezierCurve = function ( v0, v1, v2, v3 ) {\r\n\r\n\tthis.v0 = v0;\r\n\tthis.v1 = v1;\r\n\tthis.v2 = v2;\r\n\tthis.v3 = v3;\r\n\r\n};\r\n\r\nTHREE.CubicBezierCurve.prototype = Object.create( THREE.Curve.prototype );\r\nTHREE.CubicBezierCurve.prototype.constructor = THREE.CubicBezierCurve;\r\n\r\nTHREE.CubicBezierCurve.prototype.getPoint = function ( t ) {\r\n\r\n\tvar tx, ty;\r\n\r\n\ttx = THREE.Shape.Utils.b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );\r\n\tty = THREE.Shape.Utils.b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );\r\n\r\n\treturn new THREE.Vector2( tx, ty );\r\n\r\n};\r\n\r\nTHREE.CubicBezierCurve.prototype.getTangent = function( t ) {\r\n\r\n\tvar tx, ty;\r\n\r\n\ttx = THREE.Curve.Utils.tangentCubicBezier( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );\r\n\tty = THREE.Curve.Utils.tangentCubicBezier( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );\r\n\r\n\tvar tangent = new THREE.Vector2( tx, ty );\r\n\ttangent.normalize();\r\n\r\n\treturn tangent;\r\n\r\n};\r\n\r\n// File:src/extras/curves/SplineCurve.js\r\n\r\n/**************************************************************\r\n *\tSpline curve\r\n **************************************************************/\r\n\r\nTHREE.SplineCurve = function ( points /* array of Vector2 */ ) {\r\n\r\n\tthis.points = ( points == undefined ) ? [] : points;\r\n\r\n};\r\n\r\nTHREE.SplineCurve.prototype = Object.create( THREE.Curve.prototype );\r\nTHREE.SplineCurve.prototype.constructor = THREE.SplineCurve;\r\n\r\nTHREE.SplineCurve.prototype.getPoint = function ( t ) {\r\n\r\n\tvar points = this.points;\r\n\tvar point = ( points.length - 1 ) * t;\r\n\r\n\tvar intPoint = Math.floor( point );\r\n\tvar weight = point - intPoint;\r\n\r\n\tvar point0 = points[ intPoint == 0 ? intPoint : intPoint - 1 ]\r\n\tvar point1 = points[ intPoint ]\r\n\tvar point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ]\r\n\tvar point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ]\r\n\r\n\tvar vector = new THREE.Vector2();\r\n\r\n\tvector.x = THREE.Curve.Utils.interpolate( point0.x, point1.x, point2.x, point3.x, weight );\r\n\tvector.y = THREE.Curve.Utils.interpolate( point0.y, point1.y, point2.y, point3.y, weight );\r\n\r\n\treturn vector;\r\n\r\n};\r\n\r\n// File:src/extras/curves/EllipseCurve.js\r\n\r\n/**************************************************************\r\n *\tEllipse curve\r\n **************************************************************/\r\n\r\nTHREE.EllipseCurve = function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise ) {\r\n\r\n\tthis.aX = aX;\r\n\tthis.aY = aY;\r\n\r\n\tthis.xRadius = xRadius;\r\n\tthis.yRadius = yRadius;\r\n\r\n\tthis.aStartAngle = aStartAngle;\r\n\tthis.aEndAngle = aEndAngle;\r\n\r\n\tthis.aClockwise = aClockwise;\r\n\r\n};\r\n\r\nTHREE.EllipseCurve.prototype = Object.create( THREE.Curve.prototype );\r\nTHREE.EllipseCurve.prototype.constructor = THREE.EllipseCurve;\r\n\r\nTHREE.EllipseCurve.prototype.getPoint = function ( t ) {\r\n\r\n\tvar deltaAngle = this.aEndAngle - this.aStartAngle;\r\n\r\n\tif ( deltaAngle < 0 ) deltaAngle += Math.PI * 2;\r\n\tif ( deltaAngle > Math.PI * 2 ) deltaAngle -= Math.PI * 2;\r\n\r\n\tvar angle;\r\n\r\n\tif ( this.aClockwise === true ) {\r\n\r\n\t\tangle = this.aEndAngle + ( 1 - t ) * ( Math.PI * 2 - deltaAngle );\r\n\r\n\t} else {\r\n\r\n\t\tangle = this.aStartAngle + t * deltaAngle;\r\n\r\n\t}\r\n\t\r\n\tvar vector = new THREE.Vector2();\r\n\r\n\tvector.x = this.aX + this.xRadius * Math.cos( angle );\r\n\tvector.y = this.aY + this.yRadius * Math.sin( angle );\r\n\r\n\treturn vector;\r\n\r\n};\r\n\r\n// File:src/extras/curves/ArcCurve.js\r\n\r\n/**************************************************************\r\n *\tArc curve\r\n **************************************************************/\r\n\r\nTHREE.ArcCurve = function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\r\n\r\n\tTHREE.EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\r\n};\r\n\r\nTHREE.ArcCurve.prototype = Object.create( THREE.EllipseCurve.prototype );\r\nTHREE.ArcCurve.prototype.constructor = THREE.ArcCurve;\r\n\r\n// File:src/extras/curves/LineCurve3.js\r\n\r\n/**************************************************************\r\n *\tLine3D\r\n **************************************************************/\r\n\r\nTHREE.LineCurve3 = THREE.Curve.create(\r\n\r\n\tfunction ( v1, v2 ) {\r\n\r\n\t\tthis.v1 = v1;\r\n\t\tthis.v2 = v2;\r\n\r\n\t},\r\n\r\n\tfunction ( t ) {\r\n\r\n\t\tvar vector = new THREE.Vector3();\r\n\r\n\t\tvector.subVectors( this.v2, this.v1 ); // diff\r\n\t\tvector.multiplyScalar( t );\r\n\t\tvector.add( this.v1 );\r\n\r\n\t\treturn vector;\r\n\r\n\t}\r\n\r\n);\r\n\r\n// File:src/extras/curves/QuadraticBezierCurve3.js\r\n\r\n/**************************************************************\r\n *\tQuadratic Bezier 3D curve\r\n **************************************************************/\r\n\r\nTHREE.QuadraticBezierCurve3 = THREE.Curve.create(\r\n\r\n\tfunction ( v0, v1, v2 ) {\r\n\r\n\t\tthis.v0 = v0;\r\n\t\tthis.v1 = v1;\r\n\t\tthis.v2 = v2;\r\n\r\n\t},\r\n\r\n\tfunction ( t ) {\r\n\r\n\t\tvar vector = new THREE.Vector3();\r\n\r\n\t\tvector.x = THREE.Shape.Utils.b2( t, this.v0.x, this.v1.x, this.v2.x );\r\n\t\tvector.y = THREE.Shape.Utils.b2( t, this.v0.y, this.v1.y, this.v2.y );\r\n\t\tvector.z = THREE.Shape.Utils.b2( t, this.v0.z, this.v1.z, this.v2.z );\r\n\r\n\t\treturn vector;\r\n\r\n\t}\r\n\r\n);\r\n\r\n// File:src/extras/curves/CubicBezierCurve3.js\r\n\r\n/**************************************************************\r\n *\tCubic Bezier 3D curve\r\n **************************************************************/\r\n\r\nTHREE.CubicBezierCurve3 = THREE.Curve.create(\r\n\r\n\tfunction ( v0, v1, v2, v3 ) {\r\n\r\n\t\tthis.v0 = v0;\r\n\t\tthis.v1 = v1;\r\n\t\tthis.v2 = v2;\r\n\t\tthis.v3 = v3;\r\n\r\n\t},\r\n\r\n\tfunction ( t ) {\r\n\r\n\t\tvar vector = new THREE.Vector3();\r\n\r\n\t\tvector.x = THREE.Shape.Utils.b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );\r\n\t\tvector.y = THREE.Shape.Utils.b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );\r\n\t\tvector.z = THREE.Shape.Utils.b3( t, this.v0.z, this.v1.z, this.v2.z, this.v3.z );\r\n\r\n\t\treturn vector;\r\n\r\n\t}\r\n\r\n);\r\n\r\n// File:src/extras/curves/SplineCurve3.js\r\n\r\n/**************************************************************\r\n *\tSpline 3D curve\r\n **************************************************************/\r\n\r\n\r\nTHREE.SplineCurve3 = THREE.Curve.create(\r\n\r\n\tfunction ( points /* array of Vector3 */) {\r\n\r\n\t\tthis.points = ( points == undefined ) ? [] : points;\r\n\r\n\t},\r\n\r\n\tfunction ( t ) {\r\n\r\n\t\tvar points = this.points;\r\n\t\tvar point = ( points.length - 1 ) * t;\r\n\r\n\t\tvar intPoint = Math.floor( point );\r\n\t\tvar weight = point - intPoint;\r\n\r\n\t\tvar point0 = points[ intPoint == 0 ? intPoint : intPoint - 1 ];\r\n\t\tvar point1 = points[ intPoint ];\r\n\t\tvar point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];\r\n\t\tvar point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];\r\n\r\n\t\tvar vector = new THREE.Vector3();\r\n\r\n\t\tvector.x = THREE.Curve.Utils.interpolate( point0.x, point1.x, point2.x, point3.x, weight );\r\n\t\tvector.y = THREE.Curve.Utils.interpolate( point0.y, point1.y, point2.y, point3.y, weight );\r\n\t\tvector.z = THREE.Curve.Utils.interpolate( point0.z, point1.z, point2.z, point3.z, weight );\r\n\r\n\t\treturn vector;\r\n\r\n\t}\r\n\r\n);\r\n\r\n// File:src/extras/curves/ClosedSplineCurve3.js\r\n\r\n/**************************************************************\r\n *\tClosed Spline 3D curve\r\n **************************************************************/\r\n\r\n\r\nTHREE.ClosedSplineCurve3 = THREE.Curve.create(\r\n\r\n\tfunction ( points /* array of Vector3 */) {\r\n\r\n\t\tthis.points = ( points == undefined ) ? [] : points;\r\n\r\n\t},\r\n\r\n\tfunction ( t ) {\r\n\r\n\t\tvar points = this.points;\r\n\t\tvar point = ( points.length - 0 ) * t; // This needs to be from 0-length +1\r\n\r\n\t\tvar intPoint = Math.floor( point );\r\n\t\tvar weight = point - intPoint;\r\n\r\n\t\tintPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;\r\n\r\n\t\tvar point0 = points[ ( intPoint - 1 ) % points.length ];\r\n\t\tvar point1 = points[ ( intPoint     ) % points.length ];\r\n\t\tvar point2 = points[ ( intPoint + 1 ) % points.length ];\r\n\t\tvar point3 = points[ ( intPoint + 2 ) % points.length ];\r\n\r\n\t\tvar vector = new THREE.Vector3();\r\n\r\n\t\tvector.x = THREE.Curve.Utils.interpolate( point0.x, point1.x, point2.x, point3.x, weight );\r\n\t\tvector.y = THREE.Curve.Utils.interpolate( point0.y, point1.y, point2.y, point3.y, weight );\r\n\t\tvector.z = THREE.Curve.Utils.interpolate( point0.z, point1.z, point2.z, point3.z, weight );\r\n\r\n\t\treturn vector;\r\n\r\n\t}\r\n\r\n);\r\n\r\n// File:src/extras/animation/AnimationHandler.js\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n */\r\n\r\nTHREE.AnimationHandler = {\r\n\r\n\tLINEAR: 0,\r\n\tCATMULLROM: 1,\r\n\tCATMULLROM_FORWARD: 2,\r\n\r\n\t//\r\n\r\n\tadd: function () { THREE.warn( 'THREE.AnimationHandler.add() has been deprecated.' ); },\r\n\tget: function () { THREE.warn( 'THREE.AnimationHandler.get() has been deprecated.' ); },\r\n\tremove: function () { THREE.warn( 'THREE.AnimationHandler.remove() has been deprecated.' ); },\r\n\r\n\t//\r\n\r\n\tanimations: [],\r\n\r\n\tinit: function ( data ) {\r\n\r\n\t\tif ( data.initialized === true ) return data;\r\n\r\n\t\t// loop through all keys\r\n\r\n\t\tfor ( var h = 0; h < data.hierarchy.length; h ++ ) {\r\n\r\n\t\t\tfor ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {\r\n\r\n\t\t\t\t// remove minus times\r\n\r\n\t\t\t\tif ( data.hierarchy[ h ].keys[ k ].time < 0 ) {\r\n\r\n\t\t\t\t\t data.hierarchy[ h ].keys[ k ].time = 0;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// create quaternions\r\n\r\n\t\t\t\tif ( data.hierarchy[ h ].keys[ k ].rot !== undefined &&\r\n\t\t\t\t  ! ( data.hierarchy[ h ].keys[ k ].rot instanceof THREE.Quaternion ) ) {\r\n\r\n\t\t\t\t\tvar quat = data.hierarchy[ h ].keys[ k ].rot;\r\n\t\t\t\t\tdata.hierarchy[ h ].keys[ k ].rot = new THREE.Quaternion().fromArray( quat );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// prepare morph target keys\r\n\r\n\t\t\tif ( data.hierarchy[ h ].keys.length && data.hierarchy[ h ].keys[ 0 ].morphTargets !== undefined ) {\r\n\r\n\t\t\t\t// get all used\r\n\r\n\t\t\t\tvar usedMorphTargets = {};\r\n\r\n\t\t\t\tfor ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {\r\n\r\n\t\t\t\t\tfor ( var m = 0; m < data.hierarchy[ h ].keys[ k ].morphTargets.length; m ++ ) {\r\n\r\n\t\t\t\t\t\tvar morphTargetName = data.hierarchy[ h ].keys[ k ].morphTargets[ m ];\r\n\t\t\t\t\t\tusedMorphTargets[ morphTargetName ] = - 1;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tdata.hierarchy[ h ].usedMorphTargets = usedMorphTargets;\r\n\r\n\r\n\t\t\t\t// set all used on all frames\r\n\r\n\t\t\t\tfor ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {\r\n\r\n\t\t\t\t\tvar influences = {};\r\n\r\n\t\t\t\t\tfor ( var morphTargetName in usedMorphTargets ) {\r\n\r\n\t\t\t\t\t\tfor ( var m = 0; m < data.hierarchy[ h ].keys[ k ].morphTargets.length; m ++ ) {\r\n\r\n\t\t\t\t\t\t\tif ( data.hierarchy[ h ].keys[ k ].morphTargets[ m ] === morphTargetName ) {\r\n\r\n\t\t\t\t\t\t\t\tinfluences[ morphTargetName ] = data.hierarchy[ h ].keys[ k ].morphTargetsInfluences[ m ];\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif ( m === data.hierarchy[ h ].keys[ k ].morphTargets.length ) {\r\n\r\n\t\t\t\t\t\t\tinfluences[ morphTargetName ] = 0;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tdata.hierarchy[ h ].keys[ k ].morphTargetsInfluences = influences;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\r\n\t\t\t// remove all keys that are on the same time\r\n\r\n\t\t\tfor ( var k = 1; k < data.hierarchy[ h ].keys.length; k ++ ) {\r\n\r\n\t\t\t\tif ( data.hierarchy[ h ].keys[ k ].time === data.hierarchy[ h ].keys[ k - 1 ].time ) {\r\n\r\n\t\t\t\t\tdata.hierarchy[ h ].keys.splice( k, 1 );\r\n\t\t\t\t\tk --;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\r\n\t\t\t// set index\r\n\r\n\t\t\tfor ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {\r\n\r\n\t\t\t\tdata.hierarchy[ h ].keys[ k ].index = k;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tdata.initialized = true;\r\n\r\n\t\treturn data;\r\n\r\n\t},\r\n\r\n\tparse: function ( root ) {\r\n\r\n\t\tvar parseRecurseHierarchy = function ( root, hierarchy ) {\r\n\r\n\t\t\thierarchy.push( root );\r\n\r\n\t\t\tfor ( var c = 0; c < root.children.length; c ++ )\r\n\t\t\t\tparseRecurseHierarchy( root.children[ c ], hierarchy );\r\n\r\n\t\t};\r\n\r\n\t\t// setup hierarchy\r\n\r\n\t\tvar hierarchy = [];\r\n\r\n\t\tif ( root instanceof THREE.SkinnedMesh ) {\r\n\r\n\t\t\tfor ( var b = 0; b < root.skeleton.bones.length; b ++ ) {\r\n\r\n\t\t\t\thierarchy.push( root.skeleton.bones[ b ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tparseRecurseHierarchy( root, hierarchy );\r\n\r\n\t\t}\r\n\r\n\t\treturn hierarchy;\r\n\r\n\t},\r\n\r\n\tplay: function ( animation ) {\r\n\r\n\t\tif ( this.animations.indexOf( animation ) === - 1 ) {\r\n\r\n\t\t\tthis.animations.push( animation );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tstop: function ( animation ) {\r\n\r\n\t\tvar index = this.animations.indexOf( animation );\r\n\r\n\t\tif ( index !== - 1 ) {\r\n\r\n\t\t\tthis.animations.splice( index, 1 );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tupdate: function ( deltaTimeMS ) {\r\n\r\n\t\tfor ( var i = 0; i < this.animations.length; i ++ ) {\r\n\r\n\t\t\tthis.animations[ i ].resetBlendWeights( );\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var i = 0; i < this.animations.length; i ++ ) {\r\n\r\n\t\t\tthis.animations[ i ].update( deltaTimeMS );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/extras/animation/Animation.js\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Animation = function ( root, data ) {\r\n\r\n\tthis.root = root;\r\n\tthis.data = THREE.AnimationHandler.init( data );\r\n\tthis.hierarchy = THREE.AnimationHandler.parse( root );\r\n\r\n\tthis.currentTime = 0;\r\n\tthis.timeScale = 1;\r\n\r\n\tthis.isPlaying = false;\r\n\tthis.loop = true;\r\n\tthis.weight = 0;\r\n\r\n\tthis.interpolationType = THREE.AnimationHandler.LINEAR;\r\n\r\n};\r\n\r\nTHREE.Animation.prototype = {\r\n\r\n\tconstructor: THREE.Animation,\r\n\r\n\tkeyTypes:  [ \"pos\", \"rot\", \"scl\" ],\r\n\r\n\tplay: function ( startTime, weight ) {\r\n\r\n\t\tthis.currentTime = startTime !== undefined ? startTime : 0;\r\n\t\tthis.weight = weight !== undefined ? weight : 1;\r\n\r\n\t\tthis.isPlaying = true;\r\n\r\n\t\tthis.reset();\r\n\r\n\t\tTHREE.AnimationHandler.play( this );\r\n\r\n\t},\r\n\r\n\tstop: function() {\r\n\r\n\t\tthis.isPlaying = false;\r\n\r\n\t\tTHREE.AnimationHandler.stop( this );\r\n\r\n\t},\r\n\r\n\treset: function () {\r\n\r\n\t\tfor ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {\r\n\r\n\t\t\tvar object = this.hierarchy[ h ];\r\n\r\n\t\t\tif ( object.animationCache === undefined ) {\r\n\r\n\t\t\t\tobject.animationCache = {\r\n\t\t\t\t\tanimations: {},\r\n\t\t\t\t\tblending: {\r\n\t\t\t\t\t\tpositionWeight: 0.0,\r\n\t\t\t\t\t\tquaternionWeight: 0.0,\r\n\t\t\t\t\t\tscaleWeight: 0.0\r\n\t\t\t\t\t}\r\n\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\tvar name = this.data.name;\r\n\t\t\tvar animations = object.animationCache.animations;\r\n\t\t\tvar animationCache = animations[ name ];\r\n\r\n\t\t\tif ( animationCache === undefined ) {\r\n\r\n\t\t\t\tanimationCache = {\r\n\t\t\t\t\tprevKey: { pos: 0, rot: 0, scl: 0 },\r\n\t\t\t\t\tnextKey: { pos: 0, rot: 0, scl: 0 },\r\n\t\t\t\t\toriginalMatrix: object.matrix\r\n\t\t\t\t};\r\n\r\n\t\t\t\tanimations[ name ] = animationCache;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Get keys to match our current time\r\n\r\n\t\t\tfor ( var t = 0; t < 3; t ++ ) {\r\n\r\n\t\t\t\tvar type = this.keyTypes[ t ];\r\n\r\n\t\t\t\tvar prevKey = this.data.hierarchy[ h ].keys[ 0 ];\r\n\t\t\t\tvar nextKey = this.getNextKeyWith( type, h, 1 );\r\n\r\n\t\t\t\twhile ( nextKey.time < this.currentTime && nextKey.index > prevKey.index ) {\r\n\r\n\t\t\t\t\tprevKey = nextKey;\r\n\t\t\t\t\tnextKey = this.getNextKeyWith( type, h, nextKey.index + 1 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tanimationCache.prevKey[ type ] = prevKey;\r\n\t\t\t\tanimationCache.nextKey[ type ] = nextKey;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tresetBlendWeights: function () {\r\n\r\n\t\tfor ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {\r\n\r\n\t\t\tvar object = this.hierarchy[ h ];\r\n\t\t\tvar animationCache = object.animationCache;\r\n\r\n\t\t\tif ( animationCache !== undefined ) {\r\n\r\n\t\t\t\tvar blending = animationCache.blending;\r\n\r\n\t\t\t\tblending.positionWeight = 0.0;\r\n\t\t\t\tblending.quaternionWeight = 0.0;\r\n\t\t\t\tblending.scaleWeight = 0.0;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tupdate: ( function() {\r\n\r\n\t\tvar points = [];\r\n\t\tvar target = new THREE.Vector3();\r\n\t\tvar newVector = new THREE.Vector3();\r\n\t\tvar newQuat = new THREE.Quaternion();\r\n\r\n\t\t// Catmull-Rom spline\r\n\r\n\t\tvar interpolateCatmullRom = function ( points, scale ) {\r\n\r\n\t\t\tvar c = [], v3 = [],\r\n\t\t\tpoint, intPoint, weight, w2, w3,\r\n\t\t\tpa, pb, pc, pd;\r\n\r\n\t\t\tpoint = ( points.length - 1 ) * scale;\r\n\t\t\tintPoint = Math.floor( point );\r\n\t\t\tweight = point - intPoint;\r\n\r\n\t\t\tc[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;\r\n\t\t\tc[ 1 ] = intPoint;\r\n\t\t\tc[ 2 ] = intPoint > points.length - 2 ? intPoint : intPoint + 1;\r\n\t\t\tc[ 3 ] = intPoint > points.length - 3 ? intPoint : intPoint + 2;\r\n\r\n\t\t\tpa = points[ c[ 0 ] ];\r\n\t\t\tpb = points[ c[ 1 ] ];\r\n\t\t\tpc = points[ c[ 2 ] ];\r\n\t\t\tpd = points[ c[ 3 ] ];\r\n\r\n\t\t\tw2 = weight * weight;\r\n\t\t\tw3 = weight * w2;\r\n\r\n\t\t\tv3[ 0 ] = interpolate( pa[ 0 ], pb[ 0 ], pc[ 0 ], pd[ 0 ], weight, w2, w3 );\r\n\t\t\tv3[ 1 ] = interpolate( pa[ 1 ], pb[ 1 ], pc[ 1 ], pd[ 1 ], weight, w2, w3 );\r\n\t\t\tv3[ 2 ] = interpolate( pa[ 2 ], pb[ 2 ], pc[ 2 ], pd[ 2 ], weight, w2, w3 );\r\n\r\n\t\t\treturn v3;\r\n\r\n\t\t};\r\n\r\n\t\tvar interpolate = function ( p0, p1, p2, p3, t, t2, t3 ) {\r\n\r\n\t\t\tvar v0 = ( p2 - p0 ) * 0.5,\r\n\t\t\t\tv1 = ( p3 - p1 ) * 0.5;\r\n\r\n\t\t\treturn ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;\r\n\r\n\t\t};\r\n\r\n\t\treturn function ( delta ) {\r\n\r\n\t\t\tif ( this.isPlaying === false ) return;\r\n\r\n\t\t\tthis.currentTime += delta * this.timeScale;\r\n\r\n\t\t\tif ( this.weight === 0 )\r\n\t\t\t\treturn;\r\n\r\n\t\t\t//\r\n\r\n\t\t\tvar duration = this.data.length;\r\n\r\n\t\t\tif ( this.currentTime > duration || this.currentTime < 0 ) {\r\n\r\n\t\t\t\tif ( this.loop ) {\r\n\r\n\t\t\t\t\tthis.currentTime %= duration;\r\n\r\n\t\t\t\t\tif ( this.currentTime < 0 )\r\n\t\t\t\t\t\tthis.currentTime += duration;\r\n\r\n\t\t\t\t\tthis.reset();\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tthis.stop();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {\r\n\r\n\t\t\t\tvar object = this.hierarchy[ h ];\r\n\t\t\t\tvar animationCache = object.animationCache.animations[this.data.name];\r\n\t\t\t\tvar blending = object.animationCache.blending;\r\n\r\n\t\t\t\t// loop through pos/rot/scl\r\n\r\n\t\t\t\tfor ( var t = 0; t < 3; t ++ ) {\r\n\r\n\t\t\t\t\t// get keys\r\n\r\n\t\t\t\t\tvar type    = this.keyTypes[ t ];\r\n\t\t\t\t\tvar prevKey = animationCache.prevKey[ type ];\r\n\t\t\t\t\tvar nextKey = animationCache.nextKey[ type ];\r\n\r\n\t\t\t\t\tif ( ( this.timeScale > 0 && nextKey.time <= this.currentTime ) ||\r\n\t\t\t\t\t\t( this.timeScale < 0 && prevKey.time >= this.currentTime ) ) {\r\n\r\n\t\t\t\t\t\tprevKey = this.data.hierarchy[ h ].keys[ 0 ];\r\n\t\t\t\t\t\tnextKey = this.getNextKeyWith( type, h, 1 );\r\n\r\n\t\t\t\t\t\twhile ( nextKey.time < this.currentTime && nextKey.index > prevKey.index ) {\r\n\r\n\t\t\t\t\t\t\tprevKey = nextKey;\r\n\t\t\t\t\t\t\tnextKey = this.getNextKeyWith( type, h, nextKey.index + 1 );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tanimationCache.prevKey[ type ] = prevKey;\r\n\t\t\t\t\t\tanimationCache.nextKey[ type ] = nextKey;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tvar scale = ( this.currentTime - prevKey.time ) / ( nextKey.time - prevKey.time );\r\n\r\n\t\t\t\t\tvar prevXYZ = prevKey[ type ];\r\n\t\t\t\t\tvar nextXYZ = nextKey[ type ];\r\n\r\n\t\t\t\t\tif ( scale < 0 ) scale = 0;\r\n\t\t\t\t\tif ( scale > 1 ) scale = 1;\r\n\r\n\t\t\t\t\t// interpolate\r\n\r\n\t\t\t\t\tif ( type === \"pos\" ) {\r\n\r\n\t\t\t\t\t\tif ( this.interpolationType === THREE.AnimationHandler.LINEAR ) {\r\n\r\n\t\t\t\t\t\t\tnewVector.x = prevXYZ[ 0 ] + ( nextXYZ[ 0 ] - prevXYZ[ 0 ] ) * scale;\r\n\t\t\t\t\t\t\tnewVector.y = prevXYZ[ 1 ] + ( nextXYZ[ 1 ] - prevXYZ[ 1 ] ) * scale;\r\n\t\t\t\t\t\t\tnewVector.z = prevXYZ[ 2 ] + ( nextXYZ[ 2 ] - prevXYZ[ 2 ] ) * scale;\r\n\r\n\t\t\t\t\t\t\t// blend\r\n\t\t\t\t\t\t\tvar proportionalWeight = this.weight / ( this.weight + blending.positionWeight );\r\n\t\t\t\t\t\t\tobject.position.lerp( newVector, proportionalWeight );\r\n\t\t\t\t\t\t\tblending.positionWeight += this.weight;\r\n\r\n\t\t\t\t\t\t} else if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||\r\n\t\t\t\t\t\t\t\t\tthis.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {\r\n\r\n\t\t\t\t\t\t\tpoints[ 0 ] = this.getPrevKeyWith( \"pos\", h, prevKey.index - 1 )[ \"pos\" ];\r\n\t\t\t\t\t\t\tpoints[ 1 ] = prevXYZ;\r\n\t\t\t\t\t\t\tpoints[ 2 ] = nextXYZ;\r\n\t\t\t\t\t\t\tpoints[ 3 ] = this.getNextKeyWith( \"pos\", h, nextKey.index + 1 )[ \"pos\" ];\r\n\r\n\t\t\t\t\t\t\tscale = scale * 0.33 + 0.33;\r\n\r\n\t\t\t\t\t\t\tvar currentPoint = interpolateCatmullRom( points, scale );\r\n\t\t\t\t\t\t\tvar proportionalWeight = this.weight / ( this.weight + blending.positionWeight );\r\n\t\t\t\t\t\t\tblending.positionWeight += this.weight;\r\n\r\n\t\t\t\t\t\t\t// blend\r\n\r\n\t\t\t\t\t\t\tvar vector = object.position;\r\n\r\n\t\t\t\t\t\t\tvector.x = vector.x + ( currentPoint[ 0 ] - vector.x ) * proportionalWeight;\r\n\t\t\t\t\t\t\tvector.y = vector.y + ( currentPoint[ 1 ] - vector.y ) * proportionalWeight;\r\n\t\t\t\t\t\t\tvector.z = vector.z + ( currentPoint[ 2 ] - vector.z ) * proportionalWeight;\r\n\r\n\t\t\t\t\t\t\tif ( this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {\r\n\r\n\t\t\t\t\t\t\t\tvar forwardPoint = interpolateCatmullRom( points, scale * 1.01 );\r\n\r\n\t\t\t\t\t\t\t\ttarget.set( forwardPoint[ 0 ], forwardPoint[ 1 ], forwardPoint[ 2 ] );\r\n\t\t\t\t\t\t\t\ttarget.sub( vector );\r\n\t\t\t\t\t\t\t\ttarget.y = 0;\r\n\t\t\t\t\t\t\t\ttarget.normalize();\r\n\r\n\t\t\t\t\t\t\t\tvar angle = Math.atan2( target.x, target.z );\r\n\t\t\t\t\t\t\t\tobject.rotation.set( 0, angle, 0 );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( type === \"rot\" ) {\r\n\r\n\t\t\t\t\t\tTHREE.Quaternion.slerp( prevXYZ, nextXYZ, newQuat, scale );\r\n\r\n\t\t\t\t\t\t// Avoid paying the cost of an additional slerp if we don't have to\r\n\t\t\t\t\t\tif ( blending.quaternionWeight === 0 ) {\r\n\r\n\t\t\t\t\t\t\tobject.quaternion.copy(newQuat);\r\n\t\t\t\t\t\t\tblending.quaternionWeight = this.weight;\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tvar proportionalWeight = this.weight / ( this.weight + blending.quaternionWeight );\r\n\t\t\t\t\t\t\tTHREE.Quaternion.slerp( object.quaternion, newQuat, object.quaternion, proportionalWeight );\r\n\t\t\t\t\t\t\tblending.quaternionWeight += this.weight;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( type === \"scl\" ) {\r\n\r\n\t\t\t\t\t\tnewVector.x = prevXYZ[ 0 ] + ( nextXYZ[ 0 ] - prevXYZ[ 0 ] ) * scale;\r\n\t\t\t\t\t\tnewVector.y = prevXYZ[ 1 ] + ( nextXYZ[ 1 ] - prevXYZ[ 1 ] ) * scale;\r\n\t\t\t\t\t\tnewVector.z = prevXYZ[ 2 ] + ( nextXYZ[ 2 ] - prevXYZ[ 2 ] ) * scale;\r\n\r\n\t\t\t\t\t\tvar proportionalWeight = this.weight / ( this.weight + blending.scaleWeight );\r\n\t\t\t\t\t\tobject.scale.lerp( newVector, proportionalWeight );\r\n\t\t\t\t\t\tblending.scaleWeight += this.weight;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t};\r\n\r\n\t} )(),\r\n\r\n\tgetNextKeyWith: function ( type, h, key ) {\r\n\r\n\t\tvar keys = this.data.hierarchy[ h ].keys;\r\n\r\n\t\tif ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||\r\n\t\t\t this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {\r\n\r\n\t\t\tkey = key < keys.length - 1 ? key : keys.length - 1;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tkey = key % keys.length;\r\n\r\n\t\t}\r\n\r\n\t\tfor ( ; key < keys.length; key ++ ) {\r\n\r\n\t\t\tif ( keys[ key ][ type ] !== undefined ) {\r\n\r\n\t\t\t\treturn keys[ key ];\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn this.data.hierarchy[ h ].keys[ 0 ];\r\n\r\n\t},\r\n\r\n\tgetPrevKeyWith: function ( type, h, key ) {\r\n\r\n\t\tvar keys = this.data.hierarchy[ h ].keys;\r\n\r\n\t\tif ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||\r\n\t\t\tthis.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {\r\n\r\n\t\t\tkey = key > 0 ? key : 0;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tkey = key >= 0 ? key : key + keys.length;\r\n\r\n\t\t}\r\n\r\n\r\n\t\tfor ( ; key >= 0; key -- ) {\r\n\r\n\t\t\tif ( keys[ key ][ type ] !== undefined ) {\r\n\r\n\t\t\t\treturn keys[ key ];\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn this.data.hierarchy[ h ].keys[ keys.length - 1 ];\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/extras/animation/KeyFrameAnimation.js\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author khang duong\r\n * @author erik kitson\r\n */\r\n\r\nTHREE.KeyFrameAnimation = function ( data ) {\r\n\r\n\tthis.root = data.node;\r\n\tthis.data = THREE.AnimationHandler.init( data );\r\n\tthis.hierarchy = THREE.AnimationHandler.parse( this.root );\r\n\tthis.currentTime = 0;\r\n\tthis.timeScale = 0.001;\r\n\tthis.isPlaying = false;\r\n\tthis.isPaused = true;\r\n\tthis.loop = true;\r\n\r\n\t// initialize to first keyframes\r\n\r\n\tfor ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {\r\n\r\n\t\tvar keys = this.data.hierarchy[h].keys,\r\n\t\t\tsids = this.data.hierarchy[h].sids,\r\n\t\t\tobj = this.hierarchy[h];\r\n\r\n\t\tif ( keys.length && sids ) {\r\n\r\n\t\t\tfor ( var s = 0; s < sids.length; s ++ ) {\r\n\r\n\t\t\t\tvar sid = sids[ s ],\r\n\t\t\t\t\tnext = this.getNextKeyWith( sid, h, 0 );\r\n\r\n\t\t\t\tif ( next ) {\r\n\r\n\t\t\t\t\tnext.apply( sid );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tobj.matrixAutoUpdate = false;\r\n\t\t\tthis.data.hierarchy[h].node.updateMatrix();\r\n\t\t\tobj.matrixWorldNeedsUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.KeyFrameAnimation.prototype = {\r\n\r\n\tconstructor: THREE.KeyFrameAnimation,\r\n\r\n\tplay: function ( startTime ) {\r\n\r\n\t\tthis.currentTime = startTime !== undefined ? startTime : 0;\r\n\r\n\t\tif ( this.isPlaying === false ) {\r\n\r\n\t\t\tthis.isPlaying = true;\r\n\r\n\t\t\t// reset key cache\r\n\r\n\t\t\tvar h, hl = this.hierarchy.length,\r\n\t\t\t\tobject,\r\n\t\t\t\tnode;\r\n\r\n\t\t\tfor ( h = 0; h < hl; h ++ ) {\r\n\r\n\t\t\t\tobject = this.hierarchy[ h ];\r\n\t\t\t\tnode = this.data.hierarchy[ h ];\r\n\r\n\t\t\t\tif ( node.animationCache === undefined ) {\r\n\r\n\t\t\t\t\tnode.animationCache = {};\r\n\t\t\t\t\tnode.animationCache.prevKey = null;\r\n\t\t\t\t\tnode.animationCache.nextKey = null;\r\n\t\t\t\t\tnode.animationCache.originalMatrix = object.matrix;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar keys = this.data.hierarchy[h].keys;\r\n\r\n\t\t\t\tif (keys.length) {\r\n\r\n\t\t\t\t\tnode.animationCache.prevKey = keys[ 0 ];\r\n\t\t\t\t\tnode.animationCache.nextKey = keys[ 1 ];\r\n\r\n\t\t\t\t\tthis.startTime = Math.min( keys[0].time, this.startTime );\r\n\t\t\t\t\tthis.endTime = Math.max( keys[keys.length - 1].time, this.endTime );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.update( 0 );\r\n\r\n\t\t}\r\n\r\n\t\tthis.isPaused = false;\r\n\r\n\t\tTHREE.AnimationHandler.play( this );\r\n\r\n\t},\r\n\r\n\tstop: function () {\r\n\r\n\t\tthis.isPlaying = false;\r\n\t\tthis.isPaused  = false;\r\n\r\n\t\tTHREE.AnimationHandler.stop( this );\r\n\r\n\t\t// reset JIT matrix and remove cache\r\n\r\n\t\tfor ( var h = 0; h < this.data.hierarchy.length; h ++ ) {\r\n\r\n\t\t\tvar obj = this.hierarchy[ h ];\r\n\t\t\tvar node = this.data.hierarchy[ h ];\r\n\r\n\t\t\tif ( node.animationCache !== undefined ) {\r\n\r\n\t\t\t\tvar original = node.animationCache.originalMatrix;\r\n\r\n\t\t\t\toriginal.copy( obj.matrix );\r\n\t\t\t\tobj.matrix = original;\r\n\r\n\t\t\t\tdelete node.animationCache;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tupdate: function ( delta ) {\r\n\r\n\t\tif ( this.isPlaying === false ) return;\r\n\r\n\t\tthis.currentTime += delta * this.timeScale;\r\n\r\n\t\t//\r\n\r\n\t\tvar duration = this.data.length;\r\n\r\n\t\tif ( this.loop === true && this.currentTime > duration ) {\r\n\r\n\t\t\tthis.currentTime %= duration;\r\n\r\n\t\t}\r\n\r\n\t\tthis.currentTime = Math.min( this.currentTime, duration );\r\n\r\n\t\tfor ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {\r\n\r\n\t\t\tvar object = this.hierarchy[ h ];\r\n\t\t\tvar node = this.data.hierarchy[ h ];\r\n\r\n\t\t\tvar keys = node.keys,\r\n\t\t\t\tanimationCache = node.animationCache;\r\n\r\n\r\n\t\t\tif ( keys.length ) {\r\n\r\n\t\t\t\tvar prevKey = animationCache.prevKey;\r\n\t\t\t\tvar nextKey = animationCache.nextKey;\r\n\r\n\t\t\t\tif ( nextKey.time <= this.currentTime ) {\r\n\r\n\t\t\t\t\twhile ( nextKey.time < this.currentTime && nextKey.index > prevKey.index ) {\r\n\r\n\t\t\t\t\t\tprevKey = nextKey;\r\n\t\t\t\t\t\tnextKey = keys[ prevKey.index + 1 ];\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tanimationCache.prevKey = prevKey;\r\n\t\t\t\t\tanimationCache.nextKey = nextKey;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( nextKey.time >= this.currentTime ) {\r\n\r\n\t\t\t\t\tprevKey.interpolate( nextKey, this.currentTime );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tprevKey.interpolate( nextKey, nextKey.time );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.data.hierarchy[ h ].node.updateMatrix();\r\n\t\t\t\tobject.matrixWorldNeedsUpdate = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tgetNextKeyWith: function ( sid, h, key ) {\r\n\r\n\t\tvar keys = this.data.hierarchy[ h ].keys;\r\n\t\tkey = key % keys.length;\r\n\r\n\t\tfor ( ; key < keys.length; key ++ ) {\r\n\r\n\t\t\tif ( keys[ key ].hasTarget( sid ) ) {\r\n\r\n\t\t\t\treturn keys[ key ];\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn keys[ 0 ];\r\n\r\n\t},\r\n\r\n\tgetPrevKeyWith: function ( sid, h, key ) {\r\n\r\n\t\tvar keys = this.data.hierarchy[ h ].keys;\r\n\t\tkey = key >= 0 ? key : key + keys.length;\r\n\r\n\t\tfor ( ; key >= 0; key -- ) {\r\n\r\n\t\t\tif ( keys[ key ].hasTarget( sid ) ) {\r\n\r\n\t\t\t\treturn keys[ key ];\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn keys[ keys.length - 1 ];\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/extras/animation/MorphAnimation.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com\r\n * @author willy-vvu / http://willy-vvu.github.io\r\n */\r\n\r\nTHREE.MorphAnimation = function ( mesh ) {\r\n\r\n\tthis.mesh = mesh;\r\n\tthis.frames = mesh.morphTargetInfluences.length;\r\n\tthis.currentTime = 0;\r\n\tthis.duration = 1000;\r\n\tthis.loop = true;\r\n\tthis.lastFrame = 0;\r\n\tthis.currentFrame = 0;\r\n\r\n\tthis.isPlaying = false;\r\n\r\n};\r\n\r\nTHREE.MorphAnimation.prototype = {\r\n\r\n\tconstructor: THREE.MorphAnimation,\r\n\r\n\tplay: function () {\r\n\r\n\t\tthis.isPlaying = true;\r\n\r\n\t},\r\n\r\n\tpause: function () {\r\n\r\n\t\tthis.isPlaying = false;\r\n\r\n\t},\r\n\r\n\tupdate: function ( delta ) {\r\n\r\n\t\tif ( this.isPlaying === false ) return;\r\n\r\n\t\tthis.currentTime += delta;\r\n\r\n\t\tif ( this.loop === true && this.currentTime > this.duration ) {\r\n\r\n\t\t\tthis.currentTime %= this.duration;\r\n\r\n\t\t}\r\n\r\n\t\tthis.currentTime = Math.min( this.currentTime, this.duration );\r\n\r\n\t\tvar interpolation = this.duration / this.frames;\r\n\t\tvar frame = Math.floor( this.currentTime / interpolation );\r\n\r\n\t\tvar influences = this.mesh.morphTargetInfluences;\r\n\r\n\t\tif ( frame != this.currentFrame ) {\r\n\r\n\t\t\tinfluences[ this.lastFrame ] = 0;\r\n\t\t\tinfluences[ this.currentFrame ] = 1;\r\n\t\t\tinfluences[ frame ] = 0;\r\n\r\n\t\t\tthis.lastFrame = this.currentFrame;\r\n\t\t\tthis.currentFrame = frame;\r\n\r\n\t\t}\r\n\r\n\t\tinfluences[ frame ] = ( this.currentTime % interpolation ) / interpolation;\r\n\t\tinfluences[ this.lastFrame ] = 1 - influences[ frame ];\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/extras/geometries/BoxGeometry.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as\r\n */\r\n\r\nTHREE.BoxGeometry = function ( width, height, depth, widthSegments, heightSegments, depthSegments ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tthis.type = 'BoxGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\twidth: width,\r\n\t\theight: height,\r\n\t\tdepth: depth,\r\n\t\twidthSegments: widthSegments,\r\n\t\theightSegments: heightSegments,\r\n\t\tdepthSegments: depthSegments\r\n\t};\r\n\r\n\tthis.widthSegments = widthSegments || 1;\r\n\tthis.heightSegments = heightSegments || 1;\r\n\tthis.depthSegments = depthSegments || 1;\r\n\r\n\tvar scope = this;\r\n\r\n\tvar width_half = width / 2;\r\n\tvar height_half = height / 2;\r\n\tvar depth_half = depth / 2;\r\n\r\n\tbuildPlane( 'z', 'y', - 1, - 1, depth, height, width_half, 0 ); // px\r\n\tbuildPlane( 'z', 'y',   1, - 1, depth, height, - width_half, 1 ); // nx\r\n\tbuildPlane( 'x', 'z',   1,   1, width, depth, height_half, 2 ); // py\r\n\tbuildPlane( 'x', 'z',   1, - 1, width, depth, - height_half, 3 ); // ny\r\n\tbuildPlane( 'x', 'y',   1, - 1, width, height, depth_half, 4 ); // pz\r\n\tbuildPlane( 'x', 'y', - 1, - 1, width, height, - depth_half, 5 ); // nz\r\n\r\n\tfunction buildPlane( u, v, udir, vdir, width, height, depth, materialIndex ) {\r\n\r\n\t\tvar w, ix, iy,\r\n\t\tgridX = scope.widthSegments,\r\n\t\tgridY = scope.heightSegments,\r\n\t\twidth_half = width / 2,\r\n\t\theight_half = height / 2,\r\n\t\toffset = scope.vertices.length;\r\n\r\n\t\tif ( ( u === 'x' && v === 'y' ) || ( u === 'y' && v === 'x' ) ) {\r\n\r\n\t\t\tw = 'z';\r\n\r\n\t\t} else if ( ( u === 'x' && v === 'z' ) || ( u === 'z' && v === 'x' ) ) {\r\n\r\n\t\t\tw = 'y';\r\n\t\t\tgridY = scope.depthSegments;\r\n\r\n\t\t} else if ( ( u === 'z' && v === 'y' ) || ( u === 'y' && v === 'z' ) ) {\r\n\r\n\t\t\tw = 'x';\r\n\t\t\tgridX = scope.depthSegments;\r\n\r\n\t\t}\r\n\r\n\t\tvar gridX1 = gridX + 1,\r\n\t\tgridY1 = gridY + 1,\r\n\t\tsegment_width = width / gridX,\r\n\t\tsegment_height = height / gridY,\r\n\t\tnormal = new THREE.Vector3();\r\n\r\n\t\tnormal[ w ] = depth > 0 ? 1 : - 1;\r\n\r\n\t\tfor ( iy = 0; iy < gridY1; iy ++ ) {\r\n\r\n\t\t\tfor ( ix = 0; ix < gridX1; ix ++ ) {\r\n\r\n\t\t\t\tvar vector = new THREE.Vector3();\r\n\t\t\t\tvector[ u ] = ( ix * segment_width - width_half ) * udir;\r\n\t\t\t\tvector[ v ] = ( iy * segment_height - height_half ) * vdir;\r\n\t\t\t\tvector[ w ] = depth;\r\n\r\n\t\t\t\tscope.vertices.push( vector );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfor ( iy = 0; iy < gridY; iy ++ ) {\r\n\r\n\t\t\tfor ( ix = 0; ix < gridX; ix ++ ) {\r\n\r\n\t\t\t\tvar a = ix + gridX1 * iy;\r\n\t\t\t\tvar b = ix + gridX1 * ( iy + 1 );\r\n\t\t\t\tvar c = ( ix + 1 ) + gridX1 * ( iy + 1 );\r\n\t\t\t\tvar d = ( ix + 1 ) + gridX1 * iy;\r\n\r\n\t\t\t\tvar uva = new THREE.Vector2( ix / gridX, 1 - iy / gridY );\r\n\t\t\t\tvar uvb = new THREE.Vector2( ix / gridX, 1 - ( iy + 1 ) / gridY );\r\n\t\t\t\tvar uvc = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - ( iy + 1 ) / gridY );\r\n\t\t\t\tvar uvd = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - iy / gridY );\r\n\r\n\t\t\t\tvar face = new THREE.Face3( a + offset, b + offset, d + offset );\r\n\t\t\t\tface.normal.copy( normal );\r\n\t\t\t\tface.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );\r\n\t\t\t\tface.materialIndex = materialIndex;\r\n\r\n\t\t\t\tscope.faces.push( face );\r\n\t\t\t\tscope.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );\r\n\r\n\t\t\t\tface = new THREE.Face3( b + offset, c + offset, d + offset );\r\n\t\t\t\tface.normal.copy( normal );\r\n\t\t\t\tface.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );\r\n\t\t\t\tface.materialIndex = materialIndex;\r\n\r\n\t\t\t\tscope.faces.push( face );\r\n\t\t\t\tscope.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tthis.mergeVertices();\r\n\r\n};\r\n\r\nTHREE.BoxGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.BoxGeometry.prototype.constructor = THREE.BoxGeometry;\r\n\r\n// File:src/extras/geometries/CircleGeometry.js\r\n\r\n/**\r\n * @author hughes\r\n */\r\n\r\nTHREE.CircleGeometry = function ( radius, segments, thetaStart, thetaLength ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tthis.type = 'CircleGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tradius: radius,\r\n\t\tsegments: segments,\r\n\t\tthetaStart: thetaStart,\r\n\t\tthetaLength: thetaLength\r\n\t};\r\n\r\n\tradius = radius || 50;\r\n\tsegments = segments !== undefined ? Math.max( 3, segments ) : 8;\r\n\r\n\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\r\n\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\r\n\r\n\tvar i, uvs = [],\r\n\tcenter = new THREE.Vector3(), centerUV = new THREE.Vector2( 0.5, 0.5 );\r\n\r\n\tthis.vertices.push(center);\r\n\tuvs.push( centerUV );\r\n\r\n\tfor ( i = 0; i <= segments; i ++ ) {\r\n\r\n\t\tvar vertex = new THREE.Vector3();\r\n\t\tvar segment = thetaStart + i / segments * thetaLength;\r\n\r\n\t\tvertex.x = radius * Math.cos( segment );\r\n\t\tvertex.y = radius * Math.sin( segment );\r\n\r\n\t\tthis.vertices.push( vertex );\r\n\t\tuvs.push( new THREE.Vector2( ( vertex.x / radius + 1 ) / 2, ( vertex.y / radius + 1 ) / 2 ) );\r\n\r\n\t}\r\n\r\n\tvar n = new THREE.Vector3( 0, 0, 1 );\r\n\r\n\tfor ( i = 1; i <= segments; i ++ ) {\r\n\r\n\t\tthis.faces.push( new THREE.Face3( i, i + 1, 0, [ n.clone(), n.clone(), n.clone() ] ) );\r\n\t\tthis.faceVertexUvs[ 0 ].push( [ uvs[ i ].clone(), uvs[ i + 1 ].clone(), centerUV.clone() ] );\r\n\r\n\t}\r\n\r\n\tthis.computeFaceNormals();\r\n\r\n\tthis.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\r\n\r\n};\r\n\r\nTHREE.CircleGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.CircleGeometry.prototype.constructor = THREE.CircleGeometry;\r\n\r\n// File:src/extras/geometries/CubeGeometry.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\n\r\nTHREE.CubeGeometry = function ( width, height, depth, widthSegments, heightSegments, depthSegments ) {\r\n\r\n\tTHREE.warn( 'THREE.CubeGeometry has been renamed to THREE.BoxGeometry.' );\r\n\treturn new THREE.BoxGeometry( width, height, depth, widthSegments, heightSegments, depthSegments );\r\n\r\n };\r\n\r\n// File:src/extras/geometries/CylinderGeometry.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.CylinderGeometry = function ( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tthis.type = 'CylinderGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tradiusTop: radiusTop,\r\n\t\tradiusBottom: radiusBottom,\r\n\t\theight: height,\r\n\t\tradialSegments: radialSegments,\r\n\t\theightSegments: heightSegments,\r\n\t\topenEnded: openEnded,\r\n\t\tthetaStart: thetaStart,\r\n\t\tthetaLength: thetaLength\r\n\t};\r\n\r\n\tradiusTop = radiusTop !== undefined ? radiusTop : 20;\r\n\tradiusBottom = radiusBottom !== undefined ? radiusBottom : 20;\r\n\theight = height !== undefined ? height : 100;\r\n\r\n\tradialSegments = radialSegments || 8;\r\n\theightSegments = heightSegments || 1;\r\n\r\n\topenEnded = openEnded !== undefined ? openEnded : false;\r\n\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\r\n\tthetaLength = thetaLength !== undefined ? thetaLength : 2 * Math.PI;\r\n\r\n\tvar heightHalf = height / 2;\r\n\r\n\tvar x, y, vertices = [], uvs = [];\r\n\r\n\tfor ( y = 0; y <= heightSegments; y ++ ) {\r\n\r\n\t\tvar verticesRow = [];\r\n\t\tvar uvsRow = [];\r\n\r\n\t\tvar v = y / heightSegments;\r\n\t\tvar radius = v * ( radiusBottom - radiusTop ) + radiusTop;\r\n\r\n\t\tfor ( x = 0; x <= radialSegments; x ++ ) {\r\n\r\n\t\t\tvar u = x / radialSegments;\r\n\r\n\t\t\tvar vertex = new THREE.Vector3();\r\n\t\t\tvertex.x = radius * Math.sin( u * thetaLength + thetaStart );\r\n\t\t\tvertex.y = - v * height + heightHalf;\r\n\t\t\tvertex.z = radius * Math.cos( u * thetaLength + thetaStart );\r\n\r\n\t\t\tthis.vertices.push( vertex );\r\n\r\n\t\t\tverticesRow.push( this.vertices.length - 1 );\r\n\t\t\tuvsRow.push( new THREE.Vector2( u, 1 - v ) );\r\n\r\n\t\t}\r\n\r\n\t\tvertices.push( verticesRow );\r\n\t\tuvs.push( uvsRow );\r\n\r\n\t}\r\n\r\n\tvar tanTheta = ( radiusBottom - radiusTop ) / height;\r\n\tvar na, nb;\r\n\r\n\tfor ( x = 0; x < radialSegments; x ++ ) {\r\n\r\n\t\tif ( radiusTop !== 0 ) {\r\n\r\n\t\t\tna = this.vertices[ vertices[ 0 ][ x ] ].clone();\r\n\t\t\tnb = this.vertices[ vertices[ 0 ][ x + 1 ] ].clone();\r\n\r\n\t\t} else {\r\n\r\n\t\t\tna = this.vertices[ vertices[ 1 ][ x ] ].clone();\r\n\t\t\tnb = this.vertices[ vertices[ 1 ][ x + 1 ] ].clone();\r\n\r\n\t\t}\r\n\r\n\t\tna.setY( Math.sqrt( na.x * na.x + na.z * na.z ) * tanTheta ).normalize();\r\n\t\tnb.setY( Math.sqrt( nb.x * nb.x + nb.z * nb.z ) * tanTheta ).normalize();\r\n\r\n\t\tfor ( y = 0; y < heightSegments; y ++ ) {\r\n\r\n\t\t\tvar v1 = vertices[ y ][ x ];\r\n\t\t\tvar v2 = vertices[ y + 1 ][ x ];\r\n\t\t\tvar v3 = vertices[ y + 1 ][ x + 1 ];\r\n\t\t\tvar v4 = vertices[ y ][ x + 1 ];\r\n\r\n\t\t\tvar n1 = na.clone();\r\n\t\t\tvar n2 = na.clone();\r\n\t\t\tvar n3 = nb.clone();\r\n\t\t\tvar n4 = nb.clone();\r\n\r\n\t\t\tvar uv1 = uvs[ y ][ x ].clone();\r\n\t\t\tvar uv2 = uvs[ y + 1 ][ x ].clone();\r\n\t\t\tvar uv3 = uvs[ y + 1 ][ x + 1 ].clone();\r\n\t\t\tvar uv4 = uvs[ y ][ x + 1 ].clone();\r\n\r\n\t\t\tthis.faces.push( new THREE.Face3( v1, v2, v4, [ n1, n2, n4 ] ) );\r\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv4 ] );\r\n\r\n\t\t\tthis.faces.push( new THREE.Face3( v2, v3, v4, [ n2.clone(), n3, n4.clone() ] ) );\r\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uv2.clone(), uv3, uv4.clone() ] );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// top cap\r\n\r\n\tif ( openEnded === false && radiusTop > 0 ) {\r\n\r\n\t\tthis.vertices.push( new THREE.Vector3( 0, heightHalf, 0 ) );\r\n\r\n\t\tfor ( x = 0; x < radialSegments; x ++ ) {\r\n\r\n\t\t\tvar v1 = vertices[ 0 ][ x ];\r\n\t\t\tvar v2 = vertices[ 0 ][ x + 1 ];\r\n\t\t\tvar v3 = this.vertices.length - 1;\r\n\r\n\t\t\tvar n1 = new THREE.Vector3( 0, 1, 0 );\r\n\t\t\tvar n2 = new THREE.Vector3( 0, 1, 0 );\r\n\t\t\tvar n3 = new THREE.Vector3( 0, 1, 0 );\r\n\r\n\t\t\tvar uv1 = uvs[ 0 ][ x ].clone();\r\n\t\t\tvar uv2 = uvs[ 0 ][ x + 1 ].clone();\r\n\t\t\tvar uv3 = new THREE.Vector2( uv2.x, 0 );\r\n\r\n\t\t\tthis.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );\r\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// bottom cap\r\n\r\n\tif ( openEnded === false && radiusBottom > 0 ) {\r\n\r\n\t\tthis.vertices.push( new THREE.Vector3( 0, - heightHalf, 0 ) );\r\n\r\n\t\tfor ( x = 0; x < radialSegments; x ++ ) {\r\n\r\n\t\t\tvar v1 = vertices[ heightSegments ][ x + 1 ];\r\n\t\t\tvar v2 = vertices[ heightSegments ][ x ];\r\n\t\t\tvar v3 = this.vertices.length - 1;\r\n\r\n\t\t\tvar n1 = new THREE.Vector3( 0, - 1, 0 );\r\n\t\t\tvar n2 = new THREE.Vector3( 0, - 1, 0 );\r\n\t\t\tvar n3 = new THREE.Vector3( 0, - 1, 0 );\r\n\r\n\t\t\tvar uv1 = uvs[ heightSegments ][ x + 1 ].clone();\r\n\t\t\tvar uv2 = uvs[ heightSegments ][ x ].clone();\r\n\t\t\tvar uv3 = new THREE.Vector2( uv2.x, 1 );\r\n\r\n\t\t\tthis.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );\r\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tthis.computeFaceNormals();\r\n\r\n};\r\n\r\nTHREE.CylinderGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.CylinderGeometry.prototype.constructor = THREE.CylinderGeometry;\r\n\r\n// File:src/extras/geometries/ExtrudeGeometry.js\r\n\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n *\r\n * Creates extruded geometry from a path shape.\r\n *\r\n * parameters = {\r\n *\r\n *  curveSegments: <int>, // number of points on the curves\r\n *  steps: <int>, // number of points for z-side extrusions / used for subdividing segements of extrude spline too\r\n *  amount: <int>, // Depth to extrude the shape\r\n *\r\n *  bevelEnabled: <bool>, // turn on bevel\r\n *  bevelThickness: <float>, // how deep into the original shape bevel goes\r\n *  bevelSize: <float>, // how far from shape outline is bevel\r\n *  bevelSegments: <int>, // number of bevel layers\r\n *\r\n *  extrudePath: <THREE.CurvePath> // 3d spline path to extrude shape along. (creates Frames if .frames aren't defined)\r\n *  frames: <THREE.TubeGeometry.FrenetFrames> // containing arrays of tangents, normals, binormals\r\n *\r\n *  material: <int> // material index for front and back faces\r\n *  extrudeMaterial: <int> // material index for extrusion and beveled faces\r\n *  uvGenerator: <Object> // object that provides UV generator functions\r\n *\r\n * }\r\n **/\r\n\r\nTHREE.ExtrudeGeometry = function ( shapes, options ) {\r\n\r\n\tif ( typeof( shapes ) === \"undefined\" ) {\r\n\t\tshapes = [];\r\n\t\treturn;\r\n\t}\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tthis.type = 'ExtrudeGeometry';\r\n\r\n\tshapes = shapes instanceof Array ? shapes : [ shapes ];\r\n\r\n\tthis.addShapeList( shapes, options );\r\n\r\n\tthis.computeFaceNormals();\r\n\r\n\t// can't really use automatic vertex normals\r\n\t// as then front and back sides get smoothed too\r\n\t// should do separate smoothing just for sides\r\n\r\n\t//this.computeVertexNormals();\r\n\r\n\t//console.log( \"took\", ( Date.now() - startTime ) );\r\n\r\n};\r\n\r\nTHREE.ExtrudeGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.ExtrudeGeometry.prototype.constructor = THREE.ExtrudeGeometry;\r\n\r\nTHREE.ExtrudeGeometry.prototype.addShapeList = function ( shapes, options ) {\r\n\tvar sl = shapes.length;\r\n\r\n\tfor ( var s = 0; s < sl; s ++ ) {\r\n\t\tvar shape = shapes[ s ];\r\n\t\tthis.addShape( shape, options );\r\n\t}\r\n};\r\n\r\nTHREE.ExtrudeGeometry.prototype.addShape = function ( shape, options ) {\r\n\r\n\tvar amount = options.amount !== undefined ? options.amount : 100;\r\n\r\n\tvar bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10\r\n\tvar bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8\r\n\tvar bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;\r\n\r\n\tvar bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false\r\n\r\n\tvar curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\r\n\r\n\tvar steps = options.steps !== undefined ? options.steps : 1;\r\n\r\n\tvar extrudePath = options.extrudePath;\r\n\tvar extrudePts, extrudeByPath = false;\r\n\r\n\tvar material = options.material;\r\n\tvar extrudeMaterial = options.extrudeMaterial;\r\n\r\n\t// Use default WorldUVGenerator if no UV generators are specified.\r\n\tvar uvgen = options.UVGenerator !== undefined ? options.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator;\r\n\r\n\tvar splineTube, binormal, normal, position2;\r\n\tif ( extrudePath ) {\r\n\r\n\t\textrudePts = extrudePath.getSpacedPoints( steps );\r\n\r\n\t\textrudeByPath = true;\r\n\t\tbevelEnabled = false; // bevels not supported for path extrusion\r\n\r\n\t\t// SETUP TNB variables\r\n\r\n\t\t// Reuse TNB from TubeGeomtry for now.\r\n\t\t// TODO1 - have a .isClosed in spline?\r\n\r\n\t\tsplineTube = options.frames !== undefined ? options.frames : new THREE.TubeGeometry.FrenetFrames(extrudePath, steps, false);\r\n\r\n\t\t// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);\r\n\r\n\t\tbinormal = new THREE.Vector3();\r\n\t\tnormal = new THREE.Vector3();\r\n\t\tposition2 = new THREE.Vector3();\r\n\r\n\t}\r\n\r\n\t// Safeguards if bevels are not enabled\r\n\r\n\tif ( ! bevelEnabled ) {\r\n\r\n\t\tbevelSegments = 0;\r\n\t\tbevelThickness = 0;\r\n\t\tbevelSize = 0;\r\n\r\n\t}\r\n\r\n\t// Variables initalization\r\n\r\n\tvar ahole, h, hl; // looping of holes\r\n\tvar scope = this;\r\n\r\n\tvar shapesOffset = this.vertices.length;\r\n\r\n\tvar shapePoints = shape.extractPoints( curveSegments );\r\n\r\n\tvar vertices = shapePoints.shape;\r\n\tvar holes = shapePoints.holes;\r\n\r\n\tvar reverse = ! THREE.Shape.Utils.isClockWise( vertices ) ;\r\n\r\n\tif ( reverse ) {\r\n\r\n\t\tvertices = vertices.reverse();\r\n\r\n\t\t// Maybe we should also check if holes are in the opposite direction, just to be safe ...\r\n\r\n\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n\t\t\tahole = holes[ h ];\r\n\r\n\t\t\tif ( THREE.Shape.Utils.isClockWise( ahole ) ) {\r\n\r\n\t\t\t\tholes[ h ] = ahole.reverse();\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treverse = false; // If vertices are in order now, we shouldn't need to worry about them again (hopefully)!\r\n\r\n\t}\r\n\r\n\r\n\tvar faces = THREE.Shape.Utils.triangulateShape ( vertices, holes );\r\n\r\n\t/* Vertices */\r\n\r\n\tvar contour = vertices; // vertices has all points but contour has only points of circumference\r\n\r\n\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n\t\tahole = holes[ h ];\r\n\r\n\t\tvertices = vertices.concat( ahole );\r\n\r\n\t}\r\n\r\n\r\n\tfunction scalePt2 ( pt, vec, size ) {\r\n\r\n\t\tif ( ! vec ) THREE.error( \"THREE.ExtrudeGeometry: vec does not exist\" );\r\n\r\n\t\treturn vec.clone().multiplyScalar( size ).add( pt );\r\n\r\n\t}\r\n\r\n\tvar b, bs, t, z,\r\n\t\tvert, vlen = vertices.length,\r\n\t\tface, flen = faces.length;\r\n\r\n\r\n\t// Find directions for point movement\r\n\r\n\r\n\tfunction getBevelVec( inPt, inPrev, inNext ) {\r\n\r\n\t\tvar EPSILON = 0.0000000001;\r\n\t\t\r\n\t\t// computes for inPt the corresponding point inPt' on a new contour\r\n\t\t//   shiftet by 1 unit (length of normalized vector) to the left\r\n\t\t// if we walk along contour clockwise, this new contour is outside the old one\r\n\t\t//\r\n\t\t// inPt' is the intersection of the two lines parallel to the two\r\n\t\t//  adjacent edges of inPt at a distance of 1 unit on the left side.\r\n\t\t\r\n\t\tvar v_trans_x, v_trans_y, shrink_by = 1;\t\t// resulting translation vector for inPt\r\n\r\n\t\t// good reading for geometry algorithms (here: line-line intersection)\r\n\t\t// http://geomalgorithms.com/a05-_intersect-1.html\r\n\r\n\t\tvar v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;\r\n\t\tvar v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;\r\n\t\t\r\n\t\tvar v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );\r\n\t\t\r\n\t\t// check for colinear edges\r\n\t\tvar colinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );\r\n\t\t\r\n\t\tif ( Math.abs( colinear0 ) > EPSILON ) {\t\t// not colinear\r\n\t\t\t\r\n\t\t\t// length of vectors for normalizing\r\n\t\r\n\t\t\tvar v_prev_len = Math.sqrt( v_prev_lensq );\r\n\t\t\tvar v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );\r\n\t\t\t\r\n\t\t\t// shift adjacent points by unit vectors to the left\r\n\t\r\n\t\t\tvar ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );\r\n\t\t\tvar ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );\r\n\t\t\t\r\n\t\t\tvar ptNextShift_x = ( inNext.x - v_next_y / v_next_len );\r\n\t\t\tvar ptNextShift_y = ( inNext.y + v_next_x / v_next_len );\r\n\t\r\n\t\t\t// scaling factor for v_prev to intersection point\r\n\t\r\n\t\t\tvar sf = (  ( ptNextShift_x - ptPrevShift_x ) * v_next_y -\r\n\t\t\t\t\t\t( ptNextShift_y - ptPrevShift_y ) * v_next_x    ) /\r\n\t\t\t\t\t  ( v_prev_x * v_next_y - v_prev_y * v_next_x );\r\n\t\r\n\t\t\t// vector from inPt to intersection point\r\n\t\r\n\t\t\tv_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );\r\n\t\t\tv_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );\r\n\t\r\n\t\t\t// Don't normalize!, otherwise sharp corners become ugly\r\n\t\t\t//  but prevent crazy spikes\r\n\t\t\tvar v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y )\r\n\t\t\tif ( v_trans_lensq <= 2 ) {\r\n\t\t\t\treturn\tnew THREE.Vector2( v_trans_x, v_trans_y );\r\n\t\t\t} else {\r\n\t\t\t\tshrink_by = Math.sqrt( v_trans_lensq / 2 );\r\n\t\t\t}\r\n\t\t\t\r\n\t\t} else {\t\t// handle special case of colinear edges\r\n\r\n\t\t\tvar direction_eq = false;\t\t// assumes: opposite\r\n\t\t\tif ( v_prev_x > EPSILON ) {\r\n\t\t\t\tif ( v_next_x > EPSILON ) { direction_eq = true; }\r\n\t\t\t} else {\r\n\t\t\t\tif ( v_prev_x < - EPSILON ) {\r\n\t\t\t\t\tif ( v_next_x < - EPSILON ) { direction_eq = true; }\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif ( Math.sign(v_prev_y) == Math.sign(v_next_y) ) { direction_eq = true; }\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif ( direction_eq ) {\r\n\t\t\t\t// console.log(\"Warning: lines are a straight sequence\");\r\n\t\t\t\tv_trans_x = - v_prev_y;\r\n\t\t\t\tv_trans_y =  v_prev_x;\r\n\t\t\t\tshrink_by = Math.sqrt( v_prev_lensq );\r\n\t\t\t} else {\r\n\t\t\t\t// console.log(\"Warning: lines are a straight spike\");\r\n\t\t\t\tv_trans_x = v_prev_x;\r\n\t\t\t\tv_trans_y = v_prev_y;\r\n\t\t\t\tshrink_by = Math.sqrt( v_prev_lensq / 2 );\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn\tnew THREE.Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );\r\n\r\n\t}\r\n\r\n\r\n\tvar contourMovements = [];\r\n\r\n\tfor ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\r\n\r\n\t\tif ( j === il ) j = 0;\r\n\t\tif ( k === il ) k = 0;\r\n\r\n\t\t//  (j)---(i)---(k)\r\n\t\t// console.log('i,j,k', i, j , k)\r\n\r\n\t\tcontourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );\r\n\r\n\t}\r\n\r\n\tvar holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();\r\n\r\n\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n\t\tahole = holes[ h ];\r\n\r\n\t\toneHoleMovements = [];\r\n\r\n\t\tfor ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\r\n\r\n\t\t\tif ( j === il ) j = 0;\r\n\t\t\tif ( k === il ) k = 0;\r\n\r\n\t\t\t//  (j)---(i)---(k)\r\n\t\t\toneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );\r\n\r\n\t\t}\r\n\r\n\t\tholesMovements.push( oneHoleMovements );\r\n\t\tverticesMovements = verticesMovements.concat( oneHoleMovements );\r\n\r\n\t}\r\n\r\n\r\n\t// Loop bevelSegments, 1 for the front, 1 for the back\r\n\r\n\tfor ( b = 0; b < bevelSegments; b ++ ) {\r\n\t//for ( b = bevelSegments; b > 0; b -- ) {\r\n\r\n\t\tt = b / bevelSegments;\r\n\t\tz = bevelThickness * ( 1 - t );\r\n\r\n\t\t//z = bevelThickness * t;\r\n\t\tbs = bevelSize * ( Math.sin ( t * Math.PI / 2 ) ) ; // curved\r\n\t\t//bs = bevelSize * t ; // linear\r\n\r\n\t\t// contract shape\r\n\r\n\t\tfor ( i = 0, il = contour.length; i < il; i ++ ) {\r\n\r\n\t\t\tvert = scalePt2( contour[ i ], contourMovements[ i ], bs );\r\n\r\n\t\t\tv( vert.x, vert.y,  - z );\r\n\r\n\t\t}\r\n\r\n\t\t// expand holes\r\n\r\n\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n\t\t\tahole = holes[ h ];\r\n\t\t\toneHoleMovements = holesMovements[ h ];\r\n\r\n\t\t\tfor ( i = 0, il = ahole.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tvert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\r\n\r\n\t\t\t\tv( vert.x, vert.y,  - z );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tbs = bevelSize;\r\n\r\n\t// Back facing vertices\r\n\r\n\tfor ( i = 0; i < vlen; i ++ ) {\r\n\r\n\t\tvert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\r\n\r\n\t\tif ( ! extrudeByPath ) {\r\n\r\n\t\t\tv( vert.x, vert.y, 0 );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );\r\n\r\n\t\t\tnormal.copy( splineTube.normals[0] ).multiplyScalar(vert.x);\r\n\t\t\tbinormal.copy( splineTube.binormals[0] ).multiplyScalar(vert.y);\r\n\r\n\t\t\tposition2.copy( extrudePts[0] ).add(normal).add(binormal);\r\n\r\n\t\t\tv( position2.x, position2.y, position2.z );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// Add stepped vertices...\r\n\t// Including front facing vertices\r\n\r\n\tvar s;\r\n\r\n\tfor ( s = 1; s <= steps; s ++ ) {\r\n\r\n\t\tfor ( i = 0; i < vlen; i ++ ) {\r\n\r\n\t\t\tvert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\r\n\r\n\t\t\tif ( ! extrudeByPath ) {\r\n\r\n\t\t\t\tv( vert.x, vert.y, amount / steps * s );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );\r\n\r\n\t\t\t\tnormal.copy( splineTube.normals[s] ).multiplyScalar( vert.x );\r\n\t\t\t\tbinormal.copy( splineTube.binormals[s] ).multiplyScalar( vert.y );\r\n\r\n\t\t\t\tposition2.copy( extrudePts[s] ).add( normal ).add( binormal );\r\n\r\n\t\t\t\tv( position2.x, position2.y, position2.z );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\r\n\t// Add bevel segments planes\r\n\r\n\t//for ( b = 1; b <= bevelSegments; b ++ ) {\r\n\tfor ( b = bevelSegments - 1; b >= 0; b -- ) {\r\n\r\n\t\tt = b / bevelSegments;\r\n\t\tz = bevelThickness * ( 1 - t );\r\n\t\t//bs = bevelSize * ( 1-Math.sin ( ( 1 - t ) * Math.PI/2 ) );\r\n\t\tbs = bevelSize * Math.sin ( t * Math.PI / 2 ) ;\r\n\r\n\t\t// contract shape\r\n\r\n\t\tfor ( i = 0, il = contour.length; i < il; i ++ ) {\r\n\r\n\t\t\tvert = scalePt2( contour[ i ], contourMovements[ i ], bs );\r\n\t\t\tv( vert.x, vert.y,  amount + z );\r\n\r\n\t\t}\r\n\r\n\t\t// expand holes\r\n\r\n\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n\t\t\tahole = holes[ h ];\r\n\t\t\toneHoleMovements = holesMovements[ h ];\r\n\r\n\t\t\tfor ( i = 0, il = ahole.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tvert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\r\n\r\n\t\t\t\tif ( ! extrudeByPath ) {\r\n\r\n\t\t\t\t\tv( vert.x, vert.y,  amount + z );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tv( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/* Faces */\r\n\r\n\t// Top and bottom faces\r\n\r\n\tbuildLidFaces();\r\n\r\n\t// Sides faces\r\n\r\n\tbuildSideFaces();\r\n\r\n\r\n\t/////  Internal functions\r\n\r\n\tfunction buildLidFaces() {\r\n\r\n\t\tif ( bevelEnabled ) {\r\n\r\n\t\t\tvar layer = 0 ; // steps + 1\r\n\t\t\tvar offset = vlen * layer;\r\n\r\n\t\t\t// Bottom faces\r\n\r\n\t\t\tfor ( i = 0; i < flen; i ++ ) {\r\n\r\n\t\t\t\tface = faces[ i ];\r\n\t\t\t\tf3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tlayer = steps + bevelSegments * 2;\r\n\t\t\toffset = vlen * layer;\r\n\r\n\t\t\t// Top faces\r\n\r\n\t\t\tfor ( i = 0; i < flen; i ++ ) {\r\n\r\n\t\t\t\tface = faces[ i ];\r\n\t\t\t\tf3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// Bottom faces\r\n\r\n\t\t\tfor ( i = 0; i < flen; i ++ ) {\r\n\r\n\t\t\t\tface = faces[ i ];\r\n\t\t\t\tf3( face[ 2 ], face[ 1 ], face[ 0 ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Top faces\r\n\r\n\t\t\tfor ( i = 0; i < flen; i ++ ) {\r\n\r\n\t\t\t\tface = faces[ i ];\r\n\t\t\t\tf3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );\r\n\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// Create faces for the z-sides of the shape\r\n\r\n\tfunction buildSideFaces() {\r\n\r\n\t\tvar layeroffset = 0;\r\n\t\tsidewalls( contour, layeroffset );\r\n\t\tlayeroffset += contour.length;\r\n\r\n\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n\t\t\tahole = holes[ h ];\r\n\t\t\tsidewalls( ahole, layeroffset );\r\n\r\n\t\t\t//, true\r\n\t\t\tlayeroffset += ahole.length;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction sidewalls( contour, layeroffset ) {\r\n\r\n\t\tvar j, k;\r\n\t\ti = contour.length;\r\n\r\n\t\twhile ( -- i >= 0 ) {\r\n\r\n\t\t\tj = i;\r\n\t\t\tk = i - 1;\r\n\t\t\tif ( k < 0 ) k = contour.length - 1;\r\n\r\n\t\t\t//console.log('b', i,j, i-1, k,vertices.length);\r\n\r\n\t\t\tvar s = 0, sl = steps  + bevelSegments * 2;\r\n\r\n\t\t\tfor ( s = 0; s < sl; s ++ ) {\r\n\r\n\t\t\t\tvar slen1 = vlen * s;\r\n\t\t\t\tvar slen2 = vlen * ( s + 1 );\r\n\r\n\t\t\t\tvar a = layeroffset + j + slen1,\r\n\t\t\t\t\tb = layeroffset + k + slen1,\r\n\t\t\t\t\tc = layeroffset + k + slen2,\r\n\t\t\t\t\td = layeroffset + j + slen2;\r\n\r\n\t\t\t\tf4( a, b, c, d, contour, s, sl, j, k );\r\n\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t}\r\n\r\n\r\n\tfunction v( x, y, z ) {\r\n\r\n\t\tscope.vertices.push( new THREE.Vector3( x, y, z ) );\r\n\r\n\t}\r\n\r\n\tfunction f3( a, b, c ) {\r\n\r\n\t\ta += shapesOffset;\r\n\t\tb += shapesOffset;\r\n\t\tc += shapesOffset;\r\n\r\n\t\t// normal, color, material\r\n\t\tscope.faces.push( new THREE.Face3( a, b, c, null, null, material ) );\r\n\r\n\t\tvar uvs = uvgen.generateTopUV( scope, a, b, c );\r\n\r\n\t\tscope.faceVertexUvs[ 0 ].push( uvs );\r\n\r\n\t}\r\n\r\n\tfunction f4( a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2 ) {\r\n\r\n\t\ta += shapesOffset;\r\n\t\tb += shapesOffset;\r\n\t\tc += shapesOffset;\r\n\t\td += shapesOffset;\r\n\r\n\t\tscope.faces.push( new THREE.Face3( a, b, d, null, null, extrudeMaterial ) );\r\n\t\tscope.faces.push( new THREE.Face3( b, c, d, null, null, extrudeMaterial ) );\r\n\r\n\t\tvar uvs = uvgen.generateSideWallUV( scope, a, b, c, d );\r\n\r\n\t\tscope.faceVertexUvs[ 0 ].push( [ uvs[ 0 ], uvs[ 1 ], uvs[ 3 ] ] );\r\n\t\tscope.faceVertexUvs[ 0 ].push( [ uvs[ 1 ], uvs[ 2 ], uvs[ 3 ] ] );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.ExtrudeGeometry.WorldUVGenerator = {\r\n\r\n\tgenerateTopUV: function ( geometry, indexA, indexB, indexC ) {\r\n\r\n\t\tvar vertices = geometry.vertices;\r\n\r\n\t\tvar a = vertices[ indexA ];\r\n\t\tvar b = vertices[ indexB ];\r\n\t\tvar c = vertices[ indexC ];\r\n\r\n\t\treturn [\r\n\t\t\tnew THREE.Vector2( a.x, a.y ),\r\n\t\t\tnew THREE.Vector2( b.x, b.y ),\r\n\t\t\tnew THREE.Vector2( c.x, c.y )\r\n\t\t];\r\n\r\n\t},\r\n\r\n\tgenerateSideWallUV: function ( geometry, indexA, indexB, indexC, indexD ) {\r\n\r\n\t\tvar vertices = geometry.vertices;\r\n\r\n\t\tvar a = vertices[ indexA ];\r\n\t\tvar b = vertices[ indexB ];\r\n\t\tvar c = vertices[ indexC ];\r\n\t\tvar d = vertices[ indexD ];\r\n\r\n\t\tif ( Math.abs( a.y - b.y ) < 0.01 ) {\r\n\t\t\treturn [\r\n\t\t\t\tnew THREE.Vector2( a.x, 1 - a.z ),\r\n\t\t\t\tnew THREE.Vector2( b.x, 1 - b.z ),\r\n\t\t\t\tnew THREE.Vector2( c.x, 1 - c.z ),\r\n\t\t\t\tnew THREE.Vector2( d.x, 1 - d.z )\r\n\t\t\t];\r\n\t\t} else {\r\n\t\t\treturn [\r\n\t\t\t\tnew THREE.Vector2( a.y, 1 - a.z ),\r\n\t\t\t\tnew THREE.Vector2( b.y, 1 - b.z ),\r\n\t\t\t\tnew THREE.Vector2( c.y, 1 - c.z ),\r\n\t\t\t\tnew THREE.Vector2( d.y, 1 - d.z )\r\n\t\t\t];\r\n\t\t}\r\n\t}\r\n};\r\n\r\n// File:src/extras/geometries/ShapeGeometry.js\r\n\r\n/**\r\n * @author jonobr1 / http://jonobr1.com\r\n *\r\n * Creates a one-sided polygonal geometry from a path shape. Similar to\r\n * ExtrudeGeometry.\r\n *\r\n * parameters = {\r\n *\r\n *\tcurveSegments: <int>, // number of points on the curves. NOT USED AT THE MOMENT.\r\n *\r\n *\tmaterial: <int> // material index for front and back faces\r\n *\tuvGenerator: <Object> // object that provides UV generator functions\r\n *\r\n * }\r\n **/\r\n\r\nTHREE.ShapeGeometry = function ( shapes, options ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tthis.type = 'ShapeGeometry';\r\n\r\n\tif ( shapes instanceof Array === false ) shapes = [ shapes ];\r\n\r\n\tthis.addShapeList( shapes, options );\r\n\r\n\tthis.computeFaceNormals();\r\n\r\n};\r\n\r\nTHREE.ShapeGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.ShapeGeometry.prototype.constructor = THREE.ShapeGeometry;\r\n\r\n/**\r\n * Add an array of shapes to THREE.ShapeGeometry.\r\n */\r\nTHREE.ShapeGeometry.prototype.addShapeList = function ( shapes, options ) {\r\n\r\n\tfor ( var i = 0, l = shapes.length; i < l; i ++ ) {\r\n\r\n\t\tthis.addShape( shapes[ i ], options );\r\n\r\n\t}\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\n/**\r\n * Adds a shape to THREE.ShapeGeometry, based on THREE.ExtrudeGeometry.\r\n */\r\nTHREE.ShapeGeometry.prototype.addShape = function ( shape, options ) {\r\n\r\n\tif ( options === undefined ) options = {};\r\n\tvar curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\r\n\r\n\tvar material = options.material;\r\n\tvar uvgen = options.UVGenerator === undefined ? THREE.ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;\r\n\r\n\t//\r\n\r\n\tvar i, l, hole;\r\n\r\n\tvar shapesOffset = this.vertices.length;\r\n\tvar shapePoints = shape.extractPoints( curveSegments );\r\n\r\n\tvar vertices = shapePoints.shape;\r\n\tvar holes = shapePoints.holes;\r\n\r\n\tvar reverse = ! THREE.Shape.Utils.isClockWise( vertices );\r\n\r\n\tif ( reverse ) {\r\n\r\n\t\tvertices = vertices.reverse();\r\n\r\n\t\t// Maybe we should also check if holes are in the opposite direction, just to be safe...\r\n\r\n\t\tfor ( i = 0, l = holes.length; i < l; i ++ ) {\r\n\r\n\t\t\thole = holes[ i ];\r\n\r\n\t\t\tif ( THREE.Shape.Utils.isClockWise( hole ) ) {\r\n\r\n\t\t\t\tholes[ i ] = hole.reverse();\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treverse = false;\r\n\r\n\t}\r\n\r\n\tvar faces = THREE.Shape.Utils.triangulateShape( vertices, holes );\r\n\r\n\t// Vertices\r\n\r\n\tvar contour = vertices;\r\n\r\n\tfor ( i = 0, l = holes.length; i < l; i ++ ) {\r\n\r\n\t\thole = holes[ i ];\r\n\t\tvertices = vertices.concat( hole );\r\n\r\n\t}\r\n\r\n\t//\r\n\r\n\tvar vert, vlen = vertices.length;\r\n\tvar face, flen = faces.length;\r\n\r\n\tfor ( i = 0; i < vlen; i ++ ) {\r\n\r\n\t\tvert = vertices[ i ];\r\n\r\n\t\tthis.vertices.push( new THREE.Vector3( vert.x, vert.y, 0 ) );\r\n\r\n\t}\r\n\r\n\tfor ( i = 0; i < flen; i ++ ) {\r\n\r\n\t\tface = faces[ i ];\r\n\r\n\t\tvar a = face[ 0 ] + shapesOffset;\r\n\t\tvar b = face[ 1 ] + shapesOffset;\r\n\t\tvar c = face[ 2 ] + shapesOffset;\r\n\r\n\t\tthis.faces.push( new THREE.Face3( a, b, c, null, null, material ) );\r\n\t\tthis.faceVertexUvs[ 0 ].push( uvgen.generateTopUV( this, a, b, c ) );\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/extras/geometries/LatheGeometry.js\r\n\r\n/**\r\n * @author astrodud / http://astrodud.isgreat.org/\r\n * @author zz85 / https://github.com/zz85\r\n * @author bhouston / http://exocortex.com\r\n */\r\n\r\n// points - to create a closed torus, one must use a set of points \r\n//    like so: [ a, b, c, d, a ], see first is the same as last.\r\n// segments - the number of circumference segments to create\r\n// phiStart - the starting radian\r\n// phiLength - the radian (0 to 2*PI) range of the lathed section\r\n//    2*pi is a closed lathe, less than 2PI is a portion.\r\n\r\nTHREE.LatheGeometry = function ( points, segments, phiStart, phiLength ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tthis.type = 'LatheGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tpoints: points,\r\n\t\tsegments: segments,\r\n\t\tphiStart: phiStart,\r\n\t\tphiLength: phiLength\r\n\t};\r\n\r\n\tsegments = segments || 12;\r\n\tphiStart = phiStart || 0;\r\n\tphiLength = phiLength || 2 * Math.PI;\r\n\r\n\tvar inversePointLength = 1.0 / ( points.length - 1 );\r\n\tvar inverseSegments = 1.0 / segments;\r\n\r\n\tfor ( var i = 0, il = segments; i <= il; i ++ ) {\r\n\r\n\t\tvar phi = phiStart + i * inverseSegments * phiLength;\r\n\r\n\t\tvar c = Math.cos( phi ),\r\n\t\t\ts = Math.sin( phi );\r\n\r\n\t\tfor ( var j = 0, jl = points.length; j < jl; j ++ ) {\r\n\r\n\t\t\tvar pt = points[ j ];\r\n\r\n\t\t\tvar vertex = new THREE.Vector3();\r\n\r\n\t\t\tvertex.x = c * pt.x - s * pt.y;\r\n\t\t\tvertex.y = s * pt.x + c * pt.y;\r\n\t\t\tvertex.z = pt.z;\r\n\r\n\t\t\tthis.vertices.push( vertex );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tvar np = points.length;\r\n\r\n\tfor ( var i = 0, il = segments; i < il; i ++ ) {\r\n\r\n\t\tfor ( var j = 0, jl = points.length - 1; j < jl; j ++ ) {\r\n\r\n\t\t\tvar base = j + np * i;\r\n\t\t\tvar a = base;\r\n\t\t\tvar b = base + np;\r\n\t\t\tvar c = base + 1 + np;\r\n\t\t\tvar d = base + 1;\r\n\r\n\t\t\tvar u0 = i * inverseSegments;\r\n\t\t\tvar v0 = j * inversePointLength;\r\n\t\t\tvar u1 = u0 + inverseSegments;\r\n\t\t\tvar v1 = v0 + inversePointLength;\r\n\r\n\t\t\tthis.faces.push( new THREE.Face3( a, b, d ) );\r\n\r\n\t\t\tthis.faceVertexUvs[ 0 ].push( [\r\n\r\n\t\t\t\tnew THREE.Vector2( u0, v0 ),\r\n\t\t\t\tnew THREE.Vector2( u1, v0 ),\r\n\t\t\t\tnew THREE.Vector2( u0, v1 )\r\n\r\n\t\t\t] );\r\n\r\n\t\t\tthis.faces.push( new THREE.Face3( b, c, d ) );\r\n\r\n\t\t\tthis.faceVertexUvs[ 0 ].push( [\r\n\r\n\t\t\t\tnew THREE.Vector2( u1, v0 ),\r\n\t\t\t\tnew THREE.Vector2( u1, v1 ),\r\n\t\t\t\tnew THREE.Vector2( u0, v1 )\r\n\r\n\t\t\t] );\r\n\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tthis.mergeVertices();\r\n\tthis.computeFaceNormals();\r\n\tthis.computeVertexNormals();\r\n\r\n};\r\n\r\nTHREE.LatheGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.LatheGeometry.prototype.constructor = THREE.LatheGeometry;\r\n\r\n// File:src/extras/geometries/PlaneGeometry.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as\r\n */\r\n\r\nTHREE.PlaneGeometry = function ( width, height, widthSegments, heightSegments ) {\r\n\r\n\tconsole.info( 'THREE.PlaneGeometry: Consider using THREE.PlaneBufferGeometry for lower memory footprint.' );\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tthis.type = 'PlaneGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\twidth: width,\r\n\t\theight: height,\r\n\t\twidthSegments: widthSegments,\r\n\t\theightSegments: heightSegments\r\n\t};\r\n\r\n\tthis.fromBufferGeometry( new THREE.PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );\r\n\r\n};\r\n\r\nTHREE.PlaneGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.PlaneGeometry.prototype.constructor = THREE.PlaneGeometry;\r\n\r\n// File:src/extras/geometries/PlaneBufferGeometry.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as\r\n */\r\n\r\nTHREE.PlaneBufferGeometry = function ( width, height, widthSegments, heightSegments ) {\r\n\r\n\tTHREE.BufferGeometry.call( this );\r\n\r\n\tthis.type = 'PlaneBufferGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\twidth: width,\r\n\t\theight: height,\r\n\t\twidthSegments: widthSegments,\r\n\t\theightSegments: heightSegments\r\n\t};\r\n\r\n\tvar width_half = width / 2;\r\n\tvar height_half = height / 2;\r\n\r\n\tvar gridX = widthSegments || 1;\r\n\tvar gridY = heightSegments || 1;\r\n\r\n\tvar gridX1 = gridX + 1;\r\n\tvar gridY1 = gridY + 1;\r\n\r\n\tvar segment_width = width / gridX;\r\n\tvar segment_height = height / gridY;\r\n\r\n\tvar vertices = new Float32Array( gridX1 * gridY1 * 3 );\r\n\tvar normals = new Float32Array( gridX1 * gridY1 * 3 );\r\n\tvar uvs = new Float32Array( gridX1 * gridY1 * 2 );\r\n\r\n\tvar offset = 0;\r\n\tvar offset2 = 0;\r\n\r\n\tfor ( var iy = 0; iy < gridY1; iy ++ ) {\r\n\r\n\t\tvar y = iy * segment_height - height_half;\r\n\r\n\t\tfor ( var ix = 0; ix < gridX1; ix ++ ) {\r\n\r\n\t\t\tvar x = ix * segment_width - width_half;\r\n\r\n\t\t\tvertices[ offset     ] = x;\r\n\t\t\tvertices[ offset + 1 ] = - y;\r\n\r\n\t\t\tnormals[ offset + 2 ] = 1;\r\n\r\n\t\t\tuvs[ offset2     ] = ix / gridX;\r\n\t\t\tuvs[ offset2 + 1 ] = 1 - ( iy / gridY );\r\n\r\n\t\t\toffset += 3;\r\n\t\t\toffset2 += 2;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\toffset = 0;\r\n\r\n\tvar indices = new ( ( vertices.length / 3 ) > 65535 ? Uint32Array : Uint16Array )( gridX * gridY * 6 );\r\n\r\n\tfor ( var iy = 0; iy < gridY; iy ++ ) {\r\n\r\n\t\tfor ( var ix = 0; ix < gridX; ix ++ ) {\r\n\r\n\t\t\tvar a = ix + gridX1 * iy;\r\n\t\t\tvar b = ix + gridX1 * ( iy + 1 );\r\n\t\t\tvar c = ( ix + 1 ) + gridX1 * ( iy + 1 );\r\n\t\t\tvar d = ( ix + 1 ) + gridX1 * iy;\r\n\r\n\t\t\tindices[ offset     ] = a;\r\n\t\t\tindices[ offset + 1 ] = b;\r\n\t\t\tindices[ offset + 2 ] = d;\r\n\r\n\t\t\tindices[ offset + 3 ] = b;\r\n\t\t\tindices[ offset + 4 ] = c;\r\n\t\t\tindices[ offset + 5 ] = d;\r\n\r\n\t\t\toffset += 6;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tthis.addAttribute( 'index', new THREE.BufferAttribute( indices, 1 ) );\r\n\tthis.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\r\n\tthis.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );\r\n\tthis.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );\r\n\r\n};\r\n\r\nTHREE.PlaneBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\r\nTHREE.PlaneBufferGeometry.prototype.constructor = THREE.PlaneBufferGeometry;\r\n\r\n// File:src/extras/geometries/RingGeometry.js\r\n\r\n/**\r\n * @author Kaleb Murphy\r\n */\r\n\r\nTHREE.RingGeometry = function ( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tthis.type = 'RingGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tinnerRadius: innerRadius,\r\n\t\touterRadius: outerRadius,\r\n\t\tthetaSegments: thetaSegments,\r\n\t\tphiSegments: phiSegments,\r\n\t\tthetaStart: thetaStart,\r\n\t\tthetaLength: thetaLength\r\n\t};\r\n\r\n\tinnerRadius = innerRadius || 0;\r\n\touterRadius = outerRadius || 50;\r\n\r\n\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\r\n\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\r\n\r\n\tthetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;\r\n\tphiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 8;\r\n\r\n\tvar i, o, uvs = [], radius = innerRadius, radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );\r\n\r\n\tfor ( i = 0; i < phiSegments + 1; i ++ ) { // concentric circles inside ring\r\n\r\n\t\tfor ( o = 0; o < thetaSegments + 1; o ++ ) { // number of segments per circle\r\n\r\n\t\t\tvar vertex = new THREE.Vector3();\r\n\t\t\tvar segment = thetaStart + o / thetaSegments * thetaLength;\r\n\t\t\tvertex.x = radius * Math.cos( segment );\r\n\t\t\tvertex.y = radius * Math.sin( segment );\r\n\r\n\t\t\tthis.vertices.push( vertex );\r\n\t\t\tuvs.push( new THREE.Vector2( ( vertex.x / outerRadius + 1 ) / 2, ( vertex.y / outerRadius + 1 ) / 2 ) );\r\n\t\t}\r\n\r\n\t\tradius += radiusStep;\r\n\r\n\t}\r\n\r\n\tvar n = new THREE.Vector3( 0, 0, 1 );\r\n\r\n\tfor ( i = 0; i < phiSegments; i ++ ) { // concentric circles inside ring\r\n\r\n\t\tvar thetaSegment = i * (thetaSegments + 1);\r\n\r\n\t\tfor ( o = 0; o < thetaSegments ; o ++ ) { // number of segments per circle\r\n\r\n\t\t\tvar segment = o + thetaSegment;\r\n\r\n\t\t\tvar v1 = segment;\r\n\t\t\tvar v2 = segment + thetaSegments + 1;\r\n\t\t\tvar v3 = segment + thetaSegments + 2;\r\n\r\n\t\t\tthis.faces.push( new THREE.Face3( v1, v2, v3, [ n.clone(), n.clone(), n.clone() ] ) );\r\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uvs[ v1 ].clone(), uvs[ v2 ].clone(), uvs[ v3 ].clone() ]);\r\n\r\n\t\t\tv1 = segment;\r\n\t\t\tv2 = segment + thetaSegments + 2;\r\n\t\t\tv3 = segment + 1;\r\n\r\n\t\t\tthis.faces.push( new THREE.Face3( v1, v2, v3, [ n.clone(), n.clone(), n.clone() ] ) );\r\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uvs[ v1 ].clone(), uvs[ v2 ].clone(), uvs[ v3 ].clone() ]);\r\n\r\n\t\t}\r\n\t}\r\n\r\n\tthis.computeFaceNormals();\r\n\r\n\tthis.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\r\n\r\n};\r\n\r\nTHREE.RingGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.RingGeometry.prototype.constructor = THREE.RingGeometry;\r\n\r\n\r\n// File:src/extras/geometries/SphereGeometry.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.SphereGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tthis.type = 'SphereGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tradius: radius,\r\n\t\twidthSegments: widthSegments,\r\n\t\theightSegments: heightSegments,\r\n\t\tphiStart: phiStart,\r\n\t\tphiLength: phiLength,\r\n\t\tthetaStart: thetaStart,\r\n\t\tthetaLength: thetaLength \r\n\t};\r\n\r\n\tradius = radius || 50;\r\n\r\n\twidthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );\r\n\theightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );\r\n\r\n\tphiStart = phiStart !== undefined ? phiStart : 0;\r\n\tphiLength = phiLength !== undefined ? phiLength : Math.PI * 2;\r\n\r\n\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\r\n\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI;\r\n\r\n\tvar x, y, vertices = [], uvs = [];\r\n\r\n\tfor ( y = 0; y <= heightSegments; y ++ ) {\r\n\r\n\t\tvar verticesRow = [];\r\n\t\tvar uvsRow = [];\r\n\r\n\t\tfor ( x = 0; x <= widthSegments; x ++ ) {\r\n\r\n\t\t\tvar u = x / widthSegments;\r\n\t\t\tvar v = y / heightSegments;\r\n\r\n\t\t\tvar vertex = new THREE.Vector3();\r\n\t\t\tvertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\r\n\t\t\tvertex.y = radius * Math.cos( thetaStart + v * thetaLength );\r\n\t\t\tvertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\r\n\r\n\t\t\tthis.vertices.push( vertex );\r\n\r\n\t\t\tverticesRow.push( this.vertices.length - 1 );\r\n\t\t\tuvsRow.push( new THREE.Vector2( u, 1 - v ) );\r\n\r\n\t\t}\r\n\r\n\t\tvertices.push( verticesRow );\r\n\t\tuvs.push( uvsRow );\r\n\r\n\t}\r\n\r\n\tfor ( y = 0; y < heightSegments; y ++ ) {\r\n\r\n\t\tfor ( x = 0; x < widthSegments; x ++ ) {\r\n\r\n\t\t\tvar v1 = vertices[ y ][ x + 1 ];\r\n\t\t\tvar v2 = vertices[ y ][ x ];\r\n\t\t\tvar v3 = vertices[ y + 1 ][ x ];\r\n\t\t\tvar v4 = vertices[ y + 1 ][ x + 1 ];\r\n\r\n\t\t\tvar n1 = this.vertices[ v1 ].clone().normalize();\r\n\t\t\tvar n2 = this.vertices[ v2 ].clone().normalize();\r\n\t\t\tvar n3 = this.vertices[ v3 ].clone().normalize();\r\n\t\t\tvar n4 = this.vertices[ v4 ].clone().normalize();\r\n\r\n\t\t\tvar uv1 = uvs[ y ][ x + 1 ].clone();\r\n\t\t\tvar uv2 = uvs[ y ][ x ].clone();\r\n\t\t\tvar uv3 = uvs[ y + 1 ][ x ].clone();\r\n\t\t\tvar uv4 = uvs[ y + 1 ][ x + 1 ].clone();\r\n\r\n\t\t\tif ( Math.abs( this.vertices[ v1 ].y ) === radius ) {\r\n\r\n\t\t\t\tuv1.x = ( uv1.x + uv2.x ) / 2;\r\n\t\t\t\tthis.faces.push( new THREE.Face3( v1, v3, v4, [ n1, n3, n4 ] ) );\r\n\t\t\t\tthis.faceVertexUvs[ 0 ].push( [ uv1, uv3, uv4 ] );\r\n\r\n\t\t\t} else if ( Math.abs( this.vertices[ v3 ].y ) === radius ) {\r\n\r\n\t\t\t\tuv3.x = ( uv3.x + uv4.x ) / 2;\r\n\t\t\t\tthis.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );\r\n\t\t\t\tthis.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis.faces.push( new THREE.Face3( v1, v2, v4, [ n1, n2, n4 ] ) );\r\n\t\t\t\tthis.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv4 ] );\r\n\r\n\t\t\t\tthis.faces.push( new THREE.Face3( v2, v3, v4, [ n2.clone(), n3, n4.clone() ] ) );\r\n\t\t\t\tthis.faceVertexUvs[ 0 ].push( [ uv2.clone(), uv3, uv4.clone() ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tthis.computeFaceNormals();\r\n\r\n\tthis.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\r\n\r\n};\r\n\r\nTHREE.SphereGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.SphereGeometry.prototype.constructor = THREE.SphereGeometry;\r\n\r\n// File:src/extras/geometries/TextGeometry.js\r\n\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * For creating 3D text geometry in three.js\r\n *\r\n * Text = 3D Text\r\n *\r\n * parameters = {\r\n *  size: \t\t\t<float>, \t// size of the text\r\n *  height: \t\t<float>, \t// thickness to extrude text\r\n *  curveSegments: \t<int>,\t\t// number of points on the curves\r\n *\r\n *  font: \t\t\t<string>,\t\t// font name\r\n *  weight: \t\t<string>,\t\t// font weight (normal, bold)\r\n *  style: \t\t\t<string>,\t\t// font style  (normal, italics)\r\n *\r\n *  bevelEnabled:\t<bool>,\t\t\t// turn on bevel\r\n *  bevelThickness: <float>, \t\t// how deep into text bevel goes\r\n *  bevelSize:\t\t<float>, \t\t// how far from text outline is bevel\r\n *  }\r\n *\r\n */\r\n\r\n/*\tUsage Examples\r\n\r\n\t// TextGeometry wrapper\r\n\r\n\tvar text3d = new TextGeometry( text, options );\r\n\r\n\t// Complete manner\r\n\r\n\tvar textShapes = THREE.FontUtils.generateShapes( text, options );\r\n\tvar text3d = new ExtrudeGeometry( textShapes, options );\r\n\r\n*/\r\n\r\n\r\nTHREE.TextGeometry = function ( text, parameters ) {\r\n\r\n\tparameters = parameters || {};\r\n\r\n\tvar textShapes = THREE.FontUtils.generateShapes( text, parameters );\r\n\r\n\t// translate parameters to ExtrudeGeometry API\r\n\r\n\tparameters.amount = parameters.height !== undefined ? parameters.height : 50;\r\n\r\n\t// defaults\r\n\r\n\tif ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;\r\n\tif ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;\r\n\tif ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;\r\n\r\n\tTHREE.ExtrudeGeometry.call( this, textShapes, parameters );\r\n\r\n\tthis.type = 'TextGeometry';\r\n\r\n};\r\n\r\nTHREE.TextGeometry.prototype = Object.create( THREE.ExtrudeGeometry.prototype );\r\nTHREE.TextGeometry.prototype.constructor = THREE.TextGeometry;\r\n\r\n// File:src/extras/geometries/TorusGeometry.js\r\n\r\n/**\r\n * @author oosmoxiecode\r\n * @author mrdoob / http://mrdoob.com/\r\n * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3DLite/src/away3dlite/primitives/Torus.as?r=2888\r\n */\r\n\r\nTHREE.TorusGeometry = function ( radius, tube, radialSegments, tubularSegments, arc ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tthis.type = 'TorusGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tradius: radius,\r\n\t\ttube: tube,\r\n\t\tradialSegments: radialSegments,\r\n\t\ttubularSegments: tubularSegments,\r\n\t\tarc: arc\r\n\t};\r\n\r\n\tradius = radius || 100;\r\n\ttube = tube || 40;\r\n\tradialSegments = radialSegments || 8;\r\n\ttubularSegments = tubularSegments || 6;\r\n\tarc = arc || Math.PI * 2;\r\n\r\n\tvar center = new THREE.Vector3(), uvs = [], normals = [];\r\n\r\n\tfor ( var j = 0; j <= radialSegments; j ++ ) {\r\n\r\n\t\tfor ( var i = 0; i <= tubularSegments; i ++ ) {\r\n\r\n\t\t\tvar u = i / tubularSegments * arc;\r\n\t\t\tvar v = j / radialSegments * Math.PI * 2;\r\n\r\n\t\t\tcenter.x = radius * Math.cos( u );\r\n\t\t\tcenter.y = radius * Math.sin( u );\r\n\r\n\t\t\tvar vertex = new THREE.Vector3();\r\n\t\t\tvertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );\r\n\t\t\tvertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );\r\n\t\t\tvertex.z = tube * Math.sin( v );\r\n\r\n\t\t\tthis.vertices.push( vertex );\r\n\r\n\t\t\tuvs.push( new THREE.Vector2( i / tubularSegments, j / radialSegments ) );\r\n\t\t\tnormals.push( vertex.clone().sub( center ).normalize() );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfor ( var j = 1; j <= radialSegments; j ++ ) {\r\n\r\n\t\tfor ( var i = 1; i <= tubularSegments; i ++ ) {\r\n\r\n\t\t\tvar a = ( tubularSegments + 1 ) * j + i - 1;\r\n\t\t\tvar b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;\r\n\t\t\tvar c = ( tubularSegments + 1 ) * ( j - 1 ) + i;\r\n\t\t\tvar d = ( tubularSegments + 1 ) * j + i;\r\n\r\n\t\t\tvar face = new THREE.Face3( a, b, d, [ normals[ a ].clone(), normals[ b ].clone(), normals[ d ].clone() ] );\r\n\t\t\tthis.faces.push( face );\r\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uvs[ a ].clone(), uvs[ b ].clone(), uvs[ d ].clone() ] );\r\n\r\n\t\t\tface = new THREE.Face3( b, c, d, [ normals[ b ].clone(), normals[ c ].clone(), normals[ d ].clone() ] );\r\n\t\t\tthis.faces.push( face );\r\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uvs[ b ].clone(), uvs[ c ].clone(), uvs[ d ].clone() ] );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tthis.computeFaceNormals();\r\n\r\n};\r\n\r\nTHREE.TorusGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.TorusGeometry.prototype.constructor = THREE.TorusGeometry;\r\n\r\n// File:src/extras/geometries/TorusKnotGeometry.js\r\n\r\n/**\r\n * @author oosmoxiecode\r\n * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3D/src/away3d/primitives/TorusKnot.as?spec=svn2473&r=2473\r\n */\r\n\r\nTHREE.TorusKnotGeometry = function ( radius, tube, radialSegments, tubularSegments, p, q, heightScale ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tthis.type = 'TorusKnotGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tradius: radius,\r\n\t\ttube: tube,\r\n\t\tradialSegments: radialSegments,\r\n\t\ttubularSegments: tubularSegments,\r\n\t\tp: p,\r\n\t\tq: q,\r\n\t\theightScale: heightScale\r\n\t};\r\n\r\n\tradius = radius || 100;\r\n\ttube = tube || 40;\r\n\tradialSegments = radialSegments || 64;\r\n\ttubularSegments = tubularSegments || 8;\r\n\tp = p || 2;\r\n\tq = q || 3;\r\n\theightScale = heightScale || 1;\r\n\t\r\n\tvar grid = new Array( radialSegments );\r\n\tvar tang = new THREE.Vector3();\r\n\tvar n = new THREE.Vector3();\r\n\tvar bitan = new THREE.Vector3();\r\n\r\n\tfor ( var i = 0; i < radialSegments; ++ i ) {\r\n\r\n\t\tgrid[ i ] = new Array( tubularSegments );\r\n\t\tvar u = i / radialSegments * 2 * p * Math.PI;\r\n\t\tvar p1 = getPos( u, q, p, radius, heightScale );\r\n\t\tvar p2 = getPos( u + 0.01, q, p, radius, heightScale );\r\n\t\ttang.subVectors( p2, p1 );\r\n\t\tn.addVectors( p2, p1 );\r\n\r\n\t\tbitan.crossVectors( tang, n );\r\n\t\tn.crossVectors( bitan, tang );\r\n\t\tbitan.normalize();\r\n\t\tn.normalize();\r\n\r\n\t\tfor ( var j = 0; j < tubularSegments; ++ j ) {\r\n\r\n\t\t\tvar v = j / tubularSegments * 2 * Math.PI;\r\n\t\t\tvar cx = - tube * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.\r\n\t\t\tvar cy = tube * Math.sin( v );\r\n\r\n\t\t\tvar pos = new THREE.Vector3();\r\n\t\t\tpos.x = p1.x + cx * n.x + cy * bitan.x;\r\n\t\t\tpos.y = p1.y + cx * n.y + cy * bitan.y;\r\n\t\t\tpos.z = p1.z + cx * n.z + cy * bitan.z;\r\n\r\n\t\t\tgrid[ i ][ j ] = this.vertices.push( pos ) - 1;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfor ( var i = 0; i < radialSegments; ++ i ) {\r\n\r\n\t\tfor ( var j = 0; j < tubularSegments; ++ j ) {\r\n\r\n\t\t\tvar ip = ( i + 1 ) % radialSegments;\r\n\t\t\tvar jp = ( j + 1 ) % tubularSegments;\r\n\r\n\t\t\tvar a = grid[ i ][ j ];\r\n\t\t\tvar b = grid[ ip ][ j ];\r\n\t\t\tvar c = grid[ ip ][ jp ];\r\n\t\t\tvar d = grid[ i ][ jp ];\r\n\r\n\t\t\tvar uva = new THREE.Vector2( i / radialSegments, j / tubularSegments );\r\n\t\t\tvar uvb = new THREE.Vector2( ( i + 1 ) / radialSegments, j / tubularSegments );\r\n\t\t\tvar uvc = new THREE.Vector2( ( i + 1 ) / radialSegments, ( j + 1 ) / tubularSegments );\r\n\t\t\tvar uvd = new THREE.Vector2( i / radialSegments, ( j + 1 ) / tubularSegments );\r\n\r\n\t\t\tthis.faces.push( new THREE.Face3( a, b, d ) );\r\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );\r\n\r\n\t\t\tthis.faces.push( new THREE.Face3( b, c, d ) );\r\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );\r\n\r\n\t\t}\r\n\t}\r\n\r\n\tthis.computeFaceNormals();\r\n\tthis.computeVertexNormals();\r\n\r\n\tfunction getPos( u, in_q, in_p, radius, heightScale ) {\r\n\r\n\t\tvar cu = Math.cos( u );\r\n\t\tvar su = Math.sin( u );\r\n\t\tvar quOverP = in_q / in_p * u;\r\n\t\tvar cs = Math.cos( quOverP );\r\n\r\n\t\tvar tx = radius * ( 2 + cs ) * 0.5 * cu;\r\n\t\tvar ty = radius * ( 2 + cs ) * su * 0.5;\r\n\t\tvar tz = heightScale * radius * Math.sin( quOverP ) * 0.5;\r\n\r\n\t\treturn new THREE.Vector3( tx, ty, tz );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.TorusKnotGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.TorusKnotGeometry.prototype.constructor = THREE.TorusKnotGeometry;\r\n\r\n// File:src/extras/geometries/TubeGeometry.js\r\n\r\n/**\r\n * @author WestLangley / https://github.com/WestLangley\r\n * @author zz85 / https://github.com/zz85\r\n * @author miningold / https://github.com/miningold\r\n * @author jonobr1 / https://github.com/jonobr1\r\n *\r\n * Modified from the TorusKnotGeometry by @oosmoxiecode\r\n *\r\n * Creates a tube which extrudes along a 3d spline\r\n *\r\n * Uses parallel transport frames as described in\r\n * http://www.cs.indiana.edu/pub/techreports/TR425.pdf\r\n */\r\n\r\nTHREE.TubeGeometry = function ( path, segments, radius, radialSegments, closed, taper ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tthis.type = 'TubeGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tpath: path,\r\n\t\tsegments: segments,\r\n\t\tradius: radius,\r\n\t\tradialSegments: radialSegments,\r\n\t\tclosed: closed\r\n\t};\r\n\r\n\tsegments = segments || 64;\r\n\tradius = radius || 1;\r\n\tradialSegments = radialSegments || 8;\r\n\tclosed = closed || false;\r\n\ttaper = taper || THREE.TubeGeometry.NoTaper;\r\n\r\n\tvar grid = [];\r\n\r\n\tvar scope = this,\r\n\r\n\t\ttangent,\r\n\t\tnormal,\r\n\t\tbinormal,\r\n\r\n\t\tnumpoints = segments + 1,\r\n\r\n\t\tu, v, r,\r\n\r\n\t\tcx, cy,\r\n\t\tpos, pos2 = new THREE.Vector3(),\r\n\t\ti, j,\r\n\t\tip, jp,\r\n\t\ta, b, c, d,\r\n\t\tuva, uvb, uvc, uvd;\r\n\r\n\tvar frames = new THREE.TubeGeometry.FrenetFrames( path, segments, closed ),\r\n\t\ttangents = frames.tangents,\r\n\t\tnormals = frames.normals,\r\n\t\tbinormals = frames.binormals;\r\n\r\n\t// proxy internals\r\n\tthis.tangents = tangents;\r\n\tthis.normals = normals;\r\n\tthis.binormals = binormals;\r\n\r\n\tfunction vert( x, y, z ) {\r\n\r\n\t\treturn scope.vertices.push( new THREE.Vector3( x, y, z ) ) - 1;\r\n\r\n\t}\r\n\r\n\t// consruct the grid\r\n\r\n\tfor ( i = 0; i < numpoints; i ++ ) {\r\n\r\n\t\tgrid[ i ] = [];\r\n\r\n\t\tu = i / ( numpoints - 1 );\r\n\r\n\t\tpos = path.getPointAt( u );\r\n\r\n\t\ttangent = tangents[ i ];\r\n\t\tnormal = normals[ i ];\r\n\t\tbinormal = binormals[ i ];\r\n\r\n\t\tr = radius * taper( u );\r\n\r\n\t\tfor ( j = 0; j < radialSegments; j ++ ) {\r\n\r\n\t\t\tv = j / radialSegments * 2 * Math.PI;\r\n\r\n\t\t\tcx = - r * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.\r\n\t\t\tcy = r * Math.sin( v );\r\n\r\n\t\t\tpos2.copy( pos );\r\n\t\t\tpos2.x += cx * normal.x + cy * binormal.x;\r\n\t\t\tpos2.y += cx * normal.y + cy * binormal.y;\r\n\t\t\tpos2.z += cx * normal.z + cy * binormal.z;\r\n\r\n\t\t\tgrid[ i ][ j ] = vert( pos2.x, pos2.y, pos2.z );\r\n\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t// construct the mesh\r\n\r\n\tfor ( i = 0; i < segments; i ++ ) {\r\n\r\n\t\tfor ( j = 0; j < radialSegments; j ++ ) {\r\n\r\n\t\t\tip = ( closed ) ? (i + 1) % segments : i + 1;\r\n\t\t\tjp = (j + 1) % radialSegments;\r\n\r\n\t\t\ta = grid[ i ][ j ];\t\t// *** NOT NECESSARILY PLANAR ! ***\r\n\t\t\tb = grid[ ip ][ j ];\r\n\t\t\tc = grid[ ip ][ jp ];\r\n\t\t\td = grid[ i ][ jp ];\r\n\r\n\t\t\tuva = new THREE.Vector2( i / segments, j / radialSegments );\r\n\t\t\tuvb = new THREE.Vector2( ( i + 1 ) / segments, j / radialSegments );\r\n\t\t\tuvc = new THREE.Vector2( ( i + 1 ) / segments, ( j + 1 ) / radialSegments );\r\n\t\t\tuvd = new THREE.Vector2( i / segments, ( j + 1 ) / radialSegments );\r\n\r\n\t\t\tthis.faces.push( new THREE.Face3( a, b, d ) );\r\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );\r\n\r\n\t\t\tthis.faces.push( new THREE.Face3( b, c, d ) );\r\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );\r\n\r\n\t\t}\r\n\t}\r\n\r\n\tthis.computeFaceNormals();\r\n\tthis.computeVertexNormals();\r\n\r\n};\r\n\r\nTHREE.TubeGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.TubeGeometry.prototype.constructor = THREE.TubeGeometry;\r\n\r\nTHREE.TubeGeometry.NoTaper = function ( u ) {\r\n\r\n\treturn 1;\r\n\r\n};\r\n\r\nTHREE.TubeGeometry.SinusoidalTaper = function ( u ) {\r\n\r\n\treturn Math.sin( Math.PI * u );\r\n\r\n};\r\n\r\n// For computing of Frenet frames, exposing the tangents, normals and binormals the spline\r\nTHREE.TubeGeometry.FrenetFrames = function ( path, segments, closed ) {\r\n\r\n\tvar\tnormal = new THREE.Vector3(),\r\n\r\n\t\ttangents = [],\r\n\t\tnormals = [],\r\n\t\tbinormals = [],\r\n\r\n\t\tvec = new THREE.Vector3(),\r\n\t\tmat = new THREE.Matrix4(),\r\n\r\n\t\tnumpoints = segments + 1,\r\n\t\ttheta,\r\n\t\tepsilon = 0.0001,\r\n\t\tsmallest,\r\n\r\n\t\ttx, ty, tz,\r\n\t\ti, u;\r\n\r\n\r\n\t// expose internals\r\n\tthis.tangents = tangents;\r\n\tthis.normals = normals;\r\n\tthis.binormals = binormals;\r\n\r\n\t// compute the tangent vectors for each segment on the path\r\n\r\n\tfor ( i = 0; i < numpoints; i ++ ) {\r\n\r\n\t\tu = i / ( numpoints - 1 );\r\n\r\n\t\ttangents[ i ] = path.getTangentAt( u );\r\n\t\ttangents[ i ].normalize();\r\n\r\n\t}\r\n\r\n\tinitialNormal3();\r\n\r\n\t/*\r\n\tfunction initialNormal1(lastBinormal) {\r\n\t\t// fixed start binormal. Has dangers of 0 vectors\r\n\t\tnormals[ 0 ] = new THREE.Vector3();\r\n\t\tbinormals[ 0 ] = new THREE.Vector3();\r\n\t\tif (lastBinormal===undefined) lastBinormal = new THREE.Vector3( 0, 0, 1 );\r\n\t\tnormals[ 0 ].crossVectors( lastBinormal, tangents[ 0 ] ).normalize();\r\n\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();\r\n\t}\r\n\r\n\tfunction initialNormal2() {\r\n\r\n\t\t// This uses the Frenet-Serret formula for deriving binormal\r\n\t\tvar t2 = path.getTangentAt( epsilon );\r\n\r\n\t\tnormals[ 0 ] = new THREE.Vector3().subVectors( t2, tangents[ 0 ] ).normalize();\r\n\t\tbinormals[ 0 ] = new THREE.Vector3().crossVectors( tangents[ 0 ], normals[ 0 ] );\r\n\r\n\t\tnormals[ 0 ].crossVectors( binormals[ 0 ], tangents[ 0 ] ).normalize(); // last binormal x tangent\r\n\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();\r\n\r\n\t}\r\n\t*/\r\n\r\n\tfunction initialNormal3() {\r\n\t\t// select an initial normal vector perpenicular to the first tangent vector,\r\n\t\t// and in the direction of the smallest tangent xyz component\r\n\r\n\t\tnormals[ 0 ] = new THREE.Vector3();\r\n\t\tbinormals[ 0 ] = new THREE.Vector3();\r\n\t\tsmallest = Number.MAX_VALUE;\r\n\t\ttx = Math.abs( tangents[ 0 ].x );\r\n\t\tty = Math.abs( tangents[ 0 ].y );\r\n\t\ttz = Math.abs( tangents[ 0 ].z );\r\n\r\n\t\tif ( tx <= smallest ) {\r\n\t\t\tsmallest = tx;\r\n\t\t\tnormal.set( 1, 0, 0 );\r\n\t\t}\r\n\r\n\t\tif ( ty <= smallest ) {\r\n\t\t\tsmallest = ty;\r\n\t\t\tnormal.set( 0, 1, 0 );\r\n\t\t}\r\n\r\n\t\tif ( tz <= smallest ) {\r\n\t\t\tnormal.set( 0, 0, 1 );\r\n\t\t}\r\n\r\n\t\tvec.crossVectors( tangents[ 0 ], normal ).normalize();\r\n\r\n\t\tnormals[ 0 ].crossVectors( tangents[ 0 ], vec );\r\n\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );\r\n\t}\r\n\r\n\r\n\t// compute the slowly-varying normal and binormal vectors for each segment on the path\r\n\r\n\tfor ( i = 1; i < numpoints; i ++ ) {\r\n\r\n\t\tnormals[ i ] = normals[ i - 1 ].clone();\r\n\r\n\t\tbinormals[ i ] = binormals[ i - 1 ].clone();\r\n\r\n\t\tvec.crossVectors( tangents[ i - 1 ], tangents[ i ] );\r\n\r\n\t\tif ( vec.length() > epsilon ) {\r\n\r\n\t\t\tvec.normalize();\r\n\r\n\t\t\ttheta = Math.acos( THREE.Math.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors\r\n\r\n\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );\r\n\r\n\t\t}\r\n\r\n\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\r\n\r\n\t}\r\n\r\n\r\n\t// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same\r\n\r\n\tif ( closed ) {\r\n\r\n\t\ttheta = Math.acos( THREE.Math.clamp( normals[ 0 ].dot( normals[ numpoints - 1 ] ), - 1, 1 ) );\r\n\t\ttheta /= ( numpoints - 1 );\r\n\r\n\t\tif ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ numpoints - 1 ] ) ) > 0 ) {\r\n\r\n\t\t\ttheta = - theta;\r\n\r\n\t\t}\r\n\r\n\t\tfor ( i = 1; i < numpoints; i ++ ) {\r\n\r\n\t\t\t// twist a little...\r\n\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );\r\n\t\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\r\n\r\n\t\t}\r\n\r\n\t}\r\n};\r\n\r\n// File:src/extras/geometries/PolyhedronGeometry.js\r\n\r\n/**\r\n * @author clockworkgeek / https://github.com/clockworkgeek\r\n * @author timothypratley / https://github.com/timothypratley\r\n * @author WestLangley / http://github.com/WestLangley\r\n*/\r\n\r\nTHREE.PolyhedronGeometry = function ( vertices, indices, radius, detail ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tthis.type = 'PolyhedronGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tvertices: vertices,\r\n\t\tindices: indices,\r\n\t\tradius: radius,\r\n\t\tdetail: detail\r\n\t};\r\n\r\n\tradius = radius || 1;\r\n\tdetail = detail || 0;\r\n\r\n\tvar that = this;\r\n\r\n\tfor ( var i = 0, l = vertices.length; i < l; i += 3 ) {\r\n\r\n\t\tprepare( new THREE.Vector3( vertices[ i ], vertices[ i + 1 ], vertices[ i + 2 ] ) );\r\n\r\n\t}\r\n\r\n\tvar p = this.vertices;\r\n\r\n\tvar faces = [];\r\n\r\n\tfor ( var i = 0, j = 0, l = indices.length; i < l; i += 3, j ++ ) {\r\n\r\n\t\tvar v1 = p[ indices[ i     ] ];\r\n\t\tvar v2 = p[ indices[ i + 1 ] ];\r\n\t\tvar v3 = p[ indices[ i + 2 ] ];\r\n\r\n\t\tfaces[ j ] = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ] );\r\n\r\n\t}\r\n\r\n\tvar centroid = new THREE.Vector3();\r\n\r\n\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\r\n\t\tsubdivide( faces[ i ], detail );\r\n\r\n\t}\r\n\r\n\r\n\t// Handle case when face straddles the seam\r\n\r\n\tfor ( var i = 0, l = this.faceVertexUvs[ 0 ].length; i < l; i ++ ) {\r\n\r\n\t\tvar uvs = this.faceVertexUvs[ 0 ][ i ];\r\n\r\n\t\tvar x0 = uvs[ 0 ].x;\r\n\t\tvar x1 = uvs[ 1 ].x;\r\n\t\tvar x2 = uvs[ 2 ].x;\r\n\r\n\t\tvar max = Math.max( x0, Math.max( x1, x2 ) );\r\n\t\tvar min = Math.min( x0, Math.min( x1, x2 ) );\r\n\r\n\t\tif ( max > 0.9 && min < 0.1 ) { // 0.9 is somewhat arbitrary\r\n\r\n\t\t\tif ( x0 < 0.2 ) uvs[ 0 ].x += 1;\r\n\t\t\tif ( x1 < 0.2 ) uvs[ 1 ].x += 1;\r\n\t\t\tif ( x2 < 0.2 ) uvs[ 2 ].x += 1;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\r\n\t// Apply radius\r\n\r\n\tfor ( var i = 0, l = this.vertices.length; i < l; i ++ ) {\r\n\r\n\t\tthis.vertices[ i ].multiplyScalar( radius );\r\n\r\n\t}\r\n\r\n\r\n\t// Merge vertices\r\n\r\n\tthis.mergeVertices();\r\n\r\n\tthis.computeFaceNormals();\r\n\r\n\tthis.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\r\n\r\n\r\n\t// Project vector onto sphere's surface\r\n\r\n\tfunction prepare( vector ) {\r\n\r\n\t\tvar vertex = vector.normalize().clone();\r\n\t\tvertex.index = that.vertices.push( vertex ) - 1;\r\n\r\n\t\t// Texture coords are equivalent to map coords, calculate angle and convert to fraction of a circle.\r\n\r\n\t\tvar u = azimuth( vector ) / 2 / Math.PI + 0.5;\r\n\t\tvar v = inclination( vector ) / Math.PI + 0.5;\r\n\t\tvertex.uv = new THREE.Vector2( u, 1 - v );\r\n\r\n\t\treturn vertex;\r\n\r\n\t}\r\n\r\n\r\n\t// Approximate a curved face with recursively sub-divided triangles.\r\n\r\n\tfunction make( v1, v2, v3 ) {\r\n\r\n\t\tvar face = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ] );\r\n\t\tthat.faces.push( face );\r\n\r\n\t\tcentroid.copy( v1 ).add( v2 ).add( v3 ).divideScalar( 3 );\r\n\r\n\t\tvar azi = azimuth( centroid );\r\n\r\n\t\tthat.faceVertexUvs[ 0 ].push( [\r\n\t\t\tcorrectUV( v1.uv, v1, azi ),\r\n\t\t\tcorrectUV( v2.uv, v2, azi ),\r\n\t\t\tcorrectUV( v3.uv, v3, azi )\r\n\t\t] );\r\n\r\n\t}\r\n\r\n\r\n\t// Analytically subdivide a face to the required detail level.\r\n\r\n\tfunction subdivide( face, detail ) {\r\n\r\n\t\tvar cols = Math.pow(2, detail);\r\n\t\tvar a = prepare( that.vertices[ face.a ] );\r\n\t\tvar b = prepare( that.vertices[ face.b ] );\r\n\t\tvar c = prepare( that.vertices[ face.c ] );\r\n\t\tvar v = [];\r\n\r\n\t\t// Construct all of the vertices for this subdivision.\r\n\r\n\t\tfor ( var i = 0 ; i <= cols; i ++ ) {\r\n\r\n\t\t\tv[ i ] = [];\r\n\r\n\t\t\tvar aj = prepare( a.clone().lerp( c, i / cols ) );\r\n\t\t\tvar bj = prepare( b.clone().lerp( c, i / cols ) );\r\n\t\t\tvar rows = cols - i;\r\n\r\n\t\t\tfor ( var j = 0; j <= rows; j ++) {\r\n\r\n\t\t\t\tif ( j == 0 && i == cols ) {\r\n\r\n\t\t\t\t\tv[ i ][ j ] = aj;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tv[ i ][ j ] = prepare( aj.clone().lerp( bj, j / rows ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// Construct all of the faces.\r\n\r\n\t\tfor ( var i = 0; i < cols ; i ++ ) {\r\n\r\n\t\t\tfor ( var j = 0; j < 2 * (cols - i) - 1; j ++ ) {\r\n\r\n\t\t\t\tvar k = Math.floor( j / 2 );\r\n\r\n\t\t\t\tif ( j % 2 == 0 ) {\r\n\r\n\t\t\t\t\tmake(\r\n\t\t\t\t\t\tv[ i ][ k + 1],\r\n\t\t\t\t\t\tv[ i + 1 ][ k ],\r\n\t\t\t\t\t\tv[ i ][ k ]\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tmake(\r\n\t\t\t\t\t\tv[ i ][ k + 1 ],\r\n\t\t\t\t\t\tv[ i + 1][ k + 1],\r\n\t\t\t\t\t\tv[ i + 1 ][ k ]\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\r\n\t// Angle around the Y axis, counter-clockwise when looking from above.\r\n\r\n\tfunction azimuth( vector ) {\r\n\r\n\t\treturn Math.atan2( vector.z, - vector.x );\r\n\r\n\t}\r\n\r\n\r\n\t// Angle above the XZ plane.\r\n\r\n\tfunction inclination( vector ) {\r\n\r\n\t\treturn Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );\r\n\r\n\t}\r\n\r\n\r\n\t// Texture fixing helper. Spheres have some odd behaviours.\r\n\r\n\tfunction correctUV( uv, vector, azimuth ) {\r\n\r\n\t\tif ( ( azimuth < 0 ) && ( uv.x === 1 ) ) uv = new THREE.Vector2( uv.x - 1, uv.y );\r\n\t\tif ( ( vector.x === 0 ) && ( vector.z === 0 ) ) uv = new THREE.Vector2( azimuth / 2 / Math.PI + 0.5, uv.y );\r\n\t\treturn uv.clone();\r\n\r\n\t}\r\n\r\n\r\n};\r\n\r\nTHREE.PolyhedronGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.PolyhedronGeometry.prototype.constructor = THREE.PolyhedronGeometry;\r\n\r\n// File:src/extras/geometries/DodecahedronGeometry.js\r\n\r\n/**\r\n * @author Abe Pazos / https://hamoid.com\r\n */\r\n\r\nTHREE.DodecahedronGeometry = function ( radius, detail ) {\r\n\r\n\tthis.parameters = {\r\n\t\tradius: radius,\r\n\t\tdetail: detail\r\n\t};\r\n\r\n\tvar t = ( 1 + Math.sqrt( 5 ) ) / 2;\r\n\tvar r = 1 / t;\r\n\r\n\tvar vertices = [\r\n\r\n\t\t// (Â±1, Â±1, Â±1)\r\n\t\t-1, -1, -1,    -1, -1,  1,\r\n\t\t-1,  1, -1,    -1,  1,  1,\r\n\t\t 1, -1, -1,     1, -1,  1,\r\n\t\t 1,  1, -1,     1,  1,  1,\r\n\r\n\t\t// (0, Â±1/Ï, Â±Ï)\r\n\t\t 0, -r, -t,     0, -r,  t,\r\n\t\t 0,  r, -t,     0,  r,  t,\r\n\r\n\t\t// (Â±1/Ï, Â±Ï, 0)\r\n\t\t-r, -t,  0,    -r,  t,  0,\r\n\t\t r, -t,  0,     r,  t,  0,\r\n\r\n\t\t// (Â±Ï, 0, Â±1/Ï)\r\n\t\t-t,  0, -r,     t,  0, -r,\r\n\t\t-t,  0,  r,     t,  0,  r\r\n\t];\r\n\r\n\tvar indices = [\r\n\t\t 3, 11,  7,      3,  7, 15,      3, 15, 13,\r\n\t\t 7, 19, 17,      7, 17,  6,      7,  6, 15,\r\n\t\t17,  4,  8,     17,  8, 10,     17, 10,  6,\r\n\t\t 8,  0, 16,      8, 16,  2,      8,  2, 10,\r\n\t\t 0, 12,  1,      0,  1, 18,      0, 18, 16,\r\n\t\t 6, 10,  2,      6,  2, 13,      6, 13, 15,\r\n\t\t 2, 16, 18,      2, 18,  3,      2,  3, 13,\r\n\t\t18,  1,  9,     18,  9, 11,     18, 11,  3,\r\n\t\t 4, 14, 12,      4, 12,  0,      4,  0,  8,\r\n\t\t11,  9,  5,     11,  5, 19,     11, 19,  7,\r\n\t\t19,  5, 14,     19, 14,  4,     19,  4, 17,\r\n\t\t 1, 12, 14,      1, 14,  5,      1,  5,  9\r\n\t];\r\n\r\n\tTHREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );\r\n\r\n};\r\n\r\nTHREE.DodecahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.DodecahedronGeometry.prototype.constructor = THREE.DodecahedronGeometry;\r\n\r\n// File:src/extras/geometries/IcosahedronGeometry.js\r\n\r\n/**\r\n * @author timothypratley / https://github.com/timothypratley\r\n */\r\n\r\nTHREE.IcosahedronGeometry = function ( radius, detail ) {\r\n\r\n\tvar t = ( 1 + Math.sqrt( 5 ) ) / 2;\r\n\r\n\tvar vertices = [\r\n\t\t- 1,  t,  0,    1,  t,  0,   - 1, - t,  0,    1, - t,  0,\r\n\t\t 0, - 1,  t,    0,  1,  t,    0, - 1, - t,    0,  1, - t,\r\n\t\t t,  0, - 1,    t,  0,  1,   - t,  0, - 1,   - t,  0,  1\r\n\t];\r\n\r\n\tvar indices = [\r\n\t\t 0, 11,  5,    0,  5,  1,    0,  1,  7,    0,  7, 10,    0, 10, 11,\r\n\t\t 1,  5,  9,    5, 11,  4,   11, 10,  2,   10,  7,  6,    7,  1,  8,\r\n\t\t 3,  9,  4,    3,  4,  2,    3,  2,  6,    3,  6,  8,    3,  8,  9,\r\n\t\t 4,  9,  5,    2,  4, 11,    6,  2, 10,    8,  6,  7,    9,  8,  1\r\n\t];\r\n\r\n\tTHREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );\r\n\r\n\tthis.type = 'IcosahedronGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tradius: radius,\r\n\t\tdetail: detail\r\n\t};\r\n};\r\n\r\nTHREE.IcosahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.IcosahedronGeometry.prototype.constructor = THREE.IcosahedronGeometry;\r\n\r\n// File:src/extras/geometries/OctahedronGeometry.js\r\n\r\n/**\r\n * @author timothypratley / https://github.com/timothypratley\r\n */\r\n\r\nTHREE.OctahedronGeometry = function ( radius, detail ) {\r\n\r\n\tthis.parameters = {\r\n\t\tradius: radius,\r\n\t\tdetail: detail\r\n\t};\r\n\r\n\tvar vertices = [\r\n\t\t1, 0, 0,   - 1, 0, 0,    0, 1, 0,    0,- 1, 0,    0, 0, 1,    0, 0,- 1\r\n\t];\r\n\r\n\tvar indices = [\r\n\t\t0, 2, 4,    0, 4, 3,    0, 3, 5,    0, 5, 2,    1, 2, 5,    1, 5, 3,    1, 3, 4,    1, 4, 2\r\n\t];\r\n\r\n\tTHREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );\r\n\r\n\tthis.type = 'OctahedronGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tradius: radius,\r\n\t\tdetail: detail\r\n\t};\r\n};\r\n\r\nTHREE.OctahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.OctahedronGeometry.prototype.constructor = THREE.OctahedronGeometry;\r\n\r\n// File:src/extras/geometries/TetrahedronGeometry.js\r\n\r\n/**\r\n * @author timothypratley / https://github.com/timothypratley\r\n */\r\n\r\nTHREE.TetrahedronGeometry = function ( radius, detail ) {\r\n\r\n\tvar vertices = [\r\n\t\t 1,  1,  1,   - 1, - 1,  1,   - 1,  1, - 1,    1, - 1, - 1\r\n\t];\r\n\r\n\tvar indices = [\r\n\t\t 2,  1,  0,    0,  3,  2,    1,  3,  0,    2,  3,  1\r\n\t];\r\n\r\n\tTHREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );\r\n\r\n\tthis.type = 'TetrahedronGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tradius: radius,\r\n\t\tdetail: detail\r\n\t};\r\n\r\n};\r\n\r\nTHREE.TetrahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.TetrahedronGeometry.prototype.constructor = THREE.TetrahedronGeometry;\r\n\r\n// File:src/extras/geometries/ParametricGeometry.js\r\n\r\n/**\r\n * @author zz85 / https://github.com/zz85\r\n * Parametric Surfaces Geometry\r\n * based on the brilliant article by @prideout http://prideout.net/blog/?p=44\r\n *\r\n * new THREE.ParametricGeometry( parametricFunction, uSegments, ySegements );\r\n *\r\n */\r\n\r\nTHREE.ParametricGeometry = function ( func, slices, stacks ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tthis.type = 'ParametricGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tfunc: func,\r\n\t\tslices: slices,\r\n\t\tstacks: stacks\r\n\t};\r\n\r\n\tvar verts = this.vertices;\r\n\tvar faces = this.faces;\r\n\tvar uvs = this.faceVertexUvs[ 0 ];\r\n\r\n\tvar i, j, p;\r\n\tvar u, v;\r\n\r\n\tvar sliceCount = slices + 1;\r\n\r\n\tfor ( i = 0; i <= stacks; i ++ ) {\r\n\r\n\t\tv = i / stacks;\r\n\r\n\t\tfor ( j = 0; j <= slices; j ++ ) {\r\n\r\n\t\t\tu = j / slices;\r\n\r\n\t\t\tp = func( u, v );\r\n\t\t\tverts.push( p );\r\n\r\n\t\t}\r\n\t}\r\n\r\n\tvar a, b, c, d;\r\n\tvar uva, uvb, uvc, uvd;\r\n\r\n\tfor ( i = 0; i < stacks; i ++ ) {\r\n\r\n\t\tfor ( j = 0; j < slices; j ++ ) {\r\n\r\n\t\t\ta = i * sliceCount + j;\r\n\t\t\tb = i * sliceCount + j + 1;\r\n\t\t\tc = (i + 1) * sliceCount + j + 1;\r\n\t\t\td = (i + 1) * sliceCount + j;\r\n\r\n\t\t\tuva = new THREE.Vector2( j / slices, i / stacks );\r\n\t\t\tuvb = new THREE.Vector2( ( j + 1 ) / slices, i / stacks );\r\n\t\t\tuvc = new THREE.Vector2( ( j + 1 ) / slices, ( i + 1 ) / stacks );\r\n\t\t\tuvd = new THREE.Vector2( j / slices, ( i + 1 ) / stacks );\r\n\r\n\t\t\tfaces.push( new THREE.Face3( a, b, d ) );\r\n\t\t\tuvs.push( [ uva, uvb, uvd ] );\r\n\r\n\t\t\tfaces.push( new THREE.Face3( b, c, d ) );\r\n\t\t\tuvs.push( [ uvb.clone(), uvc, uvd.clone() ] );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// console.log(this);\r\n\r\n\t// magic bullet\r\n\t// var diff = this.mergeVertices();\r\n\t// console.log('removed ', diff, ' vertices by merging');\r\n\r\n\tthis.computeFaceNormals();\r\n\tthis.computeVertexNormals();\r\n\r\n};\r\n\r\nTHREE.ParametricGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.ParametricGeometry.prototype.constructor = THREE.ParametricGeometry;\r\n\r\n// File:src/extras/helpers/AxisHelper.js\r\n\r\n/**\r\n * @author sroucheray / http://sroucheray.org/\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.AxisHelper = function ( size ) {\r\n\r\n\tsize = size || 1;\r\n\r\n\tvar vertices = new Float32Array( [\r\n\t\t0, 0, 0,  size, 0, 0,\r\n\t\t0, 0, 0,  0, size, 0,\r\n\t\t0, 0, 0,  0, 0, size\r\n\t] );\r\n\r\n\tvar colors = new Float32Array( [\r\n\t\t1, 0, 0,  1, 0.6, 0,\r\n\t\t0, 1, 0,  0.6, 1, 0,\r\n\t\t0, 0, 1,  0, 0.6, 1\r\n\t] );\r\n\r\n\tvar geometry = new THREE.BufferGeometry();\r\n\tgeometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\r\n\tgeometry.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );\r\n\r\n\tvar material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );\r\n\r\n\tTHREE.Line.call( this, geometry, material, THREE.LinePieces );\r\n\r\n};\r\n\r\nTHREE.AxisHelper.prototype = Object.create( THREE.Line.prototype );\r\nTHREE.AxisHelper.prototype.constructor = THREE.AxisHelper;\r\n\r\n// File:src/extras/helpers/ArrowHelper.js\r\n\r\n/**\r\n * @author WestLangley / http://github.com/WestLangley\r\n * @author zz85 / http://github.com/zz85\r\n * @author bhouston / http://exocortex.com\r\n *\r\n * Creates an arrow for visualizing directions\r\n *\r\n * Parameters:\r\n *  dir - Vector3\r\n *  origin - Vector3\r\n *  length - Number\r\n *  color - color in hex value\r\n *  headLength - Number\r\n *  headWidth - Number\r\n */\r\n\r\nTHREE.ArrowHelper = ( function () {\r\n\r\n\tvar lineGeometry = new THREE.Geometry();\r\n\tlineGeometry.vertices.push( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 1, 0 ) );\r\n\r\n\tvar coneGeometry = new THREE.CylinderGeometry( 0, 0.5, 1, 5, 1 );\r\n\tconeGeometry.applyMatrix( new THREE.Matrix4().makeTranslation( 0, - 0.5, 0 ) );\r\n\r\n\treturn function ( dir, origin, length, color, headLength, headWidth ) {\r\n\r\n\t\t// dir is assumed to be normalized\r\n\r\n\t\tTHREE.Object3D.call( this );\r\n\r\n\t\tif ( color === undefined ) color = 0xffff00;\r\n\t\tif ( length === undefined ) length = 1;\r\n\t\tif ( headLength === undefined ) headLength = 0.2 * length;\r\n\t\tif ( headWidth === undefined ) headWidth = 0.2 * headLength;\r\n\r\n\t\tthis.position.copy( origin );\r\n\r\n\t\tthis.line = new THREE.Line( lineGeometry, new THREE.LineBasicMaterial( { color: color } ) );\r\n\t\tthis.line.matrixAutoUpdate = false;\r\n\t\tthis.add( this.line );\r\n\r\n\t\tthis.cone = new THREE.Mesh( coneGeometry, new THREE.MeshBasicMaterial( { color: color } ) );\r\n\t\tthis.cone.matrixAutoUpdate = false;\r\n\t\tthis.add( this.cone );\r\n\r\n\t\tthis.setDirection( dir );\r\n\t\tthis.setLength( length, headLength, headWidth );\r\n\r\n\t}\r\n\r\n}() );\r\n\r\nTHREE.ArrowHelper.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.ArrowHelper.prototype.constructor = THREE.ArrowHelper;\r\n\r\nTHREE.ArrowHelper.prototype.setDirection = ( function () {\r\n\r\n\tvar axis = new THREE.Vector3();\r\n\tvar radians;\r\n\r\n\treturn function ( dir ) {\r\n\r\n\t\t// dir is assumed to be normalized\r\n\r\n\t\tif ( dir.y > 0.99999 ) {\r\n\r\n\t\t\tthis.quaternion.set( 0, 0, 0, 1 );\r\n\r\n\t\t} else if ( dir.y < - 0.99999 ) {\r\n\r\n\t\t\tthis.quaternion.set( 1, 0, 0, 0 );\r\n\r\n\t\t} else {\r\n\r\n\t\t\taxis.set( dir.z, 0, - dir.x ).normalize();\r\n\r\n\t\t\tradians = Math.acos( dir.y );\r\n\r\n\t\t\tthis.quaternion.setFromAxisAngle( axis, radians );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n}() );\r\n\r\nTHREE.ArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {\r\n\r\n\tif ( headLength === undefined ) headLength = 0.2 * length;\r\n\tif ( headWidth === undefined ) headWidth = 0.2 * headLength;\r\n\r\n\tthis.line.scale.set( 1, length - headLength, 1 );\r\n\tthis.line.updateMatrix();\r\n\r\n\tthis.cone.scale.set( headWidth, headLength, headWidth );\r\n\tthis.cone.position.y = length;\r\n\tthis.cone.updateMatrix();\r\n\r\n};\r\n\r\nTHREE.ArrowHelper.prototype.setColor = function ( color ) {\r\n\r\n\tthis.line.material.color.set( color );\r\n\tthis.cone.material.color.set( color );\r\n\r\n};\r\n\r\n// File:src/extras/helpers/BoxHelper.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.BoxHelper = function ( object ) {\r\n\r\n\tvar geometry = new THREE.BufferGeometry();\r\n\tgeometry.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array( 72 ), 3 ) );\r\n\r\n\tTHREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: 0xffff00 } ), THREE.LinePieces );\r\n\r\n\tif ( object !== undefined ) {\r\n\r\n\t\tthis.update( object );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.BoxHelper.prototype = Object.create( THREE.Line.prototype );\r\nTHREE.BoxHelper.prototype.constructor = THREE.BoxHelper;\r\n\r\nTHREE.BoxHelper.prototype.update = function ( object ) {\r\n\r\n\tvar geometry = object.geometry;\r\n\r\n\tif ( geometry.boundingBox === null ) {\r\n\r\n\t\tgeometry.computeBoundingBox();\r\n\r\n\t}\r\n\r\n\tvar min = geometry.boundingBox.min;\r\n\tvar max = geometry.boundingBox.max;\r\n\r\n\t/*\r\n\t  5____4\r\n\t1/___0/|\r\n\t| 6__|_7\r\n\t2/___3/\r\n\r\n\t0: max.x, max.y, max.z\r\n\t1: min.x, max.y, max.z\r\n\t2: min.x, min.y, max.z\r\n\t3: max.x, min.y, max.z\r\n\t4: max.x, max.y, min.z\r\n\t5: min.x, max.y, min.z\r\n\t6: min.x, min.y, min.z\r\n\t7: max.x, min.y, min.z\r\n\t*/\r\n\r\n\tvar vertices = this.geometry.attributes.position.array;\r\n\r\n\tvertices[  0 ] = max.x; vertices[  1 ] = max.y; vertices[  2 ] = max.z;\r\n\tvertices[  3 ] = min.x; vertices[  4 ] = max.y; vertices[  5 ] = max.z;\r\n\r\n\tvertices[  6 ] = min.x; vertices[  7 ] = max.y; vertices[  8 ] = max.z;\r\n\tvertices[  9 ] = min.x; vertices[ 10 ] = min.y; vertices[ 11 ] = max.z;\r\n\r\n\tvertices[ 12 ] = min.x; vertices[ 13 ] = min.y; vertices[ 14 ] = max.z;\r\n\tvertices[ 15 ] = max.x; vertices[ 16 ] = min.y; vertices[ 17 ] = max.z;\r\n\r\n\tvertices[ 18 ] = max.x; vertices[ 19 ] = min.y; vertices[ 20 ] = max.z;\r\n\tvertices[ 21 ] = max.x; vertices[ 22 ] = max.y; vertices[ 23 ] = max.z;\r\n\r\n\t//\r\n\r\n\tvertices[ 24 ] = max.x; vertices[ 25 ] = max.y; vertices[ 26 ] = min.z;\r\n\tvertices[ 27 ] = min.x; vertices[ 28 ] = max.y; vertices[ 29 ] = min.z;\r\n\r\n\tvertices[ 30 ] = min.x; vertices[ 31 ] = max.y; vertices[ 32 ] = min.z;\r\n\tvertices[ 33 ] = min.x; vertices[ 34 ] = min.y; vertices[ 35 ] = min.z;\r\n\r\n\tvertices[ 36 ] = min.x; vertices[ 37 ] = min.y; vertices[ 38 ] = min.z;\r\n\tvertices[ 39 ] = max.x; vertices[ 40 ] = min.y; vertices[ 41 ] = min.z;\r\n\r\n\tvertices[ 42 ] = max.x; vertices[ 43 ] = min.y; vertices[ 44 ] = min.z;\r\n\tvertices[ 45 ] = max.x; vertices[ 46 ] = max.y; vertices[ 47 ] = min.z;\r\n\r\n\t//\r\n\r\n\tvertices[ 48 ] = max.x; vertices[ 49 ] = max.y; vertices[ 50 ] = max.z;\r\n\tvertices[ 51 ] = max.x; vertices[ 52 ] = max.y; vertices[ 53 ] = min.z;\r\n\r\n\tvertices[ 54 ] = min.x; vertices[ 55 ] = max.y; vertices[ 56 ] = max.z;\r\n\tvertices[ 57 ] = min.x; vertices[ 58 ] = max.y; vertices[ 59 ] = min.z;\r\n\r\n\tvertices[ 60 ] = min.x; vertices[ 61 ] = min.y; vertices[ 62 ] = max.z;\r\n\tvertices[ 63 ] = min.x; vertices[ 64 ] = min.y; vertices[ 65 ] = min.z;\r\n\r\n\tvertices[ 66 ] = max.x; vertices[ 67 ] = min.y; vertices[ 68 ] = max.z;\r\n\tvertices[ 69 ] = max.x; vertices[ 70 ] = min.y; vertices[ 71 ] = min.z;\r\n\r\n\tthis.geometry.attributes.position.needsUpdate = true;\r\n\r\n\tthis.geometry.computeBoundingSphere();\r\n\r\n\tthis.matrix = object.matrixWorld;\r\n\tthis.matrixAutoUpdate = false;\r\n\r\n};\r\n\r\n// File:src/extras/helpers/BoundingBoxHelper.js\r\n\r\n/**\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\r\n\r\n// a helper to show the world-axis-aligned bounding box for an object\r\n\r\nTHREE.BoundingBoxHelper = function ( object, hex ) {\r\n\r\n\tvar color = ( hex !== undefined ) ? hex : 0x888888;\r\n\r\n\tthis.object = object;\r\n\r\n\tthis.box = new THREE.Box3();\r\n\r\n\tTHREE.Mesh.call( this, new THREE.BoxGeometry( 1, 1, 1 ), new THREE.MeshBasicMaterial( { color: color, wireframe: true } ) );\r\n\r\n};\r\n\r\nTHREE.BoundingBoxHelper.prototype = Object.create( THREE.Mesh.prototype );\r\nTHREE.BoundingBoxHelper.prototype.constructor = THREE.BoundingBoxHelper;\r\n\r\nTHREE.BoundingBoxHelper.prototype.update = function () {\r\n\r\n\tthis.box.setFromObject( this.object );\r\n\r\n\tthis.box.size( this.scale );\r\n\r\n\tthis.box.center( this.position );\r\n\r\n};\r\n\r\n// File:src/extras/helpers/CameraHelper.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n *\t- shows frustum, line of sight and up of the camera\r\n *\t- suitable for fast updates\r\n * \t- based on frustum visualization in lightgl.js shadowmap example\r\n *\t\thttp://evanw.github.com/lightgl.js/tests/shadowmap.html\r\n */\r\n\r\nTHREE.CameraHelper = function ( camera ) {\r\n\r\n\tvar geometry = new THREE.Geometry();\r\n\tvar material = new THREE.LineBasicMaterial( { color: 0xffffff, vertexColors: THREE.FaceColors } );\r\n\r\n\tvar pointMap = {};\r\n\r\n\t// colors\r\n\r\n\tvar hexFrustum = 0xffaa00;\r\n\tvar hexCone = 0xff0000;\r\n\tvar hexUp = 0x00aaff;\r\n\tvar hexTarget = 0xffffff;\r\n\tvar hexCross = 0x333333;\r\n\r\n\t// near\r\n\r\n\taddLine( \"n1\", \"n2\", hexFrustum );\r\n\taddLine( \"n2\", \"n4\", hexFrustum );\r\n\taddLine( \"n4\", \"n3\", hexFrustum );\r\n\taddLine( \"n3\", \"n1\", hexFrustum );\r\n\r\n\t// far\r\n\r\n\taddLine( \"f1\", \"f2\", hexFrustum );\r\n\taddLine( \"f2\", \"f4\", hexFrustum );\r\n\taddLine( \"f4\", \"f3\", hexFrustum );\r\n\taddLine( \"f3\", \"f1\", hexFrustum );\r\n\r\n\t// sides\r\n\r\n\taddLine( \"n1\", \"f1\", hexFrustum );\r\n\taddLine( \"n2\", \"f2\", hexFrustum );\r\n\taddLine( \"n3\", \"f3\", hexFrustum );\r\n\taddLine( \"n4\", \"f4\", hexFrustum );\r\n\r\n\t// cone\r\n\r\n\taddLine( \"p\", \"n1\", hexCone );\r\n\taddLine( \"p\", \"n2\", hexCone );\r\n\taddLine( \"p\", \"n3\", hexCone );\r\n\taddLine( \"p\", \"n4\", hexCone );\r\n\r\n\t// up\r\n\r\n\taddLine( \"u1\", \"u2\", hexUp );\r\n\taddLine( \"u2\", \"u3\", hexUp );\r\n\taddLine( \"u3\", \"u1\", hexUp );\r\n\r\n\t// target\r\n\r\n\taddLine( \"c\", \"t\", hexTarget );\r\n\taddLine( \"p\", \"c\", hexCross );\r\n\r\n\t// cross\r\n\r\n\taddLine( \"cn1\", \"cn2\", hexCross );\r\n\taddLine( \"cn3\", \"cn4\", hexCross );\r\n\r\n\taddLine( \"cf1\", \"cf2\", hexCross );\r\n\taddLine( \"cf3\", \"cf4\", hexCross );\r\n\r\n\tfunction addLine( a, b, hex ) {\r\n\r\n\t\taddPoint( a, hex );\r\n\t\taddPoint( b, hex );\r\n\r\n\t}\r\n\r\n\tfunction addPoint( id, hex ) {\r\n\r\n\t\tgeometry.vertices.push( new THREE.Vector3() );\r\n\t\tgeometry.colors.push( new THREE.Color( hex ) );\r\n\r\n\t\tif ( pointMap[ id ] === undefined ) {\r\n\r\n\t\t\tpointMap[ id ] = [];\r\n\r\n\t\t}\r\n\r\n\t\tpointMap[ id ].push( geometry.vertices.length - 1 );\r\n\r\n\t}\r\n\r\n\tTHREE.Line.call( this, geometry, material, THREE.LinePieces );\r\n\r\n\tthis.camera = camera;\r\n\tthis.matrix = camera.matrixWorld;\r\n\tthis.matrixAutoUpdate = false;\r\n\r\n\tthis.pointMap = pointMap;\r\n\r\n\tthis.update();\r\n\r\n};\r\n\r\nTHREE.CameraHelper.prototype = Object.create( THREE.Line.prototype );\r\nTHREE.CameraHelper.prototype.constructor = THREE.CameraHelper;\r\n\r\nTHREE.CameraHelper.prototype.update = function () {\r\n\r\n\tvar geometry, pointMap;\r\n\t\r\n\tvar vector = new THREE.Vector3();\r\n\tvar camera = new THREE.Camera();\r\n\r\n\tvar setPoint = function ( point, x, y, z ) {\r\n\r\n\t\tvector.set( x, y, z ).unproject( camera );\r\n\r\n\t\tvar points = pointMap[ point ];\r\n\r\n\t\tif ( points !== undefined ) {\r\n\r\n\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tgeometry.vertices[ points[ i ] ].copy( vector );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\treturn function () {\r\n\r\n\t\tgeometry = this.geometry;\r\n\t\tpointMap = this.pointMap;\r\n\r\n\t\tvar w = 1, h = 1;\r\n\r\n\t\t// we need just camera projection matrix\r\n\t\t// world matrix must be identity\r\n\r\n\t\tcamera.projectionMatrix.copy( this.camera.projectionMatrix );\r\n\r\n\t\t// center / target\r\n\r\n\t\tsetPoint( \"c\", 0, 0, - 1 );\r\n\t\tsetPoint( \"t\", 0, 0,  1 );\r\n\r\n\t\t// near\r\n\r\n\t\tsetPoint( \"n1\", - w, - h, - 1 );\r\n\t\tsetPoint( \"n2\",   w, - h, - 1 );\r\n\t\tsetPoint( \"n3\", - w,   h, - 1 );\r\n\t\tsetPoint( \"n4\",   w,   h, - 1 );\r\n\r\n\t\t// far\r\n\r\n\t\tsetPoint( \"f1\", - w, - h, 1 );\r\n\t\tsetPoint( \"f2\",   w, - h, 1 );\r\n\t\tsetPoint( \"f3\", - w,   h, 1 );\r\n\t\tsetPoint( \"f4\",   w,   h, 1 );\r\n\r\n\t\t// up\r\n\r\n\t\tsetPoint( \"u1\",   w * 0.7, h * 1.1, - 1 );\r\n\t\tsetPoint( \"u2\", - w * 0.7, h * 1.1, - 1 );\r\n\t\tsetPoint( \"u3\",         0, h * 2,   - 1 );\r\n\r\n\t\t// cross\r\n\r\n\t\tsetPoint( \"cf1\", - w,   0, 1 );\r\n\t\tsetPoint( \"cf2\",   w,   0, 1 );\r\n\t\tsetPoint( \"cf3\",   0, - h, 1 );\r\n\t\tsetPoint( \"cf4\",   0,   h, 1 );\r\n\r\n\t\tsetPoint( \"cn1\", - w,   0, - 1 );\r\n\t\tsetPoint( \"cn2\",   w,   0, - 1 );\r\n\t\tsetPoint( \"cn3\",   0, - h, - 1 );\r\n\t\tsetPoint( \"cn4\",   0,   h, - 1 );\r\n\r\n\t\tgeometry.verticesNeedUpdate = true;\r\n\r\n\t};\r\n\r\n}();\r\n\r\n// File:src/extras/helpers/DirectionalLightHelper.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\r\n\r\nTHREE.DirectionalLightHelper = function ( light, size ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.light = light;\r\n\tthis.light.updateMatrixWorld();\r\n\r\n\tthis.matrix = light.matrixWorld;\r\n\tthis.matrixAutoUpdate = false;\r\n\r\n\tsize = size || 1;\r\n\r\n\tvar geometry = new THREE.Geometry();\r\n\tgeometry.vertices.push(\r\n\t\tnew THREE.Vector3( - size,   size, 0 ),\r\n\t\tnew THREE.Vector3(   size,   size, 0 ),\r\n\t\tnew THREE.Vector3(   size, - size, 0 ),\r\n\t\tnew THREE.Vector3( - size, - size, 0 ),\r\n\t\tnew THREE.Vector3( - size,   size, 0 )\r\n\t);\r\n\r\n\tvar material = new THREE.LineBasicMaterial( { fog: false } );\r\n\tmaterial.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\r\n\r\n\tthis.lightPlane = new THREE.Line( geometry, material );\r\n\tthis.add( this.lightPlane );\r\n\r\n\tgeometry = new THREE.Geometry();\r\n\tgeometry.vertices.push(\r\n\t\tnew THREE.Vector3(),\r\n\t\tnew THREE.Vector3()\r\n\t);\r\n\r\n\tmaterial = new THREE.LineBasicMaterial( { fog: false } );\r\n\tmaterial.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\r\n\r\n\tthis.targetLine = new THREE.Line( geometry, material );\r\n\tthis.add( this.targetLine );\r\n\r\n\tthis.update();\r\n\r\n};\r\n\r\nTHREE.DirectionalLightHelper.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.DirectionalLightHelper.prototype.constructor = THREE.DirectionalLightHelper;\r\n\r\nTHREE.DirectionalLightHelper.prototype.dispose = function () {\r\n\r\n\tthis.lightPlane.geometry.dispose();\r\n\tthis.lightPlane.material.dispose();\r\n\tthis.targetLine.geometry.dispose();\r\n\tthis.targetLine.material.dispose();\r\n};\r\n\r\nTHREE.DirectionalLightHelper.prototype.update = function () {\r\n\r\n\tvar v1 = new THREE.Vector3();\r\n\tvar v2 = new THREE.Vector3();\r\n\tvar v3 = new THREE.Vector3();\r\n\r\n\treturn function () {\r\n\r\n\t\tv1.setFromMatrixPosition( this.light.matrixWorld );\r\n\t\tv2.setFromMatrixPosition( this.light.target.matrixWorld );\r\n\t\tv3.subVectors( v2, v1 );\r\n\r\n\t\tthis.lightPlane.lookAt( v3 );\r\n\t\tthis.lightPlane.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\r\n\r\n\t\tthis.targetLine.geometry.vertices[ 1 ].copy( v3 );\r\n\t\tthis.targetLine.geometry.verticesNeedUpdate = true;\r\n\t\tthis.targetLine.material.color.copy( this.lightPlane.material.color );\r\n\r\n\t};\r\n\r\n}();\r\n\r\n// File:src/extras/helpers/EdgesHelper.js\r\n\r\n/**\r\n * @author WestLangley / http://github.com/WestLangley\r\n * @param object THREE.Mesh whose geometry will be used\r\n * @param hex line color\r\n * @param thresholdAngle the minimim angle (in degrees),\r\n * between the face normals of adjacent faces,\r\n * that is required to render an edge. A value of 10 means\r\n * an edge is only rendered if the angle is at least 10 degrees.\r\n */\r\n\r\nTHREE.EdgesHelper = function ( object, hex, thresholdAngle ) {\r\n\r\n\tvar color = ( hex !== undefined ) ? hex : 0xffffff;\r\n\tthresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;\r\n\r\n\tvar thresholdDot = Math.cos( THREE.Math.degToRad( thresholdAngle ) );\r\n\r\n\tvar edge = [ 0, 0 ], hash = {};\r\n\tvar sortFunction = function ( a, b ) { return a - b };\r\n\r\n\tvar keys = [ 'a', 'b', 'c' ];\r\n\tvar geometry = new THREE.BufferGeometry();\r\n\r\n\tvar geometry2;\r\n\r\n\tif ( object.geometry instanceof THREE.BufferGeometry ) {\r\n\r\n\t\tgeometry2 = new THREE.Geometry();\r\n\t\tgeometry2.fromBufferGeometry( object.geometry );\r\n\r\n\t} else {\r\n\r\n\t\tgeometry2 = object.geometry.clone();\r\n\r\n\t}\r\n\r\n\tgeometry2.mergeVertices();\r\n\tgeometry2.computeFaceNormals();\r\n\r\n\tvar vertices = geometry2.vertices;\r\n\tvar faces = geometry2.faces;\r\n\tvar numEdges = 0;\r\n\r\n\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\r\n\t\tvar face = faces[ i ];\r\n\r\n\t\tfor ( var j = 0; j < 3; j ++ ) {\r\n\r\n\t\t\tedge[ 0 ] = face[ keys[ j ] ];\r\n\t\t\tedge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];\r\n\t\t\tedge.sort( sortFunction );\r\n\r\n\t\t\tvar key = edge.toString();\r\n\r\n\t\t\tif ( hash[ key ] === undefined ) {\r\n\r\n\t\t\t\thash[ key ] = { vert1: edge[ 0 ], vert2: edge[ 1 ], face1: i, face2: undefined };\r\n\t\t\t\tnumEdges ++;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\thash[ key ].face2 = i;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tvar coords = new Float32Array( numEdges * 2 * 3 );\r\n\r\n\tvar index = 0;\r\n\r\n\tfor ( var key in hash ) {\r\n\r\n\t\tvar h = hash[ key ];\r\n\r\n\t\tif ( h.face2 === undefined || faces[ h.face1 ].normal.dot( faces[ h.face2 ].normal ) <= thresholdDot ) {\r\n\r\n\t\t\tvar vertex = vertices[ h.vert1 ];\r\n\t\t\tcoords[ index ++ ] = vertex.x;\r\n\t\t\tcoords[ index ++ ] = vertex.y;\r\n\t\t\tcoords[ index ++ ] = vertex.z;\r\n\r\n\t\t\tvertex = vertices[ h.vert2 ];\r\n\t\t\tcoords[ index ++ ] = vertex.x;\r\n\t\t\tcoords[ index ++ ] = vertex.y;\r\n\t\t\tcoords[ index ++ ] = vertex.z;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tgeometry.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );\r\n\r\n\tTHREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color } ), THREE.LinePieces );\r\n\r\n\tthis.matrix = object.matrixWorld;\r\n\tthis.matrixAutoUpdate = false;\r\n\r\n};\r\n\r\nTHREE.EdgesHelper.prototype = Object.create( THREE.Line.prototype );\r\nTHREE.EdgesHelper.prototype.constructor = THREE.EdgesHelper;\r\n\r\n// File:src/extras/helpers/FaceNormalsHelper.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n*/\r\n\r\nTHREE.FaceNormalsHelper = function ( object, size, hex, linewidth ) {\r\n\r\n\tthis.object = object;\r\n\r\n\tthis.size = ( size !== undefined ) ? size : 1;\r\n\r\n\tvar color = ( hex !== undefined ) ? hex : 0xffff00;\r\n\r\n\tvar width = ( linewidth !== undefined ) ? linewidth : 1;\r\n\r\n\tvar geometry = new THREE.Geometry();\r\n\r\n\tvar faces = this.object.geometry.faces;\r\n\r\n\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\r\n\t\tgeometry.vertices.push( new THREE.Vector3(), new THREE.Vector3() );\r\n\r\n\t}\r\n\r\n\tTHREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ), THREE.LinePieces );\r\n\r\n\tthis.matrixAutoUpdate = false;\r\n\r\n\tthis.normalMatrix = new THREE.Matrix3();\r\n\r\n\tthis.update();\r\n\r\n};\r\n\r\nTHREE.FaceNormalsHelper.prototype = Object.create( THREE.Line.prototype );\r\nTHREE.FaceNormalsHelper.prototype.constructor = THREE.FaceNormalsHelper;\r\n\r\nTHREE.FaceNormalsHelper.prototype.update = function () {\r\n\r\n\tvar vertices = this.geometry.vertices;\r\n\r\n\tvar object = this.object;\r\n\tvar objectVertices = object.geometry.vertices;\r\n\tvar objectFaces = object.geometry.faces;\r\n\tvar objectWorldMatrix = object.matrixWorld;\r\n\r\n\tobject.updateMatrixWorld( true );\r\n\r\n\tthis.normalMatrix.getNormalMatrix( objectWorldMatrix );\r\n\r\n\tfor ( var i = 0, i2 = 0, l = objectFaces.length; i < l; i ++, i2 += 2 ) {\r\n\r\n\t\tvar face = objectFaces[ i ];\r\n\r\n\t\tvertices[ i2 ].copy( objectVertices[ face.a ] )\r\n\t\t\t.add( objectVertices[ face.b ] )\r\n\t\t\t.add( objectVertices[ face.c ] )\r\n\t\t\t.divideScalar( 3 )\r\n\t\t\t.applyMatrix4( objectWorldMatrix );\r\n\r\n\t\tvertices[ i2 + 1 ].copy( face.normal )\r\n\t\t\t.applyMatrix3( this.normalMatrix )\r\n\t\t\t.normalize()\r\n\t\t\t.multiplyScalar( this.size )\r\n\t\t\t.add( vertices[ i2 ] );\r\n\r\n\t}\r\n\r\n\tthis.geometry.verticesNeedUpdate = true;\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\n\r\n// File:src/extras/helpers/GridHelper.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.GridHelper = function ( size, step ) {\r\n\r\n\tvar geometry = new THREE.Geometry();\r\n\tvar material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );\r\n\r\n\tthis.color1 = new THREE.Color( 0x444444 );\r\n\tthis.color2 = new THREE.Color( 0x888888 );\r\n\r\n\tfor ( var i = - size; i <= size; i += step ) {\r\n\r\n\t\tgeometry.vertices.push(\r\n\t\t\tnew THREE.Vector3( - size, 0, i ), new THREE.Vector3( size, 0, i ),\r\n\t\t\tnew THREE.Vector3( i, 0, - size ), new THREE.Vector3( i, 0, size )\r\n\t\t);\r\n\r\n\t\tvar color = i === 0 ? this.color1 : this.color2;\r\n\r\n\t\tgeometry.colors.push( color, color, color, color );\r\n\r\n\t}\r\n\r\n\tTHREE.Line.call( this, geometry, material, THREE.LinePieces );\r\n\r\n};\r\n\r\nTHREE.GridHelper.prototype = Object.create( THREE.Line.prototype );\r\nTHREE.GridHelper.prototype.constructor = THREE.GridHelper;\r\n\r\nTHREE.GridHelper.prototype.setColors = function( colorCenterLine, colorGrid ) {\r\n\r\n\tthis.color1.set( colorCenterLine );\r\n\tthis.color2.set( colorGrid );\r\n\r\n\tthis.geometry.colorsNeedUpdate = true;\r\n\r\n}\r\n\r\n// File:src/extras/helpers/HemisphereLightHelper.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.HemisphereLightHelper = function ( light, sphereSize ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.light = light;\r\n\tthis.light.updateMatrixWorld();\r\n\r\n\tthis.matrix = light.matrixWorld;\r\n\tthis.matrixAutoUpdate = false;\r\n\r\n\tthis.colors = [ new THREE.Color(), new THREE.Color() ];\r\n\r\n\tvar geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );\r\n\tgeometry.applyMatrix( new THREE.Matrix4().makeRotationX( - Math.PI / 2 ) );\r\n\r\n\tfor ( var i = 0, il = 8; i < il; i ++ ) {\r\n\r\n\t\tgeometry.faces[ i ].color = this.colors[ i < 4 ? 0 : 1 ];\r\n\r\n\t}\r\n\r\n\tvar material = new THREE.MeshBasicMaterial( { vertexColors: THREE.FaceColors, wireframe: true } );\r\n\r\n\tthis.lightSphere = new THREE.Mesh( geometry, material );\r\n\tthis.add( this.lightSphere );\r\n\r\n\tthis.update();\r\n\r\n};\r\n\r\nTHREE.HemisphereLightHelper.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.HemisphereLightHelper.prototype.constructor = THREE.HemisphereLightHelper;\r\n\r\nTHREE.HemisphereLightHelper.prototype.dispose = function () {\r\n\tthis.lightSphere.geometry.dispose();\r\n\tthis.lightSphere.material.dispose();\r\n};\r\n\r\nTHREE.HemisphereLightHelper.prototype.update = function () {\r\n\r\n\tvar vector = new THREE.Vector3();\r\n\r\n\treturn function () {\r\n\r\n\t\tthis.colors[ 0 ].copy( this.light.color ).multiplyScalar( this.light.intensity );\r\n\t\tthis.colors[ 1 ].copy( this.light.groundColor ).multiplyScalar( this.light.intensity );\r\n\r\n\t\tthis.lightSphere.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );\r\n\t\tthis.lightSphere.geometry.colorsNeedUpdate = true;\r\n\r\n\t}\r\n\r\n}();\r\n\r\n// File:src/extras/helpers/PointLightHelper.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.PointLightHelper = function ( light, sphereSize ) {\r\n\r\n\tthis.light = light;\r\n\tthis.light.updateMatrixWorld();\r\n\r\n\tvar geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );\r\n\tvar material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );\r\n\tmaterial.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\r\n\r\n\tTHREE.Mesh.call( this, geometry, material );\r\n\r\n\tthis.matrix = this.light.matrixWorld;\r\n\tthis.matrixAutoUpdate = false;\r\n\r\n\t/*\r\n\tvar distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );\r\n\tvar distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );\r\n\r\n\tthis.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );\r\n\tthis.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );\r\n\r\n\tvar d = light.distance;\r\n\r\n\tif ( d === 0.0 ) {\r\n\r\n\t\tthis.lightDistance.visible = false;\r\n\r\n\t} else {\r\n\r\n\t\tthis.lightDistance.scale.set( d, d, d );\r\n\r\n\t}\r\n\r\n\tthis.add( this.lightDistance );\r\n\t*/\r\n\r\n};\r\n\r\nTHREE.PointLightHelper.prototype = Object.create( THREE.Mesh.prototype );\r\nTHREE.PointLightHelper.prototype.constructor = THREE.PointLightHelper;\r\n\r\nTHREE.PointLightHelper.prototype.dispose = function () {\r\n\r\n\tthis.geometry.dispose();\r\n\tthis.material.dispose();\r\n};\r\n\r\nTHREE.PointLightHelper.prototype.update = function () {\r\n\r\n\tthis.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\r\n\r\n\t/*\r\n\tvar d = this.light.distance;\r\n\r\n\tif ( d === 0.0 ) {\r\n\r\n\t\tthis.lightDistance.visible = false;\r\n\r\n\t} else {\r\n\r\n\t\tthis.lightDistance.visible = true;\r\n\t\tthis.lightDistance.scale.set( d, d, d );\r\n\r\n\t}\r\n\t*/\r\n\r\n};\r\n\r\n// File:src/extras/helpers/SkeletonHelper.js\r\n\r\n/**\r\n * @author Sean Griffin / http://twitter.com/sgrif\r\n * @author Michael Guerrero / http://realitymeltdown.com\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author ikerr / http://verold.com\r\n */\r\n\r\nTHREE.SkeletonHelper = function ( object ) {\r\n\r\n\tthis.bones = this.getBoneList( object );\r\n\r\n\tvar geometry = new THREE.Geometry();\r\n\r\n\tfor ( var i = 0; i < this.bones.length; i ++ ) {\r\n\r\n\t\tvar bone = this.bones[ i ];\r\n\r\n\t\tif ( bone.parent instanceof THREE.Bone ) {\r\n\r\n\t\t\tgeometry.vertices.push( new THREE.Vector3() );\r\n\t\t\tgeometry.vertices.push( new THREE.Vector3() );\r\n\t\t\tgeometry.colors.push( new THREE.Color( 0, 0, 1 ) );\r\n\t\t\tgeometry.colors.push( new THREE.Color( 0, 1, 0 ) );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tvar material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors, depthTest: false, depthWrite: false, transparent: true } );\r\n\r\n\tTHREE.Line.call( this, geometry, material, THREE.LinePieces );\r\n\r\n\tthis.root = object;\r\n\r\n\tthis.matrix = object.matrixWorld;\r\n\tthis.matrixAutoUpdate = false;\r\n\r\n\tthis.update();\r\n\r\n};\r\n\r\n\r\nTHREE.SkeletonHelper.prototype = Object.create( THREE.Line.prototype );\r\nTHREE.SkeletonHelper.prototype.constructor = THREE.SkeletonHelper;\r\n\r\nTHREE.SkeletonHelper.prototype.getBoneList = function( object ) {\r\n\r\n\tvar boneList = [];\r\n\r\n\tif ( object instanceof THREE.Bone ) {\r\n\r\n\t\tboneList.push( object );\r\n\r\n\t}\r\n\r\n\tfor ( var i = 0; i < object.children.length; i ++ ) {\r\n\r\n\t\tboneList.push.apply( boneList, this.getBoneList( object.children[ i ] ) );\r\n\r\n\t}\r\n\r\n\treturn boneList;\r\n\r\n};\r\n\r\nTHREE.SkeletonHelper.prototype.update = function () {\r\n\r\n\tvar geometry = this.geometry;\r\n\r\n\tvar matrixWorldInv = new THREE.Matrix4().getInverse( this.root.matrixWorld );\r\n\r\n\tvar boneMatrix = new THREE.Matrix4();\r\n\r\n\tvar j = 0;\r\n\r\n\tfor ( var i = 0; i < this.bones.length; i ++ ) {\r\n\r\n\t\tvar bone = this.bones[ i ];\r\n\r\n\t\tif ( bone.parent instanceof THREE.Bone ) {\r\n\r\n\t\t\tboneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );\r\n\t\t\tgeometry.vertices[ j ].setFromMatrixPosition( boneMatrix );\r\n\r\n\t\t\tboneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );\r\n\t\t\tgeometry.vertices[ j + 1 ].setFromMatrixPosition( boneMatrix );\r\n\r\n\t\t\tj += 2;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tgeometry.verticesNeedUpdate = true;\r\n\r\n\tgeometry.computeBoundingSphere();\r\n\r\n};\r\n\r\n// File:src/extras/helpers/SpotLightHelper.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n*/\r\n\r\nTHREE.SpotLightHelper = function ( light ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.light = light;\r\n\tthis.light.updateMatrixWorld();\r\n\r\n\tthis.matrix = light.matrixWorld;\r\n\tthis.matrixAutoUpdate = false;\r\n\r\n\tvar geometry = new THREE.CylinderGeometry( 0, 1, 1, 8, 1, true );\r\n\r\n\tgeometry.applyMatrix( new THREE.Matrix4().makeTranslation( 0, - 0.5, 0 ) );\r\n\tgeometry.applyMatrix( new THREE.Matrix4().makeRotationX( - Math.PI / 2 ) );\r\n\r\n\tvar material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );\r\n\r\n\tthis.cone = new THREE.Mesh( geometry, material );\r\n\tthis.add( this.cone );\r\n\r\n\tthis.update();\r\n\r\n};\r\n\r\nTHREE.SpotLightHelper.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.SpotLightHelper.prototype.constructor = THREE.SpotLightHelper;\r\n\r\nTHREE.SpotLightHelper.prototype.dispose = function () {\r\n\tthis.cone.geometry.dispose();\r\n\tthis.cone.material.dispose();\r\n};\r\n\r\nTHREE.SpotLightHelper.prototype.update = function () {\r\n\r\n\tvar vector = new THREE.Vector3();\r\n\tvar vector2 = new THREE.Vector3();\r\n\r\n\treturn function () {\r\n\r\n\t\tvar coneLength = this.light.distance ? this.light.distance : 10000;\r\n\t\tvar coneWidth = coneLength * Math.tan( this.light.angle );\r\n\r\n\t\tthis.cone.scale.set( coneWidth, coneWidth, coneLength );\r\n\r\n\t\tvector.setFromMatrixPosition( this.light.matrixWorld );\r\n\t\tvector2.setFromMatrixPosition( this.light.target.matrixWorld );\r\n\r\n\t\tthis.cone.lookAt( vector2.sub( vector ) );\r\n\r\n\t\tthis.cone.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\r\n\r\n\t};\r\n\r\n}();\r\n\r\n// File:src/extras/helpers/VertexNormalsHelper.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n*/\r\n\r\nTHREE.VertexNormalsHelper = function ( object, size, hex, linewidth ) {\r\n\r\n\tthis.object = object;\r\n\r\n\tthis.size = ( size !== undefined ) ? size : 1;\r\n\r\n\tvar color = ( hex !== undefined ) ? hex : 0xff0000;\r\n\r\n\tvar width = ( linewidth !== undefined ) ? linewidth : 1;\r\n\r\n\tvar geometry = new THREE.Geometry();\r\n\r\n\tvar faces = object.geometry.faces;\r\n\r\n\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\r\n\t\tvar face = faces[ i ];\r\n\r\n\t\tfor ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\r\n\r\n\t\t\tgeometry.vertices.push( new THREE.Vector3(), new THREE.Vector3() );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tTHREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ), THREE.LinePieces );\r\n\r\n\tthis.matrixAutoUpdate = false;\r\n\r\n\tthis.normalMatrix = new THREE.Matrix3();\r\n\r\n\tthis.update();\r\n\r\n};\r\n\r\nTHREE.VertexNormalsHelper.prototype = Object.create( THREE.Line.prototype );\r\nTHREE.VertexNormalsHelper.prototype.constructor = THREE.VertexNormalsHelper;\r\n\r\nTHREE.VertexNormalsHelper.prototype.update = ( function ( object ) {\r\n\r\n\tvar v1 = new THREE.Vector3();\r\n\r\n\treturn function( object ) {\r\n\r\n\t\tvar keys = [ 'a', 'b', 'c', 'd' ];\r\n\r\n\t\tthis.object.updateMatrixWorld( true );\r\n\r\n\t\tthis.normalMatrix.getNormalMatrix( this.object.matrixWorld );\r\n\r\n\t\tvar vertices = this.geometry.vertices;\r\n\r\n\t\tvar verts = this.object.geometry.vertices;\r\n\r\n\t\tvar faces = this.object.geometry.faces;\r\n\r\n\t\tvar worldMatrix = this.object.matrixWorld;\r\n\r\n\t\tvar idx = 0;\r\n\r\n\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar face = faces[ i ];\r\n\r\n\t\t\tfor ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\tvar vertexId = face[ keys[ j ] ];\r\n\t\t\t\tvar vertex = verts[ vertexId ];\r\n\r\n\t\t\t\tvar normal = face.vertexNormals[ j ];\r\n\r\n\t\t\t\tvertices[ idx ].copy( vertex ).applyMatrix4( worldMatrix );\r\n\r\n\t\t\t\tv1.copy( normal ).applyMatrix3( this.normalMatrix ).normalize().multiplyScalar( this.size );\r\n\r\n\t\t\t\tv1.add( vertices[ idx ] );\r\n\t\t\t\tidx = idx + 1;\r\n\r\n\t\t\t\tvertices[ idx ].copy( v1 );\r\n\t\t\t\tidx = idx + 1;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis.geometry.verticesNeedUpdate = true;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n}());\r\n\r\n// File:src/extras/helpers/VertexTangentsHelper.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n*/\r\n\r\nTHREE.VertexTangentsHelper = function ( object, size, hex, linewidth ) {\r\n\r\n\tthis.object = object;\r\n\r\n\tthis.size = ( size !== undefined ) ? size : 1;\r\n\r\n\tvar color = ( hex !== undefined ) ? hex : 0x0000ff;\r\n\r\n\tvar width = ( linewidth !== undefined ) ? linewidth : 1;\r\n\r\n\tvar geometry = new THREE.Geometry();\r\n\r\n\tvar faces = object.geometry.faces;\r\n\r\n\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\r\n\t\tvar face = faces[ i ];\r\n\r\n\t\tfor ( var j = 0, jl = face.vertexTangents.length; j < jl; j ++ ) {\r\n\r\n\t\t\tgeometry.vertices.push( new THREE.Vector3() );\r\n\t\t\tgeometry.vertices.push( new THREE.Vector3() );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tTHREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ), THREE.LinePieces );\r\n\r\n\tthis.matrixAutoUpdate = false;\r\n\r\n\tthis.update();\r\n\r\n};\r\n\r\nTHREE.VertexTangentsHelper.prototype = Object.create( THREE.Line.prototype );\r\nTHREE.VertexTangentsHelper.prototype.constructor = THREE.VertexTangentsHelper;\r\n\r\nTHREE.VertexTangentsHelper.prototype.update = ( function ( object ) {\r\n\r\n\tvar v1 = new THREE.Vector3();\r\n\r\n\treturn function( object ) {\r\n\r\n\t\tvar keys = [ 'a', 'b', 'c', 'd' ];\r\n\r\n\t\tthis.object.updateMatrixWorld( true );\r\n\r\n\t\tvar vertices = this.geometry.vertices;\r\n\r\n\t\tvar verts = this.object.geometry.vertices;\r\n\r\n\t\tvar faces = this.object.geometry.faces;\r\n\r\n\t\tvar worldMatrix = this.object.matrixWorld;\r\n\r\n\t\tvar idx = 0;\r\n\r\n\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar face = faces[ i ];\r\n\r\n\t\t\tfor ( var j = 0, jl = face.vertexTangents.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\tvar vertexId = face[ keys[ j ] ];\r\n\t\t\t\tvar vertex = verts[ vertexId ];\r\n\r\n\t\t\t\tvar tangent = face.vertexTangents[ j ];\r\n\r\n\t\t\t\tvertices[ idx ].copy( vertex ).applyMatrix4( worldMatrix );\r\n\r\n\t\t\t\tv1.copy( tangent ).transformDirection( worldMatrix ).multiplyScalar( this.size );\r\n\r\n\t\t\t\tv1.add( vertices[ idx ] );\r\n\t\t\t\tidx = idx + 1;\r\n\r\n\t\t\t\tvertices[ idx ].copy( v1 );\r\n\t\t\t\tidx = idx + 1;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis.geometry.verticesNeedUpdate = true;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n}());\r\n\r\n// File:src/extras/helpers/WireframeHelper.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.WireframeHelper = function ( object, hex ) {\r\n\r\n\tvar color = ( hex !== undefined ) ? hex : 0xffffff;\r\n\r\n\tvar edge = [ 0, 0 ], hash = {};\r\n\tvar sortFunction = function ( a, b ) { return a - b };\r\n\r\n\tvar keys = [ 'a', 'b', 'c' ];\r\n\tvar geometry = new THREE.BufferGeometry();\r\n\r\n\tif ( object.geometry instanceof THREE.Geometry ) {\r\n\r\n\t\tvar vertices = object.geometry.vertices;\r\n\t\tvar faces = object.geometry.faces;\r\n\t\tvar numEdges = 0;\r\n\r\n\t\t// allocate maximal size\r\n\t\tvar edges = new Uint32Array( 6 * faces.length );\r\n\r\n\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar face = faces[ i ];\r\n\r\n\t\t\tfor ( var j = 0; j < 3; j ++ ) {\r\n\r\n\t\t\t\tedge[ 0 ] = face[ keys[ j ] ];\r\n\t\t\t\tedge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];\r\n\t\t\t\tedge.sort( sortFunction );\r\n\r\n\t\t\t\tvar key = edge.toString();\r\n\r\n\t\t\t\tif ( hash[ key ] === undefined ) {\r\n\r\n\t\t\t\t\tedges[ 2 * numEdges ] = edge[ 0 ];\r\n\t\t\t\t\tedges[ 2 * numEdges + 1 ] = edge[ 1 ];\r\n\t\t\t\t\thash[ key ] = true;\r\n\t\t\t\t\tnumEdges ++;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvar coords = new Float32Array( numEdges * 2 * 3 );\r\n\r\n\t\tfor ( var i = 0, l = numEdges; i < l; i ++ ) {\r\n\r\n\t\t\tfor ( var j = 0; j < 2; j ++ ) {\r\n\r\n\t\t\t\tvar vertex = vertices[ edges [ 2 * i + j] ];\r\n\r\n\t\t\t\tvar index = 6 * i + 3 * j;\r\n\t\t\t\tcoords[ index + 0 ] = vertex.x;\r\n\t\t\t\tcoords[ index + 1 ] = vertex.y;\r\n\t\t\t\tcoords[ index + 2 ] = vertex.z;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tgeometry.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );\r\n\r\n\t} else if ( object.geometry instanceof THREE.BufferGeometry ) {\r\n\r\n\t\tif ( object.geometry.attributes.index !== undefined ) { // Indexed BufferGeometry\r\n\r\n\t\t\tvar vertices = object.geometry.attributes.position.array;\r\n\t\t\tvar indices = object.geometry.attributes.index.array;\r\n\t\t\tvar drawcalls = object.geometry.drawcalls;\r\n\t\t\tvar numEdges = 0;\r\n\r\n\t\t\tif ( drawcalls.length === 0 ) {\r\n\r\n\t\t\t\tdrawcalls = [ { count : indices.length, index : 0, start : 0 } ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// allocate maximal size\r\n\t\t\tvar edges = new Uint32Array( 2 * indices.length );\r\n\r\n\t\t\tfor ( var o = 0, ol = drawcalls.length; o < ol; ++ o ) {\r\n\r\n\t\t\t\tvar start = drawcalls[ o ].start;\r\n\t\t\t\tvar count = drawcalls[ o ].count;\r\n\t\t\t\tvar index = drawcalls[ o ].index;\r\n\r\n\t\t\t\tfor ( var i = start, il = start + count; i < il; i += 3 ) {\r\n\r\n\t\t\t\t\tfor ( var j = 0; j < 3; j ++ ) {\r\n\r\n\t\t\t\t\t\tedge[ 0 ] = index + indices[ i + j ];\r\n\t\t\t\t\t\tedge[ 1 ] = index + indices[ i + ( j + 1 ) % 3 ];\r\n\t\t\t\t\t\tedge.sort( sortFunction );\r\n\r\n\t\t\t\t\t\tvar key = edge.toString();\r\n\r\n\t\t\t\t\t\tif ( hash[ key ] === undefined ) {\r\n\r\n\t\t\t\t\t\t\tedges[ 2 * numEdges ] = edge[ 0 ];\r\n\t\t\t\t\t\t\tedges[ 2 * numEdges + 1 ] = edge[ 1 ];\r\n\t\t\t\t\t\t\thash[ key ] = true;\r\n\t\t\t\t\t\t\tnumEdges ++;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar coords = new Float32Array( numEdges * 2 * 3 );\r\n\r\n\t\t\tfor ( var i = 0, l = numEdges; i < l; i ++ ) {\r\n\r\n\t\t\t\tfor ( var j = 0; j < 2; j ++ ) {\r\n\r\n\t\t\t\t\tvar index = 6 * i + 3 * j;\r\n\t\t\t\t\tvar index2 = 3 * edges[ 2 * i + j];\r\n\t\t\t\t\tcoords[ index + 0 ] = vertices[ index2 ];\r\n\t\t\t\t\tcoords[ index + 1 ] = vertices[ index2 + 1 ];\r\n\t\t\t\t\tcoords[ index + 2 ] = vertices[ index2 + 2 ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeometry.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );\r\n\r\n\t\t} else { // non-indexed BufferGeometry\r\n\r\n\t\t\tvar vertices = object.geometry.attributes.position.array;\r\n\t\t\tvar numEdges = vertices.length / 3;\r\n\t\t\tvar numTris = numEdges / 3;\r\n\r\n\t\t\tvar coords = new Float32Array( numEdges * 2 * 3 );\r\n\r\n\t\t\tfor ( var i = 0, l = numTris; i < l; i ++ ) {\r\n\r\n\t\t\t\tfor ( var j = 0; j < 3; j ++ ) {\r\n\r\n\t\t\t\t\tvar index = 18 * i + 6 * j;\r\n\r\n\t\t\t\t\tvar index1 = 9 * i + 3 * j;\r\n\t\t\t\t\tcoords[ index + 0 ] = vertices[ index1 ];\r\n\t\t\t\t\tcoords[ index + 1 ] = vertices[ index1 + 1 ];\r\n\t\t\t\t\tcoords[ index + 2 ] = vertices[ index1 + 2 ];\r\n\r\n\t\t\t\t\tvar index2 = 9 * i + 3 * ( ( j + 1 ) % 3 );\r\n\t\t\t\t\tcoords[ index + 3 ] = vertices[ index2 ];\r\n\t\t\t\t\tcoords[ index + 4 ] = vertices[ index2 + 1 ];\r\n\t\t\t\t\tcoords[ index + 5 ] = vertices[ index2 + 2 ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeometry.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tTHREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color } ), THREE.LinePieces );\r\n\r\n\tthis.matrix = object.matrixWorld;\r\n\tthis.matrixAutoUpdate = false;\r\n\r\n};\r\n\r\nTHREE.WireframeHelper.prototype = Object.create( THREE.Line.prototype );\r\nTHREE.WireframeHelper.prototype.constructor = THREE.WireframeHelper;\r\n\r\n// File:src/extras/objects/ImmediateRenderObject.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.ImmediateRenderObject = function () {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.render = function ( renderCallback ) {};\r\n\r\n};\r\n\r\nTHREE.ImmediateRenderObject.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.ImmediateRenderObject.prototype.constructor = THREE.ImmediateRenderObject;\r\n\r\n// File:src/extras/objects/MorphBlendMesh.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.MorphBlendMesh = function( geometry, material ) {\r\n\r\n\tTHREE.Mesh.call( this, geometry, material );\r\n\r\n\tthis.animationsMap = {};\r\n\tthis.animationsList = [];\r\n\r\n\t// prepare default animation\r\n\t// (all frames played together in 1 second)\r\n\r\n\tvar numFrames = this.geometry.morphTargets.length;\r\n\r\n\tvar name = \"__default\";\r\n\r\n\tvar startFrame = 0;\r\n\tvar endFrame = numFrames - 1;\r\n\r\n\tvar fps = numFrames / 1;\r\n\r\n\tthis.createAnimation( name, startFrame, endFrame, fps );\r\n\tthis.setAnimationWeight( name, 1 );\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype = Object.create( THREE.Mesh.prototype );\r\nTHREE.MorphBlendMesh.prototype.constructor = THREE.MorphBlendMesh;\r\n\r\nTHREE.MorphBlendMesh.prototype.createAnimation = function ( name, start, end, fps ) {\r\n\r\n\tvar animation = {\r\n\r\n\t\tstartFrame: start,\r\n\t\tendFrame: end,\r\n\r\n\t\tlength: end - start + 1,\r\n\r\n\t\tfps: fps,\r\n\t\tduration: ( end - start ) / fps,\r\n\r\n\t\tlastFrame: 0,\r\n\t\tcurrentFrame: 0,\r\n\r\n\t\tactive: false,\r\n\r\n\t\ttime: 0,\r\n\t\tdirection: 1,\r\n\t\tweight: 1,\r\n\r\n\t\tdirectionBackwards: false,\r\n\t\tmirroredLoop: false\r\n\r\n\t};\r\n\r\n\tthis.animationsMap[ name ] = animation;\r\n\tthis.animationsList.push( animation );\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.autoCreateAnimations = function ( fps ) {\r\n\r\n\tvar pattern = /([a-z]+)_?(\\d+)/;\r\n\r\n\tvar firstAnimation, frameRanges = {};\r\n\r\n\tvar geometry = this.geometry;\r\n\r\n\tfor ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {\r\n\r\n\t\tvar morph = geometry.morphTargets[ i ];\r\n\t\tvar chunks = morph.name.match( pattern );\r\n\r\n\t\tif ( chunks && chunks.length > 1 ) {\r\n\r\n\t\t\tvar name = chunks[ 1 ];\r\n\r\n\t\t\tif ( ! frameRanges[ name ] ) frameRanges[ name ] = { start: Infinity, end: - Infinity };\r\n\r\n\t\t\tvar range = frameRanges[ name ];\r\n\r\n\t\t\tif ( i < range.start ) range.start = i;\r\n\t\t\tif ( i > range.end ) range.end = i;\r\n\r\n\t\t\tif ( ! firstAnimation ) firstAnimation = name;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfor ( var name in frameRanges ) {\r\n\r\n\t\tvar range = frameRanges[ name ];\r\n\t\tthis.createAnimation( name, range.start, range.end, fps );\r\n\r\n\t}\r\n\r\n\tthis.firstAnimation = firstAnimation;\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function ( name ) {\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\tanimation.direction = 1;\r\n\t\tanimation.directionBackwards = false;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function ( name ) {\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\tanimation.direction = - 1;\r\n\t\tanimation.directionBackwards = true;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.setAnimationFPS = function ( name, fps ) {\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\tanimation.fps = fps;\r\n\t\tanimation.duration = ( animation.end - animation.start ) / animation.fps;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.setAnimationDuration = function ( name, duration ) {\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\tanimation.duration = duration;\r\n\t\tanimation.fps = ( animation.end - animation.start ) / animation.duration;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.setAnimationWeight = function ( name, weight ) {\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\tanimation.weight = weight;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.setAnimationTime = function ( name, time ) {\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\tanimation.time = time;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.getAnimationTime = function ( name ) {\r\n\r\n\tvar time = 0;\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\ttime = animation.time;\r\n\r\n\t}\r\n\r\n\treturn time;\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.getAnimationDuration = function ( name ) {\r\n\r\n\tvar duration = - 1;\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\tduration = animation.duration;\r\n\r\n\t}\r\n\r\n\treturn duration;\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.playAnimation = function ( name ) {\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\tanimation.time = 0;\r\n\t\tanimation.active = true;\r\n\r\n\t} else {\r\n\r\n\t\tTHREE.warn( \"THREE.MorphBlendMesh: animation[\" + name + \"] undefined in .playAnimation()\" );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.stopAnimation = function ( name ) {\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\tanimation.active = false;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.update = function ( delta ) {\r\n\r\n\tfor ( var i = 0, il = this.animationsList.length; i < il; i ++ ) {\r\n\r\n\t\tvar animation = this.animationsList[ i ];\r\n\r\n\t\tif ( ! animation.active ) continue;\r\n\r\n\t\tvar frameTime = animation.duration / animation.length;\r\n\r\n\t\tanimation.time += animation.direction * delta;\r\n\r\n\t\tif ( animation.mirroredLoop ) {\r\n\r\n\t\t\tif ( animation.time > animation.duration || animation.time < 0 ) {\r\n\r\n\t\t\t\tanimation.direction *= - 1;\r\n\r\n\t\t\t\tif ( animation.time > animation.duration ) {\r\n\r\n\t\t\t\t\tanimation.time = animation.duration;\r\n\t\t\t\t\tanimation.directionBackwards = true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( animation.time < 0 ) {\r\n\r\n\t\t\t\t\tanimation.time = 0;\r\n\t\t\t\t\tanimation.directionBackwards = false;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tanimation.time = animation.time % animation.duration;\r\n\r\n\t\t\tif ( animation.time < 0 ) animation.time += animation.duration;\r\n\r\n\t\t}\r\n\r\n\t\tvar keyframe = animation.startFrame + THREE.Math.clamp( Math.floor( animation.time / frameTime ), 0, animation.length - 1 );\r\n\t\tvar weight = animation.weight;\r\n\r\n\t\tif ( keyframe !== animation.currentFrame ) {\r\n\r\n\t\t\tthis.morphTargetInfluences[ animation.lastFrame ] = 0;\r\n\t\t\tthis.morphTargetInfluences[ animation.currentFrame ] = 1 * weight;\r\n\r\n\t\t\tthis.morphTargetInfluences[ keyframe ] = 0;\r\n\r\n\t\t\tanimation.lastFrame = animation.currentFrame;\r\n\t\t\tanimation.currentFrame = keyframe;\r\n\r\n\t\t}\r\n\r\n\t\tvar mix = ( animation.time % frameTime ) / frameTime;\r\n\r\n\t\tif ( animation.directionBackwards ) mix = 1 - mix;\r\n\r\n\t\tthis.morphTargetInfluences[ animation.currentFrame ] = mix * weight;\r\n\t\tthis.morphTargetInfluences[ animation.lastFrame ] = ( 1 - mix ) * weight;\r\n\r\n\t}\r\n\r\n};\r\n\r\n\r\n// Export the THREE object for **Node.js**, with\r\n// backwards-compatibility for the old `require()` API. If we're in\r\n// the browser, add `_` as a global object via a string identifier,\r\n// for Closure Compiler \"advanced\" mode.\r\nif (typeof exports !== 'undefined') {\r\n  if (typeof module !== 'undefined' && module.exports) {\r\n    exports = module.exports = THREE;\r\n  }\r\n  exports.THREE = THREE;\r\n} else {\r\n  this['THREE'] = THREE;\r\n}\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/three/three.js\n ** module id = 33\n ** module chunks = 0\n **/","var map = {\n\t\"./asphalt.jpg\": 42,\n\t\"./brick-tiles.jpg\": 43,\n\t\"./bricks-normal.jpg\": 44,\n\t\"./bricks-specular.jpg\": 45,\n\t\"./bricks.jpg\": 46,\n\t\"./checkerboard.png\": 47,\n\t\"./cloud10.png\": 48,\n\t\"./grass.jpg\": 49,\n\t\"./metal-floor.jpg\": 50,\n\t\"./metal.jpg\": 51,\n\t\"./stone.jpg\": 52,\n\t\"./tiles.jpg\": 53,\n\t\"./weathered-wood.jpg\": 54,\n\t\"./wood.jpg\": 55\n};\nfunction webpackContext(req) {\n\treturn __webpack_require__(webpackContextResolve(req));\n};\nfunction webpackContextResolve(req) {\n\treturn map[req] || (function() { throw new Error(\"Cannot find module '\" + req + \"'.\") }());\n};\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = 34;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/images ^\\.\\/.*$\n ** module id = 34\n ** module chunks = 0\n **/","module.exports = new RegExp(\n\t'^' +\n\n\t// protocol identifier\n\t'(?:(?:(?:https?):)?//)' +\n\n\t// user:pass authentication\n\t'(?:\\\\S+(?::\\\\S*)?@)?' +\n\t'(?:' +\n\n\t// IP address exclusion\n\t// private & local networks\n\t'(' +\n\t'(?!(?:10|127)(?:\\\\.\\\\d{1,3}){3})' +\n\t'(?!(?:169\\\\.254|192\\\\.168)(?:\\\\.\\\\d{1,3}){2})' +\n\t'(?!172\\\\.(?:1[6-9]|2\\\\d|3[0-1])(?:\\\\.\\\\d{1,3}){2})' +\n\n\t// IP address dotted notation octets\n\t// excludes loopback network 0.0.0.0\n\t// excludes reserved space >= 224.0.0.0\n\t// excludes network & broacast addresses\n\t// (first & last IP address of each class)\n\t'(?:[1-9]\\\\d?|1\\\\d\\\\d|2[01]\\\\d|22[0-3])' +\n\t'(?:\\\\.(?:1?\\\\d{1,2}|2[0-4]\\\\d|25[0-5])){2}' +\n\t'(?:\\\\.(?:[1-9]\\\\d?|1\\\\d\\\\d|2[0-4]\\\\d|25[0-4]))' +\n\t'|' +\n\n\t// host name\n\t'(?:(?:[a-z\\\\u00a1-\\\\uffff0-9]-*)*[a-z\\\\u00a1-\\\\uffff0-9]+)' +\n\n\t// domain name\n\t'(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff0-9]-*)*[a-z\\\\u00a1-\\\\uffff0-9]+)*' +\n\n\t// TLD identifier\n\t'(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff]{2,}))?' +\n\t')' +\n\n\t')' +\n\n\t// port number\n\t'(?::(\\\\d{2,5}))?' +\n\n\t// resource path\n\t'(?:/\\\\S*)?' +\n\t'$', 'i'\n);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/utils/urlregex.js\n ** module id = 35\n ** module chunks = 0\n **/","/**\n * lodash 3.0.3 (Custom Build) <https://lodash.com/>\n * Build: `lodash modern modularize exports=\"npm\" -o ./`\n * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <https://lodash.com/license>\n */\nvar arrayEach = require('lodash._arrayeach'),\n    baseEach = require('lodash._baseeach'),\n    bindCallback = require('lodash._bindcallback'),\n    isArray = require('lodash.isarray');\n\n/**\n * Creates a function for `_.forEach` or `_.forEachRight`.\n *\n * @private\n * @param {Function} arrayFunc The function to iterate over an array.\n * @param {Function} eachFunc The function to iterate over a collection.\n * @returns {Function} Returns the new each function.\n */\nfunction createForEach(arrayFunc, eachFunc) {\n  return function(collection, iteratee, thisArg) {\n    return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection))\n      ? arrayFunc(collection, iteratee)\n      : eachFunc(collection, bindCallback(iteratee, thisArg, 3));\n  };\n}\n\n/**\n * Iterates over elements of `collection` invoking `iteratee` for each element.\n * The `iteratee` is bound to `thisArg` and invoked with three arguments:\n * (value, index|key, collection). Iteratee functions may exit iteration early\n * by explicitly returning `false`.\n *\n * **Note:** As with other \"Collections\" methods, objects with a \"length\" property\n * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`\n * may be used for object iteration.\n *\n * @static\n * @memberOf _\n * @alias each\n * @category Collection\n * @param {Array|Object|string} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @param {*} [thisArg] The `this` binding of `iteratee`.\n * @returns {Array|Object|string} Returns `collection`.\n * @example\n *\n * _([1, 2]).forEach(function(n) {\n *   console.log(n);\n * }).value();\n * // => logs each value from left to right and returns the array\n *\n * _.forEach({ 'a': 1, 'b': 2 }, function(n, key) {\n *   console.log(n, key);\n * });\n * // => logs each value-key pair and returns the object (iteration order is not guaranteed)\n */\nvar forEach = createForEach(arrayEach, baseEach);\n\nmodule.exports = forEach;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash.foreach/index.js\n ** module id = 36\n ** module chunks = 0\n **/","/**\n * lodash 3.1.0 (Custom Build) <https://lodash.com/>\n * Build: `lodash modern modularize exports=\"npm\" -o ./`\n * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <https://lodash.com/license>\n */\nvar baseAssign = require('lodash._baseassign'),\n    createAssigner = require('lodash._createassigner'),\n    isNative = require('lodash.isnative'),\n    keys = require('lodash.keys');\n\n/** Used for native method references. */\nvar arrayProto = Array.prototype;\n\n/** Native method references. */\nvar getOwnPropertySymbols = isNative(getOwnPropertySymbols = Object.getOwnPropertySymbols) && getOwnPropertySymbols,\n    push = arrayProto.push;\n\n/**\n * A specialized version of `_.assign` for customizing assigned values without\n * support for argument juggling, multiple sources, and `this` binding `customizer`\n * functions.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @param {Function} customizer The function to customize assigned values.\n * @returns {Object} Returns `object`.\n */\nfunction assignWith(object, source, customizer) {\n  var props = keys(source);\n  push.apply(props, getSymbols(source));\n\n  var index = -1,\n      length = props.length;\n\n  while (++index < length) {\n    var key = props[index],\n        value = object[key],\n        result = customizer(value, source[key], key, object, source);\n\n    if ((result === result ? (result !== value) : (value === value)) ||\n        (value === undefined && !(key in object))) {\n      object[key] = result;\n    }\n  }\n  return object;\n}\n\n/**\n * Creates an array of the own symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbols = !getOwnPropertySymbols ? constant([]) : function(object) {\n  return getOwnPropertySymbols(toObject(object));\n};\n\n/**\n * Converts `value` to an object if it is not one.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {Object} Returns the object.\n */\nfunction toObject(value) {\n  return isObject(value) ? value : Object(value);\n}\n\n/**\n * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.\n * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(1);\n * // => false\n */\nfunction isObject(value) {\n  // Avoid a V8 JIT bug in Chrome 19-20.\n  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n  var type = typeof value;\n  return type == 'function' || (!!value && type == 'object');\n}\n\n/**\n * Assigns own enumerable properties of source object(s) to the destination\n * object. Subsequent sources overwrite property assignments of previous sources.\n * If `customizer` is provided it is invoked to produce the assigned values.\n * The `customizer` is bound to `thisArg` and invoked with five arguments:\n * (objectValue, sourceValue, key, object, source).\n *\n * **Note:** This method mutates `object` and is based on\n * [`Object.assign`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.assign).\n *\n *\n * @static\n * @memberOf _\n * @alias extend\n * @category Object\n * @param {Object} object The destination object.\n * @param {...Object} [sources] The source objects.\n * @param {Function} [customizer] The function to customize assigned values.\n * @param {*} [thisArg] The `this` binding of `customizer`.\n * @returns {Object} Returns `object`.\n * @example\n *\n * _.assign({ 'user': 'barney' }, { 'age': 40 }, { 'user': 'fred' });\n * // => { 'user': 'fred', 'age': 40 }\n *\n * // using a customizer callback\n * var defaults = _.partialRight(_.assign, function(value, other) {\n *   return _.isUndefined(value) ? other : value;\n * });\n *\n * defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });\n * // => { 'user': 'barney', 'age': 36 }\n */\nvar assign = createAssigner(function(object, source, customizer) {\n  return customizer\n    ? assignWith(object, source, customizer)\n    : baseAssign(object, source);\n});\n\n/**\n * Creates a function that returns `value`.\n *\n * @static\n * @memberOf _\n * @category Utility\n * @param {*} value The value to return from the new function.\n * @returns {Function} Returns the new function.\n * @example\n *\n * var object = { 'user': 'fred' };\n * var getter = _.constant(object);\n *\n * getter() === object;\n * // => true\n */\nfunction constant(value) {\n  return function() {\n    return value;\n  };\n}\n\nmodule.exports = assign;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash.assign/index.js\n ** module id = 37\n ** module chunks = 0\n **/","/*** IMPORTS FROM imports-loader ***/\nvar THREE = require(\"three\");\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Audio = function ( listener ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.type = 'Audio';\n\tthis.started = false;\n\n\tif (listener.context) {\n\n\t\tthis.context = listener.context;\n\t\t// this.source = this.context.createBufferSource();\n\n\t\tthis.gain = this.context.createGain();\n\t\tthis.gain.connect( listener.input );\n\n\t\tthis.panner = this.context.createPanner();\n\t\tthis.panner.connect( this.gain );\n\n\t} else {\n\n\t\tthis.source = new Audio();\n\n\t}\n};\n\nTHREE.Audio.prototype = Object.create( THREE.Object3D.prototype );\n\nTHREE.Audio.prototype.load = function ( sources ) {\n\t//todo: support multiple sources for different audio formats\n\n\tvar scope = this;\n\tvar file;\n\tvar i;\n\tvar match;\n\tvar element = this.source instanceof window.HTMLAudioElement ? this.source : new Audio();\n\n\tif (typeof sources === 'string') {\n\t\tsources = [sources];\n\t}\n\n\tfor (i = 0; i < sources.length; i++) {\n\t\tfile = sources[i];\n\t\tmatch = /\\.([a-z0-9]+)$/i.exec(file);\n\t\tif (match && element.canPlayType('audio/' + match[1])) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (this.context) {\n\t\tvar request = new XMLHttpRequest();\n\t\trequest.open( 'GET', file, true );\n\t\trequest.responseType = 'arraybuffer';\n\t\trequest.onload = function ( e ) {\n\t\t\tconsole.log('audio buffer loaded. decoding...', e );\n\t\t\tscope.context.decodeAudioData( this.response, function ( buffer ) {\n\n\t\t\t\tscope.buffer = buffer;\n\t\t\t\tif (scope.started) {\n\t\t\t\t\tscope.start();\n\t\t\t\t}\n\n\t\t\t}, function onFailure(e) {\n\t\t\t\tconsole.log('Decoding the audio buffer failed', e);\n\t\t\t} );\n\n\t\t};\n\n\t\trequest.onerror = function ( e ) {\n\t\t\tconsole.log('error', e);\n\t\t};\n\n\t\trequest.send();\n\n\t} else {\n\n\t\tthis.source.src = file;\n\t\tthis.source.play();\n\n\t}\n\n\treturn this;\n};\n\nTHREE.Audio.prototype.stop = function ( value ) {\n\n\tif (this.context) {\n\t\tthis.source.stop();\n\t\tthis.source.disconnect( this.panner );\n\t\tthis.source = null;\n\t} else {\n\t\tthis.source.pause();\n\t\tthis.source.currentTime = 0;\n\t}\n\tthis.started = false;\n};\n\nTHREE.Audio.prototype.start = function ( value ) {\n\n\tthis.started = true;\n\tif (this.context) {\n\t\tif (this.source) {\n\t\t\tthis.source.disconnect( this.panner );\n\t\t}\n\n\t\tif (this.buffer) {\n\t\t\tthis.source = this.context.createBufferSource();\n\t\t\tthis.source.buffer = this.buffer;\n\t\t\tthis.source.connect( this.panner );\n\t\t\tthis.source.start( 0 );\n\t\t}\n\t} else {\n\t\tthis.source.currentTime = 0;\n\t\tthis.source.play();\n\t}\n\n};\n\nTHREE.Audio.prototype.setLoop = function ( value ) {\n\n\tthis.source.loop = value;\n\n};\n\nTHREE.Audio.prototype.setRefDistance = function ( value ) {\n\n\tif ( this.panner ) {\n\n\t\tthis.panner.refDistance = value;\n\n\t}\n\n};\n\nTHREE.Audio.prototype.setRolloffFactor = function ( value ) {\n\n\tif ( this.panner ) {\n\n\t\tthis.panner.rolloffFactor = value;\n\n\t}\n\n};\n\nTHREE.Audio.prototype.volume = function ( volume, time ) {\n\n\tif ( this.gain ) {\n\n\t\tif ( volume !== undefined ) {\n\t\t\tthis.gain.gain.linearRampToValueAtTime( volume, this.context.currentTime + (time || 0));\n\t\t}\n\n\t\treturn this.gain.gain.value;\n\t}\n\n\tif ( volume !== undefined ) {\n\t\tthis.source.volume = volume;\n\t}\n\n\treturn this.source.volume;\n};\n\nTHREE.Audio.prototype.updateMatrixWorld = ( function () {\n\n\tvar position = new THREE.Vector3();\n\n\treturn function ( force ) {\n\n\t\tTHREE.Object3D.prototype.updateMatrixWorld.call( this, force );\n\n\t\tposition.setFromMatrixPosition( this.matrixWorld );\n\n\t\tif (this.panner) {\n\n\t\t\tthis.panner.setPosition( position.x, position.y, position.z );\n\n\t\t}\n\n\t};\n\n} )();\n\n// File:src/extras/audio/AudioListener.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.AudioListener = function () {\n\tvar AudioContext = window.AudioContext || window.webkitAudioContext;\n\n\tTHREE.Object3D.call( this );\n\n\tthis.type = 'AudioListener';\n\n\tif (AudioContext) {\n\t\tthis.context = new AudioContext();\n\t\tthis.input = this.context.createGain();\n\n\t\tthis.input.connect( this.context.destination );\n\t}\n};\n\nTHREE.AudioListener.prototype = Object.create( THREE.Object3D.prototype );\n\nTHREE.AudioListener.prototype.volume = function (val) {\n\tif (this.input) {\n\t\tval = val !== undefined && parseFloat(val);\n\t\tif (!isNaN(val)) {\n\t\t\tthis.input.gain.value = val;\n\t\t}\n\n\t\treturn this.input.gain.value;\n\t}\n};\n\nTHREE.AudioListener.prototype.updateMatrixWorld = ( function () {\n\n\tvar position = new THREE.Vector3();\n\tvar quaternion = new THREE.Quaternion();\n\tvar scale = new THREE.Vector3();\n\n\tvar orientation = new THREE.Vector3();\n\n\treturn function ( force ) {\n\n\t\tTHREE.Object3D.prototype.updateMatrixWorld.call( this, force );\n\n\t\tvar listener;\n\n\t\tif (this.context) {\n\t\t\tlistener = this.context.listener;\n\n\t\t\tthis.matrixWorld.decompose( position, quaternion, scale );\n\n\t\t\torientation.set( 0, 0, -1 ).applyQuaternion( quaternion );\n\n\t\t\tlistener.setPosition( position.x, position.y, position.z );\n\t\t\tlistener.setOrientation( orientation.x, orientation.y, orientation.z, this.up.x, this.up.y, this.up.z );\n\n\t\t}\n\t};\n\n} ());\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/imports-loader?THREE=three!./src/lib/ThreeAudio.js\n ** module id = 38\n ** module chunks = 0\n **/","/*** IMPORTS FROM imports-loader ***/\nvar THREE = require(\"three\");\n\n/**\n * @author zz85 / https://github.com/zz85\n * \n * Based on \"A Practical Analytic Model for Daylight\" \n * aka The Preetham Model, the de facto standard analytic skydome model\n * http://www.cs.utah.edu/~shirley/papers/sunsky/sunsky.pdf\n * \n * First implemented by Simon Wallner\n * http://www.simonwallner.at/projects/atmospheric-scattering\n * \n * Improved by Martin Upitis\n * http://blenderartists.org/forum/showthread.php?245954-preethams-sky-impementation-HDR\n * \n * Three.js integration by zz85 http://twitter.com/blurspline\n*/\n\nTHREE.ShaderLib['sky'] = {\n\n\tuniforms: {\n\n\t\tluminance:\t { type: \"f\", value:1 },\n\t\tturbidity:\t { type: \"f\", value:2 },\n\t\treileigh:\t { type: \"f\", value:1 },\n\t\tmieCoefficient:\t { type: \"f\", value:0.005 },\n\t\tmieDirectionalG: { type: \"f\", value:0.8 },\n\t\tsunPosition: \t { type: \"v3\", value: new THREE.Vector3() }\n\n\t},\n\n\tvertexShader: [\n\n\t\t\"varying vec3 vWorldPosition;\",\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\",\n\t\t\t\"vWorldPosition = worldPosition.xyz;\",\n\t\t\t\"vUv = uv;\",\n\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\"}\",\n\n\t].join(\"\\n\"),\n\n\tfragmentShader: [\n\n\n\t\t\"uniform sampler2D skySampler;\",\n\t\t\"uniform vec3 sunPosition;\",\n\t\t\"varying vec3 vWorldPosition;\",\n\t\t\"varying vec2 vUv;\",\n\n\n\t\t\"vec3 cameraPos = vec3(0., 0., 0.);\",\n\t\t\"// uniform sampler2D sDiffuse;\",\n\t\t\"// const float turbidity = 10.0; //\",\n\t\t\"// const float reileigh = 2.; //\",\n\t\t\"// const float luminance = 1.0; //\",\n\t\t\"// const float mieCoefficient = 0.005;\",\n\t\t\"// const float mieDirectionalG = 0.8;\",\n\n\t\t\"uniform float luminance;\",\n\t\t\"uniform float turbidity;\",\n\t\t\"uniform float reileigh;\",\n\t\t\"uniform float mieCoefficient;\",\n\t\t\"uniform float mieDirectionalG;\",\n\n\n\t\t\"vec3 sunDirection = normalize(sunPosition);\",\n\t\t\"float reileighCoefficient = reileigh;\",\n\n\t\t\"// constants for atmospheric scattering\",\n\t\t\"const float e = 2.71828182845904523536028747135266249775724709369995957;\",\n\t\t\"const float pi = 3.141592653589793238462643383279502884197169;\",\n\n\t\t\"const float n = 1.0003; // refractive index of air\",\n\t\t\"const float N = 2.545E25; // number of molecules per unit volume for air at\",\n\t\t\t\t\t\t\t\t\"// 288.15K and 1013mb (sea level -45 celsius)\",\n\t\t\"const float pn = 0.035;\t// depolatization factor for standard air\",\n\n\t\t\"// wavelength of used primaries, according to preetham\",\n\t\t\"const vec3 lambda = vec3(680E-9, 550E-9, 450E-9);\",\n\n\t\t\"// mie stuff\",\n\t\t\"// K coefficient for the primaries\",\n\t\t\"const vec3 K = vec3(0.686, 0.678, 0.666);\",\n\t\t\"const float v = 4.0;\",\n\n\t\t\"// optical length at zenith for molecules\",\n\t\t\"const float rayleighZenithLength = 8.4E3;\",\n\t\t\"const float mieZenithLength = 1.25E3;\",\n\t\t\"const vec3 up = vec3(0.0, 1.0, 0.0);\",\n\n\t\t\"const float EE = 1000.0;\",\n\t\t\"const float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;\",\n\t\t\"// 66 arc seconds -> degrees, and the cosine of that\",\n\n\t\t\"// earth shadow hack\",\n\t\t\"const float cutoffAngle = pi/1.95;\",\n\t\t\"const float steepness = 1.5;\",\n\n\n\t\t\"vec3 totalRayleigh(vec3 lambda)\",\n\t\t\"{\",\n\t\t\t\"return (8.0 * pow(pi, 3.0) * pow(pow(n, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * pn)) / (3.0 * N * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * pn));\",\n\t\t\"}\",\n\n\t\t// see http://blenderartists.org/forum/showthread.php?321110-Shaders-and-Skybox-madness\n\t\t\"// A simplied version of the total Reayleigh scattering to works on browsers that use ANGLE\",\n\t\t\"vec3 simplifiedRayleigh()\",\n\t\t\"{\",\n\t\t\t\"return 0.0005 / vec3(94, 40, 18);\",\n\t\t\t// return 0.00054532832366 / (3.0 * 2.545E25 * pow(vec3(680E-9, 550E-9, 450E-9), vec3(4.0)) * 6.245);\n\t\t\"}\",\n\n\t\t\"float rayleighPhase(float cosTheta)\",\n\t\t\"{\t \",\n\t\t\t\"return (3.0 / (16.0*pi)) * (1.0 + pow(cosTheta, 2.0));\",\n\t\t\"//\treturn (1.0 / (3.0*pi)) * (1.0 + pow(cosTheta, 2.0));\",\n\t\t\"//\treturn (3.0 / 4.0) * (1.0 + pow(cosTheta, 2.0));\",\n\t\t\"}\",\n\n\t\t\"vec3 totalMie(vec3 lambda, vec3 K, float T)\",\n\t\t\"{\",\n\t\t\t\"float c = (0.2 * T ) * 10E-18;\",\n\t\t\t\"return 0.434 * c * pi * pow((2.0 * pi) / lambda, vec3(v - 2.0)) * K;\",\n\t\t\"}\",\n\n\t\t\"float hgPhase(float cosTheta, float g)\",\n\t\t\"{\",\n\t\t\t\"return (1.0 / (4.0*pi)) * ((1.0 - pow(g, 2.0)) / pow(1.0 - 2.0*g*cosTheta + pow(g, 2.0), 1.5));\",\n\t\t\"}\",\n\n\t\t\"float sunIntensity(float zenithAngleCos)\",\n\t\t\"{\",\n\t\t\t\"return EE * max(0.0, 1.0 - exp(-((cutoffAngle - acos(zenithAngleCos))/steepness)));\",\n\t\t\"}\",\n\n\t\t\"// float logLuminance(vec3 c)\",\n\t\t\"// {\",\n\t\t\"// \treturn log(c.r * 0.2126 + c.g * 0.7152 + c.b * 0.0722);\",\n\t\t\"// }\",\n\n\t\t\"// Filmic ToneMapping http://filmicgames.com/archives/75\",\n\t\t\"float A = 0.15;\",\n\t\t\"float B = 0.50;\",\n\t\t\"float C = 0.10;\",\n\t\t\"float D = 0.20;\",\n\t\t\"float E = 0.02;\",\n\t\t\"float F = 0.30;\",\n\t\t\"float W = 1000.0;\",\n\n\t\t\"vec3 Uncharted2Tonemap(vec3 x)\",\n\t\t\"{\",\n\t\t   \"return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;\",\n\t\t\"}\",\n\n\n\t\t\"void main() \",\n\t\t\"{\",\n\t\t\t\"float sunfade = 1.0-clamp(1.0-exp((sunPosition.y/450000.0)),0.0,1.0);\",\n\n\t\t\t\"// luminance =  1.0 ;// vWorldPosition.y / 450000. + 0.5; //sunPosition.y / 450000. * 1. + 0.5;\",\n\n\t\t\t \"// gl_FragColor = vec4(sunfade, sunfade, sunfade, 1.0);\",\n\t\t\t\n\t\t\t\"reileighCoefficient = reileighCoefficient - (1.0* (1.0-sunfade));\",\n\t\t\t\n\t\t\t\"float sunE = sunIntensity(dot(sunDirection, up));\",\n\n\t\t\t\"// extinction (absorbtion + out scattering) \",\n\t\t\t\"// rayleigh coefficients\",\n\n\t\t\t// \"vec3 betaR = totalRayleigh(lambda) * reileighCoefficient;\",\n\t\t\t\"vec3 betaR = simplifiedRayleigh() * reileighCoefficient;\",\n\n\t\t\t\"// mie coefficients\",\n\t\t\t\"vec3 betaM = totalMie(lambda, K, turbidity) * mieCoefficient;\",\n\n\t\t\t\"// optical length\",\n\t\t\t\"// cutoff angle at 90 to avoid singularity in next formula.\",\n\t\t\t\"float zenithAngle = acos(max(0.0, dot(up, normalize(vWorldPosition - cameraPos))));\",\n\t\t\t\"float sR = rayleighZenithLength / (cos(zenithAngle) + 0.15 * pow(93.885 - ((zenithAngle * 180.0) / pi), -1.253));\",\n\t\t\t\"float sM = mieZenithLength / (cos(zenithAngle) + 0.15 * pow(93.885 - ((zenithAngle * 180.0) / pi), -1.253));\",\n\n\n\n\t\t\t\"// combined extinction factor\t\",\n\t\t\t\"vec3 Fex = exp(-(betaR * sR + betaM * sM));\",\n\n\t\t\t\"// in scattering\",\n\t\t\t\"float cosTheta = dot(normalize(vWorldPosition - cameraPos), sunDirection);\",\n\n\t\t\t\"float rPhase = rayleighPhase(cosTheta*0.5+0.5);\",\n\t\t\t\"vec3 betaRTheta = betaR * rPhase;\",\n\n\t\t\t\"float mPhase = hgPhase(cosTheta, mieDirectionalG);\",\n\t\t\t\"vec3 betaMTheta = betaM * mPhase;\",\n\n\n\t\t\t\"vec3 Lin = pow(sunE * ((betaRTheta + betaMTheta) / (betaR + betaM)) * (1.0 - Fex),vec3(1.5));\",\n\t\t\t\"Lin *= mix(vec3(1.0),pow(sunE * ((betaRTheta + betaMTheta) / (betaR + betaM)) * Fex,vec3(1.0/2.0)),clamp(pow(1.0-dot(up, sunDirection),5.0),0.0,1.0));\",\n\n\t\t\t\"//nightsky\",\n\t\t\t\"vec3 direction = normalize(vWorldPosition - cameraPos);\",\n\t\t\t\"float theta = acos(direction.y); // elevation --> y-axis, [-pi/2, pi/2]\",\n\t\t\t\"float phi = atan(direction.z, direction.x); // azimuth --> x-axis [-pi/2, pi/2]\",\n\t\t\t\"vec2 uv = vec2(phi, theta) / vec2(2.0*pi, pi) + vec2(0.5, 0.0);\",\n\t\t\t\"// vec3 L0 = texture2D(skySampler, uv).rgb+0.1 * Fex;\",\n\t\t\t\"vec3 L0 = vec3(0.1) * Fex;\",\n\t\t\t\n\t\t\t\"// composition + solar disc\",\n\t\t\t\"//if (cosTheta > sunAngularDiameterCos)\",\n\t\t\t\"float sundisk = smoothstep(sunAngularDiameterCos,sunAngularDiameterCos+0.00002,cosTheta);\",\n\t\t\t\"// if (normalize(vWorldPosition - cameraPos).y>0.0)\",\n\t\t\t\"L0 += (sunE * 19000.0 * Fex)*sundisk;\",\n\n\n\t\t\t\"vec3 whiteScale = 1.0/Uncharted2Tonemap(vec3(W));\",\n\t\t\t\n\t\t\t\"vec3 texColor = (Lin+L0);   \",\n\t\t\t\"texColor *= 0.04 ;\",\n\t\t\t\"texColor += vec3(0.0,0.001,0.0025)*0.3;\",\n\t\t\t\n\t\t\t\"float g_fMaxLuminance = 1.0;\",\n\t\t\t\"float fLumScaled = 0.1 / luminance;     \",\n\t\t\t\"float fLumCompressed = (fLumScaled * (1.0 + (fLumScaled / (g_fMaxLuminance * g_fMaxLuminance)))) / (1.0 + fLumScaled); \",\n\n\t\t\t\"float ExposureBias = fLumCompressed;\",\n\t\t   \n\t\t\t\"vec3 curr = Uncharted2Tonemap((log2(2.0/pow(luminance,4.0)))*texColor);\",\n\t\t\t\"vec3 color = curr*whiteScale;\",\n\n\t\t\t\"vec3 retColor = pow(color,vec3(1.0/(1.2+(1.2*sunfade))));\",\n\n\t\t\t\n\t\t\t\"gl_FragColor.rgb = retColor;\",\n\t\t\t\t\n\t\t\t\"gl_FragColor.a = 1.0;\",\n\t\t\"}\",\n\n\t].join(\"\\n\")\n\n};\n\nTHREE.Sky = function () {\n\n\tvar skyShader = THREE.ShaderLib[ \"sky\" ];\n\tvar skyUniforms = THREE.UniformsUtils.clone( skyShader.uniforms );\n\n\tvar skyMat = new THREE.ShaderMaterial( { \n\t\tfragmentShader: skyShader.fragmentShader, \n\t\tvertexShader: skyShader.vertexShader, \n\t\tuniforms: skyUniforms,\n\t\tside: THREE.BackSide\n\t} );\n\n\tvar skyGeo = new THREE.SphereGeometry( 450000, 32, 15 );\n\tvar skyMesh = new THREE.Mesh( skyGeo, skyMat );\n\n\n\t// Expose variables\n\tthis.mesh = skyMesh;\n\tthis.uniforms = skyUniforms;\n\n\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/imports-loader?THREE=three!./bower_components/SkyShader/index.js\n ** module id = 39\n ** module chunks = 0\n **/","/*** IMPORTS FROM imports-loader ***/\nvar THREE = require(\"three\");\n\n// ShaderParticleUtils 0.7.9\n//\n// (c) 2014 Luke Moody (http://www.github.com/squarefeet)\n//     & Lee Stemkoski (http://www.adelphi.edu/~stemkoski/)\n//\n// Based on Lee Stemkoski's original work:\n//    (https://github.com/stemkoski/stemkoski.github.com/blob/master/Three.js/js/ParticleEngine.js).\n//\n// ShaderParticleGroup may be freely distributed under the MIT license (See LICENSE.txt)\n\nvar SPE = SPE || {};\n\nSPE.utils = {\n\n    /**\n     * Given a base vector and a spread range vector, create\n     * a new THREE.Vector3 instance with randomised values.\n     *\n     * @private\n     *\n     * @param  {THREE.Vector3} base\n     * @param  {THREE.Vector3} spread\n     * @return {THREE.Vector3}\n     */\n    randomVector3: function( base, spread ) {\n        var v = new THREE.Vector3();\n\n        v.copy( base );\n\n        v.x += Math.random() * spread.x - (spread.x/2);\n        v.y += Math.random() * spread.y - (spread.y/2);\n        v.z += Math.random() * spread.z - (spread.z/2);\n\n        return v;\n    },\n\n    /**\n     * Create a new THREE.Color instance and given a base vector and\n     * spread range vector, assign random values.\n     *\n     * Note that THREE.Color RGB values are in the range of 0 - 1, not 0 - 255.\n     *\n     * @private\n     *\n     * @param  {THREE.Vector3} base\n     * @param  {THREE.Vector3} spread\n     * @return {THREE.Color}\n     */\n    randomColor: function( base, spread ) {\n        var v = new THREE.Color();\n\n        v.copy( base );\n\n        v.r += (Math.random() * spread.x) - (spread.x/2);\n        v.g += (Math.random() * spread.y) - (spread.y/2);\n        v.b += (Math.random() * spread.z) - (spread.z/2);\n\n        v.r = Math.max( 0, Math.min( v.r, 1 ) );\n        v.g = Math.max( 0, Math.min( v.g, 1 ) );\n        v.b = Math.max( 0, Math.min( v.b, 1 ) );\n\n        return v;\n    },\n\n    /**\n     * Create a random Number value based on an initial value and\n     * a spread range\n     *\n     * @private\n     *\n     * @param  {Number} base\n     * @param  {Number} spread\n     * @return {Number}\n     */\n    randomFloat: function( base, spread ) {\n        return base + spread * (Math.random() - 0.5);\n    },\n\n    /**\n     * Create a new THREE.Vector3 instance and project it onto a random point\n     * on a sphere with randomized radius.\n     *\n     * @param  {THREE.Vector3} base\n     * @param  {Number} radius\n     * @param  {THREE.Vector3} radiusSpread\n     * @param  {THREE.Vector3} radiusScale\n     *\n     * @private\n     *\n     * @return {THREE.Vector3}\n     */\n    randomVector3OnSphere: function( base, radius, radiusSpread, radiusScale, radiusSpreadClamp ) {\n        var z = 2 * Math.random() - 1;\n        var t = 6.2832 * Math.random();\n        var r = Math.sqrt( 1 - z*z );\n        var vec = new THREE.Vector3( r * Math.cos(t), r * Math.sin(t), z );\n\n        var rand = this._randomFloat( radius, radiusSpread );\n\n        if( radiusSpreadClamp ) {\n            rand = Math.round( rand / radiusSpreadClamp ) * radiusSpreadClamp;\n        }\n\n        vec.multiplyScalar( rand );\n\n        if( radiusScale ) {\n            vec.multiply( radiusScale );\n        }\n\n        vec.add( base );\n\n        return vec;\n    },\n\n    /**\n     * Create a new THREE.Vector3 instance and project it onto a random point\n     * on a disk (in the XY-plane) centered at `base` and with randomized radius.\n     *\n     * @param  {THREE.Vector3} base\n     * @param  {Number} radius\n     * @param  {THREE.Vector3} radiusSpread\n     * @param  {THREE.Vector3} radiusScale\n     *\n     * @private\n     *\n     * @return {THREE.Vector3}\n     */\n    randomVector3OnDisk: function( base, radius, radiusSpread, radiusScale, radiusSpreadClamp ) {\n        var t = 6.2832 * Math.random();\n        var rand = this._randomFloat( radius, radiusSpread );\n\n        if( radiusSpreadClamp ) {\n            rand = Math.round( rand / radiusSpreadClamp ) * radiusSpreadClamp;\n        }\n\n        var vec = new THREE.Vector3( Math.cos(t), Math.sin(t), 0 ).multiplyScalar( rand );\n\n        if ( radiusScale ) {\n            vec.multiply( radiusScale );\n        }\n\n        vec.add( base );\n\n        return vec ;\n    },\n\n\n    /**\n     * Create a new THREE.Vector3 instance, and given a sphere with center `base` and\n     * point `position` on sphere, set direction away from sphere center with random magnitude.\n     *\n     * @param  {THREE.Vector3} base\n     * @param  {THREE.Vector3} position\n     * @param  {Number} speed\n     * @param  {Number} speedSpread\n     * @param  {THREE.Vector3} scale\n     *\n     * @private\n     *\n     * @return {THREE.Vector3}\n     */\n    randomVelocityVector3OnSphere: function( base, position, speed, speedSpread, scale ) {\n        var direction = new THREE.Vector3().subVectors( base, position );\n\n        direction.normalize().multiplyScalar( Math.abs( this._randomFloat( speed, speedSpread ) ) );\n\n        if( scale ) {\n            direction.multiply( scale );\n        }\n\n        return direction;\n    },\n\n\n\n    /**\n     * Given a base vector and a spread vector, randomise the given vector\n     * accordingly.\n     *\n     * @param  {THREE.Vector3} vector\n     * @param  {THREE.Vector3} base\n     * @param  {THREE.Vector3} spread\n     *\n     * @private\n     *\n     * @return {[type]}\n     */\n    randomizeExistingVector3: function( v, base, spread ) {\n        v.copy( base );\n\n        v.x += Math.random() * spread.x - (spread.x/2);\n        v.y += Math.random() * spread.y - (spread.y/2);\n        v.z += Math.random() * spread.z - (spread.z/2);\n    },\n\n\n    /**\n     * Randomize a THREE.Color instance and given a base vector and\n     * spread range vector, assign random values.\n     *\n     * Note that THREE.Color RGB values are in the range of 0 - 1, not 0 - 255.\n     *\n     * @private\n     *\n     * @param  {THREE.Vector3} base\n     * @param  {THREE.Vector3} spread\n     * @return {THREE.Color}\n     */\n    randomizeExistingColor: function( v, base, spread ) {\n        v.copy( base );\n\n        v.r += (Math.random() * spread.x) - (spread.x/2);\n        v.g += (Math.random() * spread.y) - (spread.y/2);\n        v.b += (Math.random() * spread.z) - (spread.z/2);\n\n        v.r = Math.max( 0, Math.min( v.r, 1 ) );\n        v.g = Math.max( 0, Math.min( v.g, 1 ) );\n        v.b = Math.max( 0, Math.min( v.b, 1 ) );\n    },\n\n    /**\n     * Given an existing particle vector, project it onto a random point on a\n     * sphere with radius `radius` and position `base`.\n     *\n     * @private\n     *\n     * @param  {THREE.Vector3} v\n     * @param  {THREE.Vector3} base\n     * @param  {Number} radius\n     */\n    randomizeExistingVector3OnSphere: function( v, base, radius, radiusSpread, radiusScale, radiusSpreadClamp ) {\n        var z = 2 * Math.random() - 1,\n            t = 6.2832 * Math.random(),\n            r = Math.sqrt( 1 - z*z ),\n            rand = this._randomFloat( radius, radiusSpread );\n\n        if( radiusSpreadClamp ) {\n            rand = Math.round( rand / radiusSpreadClamp ) * radiusSpreadClamp;\n        }\n\n        v.set(\n            (r * Math.cos(t)) * rand,\n            (r * Math.sin(t)) * rand,\n            z * rand\n        ).multiply( radiusScale );\n\n        v.add( base );\n    },\n\n\n    /**\n     * Given an existing particle vector, project it onto a random point\n     * on a disk (in the XY-plane) centered at `base` and with radius `radius`.\n     *\n     * @private\n     *\n     * @param  {THREE.Vector3} v\n     * @param  {THREE.Vector3} base\n     * @param  {Number} radius\n     */\n    randomizeExistingVector3OnDisk: function( v, base, radius, radiusSpread, radiusScale, radiusSpreadClamp ) {\n        var t = 6.2832 * Math.random(),\n            rand = Math.abs( this._randomFloat( radius, radiusSpread ) );\n\n        if( radiusSpreadClamp ) {\n            rand = Math.round( rand / radiusSpreadClamp ) * radiusSpreadClamp;\n        }\n\n        v.set(\n            Math.cos( t ),\n            Math.sin( t ),\n            0\n        ).multiplyScalar( rand );\n\n        if ( radiusScale ) {\n            v.multiply( radiusScale );\n        }\n\n        v.add( base );\n    },\n\n    randomizeExistingVelocityVector3OnSphere: function( v, base, position, speed, speedSpread ) {\n        v.copy(position)\n            .sub(base)\n            .normalize()\n            .multiplyScalar( Math.abs( this._randomFloat( speed, speedSpread ) ) );\n    },\n\n    generateID: function() {\n        var str = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx';\n\n        str = str.replace(/[xy]/g, function(c) {\n            var rand = Math.random();\n            var r = rand*16|0%16, v = c === 'x' ? r : (r&0x3|0x8);\n\n            return v.toString(16);\n        });\n\n        return str;\n    }\n};;\n\n// ShaderParticleGroup 0.7.9\n//\n// (c) 2014 Luke Moody (http://www.github.com/squarefeet)\n//     & Lee Stemkoski (http://www.adelphi.edu/~stemkoski/)\n//\n// Based on Lee Stemkoski's original work:\n//    (https://github.com/stemkoski/stemkoski.github.com/blob/master/Three.js/js/ParticleEngine.js).\n//\n// ShaderParticleGroup may be freely distributed under the MIT license (See LICENSE.txt)\n\nvar SPE = SPE || {};\n\nSPE.Group = function( options ) {\n    var that = this;\n\n    that.fixedTimeStep          = parseFloat( typeof options.fixedTimeStep === 'number' ? options.fixedTimeStep : 0.016 );\n\n    // Uniform properties ( applied to all particles )\n    that.maxAge                 = parseFloat( options.maxAge || 3 );\n    that.texture                = options.texture || null;\n    that.hasPerspective         = parseInt( typeof options.hasPerspective === 'number' ? options.hasPerspective : 1, 10 );\n    that.colorize               = parseInt( typeof options.colorize === 'number' ? options.colorize : 1, 10 );\n\n    // Material properties\n    that.blending               = typeof options.blending === 'number' ? options.blending : THREE.AdditiveBlending;\n    that.transparent            = typeof options.transparent === 'boolean' ? options.transparent : true;\n    that.alphaTest              = typeof options.alphaTest === 'number' ? options.alphaTest : 0.5;\n    that.depthWrite             = typeof options.depthWrite === 'boolean' ? options.depthWrite : false;\n    that.depthTest              = typeof options.depthTest === 'boolean' ? options.depthTest : true;\n\n    // Create uniforms\n    that.uniforms = {\n        duration:       { type: 'f',    value: that.maxAge },\n        texture:        { type: 't',    value: that.texture },\n        hasPerspective: { type: 'i',    value: that.hasPerspective },\n        colorize:       { type: 'i',    value: that.colorize }\n    };\n\n    // Create a map of attributes that will hold values for each particle in this group.\n    that.attributes = {\n        acceleration:           { type: 'v3',   value: [] },\n        velocity:               { type: 'v3',   value: [] },\n\n        alive:                  { type: 'f',    value: [] },\n        age:                    { type: 'f',    value: [] },\n\n        size:                   { type: 'v3',   value: [] },\n        angle:                  { type: 'v4',   value: [] },\n\n        colorStart:             { type: 'c',    value: [] },\n        colorMiddle:            { type: 'c',    value: [] },\n        colorEnd:               { type: 'c',    value: [] },\n\n        opacity:                { type: 'v3',   value: [] }\n    };\n\n    // Emitters (that aren't static) will be added to this array for\n    // processing during the `tick()` function.\n    that.emitters = [];\n\n    // Create properties for use by the emitter pooling functions.\n    that._pool = [];\n    that._poolCreationSettings = null;\n    that._createNewWhenPoolEmpty = 0;\n    that.maxAgeMilliseconds = that.maxAge * 1000;\n\n    // Create an empty geometry to hold the particles.\n    // Each particle is a vertex pushed into this geometry's\n    // vertices array.\n    that.geometry = new THREE.Geometry();\n\n    // Create the shader material using the properties we set above.\n    that.material = new THREE.ShaderMaterial({\n        uniforms:       that.uniforms,\n        attributes:     that.attributes,\n        vertexShader:   SPE.shaders.vertex,\n        fragmentShader: SPE.shaders.fragment,\n        blending:       that.blending,\n        transparent:    that.transparent,\n        alphaTest:      that.alphaTest,\n        depthWrite:     that.depthWrite,\n        depthTest:      that.depthTest\n    });\n\n    // And finally create the ParticleSystem. It's got its `dynamic` property\n    // set so that THREE.js knows to update it on each frame.\n    that.mesh = new THREE.PointCloud( that.geometry, that.material );\n    that.mesh.dynamic = true;\n};\n\nSPE.Group.prototype = {\n\n    /**\n     * Tells the age and alive attributes (and the geometry vertices)\n     * that they need updating by THREE.js's internal tick functions.\n     *\n     * @private\n     *\n     * @return {this}\n     */\n    _flagUpdate: function() {\n        var that = this;\n\n        // Set flags to update (causes less garbage than\n        // ```ParticleSystem.sortParticles = true``` in THREE.r58 at least)\n        that.attributes.age.needsUpdate = true;\n        that.attributes.alive.needsUpdate = true;\n        that.attributes.angle.needsUpdate = true;\n        // that.attributes.angleAlignVelocity.needsUpdate = true;\n        that.attributes.velocity.needsUpdate = true;\n        that.attributes.acceleration.needsUpdate = true;\n        that.geometry.verticesNeedUpdate = true;\n\n        return that;\n    },\n\n    /**\n     * Add an emitter to this particle group. Once added, an emitter will be automatically\n     * updated when SPE.Group#tick() is called.\n     *\n     * @param {SPE.Emitter} emitter\n     * @return {this}\n     */\n    addEmitter: function( emitter ) {\n        var that = this;\n\n        if( emitter.duration ) {\n            emitter.particlesPerSecond = emitter.particleCount / (that.maxAge < emitter.duration ? that.maxAge : emitter.duration) | 0;\n        }\n        else {\n            emitter.particlesPerSecond = emitter.particleCount / that.maxAge | 0\n        }\n\n        var vertices            = that.geometry.vertices,\n            start               = vertices.length,\n            end                 = emitter.particleCount + start,\n            a                   = that.attributes,\n            acceleration        = a.acceleration.value,\n            velocity            = a.velocity.value,\n            alive               = a.alive.value,\n            age                 = a.age.value,\n            size                = a.size.value,\n            angle               = a.angle.value,\n            colorStart          = a.colorStart.value,\n            colorMiddle         = a.colorMiddle.value,\n            colorEnd            = a.colorEnd.value,\n            opacity             = a.opacity.value;\n\n        emitter.particleIndex = parseFloat( start );\n\n        // Create the values\n        for( var i = start; i < end; ++i ) {\n\n            if( emitter.type === 'sphere' ) {\n                vertices[i]         = that._randomVector3OnSphere( emitter.position, emitter.radius, emitter.radiusSpread, emitter.radiusScale, emitter.radiusSpreadClamp );\n                velocity[i]         = that._randomVelocityVector3OnSphere( vertices[i], emitter.position, emitter.speed, emitter.speedSpread );\n            }\n            else if( emitter.type === 'disk' ) {\n                vertices[i]         = that._randomVector3OnDisk( emitter.position, emitter.radius, emitter.radiusSpread, emitter.radiusScale, emitter.radiusSpreadClamp );\n                velocity[i]         = that._randomVelocityVector3OnSphere( vertices[i], emitter.position, emitter.speed, emitter.speedSpread );\n            }\n            else {\n                vertices[i]         = that._randomVector3( emitter.position, emitter.positionSpread );\n                velocity[i]         = that._randomVector3( emitter.velocity, emitter.velocitySpread );\n            }\n\n            acceleration[i]         = that._randomVector3( emitter.acceleration, emitter.accelerationSpread );\n\n            size[i]                 = new THREE.Vector3(\n                Math.abs( that._randomFloat( emitter.sizeStart, emitter.sizeStartSpread ) ),\n                Math.abs( that._randomFloat( emitter.sizeMiddle, emitter.sizeMiddleSpread ) ),\n                Math.abs( that._randomFloat( emitter.sizeEnd, emitter.sizeEndSpread ) )\n            );\n\n            angle[i]                = new THREE.Vector4(\n                that._randomFloat( emitter.angleStart, emitter.angleStartSpread ),\n                that._randomFloat( emitter.angleMiddle, emitter.angleMiddleSpread ),\n                that._randomFloat( emitter.angleEnd, emitter.angleEndSpread ),\n                emitter.angleAlignVelocity ? 1.0 : 0.0\n            );\n\n            age[i]                  = 0.0;\n            alive[i]                = emitter.isStatic ? 1.0 : 0.0;\n\n            colorStart[i]           = that._randomColor( emitter.colorStart,    emitter.colorStartSpread );\n            colorMiddle[i]          = that._randomColor( emitter.colorMiddle,   emitter.colorMiddleSpread );\n            colorEnd[i]             = that._randomColor( emitter.colorEnd,      emitter.colorEndSpread );\n\n            opacity[i]              = new THREE.Vector3(\n                Math.abs( that._randomFloat( emitter.opacityStart, emitter.opacityStartSpread ) ),\n                Math.abs( that._randomFloat( emitter.opacityMiddle, emitter.opacityMiddleSpread ) ),\n                Math.abs( that._randomFloat( emitter.opacityEnd, emitter.opacityEndSpread ) )\n            );\n        }\n\n        // Cache properties on the emitter so we can access\n        // them from its tick function.\n        emitter.verticesIndex   = parseFloat( start );\n        emitter.attributes      = a;\n        emitter.vertices        = that.geometry.vertices;\n        emitter.maxAge          = that.maxAge;\n\n        // Assign a unique ID to this emitter\n        emitter.__id = that._generateID();\n\n        // Save this emitter in an array for processing during this.tick()\n        if( !emitter.isStatic ) {\n            that.emitters.push( emitter );\n        }\n\n        return that;\n    },\n\n\n    removeEmitter: function( emitter ) {\n        var id,\n            emitters = this.emitters;\n\n        if( emitter instanceof SPE.Emitter ) {\n            id = emitter.__id;\n        }\n        else if( typeof emitter === 'string' ) {\n            id = emitter;\n        }\n        else {\n            console.warn('Invalid emitter or emitter ID passed to SPE.Group#removeEmitter.' );\n            return;\n        }\n\n        for( var i = 0, il = emitters.length; i < il; ++i ) {\n            if( emitters[i].__id === id ) {\n                emitters.splice(i, 1);\n                break;\n            }\n        }\n    },\n\n\n    /**\n     * The main particle group update function. Call this once per frame.\n     *\n     * @param  {Number} dt\n     * @return {this}\n     */\n    tick: function( dt ) {\n        var that = this,\n            emitters = that.emitters,\n            numEmitters = emitters.length;\n\n        dt = dt || that.fixedTimeStep;\n\n        if( numEmitters === 0 ) {\n            return;\n        }\n\n        for( var i = 0; i < numEmitters; ++i ) {\n            emitters[i].tick( dt );\n        }\n\n        that._flagUpdate();\n        return that;\n    },\n\n\n    /**\n     * Fetch a single emitter instance from the pool.\n     * If there are no objects in the pool, a new emitter will be\n     * created if specified.\n     *\n     * @return {ShaderParticleEmitter | null}\n     */\n    getFromPool: function() {\n        var that = this,\n            pool = that._pool,\n            createNew = that._createNewWhenPoolEmpty;\n\n        if( pool.length ) {\n            return pool.pop();\n        }\n        else if( createNew ) {\n            return new SPE.Emitter( that._poolCreationSettings );\n        }\n\n        return null;\n    },\n\n\n    /**\n     * Release an emitter into the pool.\n     *\n     * @param  {ShaderParticleEmitter} emitter\n     * @return {this}\n     */\n    releaseIntoPool: function( emitter ) {\n        if( !(emitter instanceof SPE.Emitter) ) {\n            console.error( 'Will not add non-emitter to particle group pool:', emitter );\n            return;\n        }\n\n        emitter.reset();\n        this._pool.unshift( emitter );\n\n        return this;\n    },\n\n\n    /**\n     * Get the pool array\n     *\n     * @return {Array}\n     */\n    getPool: function() {\n        return this._pool;\n    },\n\n\n    /**\n     * Add a pool of emitters to this particle group\n     *\n     * @param {Number} numEmitters      The number of emitters to add to the pool.\n     * @param {Object} emitterSettings  An object describing the settings to pass to each emitter.\n     * @param {Boolean} createNew       Should a new emitter be created if the pool runs out?\n     * @return {this}\n     */\n    addPool: function( numEmitters, emitterSettings, createNew ) {\n        var that = this,\n            emitter;\n\n        // Save relevant settings and flags.\n        that._poolCreationSettings = emitterSettings;\n        that._createNewWhenPoolEmpty = !!createNew;\n\n        // Create the emitters, add them to this group and the pool.\n        for( var i = 0; i < numEmitters; ++i ) {\n            emitter = new SPE.Emitter( emitterSettings );\n            that.addEmitter( emitter );\n            that.releaseIntoPool( emitter );\n        }\n\n        return that;\n    },\n\n\n    /**\n     * Internal method. Sets a single emitter to be alive\n     *\n     * @private\n     *\n     * @param  {THREE.Vector3} pos\n     * @return {this}\n     */\n    _triggerSingleEmitter: function( pos ) {\n        var that = this,\n            emitter = that.getFromPool();\n\n        if( emitter === null ) {\n            console.log('SPE.Group pool ran out.');\n            return;\n        }\n\n        // TODO: Should an instanceof check happen here? Or maybe at least a typeof?\n        if( pos ) {\n            emitter.position.copy( pos );\n        }\n\n        emitter.enable();\n\n        setTimeout( function() {\n            emitter.disable();\n            that.releaseIntoPool( emitter );\n        }, that.maxAgeMilliseconds );\n\n        return that;\n    },\n\n\n    /**\n     * Set a given number of emitters as alive, with an optional position\n     * vector3 to move them to.\n     *\n     * @param  {Number} numEmitters\n     * @param  {THREE.Vector3} position\n     * @return {this}\n     */\n    triggerPoolEmitter: function( numEmitters, position ) {\n        var that = this;\n\n        if( typeof numEmitters === 'number' && numEmitters > 1) {\n            for( var i = 0; i < numEmitters; ++i ) {\n                that._triggerSingleEmitter( position );\n            }\n        }\n        else {\n            that._triggerSingleEmitter( position );\n        }\n\n        return that;\n    }\n};\n\n\n// Extend ShaderParticleGroup's prototype with functions from utils object.\nfor( var i in SPE.utils ) {\n    SPE.Group.prototype[ '_' + i ] = SPE.utils[i];\n}\n\n\n// The all-important shaders\nSPE.shaders = {\n    vertex: [\n        'uniform float duration;',\n        'uniform int hasPerspective;',\n\n        'attribute vec3 colorStart;',\n        'attribute vec3 colorMiddle;',\n        'attribute vec3 colorEnd;',\n        'attribute vec3 opacity;',\n\n        'attribute vec3 acceleration;',\n        'attribute vec3 velocity;',\n        'attribute float alive;',\n        'attribute float age;',\n\n        'attribute vec3 size;',\n        'attribute vec4 angle;',\n\n        // values to be passed to the fragment shader\n        'varying vec4 vColor;',\n        'varying float vAngle;',\n\n\n        // Integrate acceleration into velocity and apply it to the particle's position\n        'vec4 GetPos() {',\n            'vec3 newPos = vec3( position );',\n\n            // Move acceleration & velocity vectors to the value they\n            // should be at the current age\n            'vec3 a = acceleration * age;',\n            'vec3 v = velocity * age;',\n\n            // Move velocity vector to correct values at this age\n            'v = v + (a * age);',\n\n            // Add velocity vector to the newPos vector\n            'newPos = newPos + v;',\n\n            // Convert the newPos vector into world-space\n            'vec4 mvPosition = modelViewMatrix * vec4( newPos, 1.0 );',\n\n            'return mvPosition;',\n        '}',\n\n\n        'void main() {',\n\n            'float positionInTime = (age / duration);',\n\n            'float lerpAmount1 = (age / (0.5 * duration));', // percentage during first half\n            'float lerpAmount2 = ((age - 0.5 * duration) / (0.5 * duration));', // percentage during second half\n            'float halfDuration = duration / 2.0;',\n            'float pointSize = 0.0;',\n\n            'vAngle = 0.0;',\n\n            'if( alive > 0.5 ) {',\n\n                // lerp the color and opacity\n                'if( positionInTime < 0.5 ) {',\n                    'vColor = vec4( mix(colorStart, colorMiddle, lerpAmount1), mix(opacity.x, opacity.y, lerpAmount1) );',\n                '}',\n                'else {',\n                    'vColor = vec4( mix(colorMiddle, colorEnd, lerpAmount2), mix(opacity.y, opacity.z, lerpAmount2) );',\n                '}',\n\n\n                // Get the position of this particle so we can use it\n                // when we calculate any perspective that might be required.\n                'vec4 pos = GetPos();',\n\n\n                // Determine the angle we should use for this particle.\n                'if( angle[3] == 1.0 ) {',\n                    'vAngle = -atan(pos.y, pos.x);',\n                '}',\n                'else if( positionInTime < 0.5 ) {',\n                    'vAngle = mix( angle.x, angle.y, lerpAmount1 );',\n                '}',\n                'else {',\n                    'vAngle = mix( angle.y, angle.z, lerpAmount2 );',\n                '}',\n\n                // Determine point size.\n                'if( positionInTime < 0.5) {',\n                    'pointSize = mix( size.x, size.y, lerpAmount1 );',\n                '}',\n                'else {',\n                    'pointSize = mix( size.y, size.z, lerpAmount2 );',\n                '}',\n\n\n                'if( hasPerspective == 1 ) {',\n                    'pointSize = pointSize * ( 300.0 / length( pos.xyz ) );',\n                '}',\n\n                // Set particle size and position\n                'gl_PointSize = pointSize;',\n                'gl_Position = projectionMatrix * pos;',\n            '}',\n\n            'else {',\n                // Hide particle and set its position to the (maybe) glsl\n                // equivalent of Number.POSITIVE_INFINITY\n                'vColor = vec4( 0.0, 0.0, 0.0, 0.0 );',\n                'gl_Position = vec4(1000000000.0, 1000000000.0, 1000000000.0, 0.0);',\n            '}',\n        '}',\n    ].join('\\n'),\n\n    fragment: [\n        'uniform sampler2D texture;',\n        'uniform int colorize;',\n\n        'varying vec4 vColor;',\n        'varying float vAngle;',\n\n        'void main() {',\n            'float c = cos(vAngle);',\n            'float s = sin(vAngle);',\n\n            'vec2 rotatedUV = vec2(c * (gl_PointCoord.x - 0.5) + s * (gl_PointCoord.y - 0.5) + 0.5,',\n                                  'c * (gl_PointCoord.y - 0.5) - s * (gl_PointCoord.x - 0.5) + 0.5);',\n\n            'vec4 rotatedTexture = texture2D( texture, rotatedUV );',\n\n            'if( colorize == 1 ) {',\n                'gl_FragColor = vColor * rotatedTexture;',\n            '}',\n            'else {',\n                'gl_FragColor = rotatedTexture;',\n            '}',\n        '}'\n    ].join('\\n')\n};\n;\n\n// ShaderParticleEmitter 0.7.9\n//\n// (c) 2014 Luke Moody (http://www.github.com/squarefeet)\n//     & Lee Stemkoski (http://www.adelphi.edu/~stemkoski/)\n//\n// Based on Lee Stemkoski's original work:\n//    (https://github.com/stemkoski/stemkoski.github.com/blob/master/Three.js/js/ParticleEngine.js).\n//\n// ShaderParticleEmitter may be freely distributed under the MIT license (See LICENSE.txt)\n\nvar SPE = SPE || {};\n\nSPE.Emitter = function( options ) {\n    // If no options are provided, fallback to an empty object.\n    options = options || {};\n\n    // Helps with minification. Not as easy to read the following code,\n    // but should still be readable enough!\n    var that = this;\n\n\n    that.particleCount          = typeof options.particleCount === 'number' ? options.particleCount : 100;\n    that.type                   = (options.type === 'cube' || options.type === 'sphere' || options.type === 'disk') ? options.type : 'cube';\n\n    that.position               = options.position instanceof THREE.Vector3 ? options.position : new THREE.Vector3();\n    that.positionSpread         = options.positionSpread instanceof THREE.Vector3 ? options.positionSpread : new THREE.Vector3();\n\n    // These two properties are only used when this.type === 'sphere' or 'disk'\n    that.radius                 = typeof options.radius === 'number' ? options.radius : 10;\n    that.radiusSpread           = typeof options.radiusSpread === 'number' ? options.radiusSpread : 0;\n    that.radiusScale            = options.radiusScale instanceof THREE.Vector3 ? options.radiusScale : new THREE.Vector3(1, 1, 1);\n    that.radiusSpreadClamp      = typeof options.radiusSpreadClamp === 'number' ? options.radiusSpreadClamp : 0;\n\n    that.acceleration           = options.acceleration instanceof THREE.Vector3 ? options.acceleration : new THREE.Vector3();\n    that.accelerationSpread     = options.accelerationSpread instanceof THREE.Vector3 ? options.accelerationSpread : new THREE.Vector3();\n\n    that.velocity               = options.velocity instanceof THREE.Vector3 ? options.velocity : new THREE.Vector3();\n    that.velocitySpread         = options.velocitySpread instanceof THREE.Vector3 ? options.velocitySpread : new THREE.Vector3();\n\n\n    // And again here; only used when this.type === 'sphere' or 'disk'\n    that.speed                  = parseFloat( typeof options.speed === 'number' ? options.speed : 0.0 );\n    that.speedSpread            = parseFloat( typeof options.speedSpread === 'number' ? options.speedSpread : 0.0 );\n\n\n    // Sizes\n    that.sizeStart              = parseFloat( typeof options.sizeStart === 'number' ? options.sizeStart : 1.0 );\n    that.sizeStartSpread        = parseFloat( typeof options.sizeStartSpread === 'number' ? options.sizeStartSpread : 0.0 );\n\n    that.sizeEnd                = parseFloat( typeof options.sizeEnd === 'number' ? options.sizeEnd : that.sizeStart );\n    that.sizeEndSpread          = parseFloat( typeof options.sizeEndSpread === 'number' ? options.sizeEndSpread : 0.0 );\n\n    that.sizeMiddle             = parseFloat(\n        typeof options.sizeMiddle !== 'undefined' ?\n        options.sizeMiddle :\n        Math.abs(that.sizeEnd + that.sizeStart) / 2\n    );\n    that.sizeMiddleSpread       = parseFloat( typeof options.sizeMiddleSpread === 'number' ? options.sizeMiddleSpread : 0 );\n\n\n    // Angles\n    that.angleStart             = parseFloat( typeof options.angleStart === 'number' ? options.angleStart : 0 );\n    that.angleStartSpread       = parseFloat( typeof options.angleStartSpread === 'number' ? options.angleStartSpread : 0 );\n\n    that.angleEnd               = parseFloat( typeof options.angleEnd === 'number' ? options.angleEnd : 0 );\n    that.angleEndSpread         = parseFloat( typeof options.angleEndSpread === 'number' ? options.angleEndSpread : 0 );\n\n    that.angleMiddle            = parseFloat(\n        typeof options.angleMiddle !== 'undefined' ?\n        options.angleMiddle :\n        Math.abs(that.angleEnd + that.angleStart) / 2\n    );\n    that.angleMiddleSpread      = parseFloat( typeof options.angleMiddleSpread === 'number' ? options.angleMiddleSpread : 0 );\n\n    that.angleAlignVelocity     = options.angleAlignVelocity || false;\n\n\n    // Colors\n    that.colorStart             = options.colorStart instanceof THREE.Color ? options.colorStart : new THREE.Color( 'white' );\n    that.colorStartSpread       = options.colorStartSpread instanceof THREE.Vector3 ? options.colorStartSpread : new THREE.Vector3();\n\n    that.colorEnd               = options.colorEnd instanceof THREE.Color ? options.colorEnd : that.colorStart.clone();\n    that.colorEndSpread         = options.colorEndSpread instanceof THREE.Vector3 ? options.colorEndSpread : new THREE.Vector3();\n\n    that.colorMiddle            =\n        options.colorMiddle instanceof THREE.Color ?\n        options.colorMiddle :\n        new THREE.Color().addColors( that.colorStart, that.colorEnd ).multiplyScalar( 0.5 );\n    that.colorMiddleSpread      = options.colorMiddleSpread instanceof THREE.Vector3 ? options.colorMiddleSpread : new THREE.Vector3();\n\n\n\n    // Opacities\n    that.opacityStart           = parseFloat( typeof options.opacityStart !== 'undefined' ? options.opacityStart : 1 );\n    that.opacityStartSpread     = parseFloat( typeof options.opacityStartSpread !== 'undefined' ? options.opacityStartSpread : 0 );\n\n    that.opacityEnd             = parseFloat( typeof options.opacityEnd === 'number' ? options.opacityEnd : 0 );\n    that.opacityEndSpread       = parseFloat( typeof options.opacityEndSpread !== 'undefined' ? options.opacityEndSpread : 0 );\n\n    that.opacityMiddle          = parseFloat(\n        typeof options.opacityMiddle !== 'undefined' ?\n        options.opacityMiddle :\n        Math.abs(that.opacityEnd + that.opacityStart) / 2\n    );\n    that.opacityMiddleSpread      = parseFloat( typeof options.opacityMiddleSpread === 'number' ? options.opacityMiddleSpread : 0 );\n\n\n    // Generic\n    that.duration               = typeof options.duration === 'number' ? options.duration : null;\n    that.alive                  = parseFloat( typeof options.alive === 'number' ? options.alive : 1.0 );\n    that.isStatic               = typeof options.isStatic === 'number' ? options.isStatic : 0;\n\n    // Particle spawn callback function.\n    that.onParticleSpawn = typeof options.onParticleSpawn === 'function' ? options.onParticleSpawn : null;\n\n\n    // The following properties are used internally, and mostly set when this emitter\n    // is added to a particle group.\n    that.particlesPerSecond     = 0;\n    that.attributes             = null;\n    that.vertices               = null;\n    that.verticesIndex          = 0;\n    that.age                    = 0.0;\n    that.maxAge                 = 0.0;\n\n    that.particleIndex = 0.0;\n\n    that.__id = null;\n\n    that.userData = {};\n};\n\nSPE.Emitter.prototype = {\n\n    /**\n     * Reset a particle's position. Accounts for emitter type and spreads.\n     *\n     * @private\n     *\n     * @param  {THREE.Vector3} p\n     */\n    _resetParticle: function( i ) {\n        var that = this,\n            type = that.type,\n            spread = that.positionSpread,\n            particlePosition = that.vertices[i],\n            a = that.attributes,\n            particleVelocity = a.velocity.value[i],\n\n            vSpread = that.velocitySpread,\n            aSpread = that.accelerationSpread;\n\n        // Optimise for no position spread or radius\n        if(\n            ( type === 'cube' && spread.x === 0 && spread.y === 0 && spread.z === 0 ) ||\n            ( type === 'sphere' && that.radius === 0 ) ||\n            ( type === 'disk' && that.radius === 0 )\n        ) {\n            particlePosition.copy( that.position );\n            that._randomizeExistingVector3( particleVelocity, that.velocity, vSpread );\n\n            if( type === 'cube' ) {\n                that._randomizeExistingVector3( that.attributes.acceleration.value[i], that.acceleration, aSpread );\n            }\n        }\n\n        // If there is a position spread, then get a new position based on this spread.\n        else if( type === 'cube' ) {\n            that._randomizeExistingVector3( particlePosition, that.position, spread );\n            that._randomizeExistingVector3( particleVelocity, that.velocity, vSpread );\n            that._randomizeExistingVector3( that.attributes.acceleration.value[i], that.acceleration, aSpread );\n        }\n\n        else if( type === 'sphere') {\n            that._randomizeExistingVector3OnSphere( particlePosition, that.position, that.radius, that.radiusSpread, that.radiusScale, that.radiusSpreadClamp );\n            that._randomizeExistingVelocityVector3OnSphere( particleVelocity, that.position, particlePosition, that.speed, that.speedSpread );\n        }\n\n        else if( type === 'disk') {\n            that._randomizeExistingVector3OnDisk( particlePosition, that.position, that.radius, that.radiusSpread, that.radiusScale, that.radiusSpreadClamp );\n            that._randomizeExistingVelocityVector3OnSphere( particleVelocity, that.position, particlePosition, that.speed, that.speedSpread );\n        }\n\n        if( typeof that.onParticleSpawn === 'function' ) {\n            that.onParticleSpawn( a, i );\n        }\n    },\n\n    /**\n     * Update this emitter's particle's positions. Called by the SPE.Group\n     * that this emitter belongs to.\n     *\n     * @param  {Number} dt\n     */\n    tick: function( dt ) {\n\n        if( this.isStatic ) {\n            return;\n        }\n\n        // Cache some values for quicker access in loops.\n        var that = this,\n            a = that.attributes,\n            alive = a.alive.value,\n            age = a.age.value,\n            start = that.verticesIndex,\n            particleCount = that.particleCount,\n            end = start + particleCount,\n            pps = that.particlesPerSecond * that.alive,\n            ppsdt = pps * dt,\n            m = that.maxAge,\n            emitterAge = that.age,\n            duration = that.duration,\n            pIndex = that.particleIndex;\n\n        // Loop through all the particles in this emitter and\n        // determine whether they're still alive and need advancing\n        // or if they should be dead and therefore marked as such.\n        for( var i = start; i < end; ++i ) {\n            if( alive[ i ] === 1.0 ) {\n                age[ i ] += dt;\n            }\n\n            if( age[ i ] >= m ) {\n                age[ i ] = 0.0;\n                alive[ i ] = 0.0;\n            }\n        }\n\n        // If the emitter is dead, reset any particles that are in\n        // the recycled vertices array and reset the age of the\n        // emitter to zero ready to go again if required, then\n        // exit this function.\n        if( that.alive === 0.0 ) {\n            that.age = 0.0;\n            return;\n        }\n\n        // If the emitter has a specified lifetime and we've exceeded it,\n        // mark the emitter as dead and exit this function.\n        if( typeof duration === 'number' && emitterAge > duration ) {\n            that.alive = 0.0;\n            that.age = 0.0;\n            return;\n        }\n\n\n\n        var n = Math.max( Math.min( end, pIndex + ppsdt ), 0),\n            count = 0,\n            index = 0,\n            pIndexFloor = pIndex | 0,\n            dtInc;\n\n        for( i = pIndexFloor; i < n; ++i ) {\n            if( alive[ i ] !== 1.0 ) {\n                ++count;\n            }\n        }\n\n        if( count !== 0 ) {\n            dtInc = dt / count;\n\n            for( i = pIndexFloor; i < n; ++i, ++index ) {\n                if( alive[ i ] !== 1.0 ) {\n                    alive[ i ] = 1.0;\n                    age[ i ] = dtInc * index;\n                    that._resetParticle( i );\n                }\n            }\n        }\n\n        that.particleIndex += ppsdt;\n\n        if( that.particleIndex < 0.0 ) {\n            that.particleIndex = 0.0;\n        }\n\n        if( pIndex >= start + particleCount ) {\n            that.particleIndex = parseFloat( start );\n        }\n\n        // Add the delta time value to the age of the emitter.\n        that.age += dt;\n\n        if( that.age < 0.0 ) {\n            that.age = 0.0;\n        }\n    },\n\n    /**\n     * Reset this emitter back to its starting position.\n     * If `force` is truthy, then reset all particles in this\n     * emitter as well, even if they're currently alive.\n     *\n     * @param  {Boolean} force\n     * @return {this}\n     */\n    reset: function( force ) {\n        var that = this;\n\n        that.age = 0.0;\n        that.alive = 0;\n\n        if( force ) {\n            var start = that.verticesIndex,\n                end = that.verticesIndex + that.particleCount,\n                a = that.attributes,\n                alive = a.alive.value,\n                age = a.age.value;\n\n            for( var i = start; i < end; ++i ) {\n                alive[ i ] = 0.0;\n                age[ i ] = 0.0;\n            }\n        }\n\n        return that;\n    },\n\n\n    /**\n     * Enable this emitter.\n     */\n    enable: function() {\n        this.alive = 1;\n    },\n\n    /**\n     * Disable this emitter.\n     */\n    disable: function() {\n        this.alive = 0;\n    }\n};\n\n// Extend SPE.Emitter's prototype with functions from utils object.\nfor( var i in SPE.utils ) {\n    SPE.Emitter.prototype[ '_' + i ] = SPE.utils[i];\n}\n\n\n/*** EXPORTS FROM exports-loader ***/\nmodule.exports = SPE\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/imports-loader?THREE=three!./~/exports-loader?SPE!./bower_components/ShaderParticles/index.js\n ** module id = 40\n ** module chunks = 0\n **/","'use strict';\n\nvar assign        = require('es5-ext/object/assign')\n  , normalizeOpts = require('es5-ext/object/normalize-options')\n  , isCallable    = require('es5-ext/object/is-callable')\n  , contains      = require('es5-ext/string/#/contains')\n\n  , d;\n\nd = module.exports = function (dscr, value/*, options*/) {\n\tvar c, e, w, options, desc;\n\tif ((arguments.length < 2) || (typeof dscr !== 'string')) {\n\t\toptions = value;\n\t\tvalue = dscr;\n\t\tdscr = null;\n\t} else {\n\t\toptions = arguments[2];\n\t}\n\tif (dscr == null) {\n\t\tc = w = true;\n\t\te = false;\n\t} else {\n\t\tc = contains.call(dscr, 'c');\n\t\te = contains.call(dscr, 'e');\n\t\tw = contains.call(dscr, 'w');\n\t}\n\n\tdesc = { value: value, configurable: c, enumerable: e, writable: w };\n\treturn !options ? desc : assign(normalizeOpts(options), desc);\n};\n\nd.gs = function (dscr, get, set/*, options*/) {\n\tvar c, e, options, desc;\n\tif (typeof dscr !== 'string') {\n\t\toptions = set;\n\t\tset = get;\n\t\tget = dscr;\n\t\tdscr = null;\n\t} else {\n\t\toptions = arguments[3];\n\t}\n\tif (get == null) {\n\t\tget = undefined;\n\t} else if (!isCallable(get)) {\n\t\toptions = get;\n\t\tget = set = undefined;\n\t} else if (set == null) {\n\t\tset = undefined;\n\t} else if (!isCallable(set)) {\n\t\toptions = set;\n\t\tset = undefined;\n\t}\n\tif (dscr == null) {\n\t\tc = true;\n\t\te = false;\n\t} else {\n\t\tc = contains.call(dscr, 'c');\n\t\te = contains.call(dscr, 'e');\n\t}\n\n\tdesc = { get: get, set: set, configurable: c, enumerable: e };\n\treturn !options ? desc : assign(normalizeOpts(options), desc);\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/event-emitter/~/d/index.js\n ** module id = 41\n ** module chunks = 0\n **/","module.exports = __webpack_public_path__ + \"image/asphalt.jpg\"\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/images/asphalt.jpg\n ** module id = 42\n ** module chunks = 0\n **/","module.exports = __webpack_public_path__ + \"image/brick-tiles.jpg\"\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/images/brick-tiles.jpg\n ** module id = 43\n ** module chunks = 0\n **/","module.exports = __webpack_public_path__ + \"image/bricks-normal.jpg\"\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/images/bricks-normal.jpg\n ** module id = 44\n ** module chunks = 0\n **/","module.exports = __webpack_public_path__ + \"image/bricks-specular.jpg\"\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/images/bricks-specular.jpg\n ** module id = 45\n ** module chunks = 0\n **/","module.exports = __webpack_public_path__ + \"image/bricks.jpg\"\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/images/bricks.jpg\n ** module id = 46\n ** module chunks = 0\n **/","module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEAAQMAAABmvDolAAAABlBMVEUsLCzp6enLhVdXAAAAAWJLR0QAiAUdSAAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB94KFBIOCP7R3TQAAAA4SURBVGje7dAhEgAACMOw/f/T4Gc5XKqjmlRTBQAAAAAAAAAAAAAA4AiMAQAAAAAAAAAAAADgGSyKafDiEFszywAAAABJRU5ErkJggg==\"\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/images/checkerboard.png\n ** module id = 47\n ** module chunks = 0\n **/","module.exports = \"data:image/png;base64,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\"\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/images/cloud10.png\n ** module id = 48\n ** module chunks = 0\n **/","module.exports = __webpack_public_path__ + \"image/grass.jpg\"\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/images/grass.jpg\n ** module id = 49\n ** module chunks = 0\n **/","module.exports = __webpack_public_path__ + \"image/metal-floor.jpg\"\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/images/metal-floor.jpg\n ** module id = 50\n ** module chunks = 0\n **/","module.exports = __webpack_public_path__ + \"image/metal.jpg\"\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/images/metal.jpg\n ** module id = 51\n ** module chunks = 0\n **/","module.exports = __webpack_public_path__ + \"image/stone.jpg\"\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/images/stone.jpg\n ** module id = 52\n ** module chunks = 0\n **/","module.exports = __webpack_public_path__ + \"image/tiles.jpg\"\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/images/tiles.jpg\n ** module id = 53\n ** module chunks = 0\n **/","module.exports = __webpack_public_path__ + \"image/weathered-wood.jpg\"\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/images/weathered-wood.jpg\n ** module id = 54\n ** module chunks = 0\n **/","module.exports = __webpack_public_path__ + \"image/wood.jpg\"\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/images/wood.jpg\n ** module id = 55\n ** module chunks = 0\n **/","'use strict';\n\nmodule.exports = function (fn) {\n\tif (typeof fn !== 'function') throw new TypeError(fn + \" is not a function\");\n\treturn fn;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/event-emitter/~/es5-ext/object/valid-callable.js\n ** module id = 56\n ** module chunks = 0\n **/","/**\n * lodash 3.1.0 (Custom Build) <https://lodash.com/>\n * Build: `lodash modern modularize exports=\"npm\" -o ./`\n * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <https://lodash.com/license>\n */\nvar bindCallback = require('lodash._bindcallback'),\n    isIterateeCall = require('lodash._isiterateecall'),\n    restParam = require('lodash.restparam');\n\n/**\n * Creates a function that assigns properties of source object(s) to a given\n * destination object.\n *\n * **Note:** This function is used to create `_.assign`, `_.defaults`, and `_.merge`.\n *\n * @private\n * @param {Function} assigner The function to assign values.\n * @returns {Function} Returns the new assigner function.\n */\nfunction createAssigner(assigner) {\n  return restParam(function(object, sources) {\n    var index = -1,\n        length = object == null ? 0 : sources.length,\n        customizer = length > 2 && sources[length - 2],\n        guard = length > 2 && sources[2],\n        thisArg = length > 1 && sources[length - 1];\n\n    if (typeof customizer == 'function') {\n      customizer = bindCallback(customizer, thisArg, 5);\n      length -= 2;\n    } else {\n      customizer = typeof thisArg == 'function' ? thisArg : null;\n      length -= (customizer ? 1 : 0);\n    }\n    if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n      customizer = length < 3 ? null : customizer;\n      length = 1;\n    }\n    while (++index < length) {\n      var source = sources[index];\n      if (source) {\n        assigner(object, source, customizer);\n      }\n    }\n    return object;\n  });\n}\n\nmodule.exports = createAssigner;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash.assign/~/lodash._createassigner/index.js\n ** module id = 57\n ** module chunks = 0\n **/","/**\n * lodash 3.0.2 (Custom Build) <https://lodash.com/>\n * Build: `lodash modern modularize exports=\"npm\" -o ./`\n * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <https://lodash.com/license>\n */\n\n/** `Object#toString` result references. */\nvar funcTag = '[object Function]';\n\n/**\n * Used to match `RegExp` [special characters](http://www.regular-expressions.info/characters.html#special).\n * In addition to special characters the forward slash is escaped to allow for\n * easier `eval` use and `Function` compilation.\n */\nvar reRegExpChars = /[.*+?^${}()|[\\]\\/\\\\]/g,\n    reHasRegExpChars = RegExp(reRegExpChars.source);\n\n/** Used to detect host constructors (Safari > 5). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/**\n * Converts `value` to a string if it is not one. An empty string is returned\n * for `null` or `undefined` values.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  if (typeof value == 'string') {\n    return value;\n  }\n  return value == null ? '' : (value + '');\n}\n\n/**\n * Checks if `value` is object-like.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar fnToString = Function.prototype.toString;\n\n/**\n * Used to resolve the [`toStringTag`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)\n * of values.\n */\nvar objToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  escapeRegExp(objToString)\n  .replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/**\n * Checks if `value` is a native function.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function, else `false`.\n * @example\n *\n * _.isNative(Array.prototype.push);\n * // => true\n *\n * _.isNative(_);\n * // => false\n */\nfunction isNative(value) {\n  if (value == null) {\n    return false;\n  }\n  if (objToString.call(value) == funcTag) {\n    return reIsNative.test(fnToString.call(value));\n  }\n  return isObjectLike(value) && reIsHostCtor.test(value);\n}\n\n/**\n * Escapes the `RegExp` special characters \"\\\", \"/\", \"^\", \"$\", \".\", \"|\", \"?\",\n * \"*\", \"+\", \"(\", \")\", \"[\", \"]\", \"{\" and \"}\" in `string`.\n *\n * @static\n * @memberOf _\n * @category String\n * @param {string} [string=''] The string to escape.\n * @returns {string} Returns the escaped string.\n * @example\n *\n * _.escapeRegExp('[lodash](https://lodash.com/)');\n * // => '\\[lodash\\]\\(https:\\/\\/lodash\\.com\\/\\)'\n */\nfunction escapeRegExp(string) {\n  string = baseToString(string);\n  return (string && reHasRegExpChars.test(string))\n    ? string.replace(reRegExpChars, '\\\\$&')\n    : string;\n}\n\nmodule.exports = isNative;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash.assign/~/lodash.isnative/index.js\n ** module id = 58\n ** module chunks = 0\n **/","/**\n * lodash 3.1.0 (Custom Build) <https://lodash.com/>\n * Build: `lodash modern modularize exports=\"npm\" -o ./`\n * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <https://lodash.com/license>\n */\nvar baseCopy = require('lodash._basecopy'),\n    isNative = require('lodash.isnative'),\n    keys = require('lodash.keys');\n\n/** Native method references. */\nvar getOwnPropertySymbols = isNative(getOwnPropertySymbols = Object.getOwnPropertySymbols) && getOwnPropertySymbols,\n    preventExtensions = isNative(Object.preventExtensions = Object.preventExtensions) && preventExtensions;\n\n/** Used as `baseAssign`. */\nvar nativeAssign = (function() {\n  // Avoid `Object.assign` in Firefox 34-37 which have an early implementation\n  // with a now defunct try/catch behavior. See https://bugzilla.mozilla.org/show_bug.cgi?id=1103344\n  // for more details.\n  //\n  // Use `Object.preventExtensions` on a plain object instead of simply using\n  // `Object('x')` because Chrome and IE fail to throw an error when attempting\n  // to assign values to readonly indexes of strings in strict mode.\n  var object = { '1': 0 },\n      func = preventExtensions && isNative(func = Object.assign) && func;\n\n  try { func(preventExtensions(object), 'xo'); } catch(e) {}\n  return !object[1] && func;\n}());\n\n/**\n * The base implementation of `_.assign` without support for argument juggling,\n * multiple sources, and `customizer` functions.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @returns {Object} Returns `object`.\n */\nvar baseAssign = nativeAssign || function(object, source) {\n  return source == null\n    ? object\n    : baseCopy(source, getSymbols(source), baseCopy(source, keys(source), object));\n};\n\n/**\n * Creates an array of the own symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbols = !getOwnPropertySymbols ? constant([]) : function(object) {\n  return getOwnPropertySymbols(toObject(object));\n};\n\n/**\n * Converts `value` to an object if it is not one.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {Object} Returns the object.\n */\nfunction toObject(value) {\n  return isObject(value) ? value : Object(value);\n}\n\n/**\n * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.\n * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(1);\n * // => false\n */\nfunction isObject(value) {\n  // Avoid a V8 JIT bug in Chrome 19-20.\n  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n  var type = typeof value;\n  return type == 'function' || (!!value && type == 'object');\n}\n\n/**\n * Creates a function that returns `value`.\n *\n * @static\n * @memberOf _\n * @category Utility\n * @param {*} value The value to return from the new function.\n * @returns {Function} Returns the new function.\n * @example\n *\n * var object = { 'user': 'fred' };\n * var getter = _.constant(object);\n *\n * getter() === object;\n * // => true\n */\nfunction constant(value) {\n  return function() {\n    return value;\n  };\n}\n\nmodule.exports = baseAssign;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash.assign/~/lodash._baseassign/index.js\n ** module id = 59\n ** module chunks = 0\n **/","/**\n * lodash 3.0.3 (Custom Build) <https://lodash.com/>\n * Build: `lodash modern modularize exports=\"npm\" -o ./`\n * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <https://lodash.com/license>\n */\nvar keys = require('lodash.keys');\n\n/**\n * Used as the [maximum length](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.max_safe_integer)\n * of an array-like value.\n */\nvar MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;\n\n/**\n * The base implementation of `_.forEach` without support for callback\n * shorthands and `this` binding.\n *\n * @private\n * @param {Array|Object|string} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array|Object|string} Returns `collection`.\n */\nvar baseEach = createBaseEach(baseForOwn);\n\n/**\n * The base implementation of `baseForIn` and `baseForOwn` which iterates\n * over `object` properties returned by `keysFunc` invoking `iteratee` for\n * each property. Iteratee functions may exit iteration early by explicitly\n * returning `false`.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @returns {Object} Returns `object`.\n */\nvar baseFor = createBaseFor();\n\n/**\n * The base implementation of `_.forOwn` without support for callback\n * shorthands and `this` binding.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Object} Returns `object`.\n */\nfunction baseForOwn(object, iteratee) {\n  return baseFor(object, iteratee, keys);\n}\n\n/**\n * The base implementation of `_.property` without support for deep paths.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @returns {Function} Returns the new function.\n */\nfunction baseProperty(key) {\n  return function(object) {\n    return object == null ? undefined : object[key];\n  };\n}\n\n/**\n * Creates a `baseEach` or `baseEachRight` function.\n *\n * @private\n * @param {Function} eachFunc The function to iterate over a collection.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseEach(eachFunc, fromRight) {\n  return function(collection, iteratee) {\n    var length = collection ? getLength(collection) : 0;\n    if (!isLength(length)) {\n      return eachFunc(collection, iteratee);\n    }\n    var index = fromRight ? length : -1,\n        iterable = toObject(collection);\n\n    while ((fromRight ? index-- : ++index < length)) {\n      if (iteratee(iterable[index], index, iterable) === false) {\n        break;\n      }\n    }\n    return collection;\n  };\n}\n\n/**\n * Creates a base function for `_.forIn` or `_.forInRight`.\n *\n * @private\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseFor(fromRight) {\n  return function(object, iteratee, keysFunc) {\n    var iterable = toObject(object),\n        props = keysFunc(object),\n        length = props.length,\n        index = fromRight ? length : -1;\n\n    while ((fromRight ? index-- : ++index < length)) {\n      var key = props[index];\n      if (iteratee(iterable[key], key, iterable) === false) {\n        break;\n      }\n    }\n    return object;\n  };\n}\n\n/**\n * Gets the \"length\" property value of `object`.\n *\n * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)\n * in Safari on iOS 8.1 ARM64.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {*} Returns the \"length\" value.\n */\nvar getLength = baseProperty('length');\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This function is based on [`ToLength`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength).\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n */\nfunction isLength(value) {\n  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Converts `value` to an object if it is not one.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {Object} Returns the object.\n */\nfunction toObject(value) {\n  return isObject(value) ? value : Object(value);\n}\n\n/**\n * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.\n * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(1);\n * // => false\n */\nfunction isObject(value) {\n  // Avoid a V8 JIT bug in Chrome 19-20.\n  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n  var type = typeof value;\n  return type == 'function' || (!!value && type == 'object');\n}\n\nmodule.exports = baseEach;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash.foreach/~/lodash._baseeach/index.js\n ** module id = 61\n ** module chunks = 0\n **/","/**\n * lodash 3.0.0 (Custom Build) <https://lodash.com/>\n * Build: `lodash modern modularize exports=\"npm\" -o ./`\n * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.7.0 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <https://lodash.com/license>\n */\n\n/**\n * A specialized version of `_.forEach` for arrays without support for callback\n * shorthands or `this` binding.\n *\n * @private\n * @param {Array} array The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns `array`.\n */\nfunction arrayEach(array, iteratee) {\n  var index = -1,\n      length = array.length;\n\n  while (++index < length) {\n    if (iteratee(array[index], index, array) === false) {\n      break;\n    }\n  }\n  return array;\n}\n\nmodule.exports = arrayEach;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash.foreach/~/lodash._arrayeach/index.js\n ** module id = 62\n ** module chunks = 0\n **/","/**\n * lodash 3.0.1 (Custom Build) <https://lodash.com/>\n * Build: `lodash modern modularize exports=\"npm\" -o ./`\n * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <https://lodash.com/license>\n */\n\n/**\n * A specialized version of `baseCallback` which only supports `this` binding\n * and specifying the number of arguments to provide to `func`.\n *\n * @private\n * @param {Function} func The function to bind.\n * @param {*} thisArg The `this` binding of `func`.\n * @param {number} [argCount] The number of arguments to provide to `func`.\n * @returns {Function} Returns the callback.\n */\nfunction bindCallback(func, thisArg, argCount) {\n  if (typeof func != 'function') {\n    return identity;\n  }\n  if (thisArg === undefined) {\n    return func;\n  }\n  switch (argCount) {\n    case 1: return function(value) {\n      return func.call(thisArg, value);\n    };\n    case 3: return function(value, index, collection) {\n      return func.call(thisArg, value, index, collection);\n    };\n    case 4: return function(accumulator, value, index, collection) {\n      return func.call(thisArg, accumulator, value, index, collection);\n    };\n    case 5: return function(value, other, key, object, source) {\n      return func.call(thisArg, value, other, key, object, source);\n    };\n  }\n  return function() {\n    return func.apply(thisArg, arguments);\n  };\n}\n\n/**\n * This method returns the first argument provided to it.\n *\n * @static\n * @memberOf _\n * @category Utility\n * @param {*} value Any value.\n * @returns {*} Returns `value`.\n * @example\n *\n * var object = { 'user': 'fred' };\n *\n * _.identity(object) === object;\n * // => true\n */\nfunction identity(value) {\n  return value;\n}\n\nmodule.exports = bindCallback;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash.foreach/~/lodash._bindcallback/index.js\n ** module id = 63\n ** module chunks = 0\n **/","/**\n * lodash 3.0.2 (Custom Build) <https://lodash.com/>\n * Build: `lodash modern modularize exports=\"npm\" -o ./`\n * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <https://lodash.com/license>\n */\n\n/** `Object#toString` result references. */\nvar arrayTag = '[object Array]',\n    funcTag = '[object Function]';\n\n/**\n * Used to match `RegExp` [special characters](http://www.regular-expressions.info/characters.html#special).\n * In addition to special characters the forward slash is escaped to allow for\n * easier `eval` use and `Function` compilation.\n */\nvar reRegExpChars = /[.*+?^${}()|[\\]\\/\\\\]/g,\n    reHasRegExpChars = RegExp(reRegExpChars.source);\n\n/** Used to detect host constructors (Safari > 5). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/**\n * Converts `value` to a string if it is not one. An empty string is returned\n * for `null` or `undefined` values.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  if (typeof value == 'string') {\n    return value;\n  }\n  return value == null ? '' : (value + '');\n}\n\n/**\n * Checks if `value` is object-like.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar fnToString = Function.prototype.toString;\n\n/**\n * Used to resolve the [`toStringTag`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)\n * of values.\n */\nvar objToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  escapeRegExp(objToString)\n  .replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/* Native method references for those with the same name as other `lodash` methods. */\nvar nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray;\n\n/**\n * Used as the [maximum length](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.max_safe_integer)\n * of an array-like value.\n */\nvar MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This function is based on [`ToLength`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength).\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n */\nfunction isLength(value) {\n  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(function() { return arguments; }());\n * // => false\n */\nvar isArray = nativeIsArray || function(value) {\n  return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;\n};\n\n/**\n * Checks if `value` is a native function.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function, else `false`.\n * @example\n *\n * _.isNative(Array.prototype.push);\n * // => true\n *\n * _.isNative(_);\n * // => false\n */\nfunction isNative(value) {\n  if (value == null) {\n    return false;\n  }\n  if (objToString.call(value) == funcTag) {\n    return reIsNative.test(fnToString.call(value));\n  }\n  return isObjectLike(value) && reIsHostCtor.test(value);\n}\n\n/**\n * Escapes the `RegExp` special characters \"\\\", \"/\", \"^\", \"$\", \".\", \"|\", \"?\",\n * \"*\", \"+\", \"(\", \")\", \"[\", \"]\", \"{\" and \"}\" in `string`.\n *\n * @static\n * @memberOf _\n * @category String\n * @param {string} [string=''] The string to escape.\n * @returns {string} Returns the escaped string.\n * @example\n *\n * _.escapeRegExp('[lodash](https://lodash.com/)');\n * // => '\\[lodash\\]\\(https:\\/\\/lodash\\.com\\/\\)'\n */\nfunction escapeRegExp(string) {\n  string = baseToString(string);\n  return (string && reHasRegExpChars.test(string))\n    ? string.replace(reRegExpChars, '\\\\$&')\n    : string;\n}\n\nmodule.exports = isArray;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash.foreach/~/lodash.isarray/index.js\n ** module id = 64\n ** module chunks = 0\n **/","'use strict';\n\nvar forEach = Array.prototype.forEach, create = Object.create;\n\nvar process = function (src, obj) {\n\tvar key;\n\tfor (key in src) obj[key] = src[key];\n};\n\nmodule.exports = function (options/*, â¦options*/) {\n\tvar result = create(null);\n\tforEach.call(arguments, function (options) {\n\t\tif (options == null) return;\n\t\tprocess(Object(options), result);\n\t});\n\treturn result;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/event-emitter/~/es5-ext/object/normalize-options.js\n ** module id = 65\n ** module chunks = 0\n **/","// Deprecated\n\n'use strict';\n\nmodule.exports = function (obj) { return typeof obj === 'function'; };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/event-emitter/~/es5-ext/object/is-callable.js\n ** module id = 66\n ** module chunks = 0\n **/","'use strict';\n\nmodule.exports = require('./is-implemented')()\n\t? Object.assign\n\t: require('./shim');\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/event-emitter/~/es5-ext/object/assign/index.js\n ** module id = 67\n ** module chunks = 0\n **/","'use strict';\n\nmodule.exports = require('./is-implemented')()\n\t? String.prototype.contains\n\t: require('./shim');\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/event-emitter/~/es5-ext/string/#/contains/index.js\n ** module id = 68\n ** module chunks = 0\n **/","'use strict';\n\nmodule.exports = function () {\n\tvar assign = Object.assign, obj;\n\tif (typeof assign !== 'function') return false;\n\tobj = { foo: 'raz' };\n\tassign(obj, { bar: 'dwa' }, { trzy: 'trzy' });\n\treturn (obj.foo + obj.bar + obj.trzy) === 'razdwatrzy';\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/event-emitter/~/es5-ext/object/assign/is-implemented.js\n ** module id = 69\n ** module chunks = 0\n **/","'use strict';\n\nvar keys  = require('../keys')\n  , value = require('../valid-value')\n\n  , max = Math.max;\n\nmodule.exports = function (dest, src/*, â¦srcn*/) {\n\tvar error, i, l = max(arguments.length, 2), assign;\n\tdest = Object(value(dest));\n\tassign = function (key) {\n\t\ttry { dest[key] = src[key]; } catch (e) {\n\t\t\tif (!error) error = e;\n\t\t}\n\t};\n\tfor (i = 1; i < l; ++i) {\n\t\tsrc = arguments[i];\n\t\tkeys(src).forEach(assign);\n\t}\n\tif (error !== undefined) throw error;\n\treturn dest;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/event-emitter/~/es5-ext/object/assign/shim.js\n ** module id = 70\n ** module chunks = 0\n **/","'use strict';\n\nvar str = 'razdwatrzy';\n\nmodule.exports = function () {\n\tif (typeof str.contains !== 'function') return false;\n\treturn ((str.contains('dwa') === true) && (str.contains('foo') === false));\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/event-emitter/~/es5-ext/string/#/contains/is-implemented.js\n ** module id = 71\n ** module chunks = 0\n **/","'use strict';\n\nvar indexOf = String.prototype.indexOf;\n\nmodule.exports = function (searchString/*, position*/) {\n\treturn indexOf.call(this, searchString, arguments[1]) > -1;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/event-emitter/~/es5-ext/string/#/contains/shim.js\n ** module id = 72\n ** module chunks = 0\n **/","/**\n * lodash 3.6.1 (Custom Build) <https://lodash.com/>\n * Build: `lodash modern modularize exports=\"npm\" -o ./`\n * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <https://lodash.com/license>\n */\n\n/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/* Native method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max;\n\n/**\n * Creates a function that invokes `func` with the `this` binding of the\n * created function and arguments from `start` and beyond provided as an array.\n *\n * **Note:** This method is based on the [rest parameter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters).\n *\n * @static\n * @memberOf _\n * @category Function\n * @param {Function} func The function to apply a rest parameter to.\n * @param {number} [start=func.length-1] The start position of the rest parameter.\n * @returns {Function} Returns the new function.\n * @example\n *\n * var say = _.restParam(function(what, names) {\n *   return what + ' ' + _.initial(names).join(', ') +\n *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);\n * });\n *\n * say('hello', 'fred', 'barney', 'pebbles');\n * // => 'hello fred, barney, & pebbles'\n */\nfunction restParam(func, start) {\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  start = nativeMax(start === undefined ? (func.length - 1) : (+start || 0), 0);\n  return function() {\n    var args = arguments,\n        index = -1,\n        length = nativeMax(args.length - start, 0),\n        rest = Array(length);\n\n    while (++index < length) {\n      rest[index] = args[start + index];\n    }\n    switch (start) {\n      case 0: return func.call(this, rest);\n      case 1: return func.call(this, args[0], rest);\n      case 2: return func.call(this, args[0], args[1], rest);\n    }\n    var otherArgs = Array(start + 1);\n    index = -1;\n    while (++index < start) {\n      otherArgs[index] = args[index];\n    }\n    otherArgs[start] = rest;\n    return func.apply(this, otherArgs);\n  };\n}\n\nmodule.exports = restParam;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash.assign/~/lodash._createassigner/~/lodash.restparam/index.js\n ** module id = 74\n ** module chunks = 0\n **/","/**\n * lodash 3.0.6 (Custom Build) <https://lodash.com/>\n * Build: `lodash modern modularize exports=\"npm\" -o ./`\n * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <https://lodash.com/license>\n */\n\n/**\n * Used as the [maximum length](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.max_safe_integer)\n * of an array-like value.\n */\nvar MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;\n\n/**\n * The base implementation of `_.property` without support for deep paths.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @returns {Function} Returns the new function.\n */\nfunction baseProperty(key) {\n  return function(object) {\n    return object == null ? undefined : object[key];\n  };\n}\n\n/**\n * Gets the \"length\" property value of `object`.\n *\n * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)\n * in Safari on iOS 8.1 ARM64.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {*} Returns the \"length\" value.\n */\nvar getLength = baseProperty('length');\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  value = +value;\n  length = length == null ? MAX_SAFE_INTEGER : length;\n  return value > -1 && value % 1 == 0 && value < length;\n}\n\n/**\n * Checks if the provided arguments are from an iteratee call.\n *\n * @private\n * @param {*} value The potential iteratee value argument.\n * @param {*} index The potential iteratee index or key argument.\n * @param {*} object The potential iteratee object argument.\n * @returns {boolean} Returns `true` if the arguments are from an iteratee call, else `false`.\n */\nfunction isIterateeCall(value, index, object) {\n  if (!isObject(object)) {\n    return false;\n  }\n  var type = typeof index;\n  if (type == 'number') {\n    var length = getLength(object),\n        prereq = isLength(length) && isIndex(index, length);\n  } else {\n    prereq = type == 'string' && index in object;\n  }\n  if (prereq) {\n    var other = object[index];\n    return value === value ? (value === other) : (other !== other);\n  }\n  return false;\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This function is based on [`ToLength`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength).\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n */\nfunction isLength(value) {\n  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.\n * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(1);\n * // => false\n */\nfunction isObject(value) {\n  // Avoid a V8 JIT bug in Chrome 19-20.\n  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n  var type = typeof value;\n  return type == 'function' || (!!value && type == 'object');\n}\n\nmodule.exports = isIterateeCall;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash.assign/~/lodash._createassigner/~/lodash._isiterateecall/index.js\n ** module id = 75\n ** module chunks = 0\n **/","/**\n * lodash 3.0.1 (Custom Build) <https://lodash.com/>\n * Build: `lodash modern modularize exports=\"npm\" -o ./`\n * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.8.2 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <https://lodash.com/license>\n */\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]';\n\n/**\n * Checks if `value` is object-like.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the [`toStringTag`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)\n * of values.\n */\nvar objToString = objectProto.toString;\n\n/**\n * Used as the [maximum length](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.max_safe_integer)\n * of an array-like value.\n */\nvar MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This function is based on [`ToLength`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength).\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n */\nfunction isLength(value) {\n  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is classified as an `arguments` object.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nfunction isArguments(value) {\n  var length = isObjectLike(value) ? value.length : undefined;\n  return isLength(length) && objToString.call(value) == argsTag;\n}\n\nmodule.exports = isArguments;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash.assign/~/lodash.keys/~/lodash.isarguments/index.js\n ** module id = 76\n ** module chunks = 0\n **/","/**\n * lodash 3.0.1 (Custom Build) <https://lodash.com/>\n * Build: `lodash modern modularize exports=\"npm\" -o ./`\n * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <https://lodash.com/license>\n */\n\n/**\n * Copies properties of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy properties from.\n * @param {Array} props The property names to copy.\n * @param {Object} [object={}] The object to copy properties to.\n * @returns {Object} Returns `object`.\n */\nfunction baseCopy(source, props, object) {\n  object || (object = {});\n\n  var index = -1,\n      length = props.length;\n\n  while (++index < length) {\n    var key = props[index];\n    object[key] = source[key];\n  }\n  return object;\n}\n\nmodule.exports = baseCopy;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash.assign/~/lodash._baseassign/~/lodash._basecopy/index.js\n ** module id = 77\n ** module chunks = 0\n **/","'use strict';\n\nmodule.exports = function (value) {\n\tif (value == null) throw new TypeError(\"Cannot use null or undefined\");\n\treturn value;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/event-emitter/~/es5-ext/object/valid-value.js\n ** module id = 80\n ** module chunks = 0\n **/","'use strict';\n\nmodule.exports = require('./is-implemented')()\n\t? Object.keys\n\t: require('./shim');\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/event-emitter/~/es5-ext/object/keys/index.js\n ** module id = 81\n ** module chunks = 0\n **/","'use strict';\n\nmodule.exports = function () {\n\ttry {\n\t\tObject.keys('primitive');\n\t\treturn true;\n\t} catch (e) { return false; }\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/event-emitter/~/es5-ext/object/keys/is-implemented.js\n ** module id = 82\n ** module chunks = 0\n **/","'use strict';\n\nvar keys = Object.keys;\n\nmodule.exports = function (object) {\n\treturn keys(object == null ? object : Object(object));\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/event-emitter/~/es5-ext/object/keys/shim.js\n ** module id = 83\n ** module chunks = 0\n **/","/**\n * lodash 3.0.6 (Custom Build) <https://lodash.com/>\n * Build: `lodash modern modularize exports=\"npm\" -o ./`\n * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <https://lodash.com/license>\n */\nvar isArguments = require('lodash.isarguments'),\n    isArray = require('lodash.isarray'),\n    isNative = require('lodash.isnative');\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Native method references. */\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\n\n/* Native method references for those with the same name as other `lodash` methods. */\nvar nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys;\n\n/**\n * Used as the [maximum length](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.max_safe_integer)\n * of an array-like value.\n */\nvar MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;\n\n/**\n * An object environment feature flags.\n *\n * @static\n * @memberOf _\n * @type Object\n */\nvar support = {};\n\n(function(x) {\n  var Ctor = function() { this.x = x; },\n      object = { '0': x, 'length': x },\n      props = [];\n\n  Ctor.prototype = { 'valueOf': x, 'y': x };\n  for (var key in new Ctor) { props.push(key); }\n\n  /**\n   * Detect if `arguments` object indexes are non-enumerable.\n   *\n   * In Firefox < 4, IE < 9, PhantomJS, and Safari < 5.1 `arguments` object\n   * indexes are non-enumerable. Chrome < 25 and Node.js < 0.11.0 treat\n   * `arguments` object indexes as non-enumerable and fail `hasOwnProperty`\n   * checks for indexes that exceed the number of function parameters and\n   * whose associated argument values are `0`.\n   *\n   * @memberOf _.support\n   * @type boolean\n   */\n  try {\n    support.nonEnumArgs = !propertyIsEnumerable.call(arguments, 1);\n  } catch(e) {\n    support.nonEnumArgs = true;\n  }\n}(1, 0));\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  value = +value;\n  length = length == null ? MAX_SAFE_INTEGER : length;\n  return value > -1 && value % 1 == 0 && value < length;\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This function is based on [`ToLength`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength).\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n */\nfunction isLength(value) {\n  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * A fallback implementation of `Object.keys` which creates an array of the\n * own enumerable property names of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction shimKeys(object) {\n  var props = keysIn(object),\n      propsLength = props.length,\n      length = propsLength && object.length;\n\n  var allowIndexes = length && isLength(length) &&\n    (isArray(object) || (support.nonEnumArgs && isArguments(object)));\n\n  var index = -1,\n      result = [];\n\n  while (++index < propsLength) {\n    var key = props[index];\n    if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.\n * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(1);\n * // => false\n */\nfunction isObject(value) {\n  // Avoid a V8 JIT bug in Chrome 19-20.\n  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n  var type = typeof value;\n  return type == 'function' || (!!value && type == 'object');\n}\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.keys)\n * for more details.\n *\n * @static\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nvar keys = !nativeKeys ? shimKeys : function(object) {\n  if (object) {\n    var Ctor = object.constructor,\n        length = object.length;\n  }\n  if ((typeof Ctor == 'function' && Ctor.prototype === object) ||\n      (typeof object != 'function' && isLength(length))) {\n    return shimKeys(object);\n  }\n  return isObject(object) ? nativeKeys(object) : [];\n};\n\n/**\n * Creates an array of the own and inherited enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects.\n *\n * @static\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keysIn(new Foo);\n * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n */\nfunction keysIn(object) {\n  if (object == null) {\n    return [];\n  }\n  if (!isObject(object)) {\n    object = Object(object);\n  }\n  var length = object.length;\n  length = (length && isLength(length) &&\n    (isArray(object) || (support.nonEnumArgs && isArguments(object))) && length) || 0;\n\n  var Ctor = object.constructor,\n      index = -1,\n      isProto = typeof Ctor == 'function' && Ctor.prototype === object,\n      result = Array(length),\n      skipIndexes = length > 0;\n\n  while (++index < length) {\n    result[index] = (index + '');\n  }\n  for (var key in object) {\n    if (!(skipIndexes && isIndex(key, length)) &&\n        !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = keys;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash.foreach/~/lodash._baseeach/~/lodash.keys/index.js\n ** module id = 79\n ** module chunks = 0\n **/"],"sourceRoot":""}